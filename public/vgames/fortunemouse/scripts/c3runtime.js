// Generated by Construct, the game and app creator :: https://www.construct.net
"use strict";
(function(a, b) {
    "object" === typeof exports && "undefined" !== typeof module ? b(exports) : "function" === typeof define && define.amd ? define(["exports"], b) : (a = "undefined" !== typeof globalThis ? globalThis : a || self,
    b(a.glMatrix = {}))
}
)(this, function(a) {
    function b(f, h, m) {
        var q = h[0]
          , r = h[1]
          , u = h[2];
        h = h[3];
        var v = m[0]
          , x = m[1]
          , y = m[2];
        m = m[3];
        f[0] = q * v + u * x;
        f[1] = r * v + h * x;
        f[2] = q * y + u * m;
        f[3] = r * y + h * m;
        return f
    }
    function d(f, h, m) {
        f[0] = h[0] - m[0];
        f[1] = h[1] - m[1];
        f[2] = h[2] - m[2];
        f[3] = h[3] - m[3];
        return f
    }
    function c(f, h, m) {
        var q = h[0]
          , r = h[1]
          , u = h[2]
          , v = h[3]
          , x = h[4];
        h = h[5];
        var y = m[0]
          , A = m[1]
          , D = m[2]
          , G = m[3]
          , I = m[4];
        m = m[5];
        f[0] = q * y + u * A;
        f[1] = r * y + v * A;
        f[2] = q * D + u * G;
        f[3] = r * D + v * G;
        f[4] = q * I + u * m + x;
        f[5] = r * I + v * m + h;
        return f
    }
    function e(f, h, m) {
        f[0] = h[0] - m[0];
        f[1] = h[1] - m[1];
        f[2] = h[2] - m[2];
        f[3] = h[3] - m[3];
        f[4] = h[4] - m[4];
        f[5] = h[5] - m[5];
        return f
    }
    function g() {
        var f = new aa(9);
        aa != Float32Array && (f[1] = 0,
        f[2] = 0,
        f[3] = 0,
        f[5] = 0,
        f[6] = 0,
        f[7] = 0);
        f[0] = 1;
        f[4] = 1;
        f[8] = 1;
        return f
    }
    function k(f, h, m) {
        var q = h[0]
          , r = h[1]
          , u = h[2]
          , v = h[3]
          , x = h[4]
          , y = h[5]
          , A = h[6]
          , D = h[7];
        h = h[8];
        var G = m[0]
          , I = m[1]
          , H = m[2]
          , N = m[3]
          , O = m[4]
          , L = m[5]
          , V = m[6]
          , S = m[7];
        m = m[8];
        f[0] = G * q + I * v + H * A;
        f[1] = G * r + I * x + H * D;
        f[2] = G * u + I * y + H * h;
        f[3] = N * q + O * v + L * A;
        f[4] = N * r + O * x + L * D;
        f[5] = N * u + O * y + L * h;
        f[6] = V * q + S * v + m * A;
        f[7] = V * r + S * x + m * D;
        f[8] = V * u + S * y + m * h;
        return f
    }
    function l(f, h, m) {
        f[0] = h[0] - m[0];
        f[1] = h[1] - m[1];
        f[2] = h[2] - m[2];
        f[3] = h[3] - m[3];
        f[4] = h[4] - m[4];
        f[5] = h[5] - m[5];
        f[6] = h[6] - m[6];
        f[7] = h[7] - m[7];
        f[8] = h[8] - m[8];
        return f
    }
    function n(f) {
        f[0] = 1;
        f[1] = 0;
        f[2] = 0;
        f[3] = 0;
        f[4] = 0;
        f[5] = 1;
        f[6] = 0;
        f[7] = 0;
        f[8] = 0;
        f[9] = 0;
        f[10] = 1;
        f[11] = 0;
        f[12] = 0;
        f[13] = 0;
        f[14] = 0;
        f[15] = 1;
        return f
    }
    function p(f, h, m) {
        var q = h[0]
          , r = h[1]
          , u = h[2]
          , v = h[3]
          , x = h[4]
          , y = h[5]
          , A = h[6]
          , D = h[7]
          , G = h[8]
          , I = h[9]
          , H = h[10]
          , N = h[11]
          , O = h[12]
          , L = h[13]
          , V = h[14];
        h = h[15];
        var S = m[0]
          , Y = m[1]
          , Z = m[2]
          , W = m[3];
        f[0] = S * q + Y * x + Z * G + W * O;
        f[1] = S * r + Y * y + Z * I + W * L;
        f[2] = S * u + Y * A + Z * H + W * V;
        f[3] = S * v + Y * D + Z * N + W * h;
        S = m[4];
        Y = m[5];
        Z = m[6];
        W = m[7];
        f[4] = S * q + Y * x + Z * G + W * O;
        f[5] = S * r + Y * y + Z * I + W * L;
        f[6] = S * u + Y * A + Z * H + W * V;
        f[7] = S * v + Y * D + Z * N + W * h;
        S = m[8];
        Y = m[9];
        Z = m[10];
        W = m[11];
        f[8] = S * q + Y * x + Z * G + W * O;
        f[9] = S * r + Y * y + Z * I + W * L;
        f[10] = S * u + Y * A + Z * H + W * V;
        f[11] = S * v + Y * D + Z * N + W * h;
        S = m[12];
        Y = m[13];
        Z = m[14];
        W = m[15];
        f[12] = S * q + Y * x + Z * G + W * O;
        f[13] = S * r + Y * y + Z * I + W * L;
        f[14] = S * u + Y * A + Z * H + W * V;
        f[15] = S * v + Y * D + Z * N + W * h;
        return f
    }
    function t(f, h, m) {
        var q = h[0]
          , r = h[1]
          , u = h[2]
          , v = h[3]
          , x = q + q
          , y = r + r
          , A = u + u;
        h = q * x;
        var D = q * y;
        q *= A;
        var G = r * y;
        r *= A;
        u *= A;
        x *= v;
        y *= v;
        v *= A;
        f[0] = 1 - (G + u);
        f[1] = D + v;
        f[2] = q - y;
        f[3] = 0;
        f[4] = D - v;
        f[5] = 1 - (h + u);
        f[6] = r + x;
        f[7] = 0;
        f[8] = q + y;
        f[9] = r - x;
        f[10] = 1 - (h + G);
        f[11] = 0;
        f[12] = m[0];
        f[13] = m[1];
        f[14] = m[2];
        f[15] = 1;
        return f
    }
    function w(f, h) {
        f[0] = h[12];
        f[1] = h[13];
        f[2] = h[14];
        return f
    }
    function z(f, h) {
        var m = h[4]
          , q = h[5]
          , r = h[6]
          , u = h[8]
          , v = h[9]
          , x = h[10];
        f[0] = Math.hypot(h[0], h[1], h[2]);
        f[1] = Math.hypot(m, q, r);
        f[2] = Math.hypot(u, v, x);
        return f
    }
    function B(f, h) {
        var m = new aa(3);
        z(m, h);
        var q = 1 / m[0]
          , r = 1 / m[1]
          , u = 1 / m[2]
          , v = h[0] * q;
        m = h[1] * r;
        var x = h[2] * u
          , y = h[4] * q
          , A = h[5] * r
          , D = h[6] * u;
        q *= h[8];
        r *= h[9];
        h = h[10] * u;
        u = v + A + h;
        0 < u ? (v = 2 * Math.sqrt(u + 1),
        f[3] = .25 * v,
        f[0] = (D - r) / v,
        f[1] = (q - x) / v,
        f[2] = (m - y) / v) : v > A && v > h ? (v = 2 * Math.sqrt(1 + v - A - h),
        f[3] = (D - r) / v,
        f[0] = .25 * v,
        f[1] = (m + y) / v,
        f[2] = (q + x) / v) : A > h ? (v = 2 * Math.sqrt(1 + A - v - h),
        f[3] = (q - x) / v,
        f[0] = (m + y) / v,
        f[1] = .25 * v,
        f[2] = (D + r) / v) : (v = 2 * Math.sqrt(1 + h - v - A),
        f[3] = (m - y) / v,
        f[0] = (q + x) / v,
        f[1] = (D + r) / v,
        f[2] = .25 * v);
        return f
    }
    function C(f, h, m, q, r) {
        h = 1 / Math.tan(h / 2);
        f[0] = h / m;
        f[1] = 0;
        f[2] = 0;
        f[3] = 0;
        f[4] = 0;
        f[5] = h;
        f[6] = 0;
        f[7] = 0;
        f[8] = 0;
        f[9] = 0;
        f[11] = -1;
        f[12] = 0;
        f[13] = 0;
        f[15] = 0;
        null != r && Infinity !== r ? (m = 1 / (q - r),
        f[10] = (r + q) * m,
        f[14] = 2 * r * q * m) : (f[10] = -1,
        f[14] = -2 * q);
        return f
    }
    function E(f, h, m, q, r, u, v) {
        var x = 1 / (h - m)
          , y = 1 / (q - r)
          , A = 1 / (u - v);
        f[0] = -2 * x;
        f[1] = 0;
        f[2] = 0;
        f[3] = 0;
        f[4] = 0;
        f[5] = -2 * y;
        f[6] = 0;
        f[7] = 0;
        f[8] = 0;
        f[9] = 0;
        f[10] = 2 * A;
        f[11] = 0;
        f[12] = (h + m) * x;
        f[13] = (r + q) * y;
        f[14] = (v + u) * A;
        f[15] = 1;
        return f
    }
    function F(f, h, m) {
        f[0] = h[0] - m[0];
        f[1] = h[1] - m[1];
        f[2] = h[2] - m[2];
        f[3] = h[3] - m[3];
        f[4] = h[4] - m[4];
        f[5] = h[5] - m[5];
        f[6] = h[6] - m[6];
        f[7] = h[7] - m[7];
        f[8] = h[8] - m[8];
        f[9] = h[9] - m[9];
        f[10] = h[10] - m[10];
        f[11] = h[11] - m[11];
        f[12] = h[12] - m[12];
        f[13] = h[13] - m[13];
        f[14] = h[14] - m[14];
        f[15] = h[15] - m[15];
        return f
    }
    function J() {
        var f = new aa(3);
        aa != Float32Array && (f[0] = 0,
        f[1] = 0,
        f[2] = 0);
        return f
    }
    function K(f) {
        return Math.hypot(f[0], f[1], f[2])
    }
    function M(f, h, m) {
        var q = new aa(3);
        q[0] = f;
        q[1] = h;
        q[2] = m;
        return q
    }
    function U(f, h, m) {
        f[0] = h[0] - m[0];
        f[1] = h[1] - m[1];
        f[2] = h[2] - m[2];
        return f
    }
    function X(f, h, m) {
        f[0] = h[0] * m[0];
        f[1] = h[1] * m[1];
        f[2] = h[2] * m[2];
        return f
    }
    function R(f, h, m) {
        f[0] = h[0] / m[0];
        f[1] = h[1] / m[1];
        f[2] = h[2] / m[2];
        return f
    }
    function T(f, h) {
        return Math.hypot(h[0] - f[0], h[1] - f[1], h[2] - f[2])
    }
    function P(f, h) {
        var m = h[0] - f[0]
          , q = h[1] - f[1];
        f = h[2] - f[2];
        return m * m + q * q + f * f
    }
    function fa(f) {
        var h = f[0]
          , m = f[1];
        f = f[2];
        return h * h + m * m + f * f
    }
    function ba(f, h) {
        var m = h[0]
          , q = h[1]
          , r = h[2];
        m = m * m + q * q + r * r;
        0 < m && (m = 1 / Math.sqrt(m));
        f[0] = h[0] * m;
        f[1] = h[1] * m;
        f[2] = h[2] * m;
        return f
    }
    function ea(f, h) {
        return f[0] * h[0] + f[1] * h[1] + f[2] * h[2]
    }
    function da(f, h, m) {
        var q = h[0]
          , r = h[1];
        h = h[2];
        var u = m[0]
          , v = m[1];
        m = m[2];
        f[0] = r * m - h * v;
        f[1] = h * u - q * m;
        f[2] = q * v - r * u;
        return f
    }
    function ka() {
        var f = new aa(4);
        aa != Float32Array && (f[0] = 0,
        f[1] = 0,
        f[2] = 0,
        f[3] = 0);
        return f
    }
    function Q(f) {
        var h = new aa(4);
        h[0] = f[0];
        h[1] = f[1];
        h[2] = f[2];
        h[3] = f[3];
        return h
    }
    function xa(f, h, m, q) {
        var r = new aa(4);
        r[0] = f;
        r[1] = h;
        r[2] = m;
        r[3] = q;
        return r
    }
    function ca(f, h) {
        f[0] = h[0];
        f[1] = h[1];
        f[2] = h[2];
        f[3] = h[3];
        return f
    }
    function ha(f, h, m, q, r) {
        f[0] = h;
        f[1] = m;
        f[2] = q;
        f[3] = r;
        return f
    }
    function ra(f, h, m) {
        f[0] = h[0] + m[0];
        f[1] = h[1] + m[1];
        f[2] = h[2] + m[2];
        f[3] = h[3] + m[3];
        return f
    }
    function qa(f, h, m) {
        f[0] = h[0] - m[0];
        f[1] = h[1] - m[1];
        f[2] = h[2] - m[2];
        f[3] = h[3] - m[3];
        return f
    }
    function ya(f, h, m) {
        f[0] = h[0] * m[0];
        f[1] = h[1] * m[1];
        f[2] = h[2] * m[2];
        f[3] = h[3] * m[3];
        return f
    }
    function za(f, h, m) {
        f[0] = h[0] / m[0];
        f[1] = h[1] / m[1];
        f[2] = h[2] / m[2];
        f[3] = h[3] / m[3];
        return f
    }
    function ia(f, h, m) {
        f[0] = h[0] * m;
        f[1] = h[1] * m;
        f[2] = h[2] * m;
        f[3] = h[3] * m;
        return f
    }
    function ja(f, h) {
        return Math.hypot(h[0] - f[0], h[1] - f[1], h[2] - f[2], h[3] - f[3])
    }
    function Ba(f, h) {
        var m = h[0] - f[0]
          , q = h[1] - f[1]
          , r = h[2] - f[2];
        f = h[3] - f[3];
        return m * m + q * q + r * r + f * f
    }
    function ua(f) {
        return Math.hypot(f[0], f[1], f[2], f[3])
    }
    function ta(f) {
        var h = f[0]
          , m = f[1]
          , q = f[2];
        f = f[3];
        return h * h + m * m + q * q + f * f
    }
    function Ca(f, h) {
        var m = h[0]
          , q = h[1]
          , r = h[2];
        h = h[3];
        var u = m * m + q * q + r * r + h * h;
        0 < u && (u = 1 / Math.sqrt(u));
        f[0] = m * u;
        f[1] = q * u;
        f[2] = r * u;
        f[3] = h * u;
        return f
    }
    function Da(f, h) {
        return f[0] * h[0] + f[1] * h[1] + f[2] * h[2] + f[3] * h[3]
    }
    function La(f, h, m, q) {
        var r = h[0]
          , u = h[1]
          , v = h[2];
        h = h[3];
        f[0] = r + q * (m[0] - r);
        f[1] = u + q * (m[1] - u);
        f[2] = v + q * (m[2] - v);
        f[3] = h + q * (m[3] - h);
        return f
    }
    function Ma(f, h) {
        return f[0] === h[0] && f[1] === h[1] && f[2] === h[2] && f[3] === h[3]
    }
    function Fa() {
        var f = new aa(4);
        aa != Float32Array && (f[0] = 0,
        f[1] = 0,
        f[2] = 0);
        f[3] = 1;
        return f
    }
    function Na(f, h, m) {
        m *= .5;
        var q = Math.sin(m);
        f[0] = q * h[0];
        f[1] = q * h[1];
        f[2] = q * h[2];
        f[3] = Math.cos(m);
        return f
    }
    function Oa(f, h, m) {
        var q = h[0]
          , r = h[1]
          , u = h[2];
        h = h[3];
        var v = m[0]
          , x = m[1]
          , y = m[2];
        m = m[3];
        f[0] = q * m + h * v + r * y - u * x;
        f[1] = r * m + h * x + u * v - q * y;
        f[2] = u * m + h * y + q * x - r * v;
        f[3] = h * m - q * v - r * x - u * y;
        return f
    }
    function Pa(f, h, m) {
        m *= .5;
        var q = h[0]
          , r = h[1]
          , u = h[2];
        h = h[3];
        var v = Math.sin(m);
        m = Math.cos(m);
        f[0] = q * m + h * v;
        f[1] = r * m + u * v;
        f[2] = u * m - r * v;
        f[3] = h * m - q * v;
        return f
    }
    function Qa(f, h, m) {
        m *= .5;
        var q = h[0]
          , r = h[1]
          , u = h[2];
        h = h[3];
        var v = Math.sin(m);
        m = Math.cos(m);
        f[0] = q * m - u * v;
        f[1] = r * m + h * v;
        f[2] = u * m + q * v;
        f[3] = h * m - r * v;
        return f
    }
    function Ra(f, h, m) {
        m *= .5;
        var q = h[0]
          , r = h[1]
          , u = h[2];
        h = h[3];
        var v = Math.sin(m);
        m = Math.cos(m);
        f[0] = q * m + r * v;
        f[1] = r * m - q * v;
        f[2] = u * m + h * v;
        f[3] = h * m - u * v;
        return f
    }
    function Sa(f, h) {
        var m = h[0]
          , q = h[1]
          , r = h[2]
          , u = Math.sqrt(m * m + q * q + r * r);
        h = Math.exp(h[3]);
        var v = 0 < u ? h * Math.sin(u) / u : 0;
        f[0] = m * v;
        f[1] = q * v;
        f[2] = r * v;
        f[3] = h * Math.cos(u);
        return f
    }
    function Ta(f, h) {
        var m = h[0]
          , q = h[1]
          , r = h[2];
        h = h[3];
        var u = Math.sqrt(m * m + q * q + r * r);
        u = 0 < u ? Math.atan2(u, h) / u : 0;
        f[0] = m * u;
        f[1] = q * u;
        f[2] = r * u;
        f[3] = .5 * Math.log(m * m + q * q + r * r + h * h);
        return f
    }
    function Ga(f, h, m, q) {
        var r = h[0]
          , u = h[1]
          , v = h[2];
        h = h[3];
        var x = m[0]
          , y = m[1]
          , A = m[2];
        m = m[3];
        var D = r * x + u * y + v * A + h * m;
        0 > D && (D = -D,
        x = -x,
        y = -y,
        A = -A,
        m = -m);
        if (1E-6 < 1 - D) {
            var G = Math.acos(D);
            var I = Math.sin(G);
            D = Math.sin((1 - q) * G) / I;
            q = Math.sin(q * G) / I
        } else
            D = 1 - q;
        f[0] = D * r + q * x;
        f[1] = D * u + q * y;
        f[2] = D * v + q * A;
        f[3] = D * h + q * m;
        return f
    }
    function Ua(f, h) {
        var m = h[0] + h[4] + h[8];
        if (0 < m)
            m = Math.sqrt(m + 1),
            f[3] = .5 * m,
            m = .5 / m,
            f[0] = (h[5] - h[7]) * m,
            f[1] = (h[6] - h[2]) * m,
            f[2] = (h[1] - h[3]) * m;
        else {
            var q = 0;
            h[4] > h[0] && (q = 1);
            h[8] > h[3 * q + q] && (q = 2);
            var r = (q + 1) % 3
              , u = (q + 2) % 3;
            m = Math.sqrt(h[3 * q + q] - h[3 * r + r] - h[3 * u + u] + 1);
            f[q] = .5 * m;
            m = .5 / m;
            f[3] = (h[3 * r + u] - h[3 * u + r]) * m;
            f[r] = (h[3 * r + q] + h[3 * q + r]) * m;
            f[u] = (h[3 * u + q] + h[3 * q + u]) * m
        }
        return f
    }
    function Va(f, h, m) {
        var q = .5 * m[0]
          , r = .5 * m[1];
        m = .5 * m[2];
        var u = h[0]
          , v = h[1]
          , x = h[2];
        h = h[3];
        f[0] = u;
        f[1] = v;
        f[2] = x;
        f[3] = h;
        f[4] = q * h + r * x - m * v;
        f[5] = r * h + m * u - q * x;
        f[6] = m * h + q * v - r * u;
        f[7] = -q * u - r * v - m * x;
        return f
    }
    function Wa(f, h) {
        f[0] = h[0];
        f[1] = h[1];
        f[2] = h[2];
        f[3] = h[3];
        f[4] = h[4];
        f[5] = h[5];
        f[6] = h[6];
        f[7] = h[7];
        return f
    }
    function Xa(f, h, m) {
        var q = h[0]
          , r = h[1]
          , u = h[2]
          , v = h[3]
          , x = m[4]
          , y = m[5]
          , A = m[6]
          , D = m[7]
          , G = h[4]
          , I = h[5]
          , H = h[6];
        h = h[7];
        var N = m[0]
          , O = m[1]
          , L = m[2];
        m = m[3];
        f[0] = q * m + v * N + r * L - u * O;
        f[1] = r * m + v * O + u * N - q * L;
        f[2] = u * m + v * L + q * O - r * N;
        f[3] = v * m - q * N - r * O - u * L;
        f[4] = q * D + v * x + r * A - u * y + G * m + h * N + I * L - H * O;
        f[5] = r * D + v * y + u * x - q * A + I * m + h * O + H * N - G * L;
        f[6] = u * D + v * A + q * y - r * x + H * m + h * L + G * O - I * N;
        f[7] = v * D - q * x - r * y - u * A + h * m - G * N - I * O - H * L;
        return f
    }
    function Ya() {
        var f = new aa(2);
        aa != Float32Array && (f[0] = 0,
        f[1] = 0);
        return f
    }
    function Za(f, h, m) {
        f[0] = h[0] - m[0];
        f[1] = h[1] - m[1];
        return f
    }
    function $a(f, h, m) {
        f[0] = h[0] * m[0];
        f[1] = h[1] * m[1];
        return f
    }
    function ab(f, h, m) {
        f[0] = h[0] / m[0];
        f[1] = h[1] / m[1];
        return f
    }
    function bb(f, h) {
        return Math.hypot(h[0] - f[0], h[1] - f[1])
    }
    function cb(f, h) {
        var m = h[0] - f[0];
        f = h[1] - f[1];
        return m * m + f * f
    }
    function db(f) {
        return Math.hypot(f[0], f[1])
    }
    function eb(f) {
        var h = f[0];
        f = f[1];
        return h * h + f * f
    }
    var aa = "undefined" !== typeof Float32Array ? Float32Array : Array
      , Aa = Math.random
      , hb = Math.PI / 180;
    Math.hypot || (Math.hypot = function() {
        for (var f = 0, h = arguments.length; h--; )
            f += arguments[h] * arguments[h];
        return Math.sqrt(f)
    }
    );
    var ib = Object.freeze({
        __proto__: null,
        EPSILON: 1E-6,
        get ARRAY_TYPE() {
            return aa
        },
        RANDOM: Aa,
        ANGLE_ORDER: "zyx",
        setMatrixArrayType: function(f) {
            aa = f
        },
        toRadian: function(f) {
            return f * hb
        },
        equals: function(f, h) {
            return Math.abs(f - h) <= 1E-6 * Math.max(1, Math.abs(f), Math.abs(h))
        }
    })
      , jb = Object.freeze({
        __proto__: null,
        create: function() {
            var f = new aa(4);
            aa != Float32Array && (f[1] = 0,
            f[2] = 0);
            f[0] = 1;
            f[3] = 1;
            return f
        },
        clone: function(f) {
            var h = new aa(4);
            h[0] = f[0];
            h[1] = f[1];
            h[2] = f[2];
            h[3] = f[3];
            return h
        },
        copy: function(f, h) {
            f[0] = h[0];
            f[1] = h[1];
            f[2] = h[2];
            f[3] = h[3];
            return f
        },
        identity: function(f) {
            f[0] = 1;
            f[1] = 0;
            f[2] = 0;
            f[3] = 1;
            return f
        },
        fromValues: function(f, h, m, q) {
            var r = new aa(4);
            r[0] = f;
            r[1] = h;
            r[2] = m;
            r[3] = q;
            return r
        },
        set: function(f, h, m, q, r) {
            f[0] = h;
            f[1] = m;
            f[2] = q;
            f[3] = r;
            return f
        },
        transpose: function(f, h) {
            if (f === h) {
                var m = h[1];
                f[1] = h[2];
                f[2] = m
            } else
                f[0] = h[0],
                f[1] = h[2],
                f[2] = h[1],
                f[3] = h[3];
            return f
        },
        invert: function(f, h) {
            var m = h[0]
              , q = h[1]
              , r = h[2];
            h = h[3];
            var u = m * h - r * q;
            if (!u)
                return null;
            u = 1 / u;
            f[0] = h * u;
            f[1] = -q * u;
            f[2] = -r * u;
            f[3] = m * u;
            return f
        },
        adjoint: function(f, h) {
            var m = h[0];
            f[0] = h[3];
            f[1] = -h[1];
            f[2] = -h[2];
            f[3] = m;
            return f
        },
        determinant: function(f) {
            return f[0] * f[3] - f[2] * f[1]
        },
        multiply: b,
        rotate: function(f, h, m) {
            var q = h[0]
              , r = h[1]
              , u = h[2];
            h = h[3];
            var v = Math.sin(m);
            m = Math.cos(m);
            f[0] = q * m + u * v;
            f[1] = r * m + h * v;
            f[2] = q * -v + u * m;
            f[3] = r * -v + h * m;
            return f
        },
        scale: function(f, h, m) {
            var q = h[1]
              , r = h[2]
              , u = h[3]
              , v = m[0];
            m = m[1];
            f[0] = h[0] * v;
            f[1] = q * v;
            f[2] = r * m;
            f[3] = u * m;
            return f
        },
        fromRotation: function(f, h) {
            var m = Math.sin(h);
            h = Math.cos(h);
            f[0] = h;
            f[1] = m;
            f[2] = -m;
            f[3] = h;
            return f
        },
        fromScaling: function(f, h) {
            f[0] = h[0];
            f[1] = 0;
            f[2] = 0;
            f[3] = h[1];
            return f
        },
        str: function(f) {
            return "mat2(" + f[0] + ", " + f[1] + ", " + f[2] + ", " + f[3] + ")"
        },
        frob: function(f) {
            return Math.hypot(f[0], f[1], f[2], f[3])
        },
        LDU: function(f, h, m, q) {
            f[2] = q[2] / q[0];
            m[0] = q[0];
            m[1] = q[1];
            m[3] = q[3] - f[2] * m[1];
            return [f, h, m]
        },
        add: function(f, h, m) {
            f[0] = h[0] + m[0];
            f[1] = h[1] + m[1];
            f[2] = h[2] + m[2];
            f[3] = h[3] + m[3];
            return f
        },
        subtract: d,
        exactEquals: function(f, h) {
            return f[0] === h[0] && f[1] === h[1] && f[2] === h[2] && f[3] === h[3]
        },
        equals: function(f, h) {
            var m = f[0]
              , q = f[1]
              , r = f[2];
            f = f[3];
            var u = h[0]
              , v = h[1]
              , x = h[2];
            h = h[3];
            return Math.abs(m - u) <= 1E-6 * Math.max(1, Math.abs(m), Math.abs(u)) && Math.abs(q - v) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(v)) && Math.abs(r - x) <= 1E-6 * Math.max(1, Math.abs(r), Math.abs(x)) && Math.abs(f - h) <= 1E-6 * Math.max(1, Math.abs(f), Math.abs(h))
        },
        multiplyScalar: function(f, h, m) {
            f[0] = h[0] * m;
            f[1] = h[1] * m;
            f[2] = h[2] * m;
            f[3] = h[3] * m;
            return f
        },
        multiplyScalarAndAdd: function(f, h, m, q) {
            f[0] = h[0] + m[0] * q;
            f[1] = h[1] + m[1] * q;
            f[2] = h[2] + m[2] * q;
            f[3] = h[3] + m[3] * q;
            return f
        },
        mul: b,
        sub: d
    })
      , kb = Object.freeze({
        __proto__: null,
        create: function() {
            var f = new aa(6);
            aa != Float32Array && (f[1] = 0,
            f[2] = 0,
            f[4] = 0,
            f[5] = 0);
            f[0] = 1;
            f[3] = 1;
            return f
        },
        clone: function(f) {
            var h = new aa(6);
            h[0] = f[0];
            h[1] = f[1];
            h[2] = f[2];
            h[3] = f[3];
            h[4] = f[4];
            h[5] = f[5];
            return h
        },
        copy: function(f, h) {
            f[0] = h[0];
            f[1] = h[1];
            f[2] = h[2];
            f[3] = h[3];
            f[4] = h[4];
            f[5] = h[5];
            return f
        },
        identity: function(f) {
            f[0] = 1;
            f[1] = 0;
            f[2] = 0;
            f[3] = 1;
            f[4] = 0;
            f[5] = 0;
            return f
        },
        fromValues: function(f, h, m, q, r, u) {
            var v = new aa(6);
            v[0] = f;
            v[1] = h;
            v[2] = m;
            v[3] = q;
            v[4] = r;
            v[5] = u;
            return v
        },
        set: function(f, h, m, q, r, u, v) {
            f[0] = h;
            f[1] = m;
            f[2] = q;
            f[3] = r;
            f[4] = u;
            f[5] = v;
            return f
        },
        invert: function(f, h) {
            var m = h[0]
              , q = h[1]
              , r = h[2]
              , u = h[3]
              , v = h[4];
            h = h[5];
            var x = m * u - q * r;
            if (!x)
                return null;
            x = 1 / x;
            f[0] = u * x;
            f[1] = -q * x;
            f[2] = -r * x;
            f[3] = m * x;
            f[4] = (r * h - u * v) * x;
            f[5] = (q * v - m * h) * x;
            return f
        },
        determinant: function(f) {
            return f[0] * f[3] - f[1] * f[2]
        },
        multiply: c,
        rotate: function(f, h, m) {
            var q = h[0]
              , r = h[1]
              , u = h[2]
              , v = h[3]
              , x = h[4];
            h = h[5];
            var y = Math.sin(m);
            m = Math.cos(m);
            f[0] = q * m + u * y;
            f[1] = r * m + v * y;
            f[2] = q * -y + u * m;
            f[3] = r * -y + v * m;
            f[4] = x;
            f[5] = h;
            return f
        },
        scale: function(f, h, m) {
            var q = h[1]
              , r = h[2]
              , u = h[3]
              , v = h[4]
              , x = h[5]
              , y = m[0];
            m = m[1];
            f[0] = h[0] * y;
            f[1] = q * y;
            f[2] = r * m;
            f[3] = u * m;
            f[4] = v;
            f[5] = x;
            return f
        },
        translate: function(f, h, m) {
            var q = h[0]
              , r = h[1]
              , u = h[2]
              , v = h[3]
              , x = h[4];
            h = h[5];
            var y = m[0];
            m = m[1];
            f[0] = q;
            f[1] = r;
            f[2] = u;
            f[3] = v;
            f[4] = q * y + u * m + x;
            f[5] = r * y + v * m + h;
            return f
        },
        fromRotation: function(f, h) {
            var m = Math.sin(h);
            h = Math.cos(h);
            f[0] = h;
            f[1] = m;
            f[2] = -m;
            f[3] = h;
            f[4] = 0;
            f[5] = 0;
            return f
        },
        fromScaling: function(f, h) {
            f[0] = h[0];
            f[1] = 0;
            f[2] = 0;
            f[3] = h[1];
            f[4] = 0;
            f[5] = 0;
            return f
        },
        fromTranslation: function(f, h) {
            f[0] = 1;
            f[1] = 0;
            f[2] = 0;
            f[3] = 1;
            f[4] = h[0];
            f[5] = h[1];
            return f
        },
        str: function(f) {
            return "mat2d(" + f[0] + ", " + f[1] + ", " + f[2] + ", " + f[3] + ", " + f[4] + ", " + f[5] + ")"
        },
        frob: function(f) {
            return Math.hypot(f[0], f[1], f[2], f[3], f[4], f[5], 1)
        },
        add: function(f, h, m) {
            f[0] = h[0] + m[0];
            f[1] = h[1] + m[1];
            f[2] = h[2] + m[2];
            f[3] = h[3] + m[3];
            f[4] = h[4] + m[4];
            f[5] = h[5] + m[5];
            return f
        },
        subtract: e,
        multiplyScalar: function(f, h, m) {
            f[0] = h[0] * m;
            f[1] = h[1] * m;
            f[2] = h[2] * m;
            f[3] = h[3] * m;
            f[4] = h[4] * m;
            f[5] = h[5] * m;
            return f
        },
        multiplyScalarAndAdd: function(f, h, m, q) {
            f[0] = h[0] + m[0] * q;
            f[1] = h[1] + m[1] * q;
            f[2] = h[2] + m[2] * q;
            f[3] = h[3] + m[3] * q;
            f[4] = h[4] + m[4] * q;
            f[5] = h[5] + m[5] * q;
            return f
        },
        exactEquals: function(f, h) {
            return f[0] === h[0] && f[1] === h[1] && f[2] === h[2] && f[3] === h[3] && f[4] === h[4] && f[5] === h[5]
        },
        equals: function(f, h) {
            var m = f[0]
              , q = f[1]
              , r = f[2]
              , u = f[3]
              , v = f[4];
            f = f[5];
            var x = h[0]
              , y = h[1]
              , A = h[2]
              , D = h[3]
              , G = h[4];
            h = h[5];
            return Math.abs(m - x) <= 1E-6 * Math.max(1, Math.abs(m), Math.abs(x)) && Math.abs(q - y) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(y)) && Math.abs(r - A) <= 1E-6 * Math.max(1, Math.abs(r), Math.abs(A)) && Math.abs(u - D) <= 1E-6 * Math.max(1, Math.abs(u), Math.abs(D)) && Math.abs(v - G) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(G)) && Math.abs(f - h) <= 1E-6 * Math.max(1, Math.abs(f), Math.abs(h))
        },
        mul: c,
        sub: e
    })
      , lb = Object.freeze({
        __proto__: null,
        create: g,
        fromMat4: function(f, h) {
            f[0] = h[0];
            f[1] = h[1];
            f[2] = h[2];
            f[3] = h[4];
            f[4] = h[5];
            f[5] = h[6];
            f[6] = h[8];
            f[7] = h[9];
            f[8] = h[10];
            return f
        },
        clone: function(f) {
            var h = new aa(9);
            h[0] = f[0];
            h[1] = f[1];
            h[2] = f[2];
            h[3] = f[3];
            h[4] = f[4];
            h[5] = f[5];
            h[6] = f[6];
            h[7] = f[7];
            h[8] = f[8];
            return h
        },
        copy: function(f, h) {
            f[0] = h[0];
            f[1] = h[1];
            f[2] = h[2];
            f[3] = h[3];
            f[4] = h[4];
            f[5] = h[5];
            f[6] = h[6];
            f[7] = h[7];
            f[8] = h[8];
            return f
        },
        fromValues: function(f, h, m, q, r, u, v, x, y) {
            var A = new aa(9);
            A[0] = f;
            A[1] = h;
            A[2] = m;
            A[3] = q;
            A[4] = r;
            A[5] = u;
            A[6] = v;
            A[7] = x;
            A[8] = y;
            return A
        },
        set: function(f, h, m, q, r, u, v, x, y, A) {
            f[0] = h;
            f[1] = m;
            f[2] = q;
            f[3] = r;
            f[4] = u;
            f[5] = v;
            f[6] = x;
            f[7] = y;
            f[8] = A;
            return f
        },
        identity: function(f) {
            f[0] = 1;
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = 1;
            f[5] = 0;
            f[6] = 0;
            f[7] = 0;
            f[8] = 1;
            return f
        },
        transpose: function(f, h) {
            if (f === h) {
                var m = h[1]
                  , q = h[2]
                  , r = h[5];
                f[1] = h[3];
                f[2] = h[6];
                f[3] = m;
                f[5] = h[7];
                f[6] = q;
                f[7] = r
            } else
                f[0] = h[0],
                f[1] = h[3],
                f[2] = h[6],
                f[3] = h[1],
                f[4] = h[4],
                f[5] = h[7],
                f[6] = h[2],
                f[7] = h[5],
                f[8] = h[8];
            return f
        },
        invert: function(f, h) {
            var m = h[0]
              , q = h[1]
              , r = h[2]
              , u = h[3]
              , v = h[4]
              , x = h[5]
              , y = h[6]
              , A = h[7];
            h = h[8];
            var D = h * v - x * A
              , G = -h * u + x * y
              , I = A * u - v * y
              , H = m * D + q * G + r * I;
            if (!H)
                return null;
            H = 1 / H;
            f[0] = D * H;
            f[1] = (-h * q + r * A) * H;
            f[2] = (x * q - r * v) * H;
            f[3] = G * H;
            f[4] = (h * m - r * y) * H;
            f[5] = (-x * m + r * u) * H;
            f[6] = I * H;
            f[7] = (-A * m + q * y) * H;
            f[8] = (v * m - q * u) * H;
            return f
        },
        adjoint: function(f, h) {
            var m = h[0]
              , q = h[1]
              , r = h[2]
              , u = h[3]
              , v = h[4]
              , x = h[5]
              , y = h[6]
              , A = h[7];
            h = h[8];
            f[0] = v * h - x * A;
            f[1] = r * A - q * h;
            f[2] = q * x - r * v;
            f[3] = x * y - u * h;
            f[4] = m * h - r * y;
            f[5] = r * u - m * x;
            f[6] = u * A - v * y;
            f[7] = q * y - m * A;
            f[8] = m * v - q * u;
            return f
        },
        determinant: function(f) {
            var h = f[3]
              , m = f[4]
              , q = f[5]
              , r = f[6]
              , u = f[7]
              , v = f[8];
            return f[0] * (v * m - q * u) + f[1] * (-v * h + q * r) + f[2] * (u * h - m * r)
        },
        multiply: k,
        translate: function(f, h, m) {
            var q = h[0]
              , r = h[1]
              , u = h[2]
              , v = h[3]
              , x = h[4]
              , y = h[5]
              , A = h[6]
              , D = h[7];
            h = h[8];
            var G = m[0];
            m = m[1];
            f[0] = q;
            f[1] = r;
            f[2] = u;
            f[3] = v;
            f[4] = x;
            f[5] = y;
            f[6] = G * q + m * v + A;
            f[7] = G * r + m * x + D;
            f[8] = G * u + m * y + h;
            return f
        },
        rotate: function(f, h, m) {
            var q = h[0]
              , r = h[1]
              , u = h[2]
              , v = h[3]
              , x = h[4]
              , y = h[5]
              , A = h[6]
              , D = h[7];
            h = h[8];
            var G = Math.sin(m);
            m = Math.cos(m);
            f[0] = m * q + G * v;
            f[1] = m * r + G * x;
            f[2] = m * u + G * y;
            f[3] = m * v - G * q;
            f[4] = m * x - G * r;
            f[5] = m * y - G * u;
            f[6] = A;
            f[7] = D;
            f[8] = h;
            return f
        },
        scale: function(f, h, m) {
            var q = m[0];
            m = m[1];
            f[0] = q * h[0];
            f[1] = q * h[1];
            f[2] = q * h[2];
            f[3] = m * h[3];
            f[4] = m * h[4];
            f[5] = m * h[5];
            f[6] = h[6];
            f[7] = h[7];
            f[8] = h[8];
            return f
        },
        fromTranslation: function(f, h) {
            f[0] = 1;
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = 1;
            f[5] = 0;
            f[6] = h[0];
            f[7] = h[1];
            f[8] = 1;
            return f
        },
        fromRotation: function(f, h) {
            var m = Math.sin(h);
            h = Math.cos(h);
            f[0] = h;
            f[1] = m;
            f[2] = 0;
            f[3] = -m;
            f[4] = h;
            f[5] = 0;
            f[6] = 0;
            f[7] = 0;
            f[8] = 1;
            return f
        },
        fromScaling: function(f, h) {
            f[0] = h[0];
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = h[1];
            f[5] = 0;
            f[6] = 0;
            f[7] = 0;
            f[8] = 1;
            return f
        },
        fromMat2d: function(f, h) {
            f[0] = h[0];
            f[1] = h[1];
            f[2] = 0;
            f[3] = h[2];
            f[4] = h[3];
            f[5] = 0;
            f[6] = h[4];
            f[7] = h[5];
            f[8] = 1;
            return f
        },
        fromQuat: function(f, h) {
            var m = h[0]
              , q = h[1]
              , r = h[2];
            h = h[3];
            var u = m + m
              , v = q + q
              , x = r + r;
            m *= u;
            var y = q * u;
            q *= v;
            var A = r * u
              , D = r * v;
            r *= x;
            u *= h;
            v *= h;
            h *= x;
            f[0] = 1 - q - r;
            f[3] = y - h;
            f[6] = A + v;
            f[1] = y + h;
            f[4] = 1 - m - r;
            f[7] = D - u;
            f[2] = A - v;
            f[5] = D + u;
            f[8] = 1 - m - q;
            return f
        },
        normalFromMat4: function(f, h) {
            var m = h[0]
              , q = h[1]
              , r = h[2]
              , u = h[3]
              , v = h[4]
              , x = h[5]
              , y = h[6]
              , A = h[7]
              , D = h[8]
              , G = h[9]
              , I = h[10]
              , H = h[11]
              , N = h[12]
              , O = h[13]
              , L = h[14];
            h = h[15];
            var V = m * x - q * v
              , S = m * y - r * v
              , Y = m * A - u * v
              , Z = q * y - r * x
              , W = q * A - u * x
              , la = r * A - u * y
              , ma = D * O - G * N
              , na = D * L - I * N;
            D = D * h - H * N;
            var oa = G * L - I * O;
            G = G * h - H * O;
            I = I * h - H * L;
            H = V * I - S * G + Y * oa + Z * D - W * na + la * ma;
            if (!H)
                return null;
            H = 1 / H;
            f[0] = (x * I - y * G + A * oa) * H;
            f[1] = (y * D - v * I - A * na) * H;
            f[2] = (v * G - x * D + A * ma) * H;
            f[3] = (r * G - q * I - u * oa) * H;
            f[4] = (m * I - r * D + u * na) * H;
            f[5] = (q * D - m * G - u * ma) * H;
            f[6] = (O * la - L * W + h * Z) * H;
            f[7] = (L * Y - N * la - h * S) * H;
            f[8] = (N * W - O * Y + h * V) * H;
            return f
        },
        projection: function(f, h, m) {
            f[0] = 2 / h;
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = -2 / m;
            f[5] = 0;
            f[6] = -1;
            f[7] = 1;
            f[8] = 1;
            return f
        },
        str: function(f) {
            return "mat3(" + f[0] + ", " + f[1] + ", " + f[2] + ", " + f[3] + ", " + f[4] + ", " + f[5] + ", " + f[6] + ", " + f[7] + ", " + f[8] + ")"
        },
        frob: function(f) {
            return Math.hypot(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8])
        },
        add: function(f, h, m) {
            f[0] = h[0] + m[0];
            f[1] = h[1] + m[1];
            f[2] = h[2] + m[2];
            f[3] = h[3] + m[3];
            f[4] = h[4] + m[4];
            f[5] = h[5] + m[5];
            f[6] = h[6] + m[6];
            f[7] = h[7] + m[7];
            f[8] = h[8] + m[8];
            return f
        },
        subtract: l,
        multiplyScalar: function(f, h, m) {
            f[0] = h[0] * m;
            f[1] = h[1] * m;
            f[2] = h[2] * m;
            f[3] = h[3] * m;
            f[4] = h[4] * m;
            f[5] = h[5] * m;
            f[6] = h[6] * m;
            f[7] = h[7] * m;
            f[8] = h[8] * m;
            return f
        },
        multiplyScalarAndAdd: function(f, h, m, q) {
            f[0] = h[0] + m[0] * q;
            f[1] = h[1] + m[1] * q;
            f[2] = h[2] + m[2] * q;
            f[3] = h[3] + m[3] * q;
            f[4] = h[4] + m[4] * q;
            f[5] = h[5] + m[5] * q;
            f[6] = h[6] + m[6] * q;
            f[7] = h[7] + m[7] * q;
            f[8] = h[8] + m[8] * q;
            return f
        },
        exactEquals: function(f, h) {
            return f[0] === h[0] && f[1] === h[1] && f[2] === h[2] && f[3] === h[3] && f[4] === h[4] && f[5] === h[5] && f[6] === h[6] && f[7] === h[7] && f[8] === h[8]
        },
        equals: function(f, h) {
            var m = f[0]
              , q = f[1]
              , r = f[2]
              , u = f[3]
              , v = f[4]
              , x = f[5]
              , y = f[6]
              , A = f[7];
            f = f[8];
            var D = h[0]
              , G = h[1]
              , I = h[2]
              , H = h[3]
              , N = h[4]
              , O = h[5]
              , L = h[6]
              , V = h[7];
            h = h[8];
            return Math.abs(m - D) <= 1E-6 * Math.max(1, Math.abs(m), Math.abs(D)) && Math.abs(q - G) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(G)) && Math.abs(r - I) <= 1E-6 * Math.max(1, Math.abs(r), Math.abs(I)) && Math.abs(u - H) <= 1E-6 * Math.max(1, Math.abs(u), Math.abs(H)) && Math.abs(v - N) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(N)) && Math.abs(x - O) <= 1E-6 * Math.max(1, Math.abs(x), Math.abs(O)) && Math.abs(y - L) <= 1E-6 * Math.max(1, Math.abs(y), Math.abs(L)) && Math.abs(A - V) <= 1E-6 * Math.max(1, Math.abs(A), Math.abs(V)) && Math.abs(f - h) <= 1E-6 * Math.max(1, Math.abs(f), Math.abs(h))
        },
        mul: k,
        sub: l
    })
      , mb = Object.freeze({
        __proto__: null,
        create: function() {
            var f = new aa(16);
            aa != Float32Array && (f[1] = 0,
            f[2] = 0,
            f[3] = 0,
            f[4] = 0,
            f[6] = 0,
            f[7] = 0,
            f[8] = 0,
            f[9] = 0,
            f[11] = 0,
            f[12] = 0,
            f[13] = 0,
            f[14] = 0);
            f[0] = 1;
            f[5] = 1;
            f[10] = 1;
            f[15] = 1;
            return f
        },
        clone: function(f) {
            var h = new aa(16);
            h[0] = f[0];
            h[1] = f[1];
            h[2] = f[2];
            h[3] = f[3];
            h[4] = f[4];
            h[5] = f[5];
            h[6] = f[6];
            h[7] = f[7];
            h[8] = f[8];
            h[9] = f[9];
            h[10] = f[10];
            h[11] = f[11];
            h[12] = f[12];
            h[13] = f[13];
            h[14] = f[14];
            h[15] = f[15];
            return h
        },
        copy: function(f, h) {
            f[0] = h[0];
            f[1] = h[1];
            f[2] = h[2];
            f[3] = h[3];
            f[4] = h[4];
            f[5] = h[5];
            f[6] = h[6];
            f[7] = h[7];
            f[8] = h[8];
            f[9] = h[9];
            f[10] = h[10];
            f[11] = h[11];
            f[12] = h[12];
            f[13] = h[13];
            f[14] = h[14];
            f[15] = h[15];
            return f
        },
        fromValues: function(f, h, m, q, r, u, v, x, y, A, D, G, I, H, N, O) {
            var L = new aa(16);
            L[0] = f;
            L[1] = h;
            L[2] = m;
            L[3] = q;
            L[4] = r;
            L[5] = u;
            L[6] = v;
            L[7] = x;
            L[8] = y;
            L[9] = A;
            L[10] = D;
            L[11] = G;
            L[12] = I;
            L[13] = H;
            L[14] = N;
            L[15] = O;
            return L
        },
        set: function(f, h, m, q, r, u, v, x, y, A, D, G, I, H, N, O, L) {
            f[0] = h;
            f[1] = m;
            f[2] = q;
            f[3] = r;
            f[4] = u;
            f[5] = v;
            f[6] = x;
            f[7] = y;
            f[8] = A;
            f[9] = D;
            f[10] = G;
            f[11] = I;
            f[12] = H;
            f[13] = N;
            f[14] = O;
            f[15] = L;
            return f
        },
        identity: n,
        transpose: function(f, h) {
            if (f === h) {
                var m = h[1]
                  , q = h[2]
                  , r = h[3]
                  , u = h[6]
                  , v = h[7]
                  , x = h[11];
                f[1] = h[4];
                f[2] = h[8];
                f[3] = h[12];
                f[4] = m;
                f[6] = h[9];
                f[7] = h[13];
                f[8] = q;
                f[9] = u;
                f[11] = h[14];
                f[12] = r;
                f[13] = v;
                f[14] = x
            } else
                f[0] = h[0],
                f[1] = h[4],
                f[2] = h[8],
                f[3] = h[12],
                f[4] = h[1],
                f[5] = h[5],
                f[6] = h[9],
                f[7] = h[13],
                f[8] = h[2],
                f[9] = h[6],
                f[10] = h[10],
                f[11] = h[14],
                f[12] = h[3],
                f[13] = h[7],
                f[14] = h[11],
                f[15] = h[15];
            return f
        },
        invert: function(f, h) {
            var m = h[0]
              , q = h[1]
              , r = h[2]
              , u = h[3]
              , v = h[4]
              , x = h[5]
              , y = h[6]
              , A = h[7]
              , D = h[8]
              , G = h[9]
              , I = h[10]
              , H = h[11]
              , N = h[12]
              , O = h[13]
              , L = h[14];
            h = h[15];
            var V = m * x - q * v
              , S = m * y - r * v
              , Y = m * A - u * v
              , Z = q * y - r * x
              , W = q * A - u * x
              , la = r * A - u * y
              , ma = D * O - G * N
              , na = D * L - I * N
              , oa = D * h - H * N
              , sa = G * L - I * O
              , va = G * h - H * O
              , wa = I * h - H * L
              , pa = V * wa - S * va + Y * sa + Z * oa - W * na + la * ma;
            if (!pa)
                return null;
            pa = 1 / pa;
            f[0] = (x * wa - y * va + A * sa) * pa;
            f[1] = (r * va - q * wa - u * sa) * pa;
            f[2] = (O * la - L * W + h * Z) * pa;
            f[3] = (I * W - G * la - H * Z) * pa;
            f[4] = (y * oa - v * wa - A * na) * pa;
            f[5] = (m * wa - r * oa + u * na) * pa;
            f[6] = (L * Y - N * la - h * S) * pa;
            f[7] = (D * la - I * Y + H * S) * pa;
            f[8] = (v * va - x * oa + A * ma) * pa;
            f[9] = (q * oa - m * va - u * ma) * pa;
            f[10] = (N * W - O * Y + h * V) * pa;
            f[11] = (G * Y - D * W - H * V) * pa;
            f[12] = (x * na - v * sa - y * ma) * pa;
            f[13] = (m * sa - q * na + r * ma) * pa;
            f[14] = (O * S - N * Z - L * V) * pa;
            f[15] = (D * Z - G * S + I * V) * pa;
            return f
        },
        adjoint: function(f, h) {
            var m = h[0]
              , q = h[1]
              , r = h[2]
              , u = h[3]
              , v = h[4]
              , x = h[5]
              , y = h[6]
              , A = h[7]
              , D = h[8]
              , G = h[9]
              , I = h[10]
              , H = h[11]
              , N = h[12]
              , O = h[13]
              , L = h[14];
            h = h[15];
            var V = m * x - q * v
              , S = m * y - r * v
              , Y = m * A - u * v
              , Z = q * y - r * x
              , W = q * A - u * x
              , la = r * A - u * y
              , ma = D * O - G * N
              , na = D * L - I * N
              , oa = D * h - H * N
              , sa = G * L - I * O
              , va = G * h - H * O
              , wa = I * h - H * L;
            f[0] = x * wa - y * va + A * sa;
            f[1] = r * va - q * wa - u * sa;
            f[2] = O * la - L * W + h * Z;
            f[3] = I * W - G * la - H * Z;
            f[4] = y * oa - v * wa - A * na;
            f[5] = m * wa - r * oa + u * na;
            f[6] = L * Y - N * la - h * S;
            f[7] = D * la - I * Y + H * S;
            f[8] = v * va - x * oa + A * ma;
            f[9] = q * oa - m * va - u * ma;
            f[10] = N * W - O * Y + h * V;
            f[11] = G * Y - D * W - H * V;
            f[12] = x * na - v * sa - y * ma;
            f[13] = m * sa - q * na + r * ma;
            f[14] = O * S - N * Z - L * V;
            f[15] = D * Z - G * S + I * V;
            return f
        },
        determinant: function(f) {
            var h = f[0]
              , m = f[1]
              , q = f[2]
              , r = f[4]
              , u = f[5]
              , v = f[6]
              , x = f[8]
              , y = f[9]
              , A = f[10]
              , D = f[12]
              , G = f[13]
              , I = f[14]
              , H = h * u - m * r
              , N = h * v - q * r
              , O = m * v - q * u
              , L = x * G - y * D
              , V = x * I - A * D
              , S = y * I - A * G;
            return f[7] * (h * S - m * V + q * L) - f[3] * (r * S - u * V + v * L) + f[15] * (x * O - y * N + A * H) - f[11] * (D * O - G * N + I * H)
        },
        multiply: p,
        translate: function(f, h, m) {
            var q = m[0]
              , r = m[1];
            m = m[2];
            if (h === f)
                f[12] = h[0] * q + h[4] * r + h[8] * m + h[12],
                f[13] = h[1] * q + h[5] * r + h[9] * m + h[13],
                f[14] = h[2] * q + h[6] * r + h[10] * m + h[14],
                f[15] = h[3] * q + h[7] * r + h[11] * m + h[15];
            else {
                var u = h[0];
                var v = h[1];
                var x = h[2];
                var y = h[3];
                var A = h[4];
                var D = h[5];
                var G = h[6];
                var I = h[7];
                var H = h[8];
                var N = h[9];
                var O = h[10];
                var L = h[11];
                f[0] = u;
                f[1] = v;
                f[2] = x;
                f[3] = y;
                f[4] = A;
                f[5] = D;
                f[6] = G;
                f[7] = I;
                f[8] = H;
                f[9] = N;
                f[10] = O;
                f[11] = L;
                f[12] = u * q + A * r + H * m + h[12];
                f[13] = v * q + D * r + N * m + h[13];
                f[14] = x * q + G * r + O * m + h[14];
                f[15] = y * q + I * r + L * m + h[15]
            }
            return f
        },
        scale: function(f, h, m) {
            var q = m[0]
              , r = m[1];
            m = m[2];
            f[0] = h[0] * q;
            f[1] = h[1] * q;
            f[2] = h[2] * q;
            f[3] = h[3] * q;
            f[4] = h[4] * r;
            f[5] = h[5] * r;
            f[6] = h[6] * r;
            f[7] = h[7] * r;
            f[8] = h[8] * m;
            f[9] = h[9] * m;
            f[10] = h[10] * m;
            f[11] = h[11] * m;
            f[12] = h[12];
            f[13] = h[13];
            f[14] = h[14];
            f[15] = h[15];
            return f
        },
        rotate: function(f, h, m, q) {
            var r = q[0]
              , u = q[1];
            q = q[2];
            var v = Math.hypot(r, u, q);
            if (1E-6 > v)
                return null;
            v = 1 / v;
            r *= v;
            u *= v;
            q *= v;
            var x = Math.sin(m);
            var y = Math.cos(m);
            var A = 1 - y;
            m = h[0];
            v = h[1];
            var D = h[2];
            var G = h[3];
            var I = h[4];
            var H = h[5];
            var N = h[6];
            var O = h[7];
            var L = h[8];
            var V = h[9];
            var S = h[10];
            var Y = h[11];
            var Z = r * r * A + y;
            var W = u * r * A + q * x;
            var la = q * r * A - u * x;
            var ma = r * u * A - q * x;
            var na = u * u * A + y;
            var oa = q * u * A + r * x;
            var sa = r * q * A + u * x;
            r = u * q * A - r * x;
            u = q * q * A + y;
            f[0] = m * Z + I * W + L * la;
            f[1] = v * Z + H * W + V * la;
            f[2] = D * Z + N * W + S * la;
            f[3] = G * Z + O * W + Y * la;
            f[4] = m * ma + I * na + L * oa;
            f[5] = v * ma + H * na + V * oa;
            f[6] = D * ma + N * na + S * oa;
            f[7] = G * ma + O * na + Y * oa;
            f[8] = m * sa + I * r + L * u;
            f[9] = v * sa + H * r + V * u;
            f[10] = D * sa + N * r + S * u;
            f[11] = G * sa + O * r + Y * u;
            h !== f && (f[12] = h[12],
            f[13] = h[13],
            f[14] = h[14],
            f[15] = h[15]);
            return f
        },
        rotateX: function(f, h, m) {
            var q = Math.sin(m);
            m = Math.cos(m);
            var r = h[4]
              , u = h[5]
              , v = h[6]
              , x = h[7]
              , y = h[8]
              , A = h[9]
              , D = h[10]
              , G = h[11];
            h !== f && (f[0] = h[0],
            f[1] = h[1],
            f[2] = h[2],
            f[3] = h[3],
            f[12] = h[12],
            f[13] = h[13],
            f[14] = h[14],
            f[15] = h[15]);
            f[4] = r * m + y * q;
            f[5] = u * m + A * q;
            f[6] = v * m + D * q;
            f[7] = x * m + G * q;
            f[8] = y * m - r * q;
            f[9] = A * m - u * q;
            f[10] = D * m - v * q;
            f[11] = G * m - x * q;
            return f
        },
        rotateY: function(f, h, m) {
            var q = Math.sin(m);
            m = Math.cos(m);
            var r = h[0]
              , u = h[1]
              , v = h[2]
              , x = h[3]
              , y = h[8]
              , A = h[9]
              , D = h[10]
              , G = h[11];
            h !== f && (f[4] = h[4],
            f[5] = h[5],
            f[6] = h[6],
            f[7] = h[7],
            f[12] = h[12],
            f[13] = h[13],
            f[14] = h[14],
            f[15] = h[15]);
            f[0] = r * m - y * q;
            f[1] = u * m - A * q;
            f[2] = v * m - D * q;
            f[3] = x * m - G * q;
            f[8] = r * q + y * m;
            f[9] = u * q + A * m;
            f[10] = v * q + D * m;
            f[11] = x * q + G * m;
            return f
        },
        rotateZ: function(f, h, m) {
            var q = Math.sin(m);
            m = Math.cos(m);
            var r = h[0]
              , u = h[1]
              , v = h[2]
              , x = h[3]
              , y = h[4]
              , A = h[5]
              , D = h[6]
              , G = h[7];
            h !== f && (f[8] = h[8],
            f[9] = h[9],
            f[10] = h[10],
            f[11] = h[11],
            f[12] = h[12],
            f[13] = h[13],
            f[14] = h[14],
            f[15] = h[15]);
            f[0] = r * m + y * q;
            f[1] = u * m + A * q;
            f[2] = v * m + D * q;
            f[3] = x * m + G * q;
            f[4] = y * m - r * q;
            f[5] = A * m - u * q;
            f[6] = D * m - v * q;
            f[7] = G * m - x * q;
            return f
        },
        fromTranslation: function(f, h) {
            f[0] = 1;
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = 0;
            f[5] = 1;
            f[6] = 0;
            f[7] = 0;
            f[8] = 0;
            f[9] = 0;
            f[10] = 1;
            f[11] = 0;
            f[12] = h[0];
            f[13] = h[1];
            f[14] = h[2];
            f[15] = 1;
            return f
        },
        fromScaling: function(f, h) {
            f[0] = h[0];
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = 0;
            f[5] = h[1];
            f[6] = 0;
            f[7] = 0;
            f[8] = 0;
            f[9] = 0;
            f[10] = h[2];
            f[11] = 0;
            f[12] = 0;
            f[13] = 0;
            f[14] = 0;
            f[15] = 1;
            return f
        },
        fromRotation: function(f, h, m) {
            var q = m[0]
              , r = m[1];
            m = m[2];
            var u = Math.hypot(q, r, m);
            if (1E-6 > u)
                return null;
            u = 1 / u;
            q *= u;
            r *= u;
            m *= u;
            u = Math.sin(h);
            h = Math.cos(h);
            var v = 1 - h;
            f[0] = q * q * v + h;
            f[1] = r * q * v + m * u;
            f[2] = m * q * v - r * u;
            f[3] = 0;
            f[4] = q * r * v - m * u;
            f[5] = r * r * v + h;
            f[6] = m * r * v + q * u;
            f[7] = 0;
            f[8] = q * m * v + r * u;
            f[9] = r * m * v - q * u;
            f[10] = m * m * v + h;
            f[11] = 0;
            f[12] = 0;
            f[13] = 0;
            f[14] = 0;
            f[15] = 1;
            return f
        },
        fromXRotation: function(f, h) {
            var m = Math.sin(h);
            h = Math.cos(h);
            f[0] = 1;
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = 0;
            f[5] = h;
            f[6] = m;
            f[7] = 0;
            f[8] = 0;
            f[9] = -m;
            f[10] = h;
            f[11] = 0;
            f[12] = 0;
            f[13] = 0;
            f[14] = 0;
            f[15] = 1;
            return f
        },
        fromYRotation: function(f, h) {
            var m = Math.sin(h);
            h = Math.cos(h);
            f[0] = h;
            f[1] = 0;
            f[2] = -m;
            f[3] = 0;
            f[4] = 0;
            f[5] = 1;
            f[6] = 0;
            f[7] = 0;
            f[8] = m;
            f[9] = 0;
            f[10] = h;
            f[11] = 0;
            f[12] = 0;
            f[13] = 0;
            f[14] = 0;
            f[15] = 1;
            return f
        },
        fromZRotation: function(f, h) {
            var m = Math.sin(h);
            h = Math.cos(h);
            f[0] = h;
            f[1] = m;
            f[2] = 0;
            f[3] = 0;
            f[4] = -m;
            f[5] = h;
            f[6] = 0;
            f[7] = 0;
            f[8] = 0;
            f[9] = 0;
            f[10] = 1;
            f[11] = 0;
            f[12] = 0;
            f[13] = 0;
            f[14] = 0;
            f[15] = 1;
            return f
        },
        fromRotationTranslation: t,
        fromQuat2: function(f, h) {
            var m = new aa(3)
              , q = -h[0]
              , r = -h[1]
              , u = -h[2]
              , v = h[3]
              , x = h[4]
              , y = h[5]
              , A = h[6]
              , D = h[7]
              , G = q * q + r * r + u * u + v * v;
            0 < G ? (m[0] = 2 * (x * v + D * q + y * u - A * r) / G,
            m[1] = 2 * (y * v + D * r + A * q - x * u) / G,
            m[2] = 2 * (A * v + D * u + x * r - y * q) / G) : (m[0] = 2 * (x * v + D * q + y * u - A * r),
            m[1] = 2 * (y * v + D * r + A * q - x * u),
            m[2] = 2 * (A * v + D * u + x * r - y * q));
            t(f, h, m);
            return f
        },
        getTranslation: w,
        getScaling: z,
        getRotation: B,
        decompose: function(f, h, m, q) {
            h[0] = q[12];
            h[1] = q[13];
            h[2] = q[14];
            var r = q[0]
              , u = q[1]
              , v = q[2]
              , x = q[4]
              , y = q[5]
              , A = q[6]
              , D = q[8];
            h = q[9];
            q = q[10];
            m[0] = Math.hypot(r, u, v);
            m[1] = Math.hypot(x, y, A);
            m[2] = Math.hypot(D, h, q);
            var G = 1 / m[0]
              , I = 1 / m[1]
              , H = 1 / m[2];
            m = r * G;
            u *= I;
            v *= H;
            x *= G;
            y *= I;
            A *= H;
            D *= G;
            h *= I;
            q *= H;
            I = m + y + q;
            0 < I ? (q = 2 * Math.sqrt(I + 1),
            f[3] = .25 * q,
            f[0] = (A - h) / q,
            f[1] = (D - v) / q,
            f[2] = (u - x) / q) : m > y && m > q ? (q = 2 * Math.sqrt(1 + m - y - q),
            f[3] = (A - h) / q,
            f[0] = .25 * q,
            f[1] = (u + x) / q,
            f[2] = (D + v) / q) : y > q ? (q = 2 * Math.sqrt(1 + y - m - q),
            f[3] = (D - v) / q,
            f[0] = (u + x) / q,
            f[1] = .25 * q,
            f[2] = (A + h) / q) : (q = 2 * Math.sqrt(1 + q - m - y),
            f[3] = (u - x) / q,
            f[0] = (D + v) / q,
            f[1] = (A + h) / q,
            f[2] = .25 * q);
            return f
        },
        fromRotationTranslationScale: function(f, h, m, q) {
            var r = h[0]
              , u = h[1]
              , v = h[2]
              , x = h[3]
              , y = r + r
              , A = u + u
              , D = v + v;
            h = r * y;
            var G = r * A;
            r *= D;
            var I = u * A;
            u *= D;
            v *= D;
            y *= x;
            A *= x;
            x *= D;
            D = q[0];
            var H = q[1];
            q = q[2];
            f[0] = (1 - (I + v)) * D;
            f[1] = (G + x) * D;
            f[2] = (r - A) * D;
            f[3] = 0;
            f[4] = (G - x) * H;
            f[5] = (1 - (h + v)) * H;
            f[6] = (u + y) * H;
            f[7] = 0;
            f[8] = (r + A) * q;
            f[9] = (u - y) * q;
            f[10] = (1 - (h + I)) * q;
            f[11] = 0;
            f[12] = m[0];
            f[13] = m[1];
            f[14] = m[2];
            f[15] = 1;
            return f
        },
        fromRotationTranslationScaleOrigin: function(f, h, m, q, r) {
            var u = h[0]
              , v = h[1]
              , x = h[2]
              , y = h[3]
              , A = u + u
              , D = v + v
              , G = x + x;
            h = u * A;
            var I = u * D
              , H = u * G;
            u = v * D;
            v *= G;
            var N = x * G;
            x = y * A;
            D *= y;
            var O = y * G
              , L = q[0]
              , V = q[1];
            G = q[2];
            q = r[0];
            y = r[1];
            r = r[2];
            A = (1 - (u + N)) * L;
            var S = (I + O) * L;
            L *= H - D;
            I = (I - O) * V;
            N = (1 - (h + N)) * V;
            V *= v + x;
            H = (H + D) * G;
            v = (v - x) * G;
            h = (1 - (h + u)) * G;
            f[0] = A;
            f[1] = S;
            f[2] = L;
            f[3] = 0;
            f[4] = I;
            f[5] = N;
            f[6] = V;
            f[7] = 0;
            f[8] = H;
            f[9] = v;
            f[10] = h;
            f[11] = 0;
            f[12] = m[0] + q - (A * q + I * y + H * r);
            f[13] = m[1] + y - (S * q + N * y + v * r);
            f[14] = m[2] + r - (L * q + V * y + h * r);
            f[15] = 1;
            return f
        },
        fromQuat: function(f, h) {
            var m = h[0]
              , q = h[1]
              , r = h[2];
            h = h[3];
            var u = m + m
              , v = q + q
              , x = r + r;
            m *= u;
            var y = q * u;
            q *= v;
            var A = r * u
              , D = r * v;
            r *= x;
            u *= h;
            v *= h;
            h *= x;
            f[0] = 1 - q - r;
            f[1] = y + h;
            f[2] = A - v;
            f[3] = 0;
            f[4] = y - h;
            f[5] = 1 - m - r;
            f[6] = D + u;
            f[7] = 0;
            f[8] = A + v;
            f[9] = D - u;
            f[10] = 1 - m - q;
            f[11] = 0;
            f[12] = 0;
            f[13] = 0;
            f[14] = 0;
            f[15] = 1;
            return f
        },
        frustum: function(f, h, m, q, r, u, v) {
            var x = 1 / (m - h)
              , y = 1 / (r - q)
              , A = 1 / (u - v);
            f[0] = 2 * u * x;
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = 0;
            f[5] = 2 * u * y;
            f[6] = 0;
            f[7] = 0;
            f[8] = (m + h) * x;
            f[9] = (r + q) * y;
            f[10] = (v + u) * A;
            f[11] = -1;
            f[12] = 0;
            f[13] = 0;
            f[14] = v * u * 2 * A;
            f[15] = 0;
            return f
        },
        perspectiveNO: C,
        perspective: C,
        perspectiveZO: function(f, h, m, q, r) {
            h = 1 / Math.tan(h / 2);
            f[0] = h / m;
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = 0;
            f[5] = h;
            f[6] = 0;
            f[7] = 0;
            f[8] = 0;
            f[9] = 0;
            f[11] = -1;
            f[12] = 0;
            f[13] = 0;
            f[15] = 0;
            null != r && Infinity !== r ? (m = 1 / (q - r),
            f[10] = r * m,
            f[14] = r * q * m) : (f[10] = -1,
            f[14] = -q);
            return f
        },
        perspectiveFromFieldOfView: function(f, h, m, q) {
            var r = Math.tan(h.upDegrees * Math.PI / 180)
              , u = Math.tan(h.downDegrees * Math.PI / 180)
              , v = Math.tan(h.leftDegrees * Math.PI / 180);
            h = Math.tan(h.rightDegrees * Math.PI / 180);
            var x = 2 / (v + h)
              , y = 2 / (r + u);
            f[0] = x;
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = 0;
            f[5] = y;
            f[6] = 0;
            f[7] = 0;
            f[8] = -((v - h) * x * .5);
            f[9] = (r - u) * y * .5;
            f[10] = q / (m - q);
            f[11] = -1;
            f[12] = 0;
            f[13] = 0;
            f[14] = q * m / (m - q);
            f[15] = 0;
            return f
        },
        orthoNO: E,
        ortho: E,
        orthoZO: function(f, h, m, q, r, u, v) {
            var x = 1 / (h - m)
              , y = 1 / (q - r);
            v = 1 / (u - v);
            f[0] = -2 * x;
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            f[4] = 0;
            f[5] = -2 * y;
            f[6] = 0;
            f[7] = 0;
            f[8] = 0;
            f[9] = 0;
            f[10] = v;
            f[11] = 0;
            f[12] = (h + m) * x;
            f[13] = (r + q) * y;
            f[14] = u * v;
            f[15] = 1;
            return f
        },
        lookAt: function(f, h, m, q) {
            var r = h[0]
              , u = h[1];
            h = h[2];
            var v = q[0];
            var x = q[1];
            var y = q[2];
            var A = m[0];
            q = m[1];
            var D = m[2];
            if (1E-6 > Math.abs(r - A) && 1E-6 > Math.abs(u - q) && 1E-6 > Math.abs(h - D))
                return n(f);
            m = r - A;
            q = u - q;
            A = h - D;
            var G = 1 / Math.hypot(m, q, A);
            m *= G;
            q *= G;
            A *= G;
            D = x * A - y * q;
            y = y * m - v * A;
            v = v * q - x * m;
            (G = Math.hypot(D, y, v)) ? (G = 1 / G,
            D *= G,
            y *= G,
            v *= G) : v = y = D = 0;
            x = q * v - A * y;
            var I = A * D - m * v;
            var H = m * y - q * D;
            (G = Math.hypot(x, I, H)) ? (G = 1 / G,
            x *= G,
            I *= G,
            H *= G) : H = I = x = 0;
            f[0] = D;
            f[1] = x;
            f[2] = m;
            f[3] = 0;
            f[4] = y;
            f[5] = I;
            f[6] = q;
            f[7] = 0;
            f[8] = v;
            f[9] = H;
            f[10] = A;
            f[11] = 0;
            f[12] = -(D * r + y * u + v * h);
            f[13] = -(x * r + I * u + H * h);
            f[14] = -(m * r + q * u + A * h);
            f[15] = 1;
            return f
        },
        targetTo: function(f, h, m, q) {
            var r = h[0]
              , u = h[1];
            h = h[2];
            var v = q[0]
              , x = q[1]
              , y = q[2];
            q = r - m[0];
            var A = u - m[1];
            m = h - m[2];
            var D = q * q + A * A + m * m;
            0 < D && (D = 1 / Math.sqrt(D),
            q *= D,
            A *= D,
            m *= D);
            var G = x * m - y * A;
            y = y * q - v * m;
            v = v * A - x * q;
            D = G * G + y * y + v * v;
            0 < D && (D = 1 / Math.sqrt(D),
            G *= D,
            y *= D,
            v *= D);
            f[0] = G;
            f[1] = y;
            f[2] = v;
            f[3] = 0;
            f[4] = A * v - m * y;
            f[5] = m * G - q * v;
            f[6] = q * y - A * G;
            f[7] = 0;
            f[8] = q;
            f[9] = A;
            f[10] = m;
            f[11] = 0;
            f[12] = r;
            f[13] = u;
            f[14] = h;
            f[15] = 1;
            return f
        },
        str: function(f) {
            return "mat4(" + f[0] + ", " + f[1] + ", " + f[2] + ", " + f[3] + ", " + f[4] + ", " + f[5] + ", " + f[6] + ", " + f[7] + ", " + f[8] + ", " + f[9] + ", " + f[10] + ", " + f[11] + ", " + f[12] + ", " + f[13] + ", " + f[14] + ", " + f[15] + ")"
        },
        frob: function(f) {
            return Math.hypot(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11], f[12], f[13], f[14], f[15])
        },
        add: function(f, h, m) {
            f[0] = h[0] + m[0];
            f[1] = h[1] + m[1];
            f[2] = h[2] + m[2];
            f[3] = h[3] + m[3];
            f[4] = h[4] + m[4];
            f[5] = h[5] + m[5];
            f[6] = h[6] + m[6];
            f[7] = h[7] + m[7];
            f[8] = h[8] + m[8];
            f[9] = h[9] + m[9];
            f[10] = h[10] + m[10];
            f[11] = h[11] + m[11];
            f[12] = h[12] + m[12];
            f[13] = h[13] + m[13];
            f[14] = h[14] + m[14];
            f[15] = h[15] + m[15];
            return f
        },
        subtract: F,
        multiplyScalar: function(f, h, m) {
            f[0] = h[0] * m;
            f[1] = h[1] * m;
            f[2] = h[2] * m;
            f[3] = h[3] * m;
            f[4] = h[4] * m;
            f[5] = h[5] * m;
            f[6] = h[6] * m;
            f[7] = h[7] * m;
            f[8] = h[8] * m;
            f[9] = h[9] * m;
            f[10] = h[10] * m;
            f[11] = h[11] * m;
            f[12] = h[12] * m;
            f[13] = h[13] * m;
            f[14] = h[14] * m;
            f[15] = h[15] * m;
            return f
        },
        multiplyScalarAndAdd: function(f, h, m, q) {
            f[0] = h[0] + m[0] * q;
            f[1] = h[1] + m[1] * q;
            f[2] = h[2] + m[2] * q;
            f[3] = h[3] + m[3] * q;
            f[4] = h[4] + m[4] * q;
            f[5] = h[5] + m[5] * q;
            f[6] = h[6] + m[6] * q;
            f[7] = h[7] + m[7] * q;
            f[8] = h[8] + m[8] * q;
            f[9] = h[9] + m[9] * q;
            f[10] = h[10] + m[10] * q;
            f[11] = h[11] + m[11] * q;
            f[12] = h[12] + m[12] * q;
            f[13] = h[13] + m[13] * q;
            f[14] = h[14] + m[14] * q;
            f[15] = h[15] + m[15] * q;
            return f
        },
        exactEquals: function(f, h) {
            return f[0] === h[0] && f[1] === h[1] && f[2] === h[2] && f[3] === h[3] && f[4] === h[4] && f[5] === h[5] && f[6] === h[6] && f[7] === h[7] && f[8] === h[8] && f[9] === h[9] && f[10] === h[10] && f[11] === h[11] && f[12] === h[12] && f[13] === h[13] && f[14] === h[14] && f[15] === h[15]
        },
        equals: function(f, h) {
            var m = f[0]
              , q = f[1]
              , r = f[2]
              , u = f[3]
              , v = f[4]
              , x = f[5]
              , y = f[6]
              , A = f[7]
              , D = f[8]
              , G = f[9]
              , I = f[10]
              , H = f[11]
              , N = f[12]
              , O = f[13]
              , L = f[14];
            f = f[15];
            var V = h[0]
              , S = h[1]
              , Y = h[2]
              , Z = h[3]
              , W = h[4]
              , la = h[5]
              , ma = h[6]
              , na = h[7]
              , oa = h[8]
              , sa = h[9]
              , va = h[10]
              , wa = h[11]
              , pa = h[12]
              , fb = h[13]
              , gb = h[14];
            h = h[15];
            return Math.abs(m - V) <= 1E-6 * Math.max(1, Math.abs(m), Math.abs(V)) && Math.abs(q - S) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(S)) && Math.abs(r - Y) <= 1E-6 * Math.max(1, Math.abs(r), Math.abs(Y)) && Math.abs(u - Z) <= 1E-6 * Math.max(1, Math.abs(u), Math.abs(Z)) && Math.abs(v - W) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(W)) && Math.abs(x - la) <= 1E-6 * Math.max(1, Math.abs(x), Math.abs(la)) && Math.abs(y - ma) <= 1E-6 * Math.max(1, Math.abs(y), Math.abs(ma)) && Math.abs(A - na) <= 1E-6 * Math.max(1, Math.abs(A), Math.abs(na)) && Math.abs(D - oa) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(oa)) && Math.abs(G - sa) <= 1E-6 * Math.max(1, Math.abs(G), Math.abs(sa)) && Math.abs(I - va) <= 1E-6 * Math.max(1, Math.abs(I), Math.abs(va)) && Math.abs(H - wa) <= 1E-6 * Math.max(1, Math.abs(H), Math.abs(wa)) && Math.abs(N - pa) <= 1E-6 * Math.max(1, Math.abs(N), Math.abs(pa)) && Math.abs(O - fb) <= 1E-6 * Math.max(1, Math.abs(O), Math.abs(fb)) && Math.abs(L - gb) <= 1E-6 * Math.max(1, Math.abs(L), Math.abs(gb)) && Math.abs(f - h) <= 1E-6 * Math.max(1, Math.abs(f), Math.abs(h))
        },
        mul: p,
        sub: F
    })
      , Ha = function() {
        var f = J();
        return function(h, m, q, r, u, v) {
            m || (m = 3);
            q || (q = 0);
            for (r = r ? Math.min(r * m + q, h.length) : h.length; q < r; q += m)
                f[0] = h[q],
                f[1] = h[q + 1],
                f[2] = h[q + 2],
                u(f, f, v),
                h[q] = f[0],
                h[q + 1] = f[1],
                h[q + 2] = f[2];
            return h
        }
    }();
    Ha = Object.freeze({
        __proto__: null,
        create: J,
        clone: function(f) {
            var h = new aa(3);
            h[0] = f[0];
            h[1] = f[1];
            h[2] = f[2];
            return h
        },
        length: K,
        fromValues: M,
        copy: function(f, h) {
            f[0] = h[0];
            f[1] = h[1];
            f[2] = h[2];
            return f
        },
        set: function(f, h, m, q) {
            f[0] = h;
            f[1] = m;
            f[2] = q;
            return f
        },
        add: function(f, h, m) {
            f[0] = h[0] + m[0];
            f[1] = h[1] + m[1];
            f[2] = h[2] + m[2];
            return f
        },
        subtract: U,
        multiply: X,
        divide: R,
        ceil: function(f, h) {
            f[0] = Math.ceil(h[0]);
            f[1] = Math.ceil(h[1]);
            f[2] = Math.ceil(h[2]);
            return f
        },
        floor: function(f, h) {
            f[0] = Math.floor(h[0]);
            f[1] = Math.floor(h[1]);
            f[2] = Math.floor(h[2]);
            return f
        },
        min: function(f, h, m) {
            f[0] = Math.min(h[0], m[0]);
            f[1] = Math.min(h[1], m[1]);
            f[2] = Math.min(h[2], m[2]);
            return f
        },
        max: function(f, h, m) {
            f[0] = Math.max(h[0], m[0]);
            f[1] = Math.max(h[1], m[1]);
            f[2] = Math.max(h[2], m[2]);
            return f
        },
        round: function(f, h) {
            f[0] = Math.round(h[0]);
            f[1] = Math.round(h[1]);
            f[2] = Math.round(h[2]);
            return f
        },
        scale: function(f, h, m) {
            f[0] = h[0] * m;
            f[1] = h[1] * m;
            f[2] = h[2] * m;
            return f
        },
        scaleAndAdd: function(f, h, m, q) {
            f[0] = h[0] + m[0] * q;
            f[1] = h[1] + m[1] * q;
            f[2] = h[2] + m[2] * q;
            return f
        },
        distance: T,
        squaredDistance: P,
        squaredLength: fa,
        negate: function(f, h) {
            f[0] = -h[0];
            f[1] = -h[1];
            f[2] = -h[2];
            return f
        },
        inverse: function(f, h) {
            f[0] = 1 / h[0];
            f[1] = 1 / h[1];
            f[2] = 1 / h[2];
            return f
        },
        normalize: ba,
        dot: ea,
        cross: da,
        lerp: function(f, h, m, q) {
            var r = h[0]
              , u = h[1];
            h = h[2];
            f[0] = r + q * (m[0] - r);
            f[1] = u + q * (m[1] - u);
            f[2] = h + q * (m[2] - h);
            return f
        },
        slerp: function(f, h, m, q) {
            var r = Math.acos(Math.min(Math.max(ea(h, m), -1), 1))
              , u = Math.sin(r)
              , v = Math.sin((1 - q) * r) / u;
            q = Math.sin(q * r) / u;
            f[0] = v * h[0] + q * m[0];
            f[1] = v * h[1] + q * m[1];
            f[2] = v * h[2] + q * m[2];
            return f
        },
        hermite: function(f, h, m, q, r, u) {
            var v = u * u
              , x = v * (2 * u - 3) + 1
              , y = v * (u - 2) + u
              , A = v * (u - 1);
            u = v * (3 - 2 * u);
            f[0] = h[0] * x + m[0] * y + q[0] * A + r[0] * u;
            f[1] = h[1] * x + m[1] * y + q[1] * A + r[1] * u;
            f[2] = h[2] * x + m[2] * y + q[2] * A + r[2] * u;
            return f
        },
        bezier: function(f, h, m, q, r, u) {
            var v = 1 - u
              , x = v * v
              , y = u * u
              , A = x * v;
            x *= 3 * u;
            v *= 3 * y;
            u *= y;
            f[0] = h[0] * A + m[0] * x + q[0] * v + r[0] * u;
            f[1] = h[1] * A + m[1] * x + q[1] * v + r[1] * u;
            f[2] = h[2] * A + m[2] * x + q[2] * v + r[2] * u;
            return f
        },
        random: function(f, h) {
            h = h || 1;
            var m = 2 * Aa() * Math.PI
              , q = 2 * Aa() - 1
              , r = Math.sqrt(1 - q * q) * h;
            f[0] = Math.cos(m) * r;
            f[1] = Math.sin(m) * r;
            f[2] = q * h;
            return f
        },
        transformMat4: function(f, h, m) {
            var q = h[0]
              , r = h[1];
            h = h[2];
            var u = m[3] * q + m[7] * r + m[11] * h + m[15];
            u = u || 1;
            f[0] = (m[0] * q + m[4] * r + m[8] * h + m[12]) / u;
            f[1] = (m[1] * q + m[5] * r + m[9] * h + m[13]) / u;
            f[2] = (m[2] * q + m[6] * r + m[10] * h + m[14]) / u;
            return f
        },
        transformMat3: function(f, h, m) {
            var q = h[0]
              , r = h[1];
            h = h[2];
            f[0] = q * m[0] + r * m[3] + h * m[6];
            f[1] = q * m[1] + r * m[4] + h * m[7];
            f[2] = q * m[2] + r * m[5] + h * m[8];
            return f
        },
        transformQuat: function(f, h, m) {
            var q = m[0]
              , r = m[1]
              , u = m[2]
              , v = h[0]
              , x = h[1];
            h = h[2];
            var y = r * h - u * x
              , A = u * v - q * h
              , D = q * x - r * v;
            m = 2 * m[3];
            f[0] = v + y * m + 2 * (r * D - u * A);
            f[1] = x + A * m + 2 * (u * y - q * D);
            f[2] = h + D * m + 2 * (q * A - r * y);
            return f
        },
        rotateX: function(f, h, m, q) {
            var r = []
              , u = [];
            r[0] = h[0] - m[0];
            r[1] = h[1] - m[1];
            r[2] = h[2] - m[2];
            u[0] = r[0];
            u[1] = r[1] * Math.cos(q) - r[2] * Math.sin(q);
            u[2] = r[1] * Math.sin(q) + r[2] * Math.cos(q);
            f[0] = u[0] + m[0];
            f[1] = u[1] + m[1];
            f[2] = u[2] + m[2];
            return f
        },
        rotateY: function(f, h, m, q) {
            var r = []
              , u = [];
            r[0] = h[0] - m[0];
            r[1] = h[1] - m[1];
            r[2] = h[2] - m[2];
            u[0] = r[2] * Math.sin(q) + r[0] * Math.cos(q);
            u[1] = r[1];
            u[2] = r[2] * Math.cos(q) - r[0] * Math.sin(q);
            f[0] = u[0] + m[0];
            f[1] = u[1] + m[1];
            f[2] = u[2] + m[2];
            return f
        },
        rotateZ: function(f, h, m, q) {
            var r = []
              , u = [];
            r[0] = h[0] - m[0];
            r[1] = h[1] - m[1];
            r[2] = h[2] - m[2];
            u[0] = r[0] * Math.cos(q) - r[1] * Math.sin(q);
            u[1] = r[0] * Math.sin(q) + r[1] * Math.cos(q);
            u[2] = r[2];
            f[0] = u[0] + m[0];
            f[1] = u[1] + m[1];
            f[2] = u[2] + m[2];
            return f
        },
        angle: function(f, h) {
            var m = f[0]
              , q = f[1]
              , r = f[2]
              , u = h[0]
              , v = h[1]
              , x = h[2];
            f = (m = Math.sqrt((m * m + q * q + r * r) * (u * u + v * v + x * x))) && ea(f, h) / m;
            return Math.acos(Math.min(Math.max(f, -1), 1))
        },
        zero: function(f) {
            f[0] = 0;
            f[1] = 0;
            f[2] = 0;
            return f
        },
        str: function(f) {
            return "vec3(" + f[0] + ", " + f[1] + ", " + f[2] + ")"
        },
        exactEquals: function(f, h) {
            return f[0] === h[0] && f[1] === h[1] && f[2] === h[2]
        },
        equals: function(f, h) {
            var m = f[0]
              , q = f[1];
            f = f[2];
            var r = h[0]
              , u = h[1];
            h = h[2];
            return Math.abs(m - r) <= 1E-6 * Math.max(1, Math.abs(m), Math.abs(r)) && Math.abs(q - u) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(u)) && Math.abs(f - h) <= 1E-6 * Math.max(1, Math.abs(f), Math.abs(h))
        },
        sub: U,
        mul: X,
        div: R,
        dist: T,
        sqrDist: P,
        len: K,
        sqrLen: fa,
        forEach: Ha
    });
    var Ia = function() {
        var f = ka();
        return function(h, m, q, r, u, v) {
            m || (m = 4);
            q || (q = 0);
            for (r = r ? Math.min(r * m + q, h.length) : h.length; q < r; q += m)
                f[0] = h[q],
                f[1] = h[q + 1],
                f[2] = h[q + 2],
                f[3] = h[q + 3],
                u(f, f, v),
                h[q] = f[0],
                h[q + 1] = f[1],
                h[q + 2] = f[2],
                h[q + 3] = f[3];
            return h
        }
    }();
    Ia = Object.freeze({
        __proto__: null,
        create: ka,
        clone: Q,
        fromValues: xa,
        copy: ca,
        set: ha,
        add: ra,
        subtract: qa,
        multiply: ya,
        divide: za,
        ceil: function(f, h) {
            f[0] = Math.ceil(h[0]);
            f[1] = Math.ceil(h[1]);
            f[2] = Math.ceil(h[2]);
            f[3] = Math.ceil(h[3]);
            return f
        },
        floor: function(f, h) {
            f[0] = Math.floor(h[0]);
            f[1] = Math.floor(h[1]);
            f[2] = Math.floor(h[2]);
            f[3] = Math.floor(h[3]);
            return f
        },
        min: function(f, h, m) {
            f[0] = Math.min(h[0], m[0]);
            f[1] = Math.min(h[1], m[1]);
            f[2] = Math.min(h[2], m[2]);
            f[3] = Math.min(h[3], m[3]);
            return f
        },
        max: function(f, h, m) {
            f[0] = Math.max(h[0], m[0]);
            f[1] = Math.max(h[1], m[1]);
            f[2] = Math.max(h[2], m[2]);
            f[3] = Math.max(h[3], m[3]);
            return f
        },
        round: function(f, h) {
            f[0] = Math.round(h[0]);
            f[1] = Math.round(h[1]);
            f[2] = Math.round(h[2]);
            f[3] = Math.round(h[3]);
            return f
        },
        scale: ia,
        scaleAndAdd: function(f, h, m, q) {
            f[0] = h[0] + m[0] * q;
            f[1] = h[1] + m[1] * q;
            f[2] = h[2] + m[2] * q;
            f[3] = h[3] + m[3] * q;
            return f
        },
        distance: ja,
        squaredDistance: Ba,
        length: ua,
        squaredLength: ta,
        negate: function(f, h) {
            f[0] = -h[0];
            f[1] = -h[1];
            f[2] = -h[2];
            f[3] = -h[3];
            return f
        },
        inverse: function(f, h) {
            f[0] = 1 / h[0];
            f[1] = 1 / h[1];
            f[2] = 1 / h[2];
            f[3] = 1 / h[3];
            return f
        },
        normalize: Ca,
        dot: Da,
        cross: function(f, h, m, q) {
            var r = m[0] * q[1] - m[1] * q[0]
              , u = m[0] * q[2] - m[2] * q[0]
              , v = m[0] * q[3] - m[3] * q[0]
              , x = m[1] * q[2] - m[2] * q[1]
              , y = m[1] * q[3] - m[3] * q[1];
            m = m[2] * q[3] - m[3] * q[2];
            q = h[0];
            var A = h[1]
              , D = h[2];
            h = h[3];
            f[0] = A * m - D * y + h * x;
            f[1] = -(q * m) + D * v - h * u;
            f[2] = q * y - A * v + h * r;
            f[3] = -(q * x) + A * u - D * r;
            return f
        },
        lerp: La,
        random: function(f, h) {
            h = h || 1;
            do {
                var m = 2 * Aa() - 1;
                var q = 2 * Aa() - 1;
                var r = m * m + q * q
            } while (1 <= r);
            do {
                var u = 2 * Aa() - 1;
                var v = 2 * Aa() - 1;
                var x = u * u + v * v
            } while (1 <= x);
            r = Math.sqrt((1 - r) / x);
            f[0] = h * m;
            f[1] = h * q;
            f[2] = h * u * r;
            f[3] = h * v * r;
            return f
        },
        transformMat4: function(f, h, m) {
            var q = h[0]
              , r = h[1]
              , u = h[2];
            h = h[3];
            f[0] = m[0] * q + m[4] * r + m[8] * u + m[12] * h;
            f[1] = m[1] * q + m[5] * r + m[9] * u + m[13] * h;
            f[2] = m[2] * q + m[6] * r + m[10] * u + m[14] * h;
            f[3] = m[3] * q + m[7] * r + m[11] * u + m[15] * h;
            return f
        },
        transformQuat: function(f, h, m) {
            var q = h[0]
              , r = h[1]
              , u = h[2]
              , v = m[0]
              , x = m[1]
              , y = m[2];
            m = m[3];
            var A = m * q + x * u - y * r
              , D = m * r + y * q - v * u
              , G = m * u + v * r - x * q;
            q = -v * q - x * r - y * u;
            f[0] = A * m + q * -v + D * -y - G * -x;
            f[1] = D * m + q * -x + G * -v - A * -y;
            f[2] = G * m + q * -y + A * -x - D * -v;
            f[3] = h[3];
            return f
        },
        zero: function(f) {
            f[0] = 0;
            f[1] = 0;
            f[2] = 0;
            f[3] = 0;
            return f
        },
        str: function(f) {
            return "vec4(" + f[0] + ", " + f[1] + ", " + f[2] + ", " + f[3] + ")"
        },
        exactEquals: Ma,
        equals: function(f, h) {
            var m = f[0]
              , q = f[1]
              , r = f[2];
            f = f[3];
            var u = h[0]
              , v = h[1]
              , x = h[2];
            h = h[3];
            return Math.abs(m - u) <= 1E-6 * Math.max(1, Math.abs(m), Math.abs(u)) && Math.abs(q - v) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(v)) && Math.abs(r - x) <= 1E-6 * Math.max(1, Math.abs(r), Math.abs(x)) && Math.abs(f - h) <= 1E-6 * Math.max(1, Math.abs(f), Math.abs(h))
        },
        sub: qa,
        mul: ya,
        div: za,
        dist: ja,
        sqrDist: Ba,
        len: ua,
        sqrLen: ta,
        forEach: Ia
    });
    var Ja = function() {
        var f = J()
          , h = M(1, 0, 0)
          , m = M(0, 1, 0);
        return function(q, r, u) {
            var v = ea(r, u);
            if (-.999999 > v)
                return da(f, h, r),
                1E-6 > K(f) && da(f, m, r),
                ba(f, f),
                Na(q, f, Math.PI),
                q;
            if (.999999 < v)
                return q[0] = 0,
                q[1] = 0,
                q[2] = 0,
                q[3] = 1,
                q;
            da(f, r, u);
            q[0] = f[0];
            q[1] = f[1];
            q[2] = f[2];
            q[3] = 1 + v;
            return Ca(q, q)
        }
    }()
      , Ka = function() {
        var f = Fa()
          , h = Fa();
        return function(m, q, r, u, v, x) {
            Ga(f, q, v, x);
            Ga(h, r, u, x);
            Ga(m, f, h, 2 * x * (1 - x));
            return m
        }
    }()
      , Ea = function() {
        var f = g();
        return function(h, m, q, r) {
            f[0] = q[0];
            f[3] = q[1];
            f[6] = q[2];
            f[1] = r[0];
            f[4] = r[1];
            f[7] = r[2];
            f[2] = -m[0];
            f[5] = -m[1];
            f[8] = -m[2];
            return Ca(h, Ua(h, f))
        }
    }();
    Ja = Object.freeze({
        __proto__: null,
        create: Fa,
        identity: function(f) {
            f[0] = 0;
            f[1] = 0;
            f[2] = 0;
            f[3] = 1;
            return f
        },
        setAxisAngle: Na,
        getAxisAngle: function(f, h) {
            var m = 2 * Math.acos(h[3])
              , q = Math.sin(m / 2);
            1E-6 < q ? (f[0] = h[0] / q,
            f[1] = h[1] / q,
            f[2] = h[2] / q) : (f[0] = 1,
            f[1] = 0,
            f[2] = 0);
            return m
        },
        getAngle: function(f, h) {
            f = Da(f, h);
            return Math.acos(2 * f * f - 1)
        },
        multiply: Oa,
        rotateX: Pa,
        rotateY: Qa,
        rotateZ: Ra,
        calculateW: function(f, h) {
            var m = h[0]
              , q = h[1];
            h = h[2];
            f[0] = m;
            f[1] = q;
            f[2] = h;
            f[3] = Math.sqrt(Math.abs(1 - m * m - q * q - h * h));
            return f
        },
        exp: Sa,
        ln: Ta,
        pow: function(f, h, m) {
            Ta(f, h);
            ia(f, f, m);
            Sa(f, f);
            return f
        },
        slerp: Ga,
        random: function(f) {
            var h = Aa()
              , m = Aa()
              , q = Aa()
              , r = Math.sqrt(1 - h);
            h = Math.sqrt(h);
            f[0] = r * Math.sin(2 * Math.PI * m);
            f[1] = r * Math.cos(2 * Math.PI * m);
            f[2] = h * Math.sin(2 * Math.PI * q);
            f[3] = h * Math.cos(2 * Math.PI * q);
            return f
        },
        invert: function(f, h) {
            var m = h[0]
              , q = h[1]
              , r = h[2];
            h = h[3];
            var u = m * m + q * q + r * r + h * h;
            u = u ? 1 / u : 0;
            f[0] = -m * u;
            f[1] = -q * u;
            f[2] = -r * u;
            f[3] = h * u;
            return f
        },
        conjugate: function(f, h) {
            f[0] = -h[0];
            f[1] = -h[1];
            f[2] = -h[2];
            f[3] = h[3];
            return f
        },
        fromMat3: Ua,
        fromEuler: function(f, h, m, q) {
            var r = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : "zyx"
              , u = Math.PI / 360;
            h *= u;
            q *= u;
            m *= u;
            u = Math.sin(h);
            var v = Math.cos(h)
              , x = Math.sin(m)
              , y = Math.cos(m)
              , A = Math.sin(q)
              , D = Math.cos(q);
            switch (r) {
            case "xyz":
                f[0] = u * y * D + v * x * A;
                f[1] = v * x * D - u * y * A;
                f[2] = v * y * A + u * x * D;
                f[3] = v * y * D - u * x * A;
                break;
            case "xzy":
                f[0] = u * y * D - v * x * A;
                f[1] = v * x * D - u * y * A;
                f[2] = v * y * A + u * x * D;
                f[3] = v * y * D + u * x * A;
                break;
            case "yxz":
                f[0] = u * y * D + v * x * A;
                f[1] = v * x * D - u * y * A;
                f[2] = v * y * A - u * x * D;
                f[3] = v * y * D + u * x * A;
                break;
            case "yzx":
                f[0] = u * y * D + v * x * A;
                f[1] = v * x * D + u * y * A;
                f[2] = v * y * A - u * x * D;
                f[3] = v * y * D - u * x * A;
                break;
            case "zxy":
                f[0] = u * y * D - v * x * A;
                f[1] = v * x * D + u * y * A;
                f[2] = v * y * A + u * x * D;
                f[3] = v * y * D - u * x * A;
                break;
            case "zyx":
                f[0] = u * y * D - v * x * A;
                f[1] = v * x * D + u * y * A;
                f[2] = v * y * A - u * x * D;
                f[3] = v * y * D + u * x * A;
                break;
            default:
                throw Error("Unknown angle order " + r);
            }
            return f
        },
        str: function(f) {
            return "quat(" + f[0] + ", " + f[1] + ", " + f[2] + ", " + f[3] + ")"
        },
        clone: Q,
        fromValues: xa,
        copy: ca,
        set: ha,
        add: ra,
        mul: Oa,
        scale: ia,
        dot: Da,
        lerp: La,
        length: ua,
        len: ua,
        squaredLength: ta,
        sqrLen: ta,
        normalize: Ca,
        exactEquals: Ma,
        equals: function(f, h) {
            return .999999 <= Math.abs(Da(f, h))
        },
        rotationTo: Ja,
        sqlerp: Ka,
        setAxes: Ea
    });
    Ka = Object.freeze({
        __proto__: null,
        create: function() {
            var f = new aa(8);
            aa != Float32Array && (f[0] = 0,
            f[1] = 0,
            f[2] = 0,
            f[4] = 0,
            f[5] = 0,
            f[6] = 0,
            f[7] = 0);
            f[3] = 1;
            return f
        },
        clone: function(f) {
            var h = new aa(8);
            h[0] = f[0];
            h[1] = f[1];
            h[2] = f[2];
            h[3] = f[3];
            h[4] = f[4];
            h[5] = f[5];
            h[6] = f[6];
            h[7] = f[7];
            return h
        },
        fromValues: function(f, h, m, q, r, u, v, x) {
            var y = new aa(8);
            y[0] = f;
            y[1] = h;
            y[2] = m;
            y[3] = q;
            y[4] = r;
            y[5] = u;
            y[6] = v;
            y[7] = x;
            return y
        },
        fromRotationTranslationValues: function(f, h, m, q, r, u, v) {
            var x = new aa(8);
            x[0] = f;
            x[1] = h;
            x[2] = m;
            x[3] = q;
            r *= .5;
            u *= .5;
            v *= .5;
            x[4] = r * q + u * m - v * h;
            x[5] = u * q + v * f - r * m;
            x[6] = v * q + r * h - u * f;
            x[7] = -r * f - u * h - v * m;
            return x
        },
        fromRotationTranslation: Va,
        fromTranslation: function(f, h) {
            f[0] = 0;
            f[1] = 0;
            f[2] = 0;
            f[3] = 1;
            f[4] = .5 * h[0];
            f[5] = .5 * h[1];
            f[6] = .5 * h[2];
            f[7] = 0;
            return f
        },
        fromRotation: function(f, h) {
            f[0] = h[0];
            f[1] = h[1];
            f[2] = h[2];
            f[3] = h[3];
            f[4] = 0;
            f[5] = 0;
            f[6] = 0;
            f[7] = 0;
            return f
        },
        fromMat4: function(f, h) {
            var m = Fa();
            B(m, h);
            var q = new aa(3);
            w(q, h);
            Va(f, m, q);
            return f
        },
        copy: Wa,
        identity: function(f) {
            f[0] = 0;
            f[1] = 0;
            f[2] = 0;
            f[3] = 1;
            f[4] = 0;
            f[5] = 0;
            f[6] = 0;
            f[7] = 0;
            return f
        },
        set: function(f, h, m, q, r, u, v, x, y) {
            f[0] = h;
            f[1] = m;
            f[2] = q;
            f[3] = r;
            f[4] = u;
            f[5] = v;
            f[6] = x;
            f[7] = y;
            return f
        },
        getReal: ca,
        getDual: function(f, h) {
            f[0] = h[4];
            f[1] = h[5];
            f[2] = h[6];
            f[3] = h[7];
            return f
        },
        setReal: ca,
        setDual: function(f, h) {
            f[4] = h[0];
            f[5] = h[1];
            f[6] = h[2];
            f[7] = h[3];
            return f
        },
        getTranslation: function(f, h) {
            var m = h[4]
              , q = h[5]
              , r = h[6]
              , u = h[7]
              , v = -h[0]
              , x = -h[1]
              , y = -h[2];
            h = h[3];
            f[0] = 2 * (m * h + u * v + q * y - r * x);
            f[1] = 2 * (q * h + u * x + r * v - m * y);
            f[2] = 2 * (r * h + u * y + m * x - q * v);
            return f
        },
        translate: function(f, h, m) {
            var q = h[0]
              , r = h[1]
              , u = h[2]
              , v = h[3]
              , x = .5 * m[0]
              , y = .5 * m[1];
            m = .5 * m[2];
            var A = h[4]
              , D = h[5]
              , G = h[6];
            h = h[7];
            f[0] = q;
            f[1] = r;
            f[2] = u;
            f[3] = v;
            f[4] = v * x + r * m - u * y + A;
            f[5] = v * y + u * x - q * m + D;
            f[6] = v * m + q * y - r * x + G;
            f[7] = -q * x - r * y - u * m + h;
            return f
        },
        rotateX: function(f, h, m) {
            var q = -h[0]
              , r = -h[1]
              , u = -h[2]
              , v = h[3]
              , x = h[4]
              , y = h[5]
              , A = h[6]
              , D = h[7]
              , G = x * v + D * q + y * u - A * r
              , I = y * v + D * r + A * q - x * u
              , H = A * v + D * u + x * r - y * q;
            x = D * v - x * q - y * r - A * u;
            Pa(f, h, m);
            q = f[0];
            r = f[1];
            u = f[2];
            v = f[3];
            f[4] = G * v + x * q + I * u - H * r;
            f[5] = I * v + x * r + H * q - G * u;
            f[6] = H * v + x * u + G * r - I * q;
            f[7] = x * v - G * q - I * r - H * u;
            return f
        },
        rotateY: function(f, h, m) {
            var q = -h[0]
              , r = -h[1]
              , u = -h[2]
              , v = h[3]
              , x = h[4]
              , y = h[5]
              , A = h[6]
              , D = h[7]
              , G = x * v + D * q + y * u - A * r
              , I = y * v + D * r + A * q - x * u
              , H = A * v + D * u + x * r - y * q;
            x = D * v - x * q - y * r - A * u;
            Qa(f, h, m);
            q = f[0];
            r = f[1];
            u = f[2];
            v = f[3];
            f[4] = G * v + x * q + I * u - H * r;
            f[5] = I * v + x * r + H * q - G * u;
            f[6] = H * v + x * u + G * r - I * q;
            f[7] = x * v - G * q - I * r - H * u;
            return f
        },
        rotateZ: function(f, h, m) {
            var q = -h[0]
              , r = -h[1]
              , u = -h[2]
              , v = h[3]
              , x = h[4]
              , y = h[5]
              , A = h[6]
              , D = h[7]
              , G = x * v + D * q + y * u - A * r
              , I = y * v + D * r + A * q - x * u
              , H = A * v + D * u + x * r - y * q;
            x = D * v - x * q - y * r - A * u;
            Ra(f, h, m);
            q = f[0];
            r = f[1];
            u = f[2];
            v = f[3];
            f[4] = G * v + x * q + I * u - H * r;
            f[5] = I * v + x * r + H * q - G * u;
            f[6] = H * v + x * u + G * r - I * q;
            f[7] = x * v - G * q - I * r - H * u;
            return f
        },
        rotateByQuatAppend: function(f, h, m) {
            var q = m[0]
              , r = m[1]
              , u = m[2];
            m = m[3];
            var v = h[0]
              , x = h[1]
              , y = h[2]
              , A = h[3];
            f[0] = v * m + A * q + x * u - y * r;
            f[1] = x * m + A * r + y * q - v * u;
            f[2] = y * m + A * u + v * r - x * q;
            f[3] = A * m - v * q - x * r - y * u;
            v = h[4];
            x = h[5];
            y = h[6];
            A = h[7];
            f[4] = v * m + A * q + x * u - y * r;
            f[5] = x * m + A * r + y * q - v * u;
            f[6] = y * m + A * u + v * r - x * q;
            f[7] = A * m - v * q - x * r - y * u;
            return f
        },
        rotateByQuatPrepend: function(f, h, m) {
            var q = h[0]
              , r = h[1]
              , u = h[2];
            h = h[3];
            var v = m[0]
              , x = m[1]
              , y = m[2]
              , A = m[3];
            f[0] = q * A + h * v + r * y - u * x;
            f[1] = r * A + h * x + u * v - q * y;
            f[2] = u * A + h * y + q * x - r * v;
            f[3] = h * A - q * v - r * x - u * y;
            v = m[4];
            x = m[5];
            y = m[6];
            A = m[7];
            f[4] = q * A + h * v + r * y - u * x;
            f[5] = r * A + h * x + u * v - q * y;
            f[6] = u * A + h * y + q * x - r * v;
            f[7] = h * A - q * v - r * x - u * y;
            return f
        },
        rotateAroundAxis: function(f, h, m, q) {
            if (1E-6 > Math.abs(q))
                return Wa(f, h);
            var r = Math.hypot(m[0], m[1], m[2]);
            q *= .5;
            var u = Math.sin(q)
              , v = u * m[0] / r
              , x = u * m[1] / r;
            m = u * m[2] / r;
            q = Math.cos(q);
            r = h[0];
            u = h[1];
            var y = h[2]
              , A = h[3];
            f[0] = r * q + A * v + u * m - y * x;
            f[1] = u * q + A * x + y * v - r * m;
            f[2] = y * q + A * m + r * x - u * v;
            f[3] = A * q - r * v - u * x - y * m;
            r = h[4];
            u = h[5];
            y = h[6];
            h = h[7];
            f[4] = r * q + h * v + u * m - y * x;
            f[5] = u * q + h * x + y * v - r * m;
            f[6] = y * q + h * m + r * x - u * v;
            f[7] = h * q - r * v - u * x - y * m;
            return f
        },
        add: function(f, h, m) {
            f[0] = h[0] + m[0];
            f[1] = h[1] + m[1];
            f[2] = h[2] + m[2];
            f[3] = h[3] + m[3];
            f[4] = h[4] + m[4];
            f[5] = h[5] + m[5];
            f[6] = h[6] + m[6];
            f[7] = h[7] + m[7];
            return f
        },
        multiply: Xa,
        mul: Xa,
        scale: function(f, h, m) {
            f[0] = h[0] * m;
            f[1] = h[1] * m;
            f[2] = h[2] * m;
            f[3] = h[3] * m;
            f[4] = h[4] * m;
            f[5] = h[5] * m;
            f[6] = h[6] * m;
            f[7] = h[7] * m;
            return f
        },
        dot: Da,
        lerp: function(f, h, m, q) {
            var r = 1 - q;
            0 > Da(h, m) && (q = -q);
            f[0] = h[0] * r + m[0] * q;
            f[1] = h[1] * r + m[1] * q;
            f[2] = h[2] * r + m[2] * q;
            f[3] = h[3] * r + m[3] * q;
            f[4] = h[4] * r + m[4] * q;
            f[5] = h[5] * r + m[5] * q;
            f[6] = h[6] * r + m[6] * q;
            f[7] = h[7] * r + m[7] * q;
            return f
        },
        invert: function(f, h) {
            var m = ta(h);
            f[0] = -h[0] / m;
            f[1] = -h[1] / m;
            f[2] = -h[2] / m;
            f[3] = h[3] / m;
            f[4] = -h[4] / m;
            f[5] = -h[5] / m;
            f[6] = -h[6] / m;
            f[7] = h[7] / m;
            return f
        },
        conjugate: function(f, h) {
            f[0] = -h[0];
            f[1] = -h[1];
            f[2] = -h[2];
            f[3] = h[3];
            f[4] = -h[4];
            f[5] = -h[5];
            f[6] = -h[6];
            f[7] = h[7];
            return f
        },
        length: ua,
        len: ua,
        squaredLength: ta,
        sqrLen: ta,
        normalize: function(f, h) {
            var m = ta(h);
            if (0 < m) {
                m = Math.sqrt(m);
                var q = h[0] / m
                  , r = h[1] / m
                  , u = h[2] / m
                  , v = h[3] / m
                  , x = h[4]
                  , y = h[5]
                  , A = h[6];
                h = h[7];
                var D = q * x + r * y + u * A + v * h;
                f[0] = q;
                f[1] = r;
                f[2] = u;
                f[3] = v;
                f[4] = (x - q * D) / m;
                f[5] = (y - r * D) / m;
                f[6] = (A - u * D) / m;
                f[7] = (h - v * D) / m
            }
            return f
        },
        str: function(f) {
            return "quat2(" + f[0] + ", " + f[1] + ", " + f[2] + ", " + f[3] + ", " + f[4] + ", " + f[5] + ", " + f[6] + ", " + f[7] + ")"
        },
        exactEquals: function(f, h) {
            return f[0] === h[0] && f[1] === h[1] && f[2] === h[2] && f[3] === h[3] && f[4] === h[4] && f[5] === h[5] && f[6] === h[6] && f[7] === h[7]
        },
        equals: function(f, h) {
            var m = f[0]
              , q = f[1]
              , r = f[2]
              , u = f[3]
              , v = f[4]
              , x = f[5]
              , y = f[6];
            f = f[7];
            var A = h[0]
              , D = h[1]
              , G = h[2]
              , I = h[3]
              , H = h[4]
              , N = h[5]
              , O = h[6];
            h = h[7];
            return Math.abs(m - A) <= 1E-6 * Math.max(1, Math.abs(m), Math.abs(A)) && Math.abs(q - D) <= 1E-6 * Math.max(1, Math.abs(q), Math.abs(D)) && Math.abs(r - G) <= 1E-6 * Math.max(1, Math.abs(r), Math.abs(G)) && Math.abs(u - I) <= 1E-6 * Math.max(1, Math.abs(u), Math.abs(I)) && Math.abs(v - H) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(H)) && Math.abs(x - N) <= 1E-6 * Math.max(1, Math.abs(x), Math.abs(N)) && Math.abs(y - O) <= 1E-6 * Math.max(1, Math.abs(y), Math.abs(O)) && Math.abs(f - h) <= 1E-6 * Math.max(1, Math.abs(f), Math.abs(h))
        }
    });
    Ea = function() {
        var f = Ya();
        return function(h, m, q, r, u, v) {
            m || (m = 2);
            q || (q = 0);
            for (r = r ? Math.min(r * m + q, h.length) : h.length; q < r; q += m)
                f[0] = h[q],
                f[1] = h[q + 1],
                u(f, f, v),
                h[q] = f[0],
                h[q + 1] = f[1];
            return h
        }
    }();
    Ea = Object.freeze({
        __proto__: null,
        create: Ya,
        clone: function(f) {
            var h = new aa(2);
            h[0] = f[0];
            h[1] = f[1];
            return h
        },
        fromValues: function(f, h) {
            var m = new aa(2);
            m[0] = f;
            m[1] = h;
            return m
        },
        copy: function(f, h) {
            f[0] = h[0];
            f[1] = h[1];
            return f
        },
        set: function(f, h, m) {
            f[0] = h;
            f[1] = m;
            return f
        },
        add: function(f, h, m) {
            f[0] = h[0] + m[0];
            f[1] = h[1] + m[1];
            return f
        },
        subtract: Za,
        multiply: $a,
        divide: ab,
        ceil: function(f, h) {
            f[0] = Math.ceil(h[0]);
            f[1] = Math.ceil(h[1]);
            return f
        },
        floor: function(f, h) {
            f[0] = Math.floor(h[0]);
            f[1] = Math.floor(h[1]);
            return f
        },
        min: function(f, h, m) {
            f[0] = Math.min(h[0], m[0]);
            f[1] = Math.min(h[1], m[1]);
            return f
        },
        max: function(f, h, m) {
            f[0] = Math.max(h[0], m[0]);
            f[1] = Math.max(h[1], m[1]);
            return f
        },
        round: function(f, h) {
            f[0] = Math.round(h[0]);
            f[1] = Math.round(h[1]);
            return f
        },
        scale: function(f, h, m) {
            f[0] = h[0] * m;
            f[1] = h[1] * m;
            return f
        },
        scaleAndAdd: function(f, h, m, q) {
            f[0] = h[0] + m[0] * q;
            f[1] = h[1] + m[1] * q;
            return f
        },
        distance: bb,
        squaredDistance: cb,
        length: db,
        squaredLength: eb,
        negate: function(f, h) {
            f[0] = -h[0];
            f[1] = -h[1];
            return f
        },
        inverse: function(f, h) {
            f[0] = 1 / h[0];
            f[1] = 1 / h[1];
            return f
        },
        normalize: function(f, h) {
            var m = h[0]
              , q = h[1];
            m = m * m + q * q;
            0 < m && (m = 1 / Math.sqrt(m));
            f[0] = h[0] * m;
            f[1] = h[1] * m;
            return f
        },
        dot: function(f, h) {
            return f[0] * h[0] + f[1] * h[1]
        },
        cross: function(f, h, m) {
            h = h[0] * m[1] - h[1] * m[0];
            f[0] = f[1] = 0;
            f[2] = h;
            return f
        },
        lerp: function(f, h, m, q) {
            var r = h[0];
            h = h[1];
            f[0] = r + q * (m[0] - r);
            f[1] = h + q * (m[1] - h);
            return f
        },
        random: function(f, h) {
            h = h || 1;
            var m = 2 * Aa() * Math.PI;
            f[0] = Math.cos(m) * h;
            f[1] = Math.sin(m) * h;
            return f
        },
        transformMat2: function(f, h, m) {
            var q = h[0];
            h = h[1];
            f[0] = m[0] * q + m[2] * h;
            f[1] = m[1] * q + m[3] * h;
            return f
        },
        transformMat2d: function(f, h, m) {
            var q = h[0];
            h = h[1];
            f[0] = m[0] * q + m[2] * h + m[4];
            f[1] = m[1] * q + m[3] * h + m[5];
            return f
        },
        transformMat3: function(f, h, m) {
            var q = h[0];
            h = h[1];
            f[0] = m[0] * q + m[3] * h + m[6];
            f[1] = m[1] * q + m[4] * h + m[7];
            return f
        },
        transformMat4: function(f, h, m) {
            var q = h[0];
            h = h[1];
            f[0] = m[0] * q + m[4] * h + m[12];
            f[1] = m[1] * q + m[5] * h + m[13];
            return f
        },
        rotate: function(f, h, m, q) {
            var r = h[0] - m[0];
            h = h[1] - m[1];
            var u = Math.sin(q);
            q = Math.cos(q);
            f[0] = r * q - h * u + m[0];
            f[1] = r * u + h * q + m[1];
            return f
        },
        angle: function(f, h) {
            var m = f[0];
            f = f[1];
            var q = h[0];
            h = h[1];
            var r = Math.sqrt((m * m + f * f) * (q * q + h * h));
            return Math.acos(Math.min(Math.max(r && (m * q + f * h) / r, -1), 1))
        },
        zero: function(f) {
            f[0] = 0;
            f[1] = 0;
            return f
        },
        str: function(f) {
            return "vec2(" + f[0] + ", " + f[1] + ")"
        },
        exactEquals: function(f, h) {
            return f[0] === h[0] && f[1] === h[1]
        },
        equals: function(f, h) {
            var m = f[0];
            f = f[1];
            var q = h[0];
            h = h[1];
            return Math.abs(m - q) <= 1E-6 * Math.max(1, Math.abs(m), Math.abs(q)) && Math.abs(f - h) <= 1E-6 * Math.max(1, Math.abs(f), Math.abs(h))
        },
        len: db,
        sub: Za,
        mul: $a,
        div: ab,
        dist: bb,
        sqrDist: cb,
        sqrLen: eb,
        forEach: Ea
    });
    a.glMatrix = ib;
    a.mat2 = jb;
    a.mat2d = kb;
    a.mat3 = lb;
    a.mat4 = mb;
    a.quat = Ja;
    a.quat2 = Ka;
    a.vec2 = Ea;
    a.vec3 = Ha;
    a.vec4 = Ia;
    Object.defineProperty(a, "__esModule", {
        value: !0
    })
});
self.GraphemeSplitter = function() {
    function a(c, e) {
        void 0 === e && (e = 0);
        var g = c.charCodeAt(e);
        if (55296 <= g && 56319 >= g && e < c.length - 1) {
            var k = g;
            c = c.charCodeAt(e + 1);
            return 56320 <= c && 57343 >= c ? 1024 * (k - 55296) + (c - 56320) + 65536 : k
        }
        return 56320 <= g && 57343 >= g && 1 <= e ? (k = c.charCodeAt(e - 1),
        c = g,
        55296 <= k && 56319 >= k ? 1024 * (k - 55296) + (c - 56320) + 65536 : c) : g
    }
    function b(c, e, g) {
        var k = [c].concat(e).concat([g])
          , l = k[k.length - 2]
          , n = k.lastIndexOf(14);
        if (1 < n && k.slice(1, n).every(function(p) {
            return 3 == p
        }) && -1 == [3, 13, 17].indexOf(c))
            return 2;
        c = k.lastIndexOf(4);
        if (0 < c && k.slice(1, c).every(function(p) {
            return 4 == p
        }) && -1 == [12, 4].indexOf(l))
            return 1 == k.filter(function(p) {
                return 4 == p
            }).length % 2 ? 3 : 4;
        if (0 == l && 1 == g)
            return 0;
        if (2 == l || 0 == l || 1 == l)
            return 14 == g && e.every(function(p) {
                return 3 == p
            }) ? 2 : 1;
        if (2 == g || 0 == g || 1 == g)
            return 1;
        if (6 != l || 6 != g && 7 != g && 9 != g && 10 != g)
            if (9 != l && 7 != l || 7 != g && 8 != g)
                if (10 != l && 8 != l || 8 != g) {
                    if (3 == g || 15 == g || 5 == g || 12 == l)
                        return 0
                } else
                    return 0;
            else
                return 0;
        else
            return 0;
        c = -1 != k.indexOf(3) ? k.lastIndexOf(3) - 1 : k.length - 2;
        return -1 != [13, 17].indexOf(k[c]) && k.slice(c + 1, -1).every(function(p) {
            return 3 == p
        }) && 14 == g || 15 == l && -1 != [16, 17].indexOf(g) ? 0 : -1 != e.indexOf(4) ? 2 : 4 == l && 4 == g ? 0 : 1
    }
    function d(c) {
        return 1536 <= c && 1541 >= c || 1757 == c || 1807 == c || 2274 == c || 3406 == c || 69821 == c || 70082 <= c && 70083 >= c || 72250 == c || 72326 <= c && 72329 >= c || 73030 == c ? 12 : 13 == c ? 0 : 10 == c ? 1 : 0 <= c && 9 >= c || 11 <= c && 12 >= c || 14 <= c && 31 >= c || 127 <= c && 159 >= c || 173 == c || 1564 == c || 6158 == c || 8203 == c || 8206 <= c && 8207 >= c || 8232 == c || 8233 == c || 8234 <= c && 8238 >= c || 8288 <= c && 8292 >= c || 8293 == c || 8294 <= c && 8303 >= c || 55296 <= c && 57343 >= c || 65279 == c || 65520 <= c && 65528 >= c || 65529 <= c && 65531 >= c || 113824 <= c && 113827 >= c || 119155 <= c && 119162 >= c || 917504 == c || 917505 == c || 917506 <= c && 917535 >= c || 917632 <= c && 917759 >= c || 918E3 <= c && 921599 >= c ? 2 : 768 <= c && 879 >= c || 1155 <= c && 1159 >= c || 1160 <= c && 1161 >= c || 1425 <= c && 1469 >= c || 1471 == c || 1473 <= c && 1474 >= c || 1476 <= c && 1477 >= c || 1479 == c || 1552 <= c && 1562 >= c || 1611 <= c && 1631 >= c || 1648 == c || 1750 <= c && 1756 >= c || 1759 <= c && 1764 >= c || 1767 <= c && 1768 >= c || 1770 <= c && 1773 >= c || 1809 == c || 1840 <= c && 1866 >= c || 1958 <= c && 1968 >= c || 2027 <= c && 2035 >= c || 2070 <= c && 2073 >= c || 2075 <= c && 2083 >= c || 2085 <= c && 2087 >= c || 2089 <= c && 2093 >= c || 2137 <= c && 2139 >= c || 2260 <= c && 2273 >= c || 2275 <= c && 2306 >= c || 2362 == c || 2364 == c || 2369 <= c && 2376 >= c || 2381 == c || 2385 <= c && 2391 >= c || 2402 <= c && 2403 >= c || 2433 == c || 2492 == c || 2494 == c || 2497 <= c && 2500 >= c || 2509 == c || 2519 == c || 2530 <= c && 2531 >= c || 2561 <= c && 2562 >= c || 2620 == c || 2625 <= c && 2626 >= c || 2631 <= c && 2632 >= c || 2635 <= c && 2637 >= c || 2641 == c || 2672 <= c && 2673 >= c || 2677 == c || 2689 <= c && 2690 >= c || 2748 == c || 2753 <= c && 2757 >= c || 2759 <= c && 2760 >= c || 2765 == c || 2786 <= c && 2787 >= c || 2810 <= c && 2815 >= c || 2817 == c || 2876 == c || 2878 == c || 2879 == c || 2881 <= c && 2884 >= c || 2893 == c || 2902 == c || 2903 == c || 2914 <= c && 2915 >= c || 2946 == c || 3006 == c || 3008 == c || 3021 == c || 3031 == c || 3072 == c || 3134 <= c && 3136 >= c || 3142 <= c && 3144 >= c || 3146 <= c && 3149 >= c || 3157 <= c && 3158 >= c || 3170 <= c && 3171 >= c || 3201 == c || 3260 == c || 3263 == c || 3266 == c || 3270 == c || 3276 <= c && 3277 >= c || 3285 <= c && 3286 >= c || 3298 <= c && 3299 >= c || 3328 <= c && 3329 >= c || 3387 <= c && 3388 >= c || 3390 == c || 3393 <= c && 3396 >= c || 3405 == c || 3415 == c || 3426 <= c && 3427 >= c || 3530 == c || 3535 == c || 3538 <= c && 3540 >= c || 3542 == c || 3551 == c || 3633 == c || 3636 <= c && 3642 >= c || 3655 <= c && 3662 >= c || 3761 == c || 3764 <= c && 3769 >= c || 3771 <= c && 3772 >= c || 3784 <= c && 3789 >= c || 3864 <= c && 3865 >= c || 3893 == c || 3895 == c || 3897 == c || 3953 <= c && 3966 >= c || 3968 <= c && 3972 >= c || 3974 <= c && 3975 >= c || 3981 <= c && 3991 >= c || 3993 <= c && 4028 >= c || 4038 == c || 4141 <= c && 4144 >= c || 4146 <= c && 4151 >= c || 4153 <= c && 4154 >= c || 4157 <= c && 4158 >= c || 4184 <= c && 4185 >= c || 4190 <= c && 4192 >= c || 4209 <= c && 4212 >= c || 4226 == c || 4229 <= c && 4230 >= c || 4237 == c || 4253 == c || 4957 <= c && 4959 >= c || 5906 <= c && 5908 >= c || 5938 <= c && 5940 >= c || 5970 <= c && 5971 >= c || 6002 <= c && 6003 >= c || 6068 <= c && 6069 >= c || 6071 <= c && 6077 >= c || 6086 == c || 6089 <= c && 6099 >= c || 6109 == c || 6155 <= c && 6157 >= c || 6277 <= c && 6278 >= c || 6313 == c || 6432 <= c && 6434 >= c || 6439 <= c && 6440 >= c || 6450 == c || 6457 <= c && 6459 >= c || 6679 <= c && 6680 >= c || 6683 == c || 6742 == c || 6744 <= c && 6750 >= c || 6752 == c || 6754 == c || 6757 <= c && 6764 >= c || 6771 <= c && 6780 >= c || 6783 == c || 6832 <= c && 6845 >= c || 6846 == c || 6912 <= c && 6915 >= c || 6964 == c || 6966 <= c && 6970 >= c || 6972 == c || 6978 == c || 7019 <= c && 7027 >= c || 7040 <= c && 7041 >= c || 7074 <= c && 7077 >= c || 7080 <= c && 7081 >= c || 7083 <= c && 7085 >= c || 7142 == c || 7144 <= c && 7145 >= c || 7149 == c || 7151 <= c && 7153 >= c || 7212 <= c && 7219 >= c || 7222 <= c && 7223 >= c || 7376 <= c && 7378 >= c || 7380 <= c && 7392 >= c || 7394 <= c && 7400 >= c || 7405 == c || 7412 == c || 7416 <= c && 7417 >= c || 7616 <= c && 7673 >= c || 7675 <= c && 7679 >= c || 8204 == c || 8400 <= c && 8412 >= c || 8413 <= c && 8416 >= c || 8417 == c || 8418 <= c && 8420 >= c || 8421 <= c && 8432 >= c || 11503 <= c && 11505 >= c || 11647 == c || 11744 <= c && 11775 >= c || 12330 <= c && 12333 >= c || 12334 <= c && 12335 >= c || 12441 <= c && 12442 >= c || 42607 == c || 42608 <= c && 42610 >= c || 42612 <= c && 42621 >= c || 42654 <= c && 42655 >= c || 42736 <= c && 42737 >= c || 43010 == c || 43014 == c || 43019 == c || 43045 <= c && 43046 >= c || 43204 <= c && 43205 >= c || 43232 <= c && 43249 >= c || 43302 <= c && 43309 >= c || 43335 <= c && 43345 >= c || 43392 <= c && 43394 >= c || 43443 == c || 43446 <= c && 43449 >= c || 43452 == c || 43493 == c || 43561 <= c && 43566 >= c || 43569 <= c && 43570 >= c || 43573 <= c && 43574 >= c || 43587 == c || 43596 == c || 43644 == c || 43696 == c || 43698 <= c && 43700 >= c || 43703 <= c && 43704 >= c || 43710 <= c && 43711 >= c || 43713 == c || 43756 <= c && 43757 >= c || 43766 == c || 44005 == c || 44008 == c || 44013 == c || 64286 == c || 65024 <= c && 65039 >= c || 65056 <= c && 65071 >= c || 65438 <= c && 65439 >= c || 66045 == c || 66272 == c || 66422 <= c && 66426 >= c || 68097 <= c && 68099 >= c || 68101 <= c && 68102 >= c || 68108 <= c && 68111 >= c || 68152 <= c && 68154 >= c || 68159 == c || 68325 <= c && 68326 >= c || 69633 == c || 69688 <= c && 69702 >= c || 69759 <= c && 69761 >= c || 69811 <= c && 69814 >= c || 69817 <= c && 69818 >= c || 69888 <= c && 69890 >= c || 69927 <= c && 69931 >= c || 69933 <= c && 69940 >= c || 70003 == c || 70016 <= c && 70017 >= c || 70070 <= c && 70078 >= c || 70090 <= c && 70092 >= c || 70191 <= c && 70193 >= c || 70196 == c || 70198 <= c && 70199 >= c || 70206 == c || 70367 == c || 70371 <= c && 70378 >= c || 70400 <= c && 70401 >= c || 70460 == c || 70462 == c || 70464 == c || 70487 == c || 70502 <= c && 70508 >= c || 70512 <= c && 70516 >= c || 70712 <= c && 70719 >= c || 70722 <= c && 70724 >= c || 70726 == c || 70832 == c || 70835 <= c && 70840 >= c || 70842 == c || 70845 == c || 70847 <= c && 70848 >= c || 70850 <= c && 70851 >= c || 71087 == c || 71090 <= c && 71093 >= c || 71100 <= c && 71101 >= c || 71103 <= c && 71104 >= c || 71132 <= c && 71133 >= c || 71219 <= c && 71226 >= c || 71229 == c || 71231 <= c && 71232 >= c || 71339 == c || 71341 == c || 71344 <= c && 71349 >= c || 71351 == c || 71453 <= c && 71455 >= c || 71458 <= c && 71461 >= c || 71463 <= c && 71467 >= c || 72193 <= c && 72198 >= c || 72201 <= c && 72202 >= c || 72243 <= c && 72248 >= c || 72251 <= c && 72254 >= c || 72263 == c || 72273 <= c && 72278 >= c || 72281 <= c && 72283 >= c || 72330 <= c && 72342 >= c || 72344 <= c && 72345 >= c || 72752 <= c && 72758 >= c || 72760 <= c && 72765 >= c || 72767 == c || 72850 <= c && 72871 >= c || 72874 <= c && 72880 >= c || 72882 <= c && 72883 >= c || 72885 <= c && 72886 >= c || 73009 <= c && 73014 >= c || 73018 == c || 73020 <= c && 73021 >= c || 73023 <= c && 73029 >= c || 73031 == c || 92912 <= c && 92916 >= c || 92976 <= c && 92982 >= c || 94095 <= c && 94098 >= c || 113821 <= c && 113822 >= c || 119141 == c || 119143 <= c && 119145 >= c || 119150 <= c && 119154 >= c || 119163 <= c && 119170 >= c || 119173 <= c && 119179 >= c || 119210 <= c && 119213 >= c || 119362 <= c && 119364 >= c || 121344 <= c && 121398 >= c || 121403 <= c && 121452 >= c || 121461 == c || 121476 == c || 121499 <= c && 121503 >= c || 121505 <= c && 121519 >= c || 122880 <= c && 122886 >= c || 122888 <= c && 122904 >= c || 122907 <= c && 122913 >= c || 122915 <= c && 122916 >= c || 122918 <= c && 122922 >= c || 125136 <= c && 125142 >= c || 125252 <= c && 125258 >= c || 917536 <= c && 917631 >= c || 917760 <= c && 917999 >= c ? 3 : 127462 <= c && 127487 >= c ? 4 : 2307 == c || 2363 == c || 2366 <= c && 2368 >= c || 2377 <= c && 2380 >= c || 2382 <= c && 2383 >= c || 2434 <= c && 2435 >= c || 2495 <= c && 2496 >= c || 2503 <= c && 2504 >= c || 2507 <= c && 2508 >= c || 2563 == c || 2622 <= c && 2624 >= c || 2691 == c || 2750 <= c && 2752 >= c || 2761 == c || 2763 <= c && 2764 >= c || 2818 <= c && 2819 >= c || 2880 == c || 2887 <= c && 2888 >= c || 2891 <= c && 2892 >= c || 3007 == c || 3009 <= c && 3010 >= c || 3014 <= c && 3016 >= c || 3018 <= c && 3020 >= c || 3073 <= c && 3075 >= c || 3137 <= c && 3140 >= c || 3202 <= c && 3203 >= c || 3262 == c || 3264 <= c && 3265 >= c || 3267 <= c && 3268 >= c || 3271 <= c && 3272 >= c || 3274 <= c && 3275 >= c || 3330 <= c && 3331 >= c || 3391 <= c && 3392 >= c || 3398 <= c && 3400 >= c || 3402 <= c && 3404 >= c || 3458 <= c && 3459 >= c || 3536 <= c && 3537 >= c || 3544 <= c && 3550 >= c || 3570 <= c && 3571 >= c || 3635 == c || 3763 == c || 3902 <= c && 3903 >= c || 3967 == c || 4145 == c || 4155 <= c && 4156 >= c || 4182 <= c && 4183 >= c || 4228 == c || 6070 == c || 6078 <= c && 6085 >= c || 6087 <= c && 6088 >= c || 6435 <= c && 6438 >= c || 6441 <= c && 6443 >= c || 6448 <= c && 6449 >= c || 6451 <= c && 6456 >= c || 6681 <= c && 6682 >= c || 6741 == c || 6743 == c || 6765 <= c && 6770 >= c || 6916 == c || 6965 == c || 6971 == c || 6973 <= c && 6977 >= c || 6979 <= c && 6980 >= c || 7042 == c || 7073 == c || 7078 <= c && 7079 >= c || 7082 == c || 7143 == c || 7146 <= c && 7148 >= c || 7150 == c || 7154 <= c && 7155 >= c || 7204 <= c && 7211 >= c || 7220 <= c && 7221 >= c || 7393 == c || 7410 <= c && 7411 >= c || 7415 == c || 43043 <= c && 43044 >= c || 43047 == c || 43136 <= c && 43137 >= c || 43188 <= c && 43203 >= c || 43346 <= c && 43347 >= c || 43395 == c || 43444 <= c && 43445 >= c || 43450 <= c && 43451 >= c || 43453 <= c && 43456 >= c || 43567 <= c && 43568 >= c || 43571 <= c && 43572 >= c || 43597 == c || 43755 == c || 43758 <= c && 43759 >= c || 43765 == c || 44003 <= c && 44004 >= c || 44006 <= c && 44007 >= c || 44009 <= c && 44010 >= c || 44012 == c || 69632 == c || 69634 == c || 69762 == c || 69808 <= c && 69810 >= c || 69815 <= c && 69816 >= c || 69932 == c || 70018 == c || 70067 <= c && 70069 >= c || 70079 <= c && 70080 >= c || 70188 <= c && 70190 >= c || 70194 <= c && 70195 >= c || 70197 == c || 70368 <= c && 70370 >= c || 70402 <= c && 70403 >= c || 70463 == c || 70465 <= c && 70468 >= c || 70471 <= c && 70472 >= c || 70475 <= c && 70477 >= c || 70498 <= c && 70499 >= c || 70709 <= c && 70711 >= c || 70720 <= c && 70721 >= c || 70725 == c || 70833 <= c && 70834 >= c || 70841 == c || 70843 <= c && 70844 >= c || 70846 == c || 70849 == c || 71088 <= c && 71089 >= c || 71096 <= c && 71099 >= c || 71102 == c || 71216 <= c && 71218 >= c || 71227 <= c && 71228 >= c || 71230 == c || 71340 == c || 71342 <= c && 71343 >= c || 71350 == c || 71456 <= c && 71457 >= c || 71462 == c || 72199 <= c && 72200 >= c || 72249 == c || 72279 <= c && 72280 >= c || 72343 == c || 72751 == c || 72766 == c || 72873 == c || 72881 == c || 72884 == c || 94033 <= c && 94078 >= c || 119142 == c || 119149 == c ? 5 : 4352 <= c && 4447 >= c || 43360 <= c && 43388 >= c ? 6 : 4448 <= c && 4519 >= c || 55216 <= c && 55238 >= c ? 7 : 4520 <= c && 4607 >= c || 55243 <= c && 55291 >= c ? 8 : 44032 == c || 44060 == c || 44088 == c || 44116 == c || 44144 == c || 44172 == c || 44200 == c || 44228 == c || 44256 == c || 44284 == c || 44312 == c || 44340 == c || 44368 == c || 44396 == c || 44424 == c || 44452 == c || 44480 == c || 44508 == c || 44536 == c || 44564 == c || 44592 == c || 44620 == c || 44648 == c || 44676 == c || 44704 == c || 44732 == c || 44760 == c || 44788 == c || 44816 == c || 44844 == c || 44872 == c || 44900 == c || 44928 == c || 44956 == c || 44984 == c || 45012 == c || 45040 == c || 45068 == c || 45096 == c || 45124 == c || 45152 == c || 45180 == c || 45208 == c || 45236 == c || 45264 == c || 45292 == c || 45320 == c || 45348 == c || 45376 == c || 45404 == c || 45432 == c || 45460 == c || 45488 == c || 45516 == c || 45544 == c || 45572 == c || 45600 == c || 45628 == c || 45656 == c || 45684 == c || 45712 == c || 45740 == c || 45768 == c || 45796 == c || 45824 == c || 45852 == c || 45880 == c || 45908 == c || 45936 == c || 45964 == c || 45992 == c || 46020 == c || 46048 == c || 46076 == c || 46104 == c || 46132 == c || 46160 == c || 46188 == c || 46216 == c || 46244 == c || 46272 == c || 46300 == c || 46328 == c || 46356 == c || 46384 == c || 46412 == c || 46440 == c || 46468 == c || 46496 == c || 46524 == c || 46552 == c || 46580 == c || 46608 == c || 46636 == c || 46664 == c || 46692 == c || 46720 == c || 46748 == c || 46776 == c || 46804 == c || 46832 == c || 46860 == c || 46888 == c || 46916 == c || 46944 == c || 46972 == c || 47E3 == c || 47028 == c || 47056 == c || 47084 == c || 47112 == c || 47140 == c || 47168 == c || 47196 == c || 47224 == c || 47252 == c || 47280 == c || 47308 == c || 47336 == c || 47364 == c || 47392 == c || 47420 == c || 47448 == c || 47476 == c || 47504 == c || 47532 == c || 47560 == c || 47588 == c || 47616 == c || 47644 == c || 47672 == c || 47700 == c || 47728 == c || 47756 == c || 47784 == c || 47812 == c || 47840 == c || 47868 == c || 47896 == c || 47924 == c || 47952 == c || 47980 == c || 48008 == c || 48036 == c || 48064 == c || 48092 == c || 48120 == c || 48148 == c || 48176 == c || 48204 == c || 48232 == c || 48260 == c || 48288 == c || 48316 == c || 48344 == c || 48372 == c || 48400 == c || 48428 == c || 48456 == c || 48484 == c || 48512 == c || 48540 == c || 48568 == c || 48596 == c || 48624 == c || 48652 == c || 48680 == c || 48708 == c || 48736 == c || 48764 == c || 48792 == c || 48820 == c || 48848 == c || 48876 == c || 48904 == c || 48932 == c || 48960 == c || 48988 == c || 49016 == c || 49044 == c || 49072 == c || 49100 == c || 49128 == c || 49156 == c || 49184 == c || 49212 == c || 49240 == c || 49268 == c || 49296 == c || 49324 == c || 49352 == c || 49380 == c || 49408 == c || 49436 == c || 49464 == c || 49492 == c || 49520 == c || 49548 == c || 49576 == c || 49604 == c || 49632 == c || 49660 == c || 49688 == c || 49716 == c || 49744 == c || 49772 == c || 49800 == c || 49828 == c || 49856 == c || 49884 == c || 49912 == c || 49940 == c || 49968 == c || 49996 == c || 50024 == c || 50052 == c || 50080 == c || 50108 == c || 50136 == c || 50164 == c || 50192 == c || 50220 == c || 50248 == c || 50276 == c || 50304 == c || 50332 == c || 50360 == c || 50388 == c || 50416 == c || 50444 == c || 50472 == c || 50500 == c || 50528 == c || 50556 == c || 50584 == c || 50612 == c || 50640 == c || 50668 == c || 50696 == c || 50724 == c || 50752 == c || 50780 == c || 50808 == c || 50836 == c || 50864 == c || 50892 == c || 50920 == c || 50948 == c || 50976 == c || 51004 == c || 51032 == c || 51060 == c || 51088 == c || 51116 == c || 51144 == c || 51172 == c || 51200 == c || 51228 == c || 51256 == c || 51284 == c || 51312 == c || 51340 == c || 51368 == c || 51396 == c || 51424 == c || 51452 == c || 51480 == c || 51508 == c || 51536 == c || 51564 == c || 51592 == c || 51620 == c || 51648 == c || 51676 == c || 51704 == c || 51732 == c || 51760 == c || 51788 == c || 51816 == c || 51844 == c || 51872 == c || 51900 == c || 51928 == c || 51956 == c || 51984 == c || 52012 == c || 52040 == c || 52068 == c || 52096 == c || 52124 == c || 52152 == c || 52180 == c || 52208 == c || 52236 == c || 52264 == c || 52292 == c || 52320 == c || 52348 == c || 52376 == c || 52404 == c || 52432 == c || 52460 == c || 52488 == c || 52516 == c || 52544 == c || 52572 == c || 52600 == c || 52628 == c || 52656 == c || 52684 == c || 52712 == c || 52740 == c || 52768 == c || 52796 == c || 52824 == c || 52852 == c || 52880 == c || 52908 == c || 52936 == c || 52964 == c || 52992 == c || 53020 == c || 53048 == c || 53076 == c || 53104 == c || 53132 == c || 53160 == c || 53188 == c || 53216 == c || 53244 == c || 53272 == c || 53300 == c || 53328 == c || 53356 == c || 53384 == c || 53412 == c || 53440 == c || 53468 == c || 53496 == c || 53524 == c || 53552 == c || 53580 == c || 53608 == c || 53636 == c || 53664 == c || 53692 == c || 53720 == c || 53748 == c || 53776 == c || 53804 == c || 53832 == c || 53860 == c || 53888 == c || 53916 == c || 53944 == c || 53972 == c || 54E3 == c || 54028 == c || 54056 == c || 54084 == c || 54112 == c || 54140 == c || 54168 == c || 54196 == c || 54224 == c || 54252 == c || 54280 == c || 54308 == c || 54336 == c || 54364 == c || 54392 == c || 54420 == c || 54448 == c || 54476 == c || 54504 == c || 54532 == c || 54560 == c || 54588 == c || 54616 == c || 54644 == c || 54672 == c || 54700 == c || 54728 == c || 54756 == c || 54784 == c || 54812 == c || 54840 == c || 54868 == c || 54896 == c || 54924 == c || 54952 == c || 54980 == c || 55008 == c || 55036 == c || 55064 == c || 55092 == c || 55120 == c || 55148 == c || 55176 == c ? 9 : 44033 <= c && 44059 >= c || 44061 <= c && 44087 >= c || 44089 <= c && 44115 >= c || 44117 <= c && 44143 >= c || 44145 <= c && 44171 >= c || 44173 <= c && 44199 >= c || 44201 <= c && 44227 >= c || 44229 <= c && 44255 >= c || 44257 <= c && 44283 >= c || 44285 <= c && 44311 >= c || 44313 <= c && 44339 >= c || 44341 <= c && 44367 >= c || 44369 <= c && 44395 >= c || 44397 <= c && 44423 >= c || 44425 <= c && 44451 >= c || 44453 <= c && 44479 >= c || 44481 <= c && 44507 >= c || 44509 <= c && 44535 >= c || 44537 <= c && 44563 >= c || 44565 <= c && 44591 >= c || 44593 <= c && 44619 >= c || 44621 <= c && 44647 >= c || 44649 <= c && 44675 >= c || 44677 <= c && 44703 >= c || 44705 <= c && 44731 >= c || 44733 <= c && 44759 >= c || 44761 <= c && 44787 >= c || 44789 <= c && 44815 >= c || 44817 <= c && 44843 >= c || 44845 <= c && 44871 >= c || 44873 <= c && 44899 >= c || 44901 <= c && 44927 >= c || 44929 <= c && 44955 >= c || 44957 <= c && 44983 >= c || 44985 <= c && 45011 >= c || 45013 <= c && 45039 >= c || 45041 <= c && 45067 >= c || 45069 <= c && 45095 >= c || 45097 <= c && 45123 >= c || 45125 <= c && 45151 >= c || 45153 <= c && 45179 >= c || 45181 <= c && 45207 >= c || 45209 <= c && 45235 >= c || 45237 <= c && 45263 >= c || 45265 <= c && 45291 >= c || 45293 <= c && 45319 >= c || 45321 <= c && 45347 >= c || 45349 <= c && 45375 >= c || 45377 <= c && 45403 >= c || 45405 <= c && 45431 >= c || 45433 <= c && 45459 >= c || 45461 <= c && 45487 >= c || 45489 <= c && 45515 >= c || 45517 <= c && 45543 >= c || 45545 <= c && 45571 >= c || 45573 <= c && 45599 >= c || 45601 <= c && 45627 >= c || 45629 <= c && 45655 >= c || 45657 <= c && 45683 >= c || 45685 <= c && 45711 >= c || 45713 <= c && 45739 >= c || 45741 <= c && 45767 >= c || 45769 <= c && 45795 >= c || 45797 <= c && 45823 >= c || 45825 <= c && 45851 >= c || 45853 <= c && 45879 >= c || 45881 <= c && 45907 >= c || 45909 <= c && 45935 >= c || 45937 <= c && 45963 >= c || 45965 <= c && 45991 >= c || 45993 <= c && 46019 >= c || 46021 <= c && 46047 >= c || 46049 <= c && 46075 >= c || 46077 <= c && 46103 >= c || 46105 <= c && 46131 >= c || 46133 <= c && 46159 >= c || 46161 <= c && 46187 >= c || 46189 <= c && 46215 >= c || 46217 <= c && 46243 >= c || 46245 <= c && 46271 >= c || 46273 <= c && 46299 >= c || 46301 <= c && 46327 >= c || 46329 <= c && 46355 >= c || 46357 <= c && 46383 >= c || 46385 <= c && 46411 >= c || 46413 <= c && 46439 >= c || 46441 <= c && 46467 >= c || 46469 <= c && 46495 >= c || 46497 <= c && 46523 >= c || 46525 <= c && 46551 >= c || 46553 <= c && 46579 >= c || 46581 <= c && 46607 >= c || 46609 <= c && 46635 >= c || 46637 <= c && 46663 >= c || 46665 <= c && 46691 >= c || 46693 <= c && 46719 >= c || 46721 <= c && 46747 >= c || 46749 <= c && 46775 >= c || 46777 <= c && 46803 >= c || 46805 <= c && 46831 >= c || 46833 <= c && 46859 >= c || 46861 <= c && 46887 >= c || 46889 <= c && 46915 >= c || 46917 <= c && 46943 >= c || 46945 <= c && 46971 >= c || 46973 <= c && 46999 >= c || 47001 <= c && 47027 >= c || 47029 <= c && 47055 >= c || 47057 <= c && 47083 >= c || 47085 <= c && 47111 >= c || 47113 <= c && 47139 >= c || 47141 <= c && 47167 >= c || 47169 <= c && 47195 >= c || 47197 <= c && 47223 >= c || 47225 <= c && 47251 >= c || 47253 <= c && 47279 >= c || 47281 <= c && 47307 >= c || 47309 <= c && 47335 >= c || 47337 <= c && 47363 >= c || 47365 <= c && 47391 >= c || 47393 <= c && 47419 >= c || 47421 <= c && 47447 >= c || 47449 <= c && 47475 >= c || 47477 <= c && 47503 >= c || 47505 <= c && 47531 >= c || 47533 <= c && 47559 >= c || 47561 <= c && 47587 >= c || 47589 <= c && 47615 >= c || 47617 <= c && 47643 >= c || 47645 <= c && 47671 >= c || 47673 <= c && 47699 >= c || 47701 <= c && 47727 >= c || 47729 <= c && 47755 >= c || 47757 <= c && 47783 >= c || 47785 <= c && 47811 >= c || 47813 <= c && 47839 >= c || 47841 <= c && 47867 >= c || 47869 <= c && 47895 >= c || 47897 <= c && 47923 >= c || 47925 <= c && 47951 >= c || 47953 <= c && 47979 >= c || 47981 <= c && 48007 >= c || 48009 <= c && 48035 >= c || 48037 <= c && 48063 >= c || 48065 <= c && 48091 >= c || 48093 <= c && 48119 >= c || 48121 <= c && 48147 >= c || 48149 <= c && 48175 >= c || 48177 <= c && 48203 >= c || 48205 <= c && 48231 >= c || 48233 <= c && 48259 >= c || 48261 <= c && 48287 >= c || 48289 <= c && 48315 >= c || 48317 <= c && 48343 >= c || 48345 <= c && 48371 >= c || 48373 <= c && 48399 >= c || 48401 <= c && 48427 >= c || 48429 <= c && 48455 >= c || 48457 <= c && 48483 >= c || 48485 <= c && 48511 >= c || 48513 <= c && 48539 >= c || 48541 <= c && 48567 >= c || 48569 <= c && 48595 >= c || 48597 <= c && 48623 >= c || 48625 <= c && 48651 >= c || 48653 <= c && 48679 >= c || 48681 <= c && 48707 >= c || 48709 <= c && 48735 >= c || 48737 <= c && 48763 >= c || 48765 <= c && 48791 >= c || 48793 <= c && 48819 >= c || 48821 <= c && 48847 >= c || 48849 <= c && 48875 >= c || 48877 <= c && 48903 >= c || 48905 <= c && 48931 >= c || 48933 <= c && 48959 >= c || 48961 <= c && 48987 >= c || 48989 <= c && 49015 >= c || 49017 <= c && 49043 >= c || 49045 <= c && 49071 >= c || 49073 <= c && 49099 >= c || 49101 <= c && 49127 >= c || 49129 <= c && 49155 >= c || 49157 <= c && 49183 >= c || 49185 <= c && 49211 >= c || 49213 <= c && 49239 >= c || 49241 <= c && 49267 >= c || 49269 <= c && 49295 >= c || 49297 <= c && 49323 >= c || 49325 <= c && 49351 >= c || 49353 <= c && 49379 >= c || 49381 <= c && 49407 >= c || 49409 <= c && 49435 >= c || 49437 <= c && 49463 >= c || 49465 <= c && 49491 >= c || 49493 <= c && 49519 >= c || 49521 <= c && 49547 >= c || 49549 <= c && 49575 >= c || 49577 <= c && 49603 >= c || 49605 <= c && 49631 >= c || 49633 <= c && 49659 >= c || 49661 <= c && 49687 >= c || 49689 <= c && 49715 >= c || 49717 <= c && 49743 >= c || 49745 <= c && 49771 >= c || 49773 <= c && 49799 >= c || 49801 <= c && 49827 >= c || 49829 <= c && 49855 >= c || 49857 <= c && 49883 >= c || 49885 <= c && 49911 >= c || 49913 <= c && 49939 >= c || 49941 <= c && 49967 >= c || 49969 <= c && 49995 >= c || 49997 <= c && 50023 >= c || 50025 <= c && 50051 >= c || 50053 <= c && 50079 >= c || 50081 <= c && 50107 >= c || 50109 <= c && 50135 >= c || 50137 <= c && 50163 >= c || 50165 <= c && 50191 >= c || 50193 <= c && 50219 >= c || 50221 <= c && 50247 >= c || 50249 <= c && 50275 >= c || 50277 <= c && 50303 >= c || 50305 <= c && 50331 >= c || 50333 <= c && 50359 >= c || 50361 <= c && 50387 >= c || 50389 <= c && 50415 >= c || 50417 <= c && 50443 >= c || 50445 <= c && 50471 >= c || 50473 <= c && 50499 >= c || 50501 <= c && 50527 >= c || 50529 <= c && 50555 >= c || 50557 <= c && 50583 >= c || 50585 <= c && 50611 >= c || 50613 <= c && 50639 >= c || 50641 <= c && 50667 >= c || 50669 <= c && 50695 >= c || 50697 <= c && 50723 >= c || 50725 <= c && 50751 >= c || 50753 <= c && 50779 >= c || 50781 <= c && 50807 >= c || 50809 <= c && 50835 >= c || 50837 <= c && 50863 >= c || 50865 <= c && 50891 >= c || 50893 <= c && 50919 >= c || 50921 <= c && 50947 >= c || 50949 <= c && 50975 >= c || 50977 <= c && 51003 >= c || 51005 <= c && 51031 >= c || 51033 <= c && 51059 >= c || 51061 <= c && 51087 >= c || 51089 <= c && 51115 >= c || 51117 <= c && 51143 >= c || 51145 <= c && 51171 >= c || 51173 <= c && 51199 >= c || 51201 <= c && 51227 >= c || 51229 <= c && 51255 >= c || 51257 <= c && 51283 >= c || 51285 <= c && 51311 >= c || 51313 <= c && 51339 >= c || 51341 <= c && 51367 >= c || 51369 <= c && 51395 >= c || 51397 <= c && 51423 >= c || 51425 <= c && 51451 >= c || 51453 <= c && 51479 >= c || 51481 <= c && 51507 >= c || 51509 <= c && 51535 >= c || 51537 <= c && 51563 >= c || 51565 <= c && 51591 >= c || 51593 <= c && 51619 >= c || 51621 <= c && 51647 >= c || 51649 <= c && 51675 >= c || 51677 <= c && 51703 >= c || 51705 <= c && 51731 >= c || 51733 <= c && 51759 >= c || 51761 <= c && 51787 >= c || 51789 <= c && 51815 >= c || 51817 <= c && 51843 >= c || 51845 <= c && 51871 >= c || 51873 <= c && 51899 >= c || 51901 <= c && 51927 >= c || 51929 <= c && 51955 >= c || 51957 <= c && 51983 >= c || 51985 <= c && 52011 >= c || 52013 <= c && 52039 >= c || 52041 <= c && 52067 >= c || 52069 <= c && 52095 >= c || 52097 <= c && 52123 >= c || 52125 <= c && 52151 >= c || 52153 <= c && 52179 >= c || 52181 <= c && 52207 >= c || 52209 <= c && 52235 >= c || 52237 <= c && 52263 >= c || 52265 <= c && 52291 >= c || 52293 <= c && 52319 >= c || 52321 <= c && 52347 >= c || 52349 <= c && 52375 >= c || 52377 <= c && 52403 >= c || 52405 <= c && 52431 >= c || 52433 <= c && 52459 >= c || 52461 <= c && 52487 >= c || 52489 <= c && 52515 >= c || 52517 <= c && 52543 >= c || 52545 <= c && 52571 >= c || 52573 <= c && 52599 >= c || 52601 <= c && 52627 >= c || 52629 <= c && 52655 >= c || 52657 <= c && 52683 >= c || 52685 <= c && 52711 >= c || 52713 <= c && 52739 >= c || 52741 <= c && 52767 >= c || 52769 <= c && 52795 >= c || 52797 <= c && 52823 >= c || 52825 <= c && 52851 >= c || 52853 <= c && 52879 >= c || 52881 <= c && 52907 >= c || 52909 <= c && 52935 >= c || 52937 <= c && 52963 >= c || 52965 <= c && 52991 >= c || 52993 <= c && 53019 >= c || 53021 <= c && 53047 >= c || 53049 <= c && 53075 >= c || 53077 <= c && 53103 >= c || 53105 <= c && 53131 >= c || 53133 <= c && 53159 >= c || 53161 <= c && 53187 >= c || 53189 <= c && 53215 >= c || 53217 <= c && 53243 >= c || 53245 <= c && 53271 >= c || 53273 <= c && 53299 >= c || 53301 <= c && 53327 >= c || 53329 <= c && 53355 >= c || 53357 <= c && 53383 >= c || 53385 <= c && 53411 >= c || 53413 <= c && 53439 >= c || 53441 <= c && 53467 >= c || 53469 <= c && 53495 >= c || 53497 <= c && 53523 >= c || 53525 <= c && 53551 >= c || 53553 <= c && 53579 >= c || 53581 <= c && 53607 >= c || 53609 <= c && 53635 >= c || 53637 <= c && 53663 >= c || 53665 <= c && 53691 >= c || 53693 <= c && 53719 >= c || 53721 <= c && 53747 >= c || 53749 <= c && 53775 >= c || 53777 <= c && 53803 >= c || 53805 <= c && 53831 >= c || 53833 <= c && 53859 >= c || 53861 <= c && 53887 >= c || 53889 <= c && 53915 >= c || 53917 <= c && 53943 >= c || 53945 <= c && 53971 >= c || 53973 <= c && 53999 >= c || 54001 <= c && 54027 >= c || 54029 <= c && 54055 >= c || 54057 <= c && 54083 >= c || 54085 <= c && 54111 >= c || 54113 <= c && 54139 >= c || 54141 <= c && 54167 >= c || 54169 <= c && 54195 >= c || 54197 <= c && 54223 >= c || 54225 <= c && 54251 >= c || 54253 <= c && 54279 >= c || 54281 <= c && 54307 >= c || 54309 <= c && 54335 >= c || 54337 <= c && 54363 >= c || 54365 <= c && 54391 >= c || 54393 <= c && 54419 >= c || 54421 <= c && 54447 >= c || 54449 <= c && 54475 >= c || 54477 <= c && 54503 >= c || 54505 <= c && 54531 >= c || 54533 <= c && 54559 >= c || 54561 <= c && 54587 >= c || 54589 <= c && 54615 >= c || 54617 <= c && 54643 >= c || 54645 <= c && 54671 >= c || 54673 <= c && 54699 >= c || 54701 <= c && 54727 >= c || 54729 <= c && 54755 >= c || 54757 <= c && 54783 >= c || 54785 <= c && 54811 >= c || 54813 <= c && 54839 >= c || 54841 <= c && 54867 >= c || 54869 <= c && 54895 >= c || 54897 <= c && 54923 >= c || 54925 <= c && 54951 >= c || 54953 <= c && 54979 >= c || 54981 <= c && 55007 >= c || 55009 <= c && 55035 >= c || 55037 <= c && 55063 >= c || 55065 <= c && 55091 >= c || 55093 <= c && 55119 >= c || 55121 <= c && 55147 >= c || 55149 <= c && 55175 >= c || 55177 <= c && 55203 >= c ? 10 : 9757 == c || 9977 == c || 9994 <= c && 9997 >= c || 127877 == c || 127938 <= c && 127940 >= c || 127943 == c || 127946 <= c && 127948 >= c || 128066 <= c && 128067 >= c || 128070 <= c && 128080 >= c || 128110 == c || 128112 <= c && 128120 >= c || 128124 == c || 128129 <= c && 128131 >= c || 128133 <= c && 128135 >= c || 128170 == c || 128372 <= c && 128373 >= c || 128378 == c || 128400 == c || 128405 <= c && 128406 >= c || 128581 <= c && 128583 >= c || 128587 <= c && 128591 >= c || 128675 == c || 128692 <= c && 128694 >= c || 128704 == c || 128716 == c || 129304 <= c && 129308 >= c || 129310 <= c && 129311 >= c || 129318 == c || 129328 <= c && 129337 >= c || 129341 <= c && 129342 >= c || 129489 <= c && 129501 >= c ? 13 : 127995 <= c && 127999 >= c ? 14 : 8205 == c ? 15 : 9792 == c || 9794 == c || 9877 <= c && 9878 >= c || 9992 == c || 10084 == c || 127752 == c || 127806 == c || 127859 == c || 127891 == c || 127908 == c || 127912 == c || 127979 == c || 127981 == c || 128139 == c || 128187 <= c && 128188 >= c || 128295 == c || 128300 == c || 128488 == c || 128640 == c || 128658 == c ? 16 : 128102 <= c && 128105 >= c ? 17 : 11
    }
    this.nextBreak = function(c, e) {
        void 0 === e && (e = 0);
        if (0 > e)
            return 0;
        if (e >= c.length - 1)
            return c.length;
        var g = d(a(c, e))
          , k = [];
        for (e += 1; e < c.length; e++) {
            var l = c
              , n = e - 1;
            if (!(55296 <= l.charCodeAt(n) && 56319 >= l.charCodeAt(n) && 56320 <= l.charCodeAt(n + 1) && 57343 >= l.charCodeAt(n + 1))) {
                l = d(a(c, e));
                if (b(g, k, l))
                    return e;
                k.push(l)
            }
        }
        return c.length
    }
    ;
    this.splitGraphemes = function(c) {
        for (var e = [], g = 0, k; (k = this.nextBreak(c, g)) < c.length; )
            e.push(c.slice(g, k)),
            g = k;
        g < c.length && e.push(c.slice(g));
        return e
    }
    ;
    this.iterateGraphemes = function(c) {
        var e = 0
          , g = {
            next: function() {
                var k;
                if ((k = this.nextBreak(c, e)) < c.length) {
                    var l = c.slice(e, k);
                    e = k;
                    return {
                        value: l,
                        done: !1
                    }
                }
                return e < c.length ? (l = c.slice(e),
                e = c.length,
                {
                    value: l,
                    done: !1
                }) : {
                    value: void 0,
                    done: !0
                }
            }
            .bind(this)
        };
        "undefined" !== typeof Symbol && Symbol.iterator && (g[Symbol.iterator] = function() {
            return g
        }
        );
        return g
    }
    ;
    this.countGraphemes = function(c) {
        for (var e = 0, g = 0, k; (k = this.nextBreak(c, g)) < c.length; )
            g = k,
            e++;
        g < c.length && e++;
        return e
    }
    ;
    return this
}
;
"use strict";
function lineInt(a, b, d) {
    var c = [0, 0];
    var e = a[1][1] - a[0][1];
    var g = a[0][0] - a[1][0];
    a = e * a[0][0] + g * a[0][1];
    var k = b[1][1] - b[0][1];
    var l = b[0][0] - b[1][0];
    b = k * b[0][0] + l * b[0][1];
    var n = e * l - k * g;
    scalar_eq(n, 0, d || 0) || (c[0] = (l * a - g * b) / n,
    c[1] = (e * b - k * a) / n);
    return c
}
function lineSegmentsIntersect(a, b, d, c) {
    var e = b[0] - a[0];
    b = b[1] - a[1];
    var g = c[0] - d[0]
      , k = c[1] - d[1];
    if (0 === g * b - k * e)
        return !1;
    c = (e * (d[1] - a[1]) + b * (a[0] - d[0])) / (g * b - k * e);
    a = (g * (a[1] - d[1]) + k * (d[0] - a[0])) / (k * e - g * b);
    return 0 <= c && 1 >= c && 0 <= a && 1 >= a
}
function triangleArea(a, b, d) {
    return (b[0] - a[0]) * (d[1] - a[1]) - (d[0] - a[0]) * (b[1] - a[1])
}
function isLeft(a, b, d) {
    return 0 < triangleArea(a, b, d)
}
function isLeftOn(a, b, d) {
    return 0 <= triangleArea(a, b, d)
}
function isRight(a, b, d) {
    return 0 > triangleArea(a, b, d)
}
function isRightOn(a, b, d) {
    return 0 >= triangleArea(a, b, d)
}
var tmpPoint1$$module$str$c3runtime = []
  , tmpPoint2$$module$str$c3runtime = [];
function collinear(a, b, d, c) {
    if (c) {
        var e = tmpPoint1$$module$str$c3runtime
          , g = tmpPoint2$$module$str$c3runtime;
        e[0] = b[0] - a[0];
        e[1] = b[1] - a[1];
        g[0] = d[0] - b[0];
        g[1] = d[1] - b[1];
        return Math.acos((e[0] * g[0] + e[1] * g[1]) / (Math.sqrt(e[0] * e[0] + e[1] * e[1]) * Math.sqrt(g[0] * g[0] + g[1] * g[1]))) < c
    }
    return 0 === triangleArea(a, b, d)
}
function sqdist(a, b) {
    var d = b[0] - a[0];
    a = b[1] - a[1];
    return d * d + a * a
}
function polygonAt(a, b) {
    var d = a.length;
    return a[0 > b ? b % d + d : b % d]
}
function polygonClear(a) {
    a.length = 0
}
function polygonAppend(a, b, d, c) {
    for (; d < c; d++)
        a.push(b[d])
}
function polygonReverse(a) {
    for (var b = [], d = a.length, c = 0; c !== d; c++)
        b.push(a.pop());
    for (c = 0; c !== d; c++)
        a[c] = b[c]
}
function polygonIsReflex(a, b) {
    return isRight(polygonAt(a, b - 1), polygonAt(a, b), polygonAt(a, b + 1))
}
var tmpLine1$$module$str$c3runtime = []
  , tmpLine2$$module$str$c3runtime = [];
function polygonCanSee(a, b, d) {
    var c = tmpLine1$$module$str$c3runtime
      , e = tmpLine2$$module$str$c3runtime;
    if (isLeftOn(polygonAt(a, b + 1), polygonAt(a, b), polygonAt(a, d)) && isRightOn(polygonAt(a, b - 1), polygonAt(a, b), polygonAt(a, d)))
        return !1;
    var g = sqdist(polygonAt(a, b), polygonAt(a, d));
    for (var k = 0; k !== a.length; ++k)
        if ((k + 1) % a.length !== b && k !== b && isLeftOn(polygonAt(a, b), polygonAt(a, d), polygonAt(a, k + 1)) && isRightOn(polygonAt(a, b), polygonAt(a, d), polygonAt(a, k))) {
            c[0] = polygonAt(a, b);
            c[1] = polygonAt(a, d);
            e[0] = polygonAt(a, k);
            e[1] = polygonAt(a, k + 1);
            var l = lineInt(c, e);
            if (sqdist(polygonAt(a, b), l) < g)
                return !1
        }
    return !0
}
function polygonCanSee2(a, b, d) {
    for (var c = 0; c !== a.length; ++c)
        if (c !== b && c !== d && (c + 1) % a.length !== b && (c + 1) % a.length !== d && lineSegmentsIntersect(polygonAt(a, b), polygonAt(a, d), polygonAt(a, c), polygonAt(a, c + 1)))
            return !1;
    return !0
}
function polygonCopy(a, b, d, c) {
    c = c || [];
    polygonClear(c);
    if (b < d)
        for (var e = b; e <= d; e++)
            c.push(a[e]);
    else {
        for (e = 0; e <= d; e++)
            c.push(a[e]);
        for (e = b; e < a.length; e++)
            c.push(a[e])
    }
    return c
}
function polygonGetCutEdges(a) {
    for (var b = [], d, c, e = [], g = Number.MAX_VALUE, k = 0; k < a.length; ++k)
        if (polygonIsReflex(a, k))
            for (var l = 0; l < a.length; ++l)
                if (polygonCanSee(a, k, l)) {
                    d = polygonGetCutEdges(polygonCopy(a, k, l, e));
                    c = polygonGetCutEdges(polygonCopy(a, l, k, e));
                    for (var n = 0; n < c.length; n++)
                        d.push(c[n]);
                    d.length < g && (b = d,
                    g = d.length,
                    b.push([polygonAt(a, k), polygonAt(a, l)]))
                }
    return b
}
function polygonSlice(a, b) {
    if (0 === b.length)
        return [a];
    if (b instanceof Array && b.length && b[0]instanceof Array && 2 === b[0].length && b[0][0]instanceof Array) {
        a = [a];
        for (var d = 0; d < b.length; d++)
            for (var c = b[d], e = 0; e < a.length; e++) {
                var g = polygonSlice(a[e], c);
                if (g) {
                    a.splice(e, 1);
                    a.push(g[0], g[1]);
                    break
                }
            }
        return a
    }
    c = b;
    d = a.indexOf(c[0]);
    e = a.indexOf(c[1]);
    return -1 !== d && -1 !== e ? [polygonCopy(a, d, e), polygonCopy(a, e, d)] : !1
}
function getIntersectionPoint(a, b, d, c, e) {
    var g = b[1] - a[1];
    b = a[0] - b[0];
    a = g * a[0] + b * a[1];
    var k = c[1] - d[1];
    c = d[0] - c[0];
    d = k * d[0] + c * d[1];
    var l = g * c - k * b;
    return scalar_eq(l, 0, e || 0) ? [0, 0] : [(c * a - b * d) / l, (g * d - k * a) / l]
}
function polygonQuickDecomp(a, b, d, c, e, g, k) {
    g = g || 100;
    k = k || 0;
    e = e || 25;
    b = "undefined" !== typeof b ? b : [];
    d = d || [];
    c = c || [];
    var l = [0, 0], n = [0, 0], p = [0, 0], t, w = 0, z = 0, B = 0, C = [], E = [];
    if (3 > a.length)
        return b;
    k++;
    if (k > g)
        return console.warn("quickDecomp: max level (" + g + ") reached."),
        b;
    for (var F = 0; F < a.length; ++F)
        if (polygonIsReflex(a, F)) {
            d.push(a[F]);
            var J = t = Number.MAX_VALUE;
            for (var K = 0; K < a.length; ++K) {
                if (isLeft(polygonAt(a, F - 1), polygonAt(a, F), polygonAt(a, K)) && isRightOn(polygonAt(a, F - 1), polygonAt(a, F), polygonAt(a, K - 1)) && (p = getIntersectionPoint(polygonAt(a, F - 1), polygonAt(a, F), polygonAt(a, K), polygonAt(a, K - 1)),
                isRight(polygonAt(a, F + 1), polygonAt(a, F), p))) {
                    var M = sqdist(a[F], p);
                    M < t && (t = M,
                    n = p,
                    z = K)
                }
                isLeft(polygonAt(a, F + 1), polygonAt(a, F), polygonAt(a, K + 1)) && isRightOn(polygonAt(a, F + 1), polygonAt(a, F), polygonAt(a, K)) && (p = getIntersectionPoint(polygonAt(a, F + 1), polygonAt(a, F), polygonAt(a, K), polygonAt(a, K + 1)),
                isLeft(polygonAt(a, F - 1), polygonAt(a, F), p) && (M = sqdist(a[F], p),
                M < J && (J = M,
                l = p,
                w = K)))
            }
            if (z === (w + 1) % a.length)
                p[0] = (n[0] + l[0]) / 2,
                p[1] = (n[1] + l[1]) / 2,
                c.push(p),
                F < w ? (polygonAppend(C, a, F, w + 1),
                C.push(p),
                E.push(p),
                0 !== z && polygonAppend(E, a, z, a.length),
                polygonAppend(E, a, 0, F + 1)) : (0 !== F && polygonAppend(C, a, F, a.length),
                polygonAppend(C, a, 0, w + 1),
                C.push(p),
                E.push(p),
                polygonAppend(E, a, z, F + 1));
            else {
                z > w && (w += a.length);
                l = Number.MAX_VALUE;
                if (w < z)
                    return b;
                for (K = z; K <= w; ++K)
                    isLeftOn(polygonAt(a, F - 1), polygonAt(a, F), polygonAt(a, K)) && isRightOn(polygonAt(a, F + 1), polygonAt(a, F), polygonAt(a, K)) && (M = sqdist(polygonAt(a, F), polygonAt(a, K)),
                    M < l && polygonCanSee2(a, F, K) && (l = M,
                    B = K % a.length));
                F < B ? (polygonAppend(C, a, F, B + 1),
                0 !== B && polygonAppend(E, a, B, a.length),
                polygonAppend(E, a, 0, F + 1)) : (0 !== F && polygonAppend(C, a, F, a.length),
                polygonAppend(C, a, 0, B + 1),
                polygonAppend(E, a, B, F + 1))
            }
            C.length < E.length ? (polygonQuickDecomp(C, b, d, c, e, g, k),
            polygonQuickDecomp(E, b, d, c, e, g, k)) : (polygonQuickDecomp(E, b, d, c, e, g, k),
            polygonQuickDecomp(C, b, d, c, e, g, k));
            return b
        }
    b.push(a);
    return b
}
function scalar_eq(a, b, d) {
    return Math.abs(a - b) <= (d || 0)
}
function points_eq(a, b, d) {
    return scalar_eq(a[0], b[0], d) && scalar_eq(a[1], b[1], d)
}
self.polyDecomp = {
    decomp: function(a) {
        var b = polygonGetCutEdges(a);
        return 0 < b.length ? polygonSlice(a, b) : [a]
    },
    quickDecomp: polygonQuickDecomp,
    isSimple: function(a) {
        var b;
        for (b = 0; b < a.length - 1; b++)
            for (var d = 0; d < b - 1; d++)
                if (lineSegmentsIntersect(a[b], a[b + 1], a[d], a[d + 1]))
                    return !1;
        for (b = 1; b < a.length - 2; b++)
            if (lineSegmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1]))
                return !1;
        return !0
    },
    removeCollinearPoints: function(a, b) {
        for (var d = 0, c = a.length - 1; 3 < a.length && 0 <= c; --c)
            collinear(polygonAt(a, c - 1), polygonAt(a, c), polygonAt(a, c + 1), b) && (a.splice(c % a.length, 1),
            d++);
        return d
    },
    removeDuplicatePoints: function(a, b) {
        for (var d = a.length - 1; 1 <= d; --d)
            for (var c = a[d], e = d - 1; 0 <= e; --e)
                points_eq(c, a[e], b) && a.splice(d, 1)
    },
    makeCCW: function(a) {
        for (var b = 0, d = 1; d < a.length; ++d)
            if (a[d][1] < a[b][1] || a[d][1] === a[b][1] && a[d][0] > a[b][0])
                b = d;
        if (isLeft(polygonAt(a, b - 1), polygonAt(a, b), polygonAt(a, b + 1)))
            return !1;
        polygonReverse(a);
        return !0
    }
};
"use strict";
let isReady = !1
  , hasAppStarted = !1
  , buildMode = "dev";
const C3$jscomp$1 = self.C3 = class {
    constructor() {
        throw TypeError("static class can't be instantiated");
    }
    static SetReady() {
        isReady = !0
    }
    static IsReady() {
        return isReady
    }
    static SetAppStarted() {
        hasAppStarted = !0
    }
    static HasAppStarted() {
        return hasAppStarted
    }
    static SetBuildMode(a) {
        buildMode = a
    }
    static GetBuildMode() {
        return buildMode
    }
    static IsReleaseBuild() {
        return "final" === buildMode
    }
}
;
C3$jscomp$1.isDebug = !1;
C3$jscomp$1.isDebugDefend = !1;
C3$jscomp$1.hardwareConcurrency = navigator.hardwareConcurrency || 2;
self.C3X = {};
"use strict";
const C3$jscomp$3 = self.C3;
C3$jscomp$3.QueryParser = class {
    constructor(a) {
        this._queryString = a;
        this._parameters = new Map;
        this._Parse()
    }
    _Parse() {
        var a = this._queryString;
        if (a.startsWith("?") || a.startsWith("#"))
            a = a.substr(1);
        a = a.split("&");
        for (const b of a)
            this._ParseParameter(b)
    }
    _ParseParameter(a) {
        if (a)
            if (a.includes("=")) {
                var b = a.indexOf("=")
                  , d = decodeURIComponent(a.substring(0, b));
                a = decodeURIComponent(a.substring(b + 1));
                this._parameters.set(d, a)
            } else
                this._parameters.set(a, null)
    }
    LogAll() {
        for (const a of this._parameters)
            console.log("[QueryParser] Parameter '" + a[0] + "' = " + (null === a[1] ? "null" : "'" + a[1] + "'"))
    }
    Has(a) {
        return this._parameters.has(a)
    }
    Get(a) {
        a = this._parameters.get(a);
        return "undefined" === typeof a ? null : a
    }
    ClearHash() {
        history.replaceState("", document.title, location.pathname + location.search)
    }
    Reparse(a) {
        this._queryString = a;
        this._parameters.clear();
        this._Parse()
    }
}
;
C3$jscomp$3.QueryString = new C3$jscomp$3.QueryParser(location.search);
C3$jscomp$3.LocationHashString = new C3$jscomp$3.QueryParser(location.hash);
C3$jscomp$3.QueryString.Has("perf") && (C3$jscomp$3.isPerformanceProfiling = !0);
"dev" !== C3$jscomp$3.QueryString.Get("mode") && C3$jscomp$3.SetBuildMode("final");
"use strict";
const C3$jscomp$4 = self.C3;
C3$jscomp$4.Platform = {
    OS: "(unknown)",
    OSVersion: "(unknown)",
    Browser: "(unknown)",
    BrowserVersion: "(unknown)",
    BrowserVersionNumber: NaN,
    BrowserEngine: "(unknown)",
    Context: "browser",
    IsDesktop: !0,
    IsMobile: !1,
    IsAppleOS: !1,
    IsIpadOS: !1,
    GetDetailedInfo: async()=>{}
};
const windowsNTVerMap = new Map([[5, "2000"], [5.1, "XP"], [5.2, "XP"], [6, "Vista"], [6.1, "7"], [6.2, "8"], [6.3, "8.1"], [10, "10"]]);
function GetWindowsNTVersionName(a) {
    const b = parseFloat(a)
      , d = windowsNTVerMap.get(b);
    return d ? d : 13 <= b ? "11" : "NT " + a
}
const uaStr = navigator.userAgent
  , uaData = navigator.userAgentData;
if (uaData && 0 < uaData.brands.length) {
    C3$jscomp$4.Platform.OS = uaData.platform;
    C3$jscomp$4.Platform.IsMobile = uaData.mobile;
    C3$jscomp$4.Platform.IsDesktop = !C3$jscomp$4.Platform.IsMobile;
    const a = new Map([["Google Chrome", "Chrome"], ["Microsoft Edge", "Edge"], ["Opera", "Opera"], ["Opera GX", "Opera GX"], ["Mozilla Firefox", "Firefox"], ["Apple Safari", "Safari"], ["NW.js", "NW.js"]])
      , b = new Map([["Chromium", "Chromium"], ["Gecko", "Gecko"], ["WebKit", "WebKit"]]);
    function d(e) {
        let g = ""
          , k = ""
          , l = ""
          , n = "";
        for (const p of e)
            e = a.get(p.brand),
            !g && e && (g = e,
            k = p.version),
            e = b.get(p.brand),
            !l && e && (l = e,
            n = p.version);
        g || "Chromium" !== l || (C3$jscomp$4.Platform.Browser = "Chromium",
        C3$jscomp$4.Platform.BrowserVersion = n);
        C3$jscomp$4.Platform.Browser = g || "(unknown)";
        C3$jscomp$4.Platform.BrowserVersion = k || "(unknown)";
        C3$jscomp$4.Platform.BrowserEngine = l || "(unknown)"
    }
    d(uaData.brands);
    let c = !1;
    C3$jscomp$4.Platform.GetDetailedInfo = async()=>{
        if (!c)
            try {
                const e = await navigator.userAgentData.getHighEntropyValues(["platformVersion", "fullVersionList"]);
                d(e.fullVersionList);
                C3$jscomp$4.Platform.OSVersion = "Windows" === C3$jscomp$4.Platform.OS ? GetWindowsNTVersionName(e.platformVersion) : e.platformVersion;
                c = !0
            } catch (e) {
                console.warn("Failed to get detailed user agent information: ", e)
            }
    }
} else {
    function a(p, t) {
        p = Array.isArray(p) ? p : [p];
        for (const w of p)
            if (p = w.exec(uaStr)) {
                t(p);
                break
            }
    }
    a(/windows\s+nt\s+([\d\.]+)/i, p=>{
        C3$jscomp$4.Platform.OS = "Windows";
        C3$jscomp$4.Platform.OSVersion = GetWindowsNTVersionName(p[1])
    }
    );
    a(/mac\s+os\s+x\s+([\d\._]+)/i, p=>{
        C3$jscomp$4.Platform.OS = "macOS";
        C3$jscomp$4.Platform.OSVersion = p[1].replace(/_/g, ".")
    }
    );
    a(/CrOS/, ()=>{
        C3$jscomp$4.Platform.OS = "Chrome OS"
    }
    );
    a(/linux|openbsd|freebsd|netbsd/i, ()=>{
        C3$jscomp$4.Platform.OS = "Linux"
    }
    );
    a(/android/i, ()=>{
        C3$jscomp$4.Platform.OS = "Android"
    }
    );
    a(/android\s+([\d\.]+)/i, p=>{
        C3$jscomp$4.Platform.OS = "Android";
        C3$jscomp$4.Platform.OSVersion = p[1]
    }
    );
    "(unknown)" === C3$jscomp$4.Platform.OS && (a(/(iphone|ipod|ipad)/i, p=>{
        C3$jscomp$4.Platform.OS = "iOS"
    }
    ),
    a([/iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i], p=>{
        C3$jscomp$4.Platform.OS = "iOS";
        C3$jscomp$4.Platform.OSVersion = p[1].replace(/_/g, ".")
    }
    ));
    const b = /chrome\//i.test(uaStr)
      , d = /chromium\//i.test(uaStr)
      , c = /edg\//i.test(uaStr)
      , e = /OPR\//.test(uaStr)
      , g = /nwjs/i.test(uaStr)
      , k = /safari\//i.test(uaStr)
      , l = /webkit/i.test(uaStr);
    c || e || a(/chrome\/([\d\.]+)/i, p=>{
        C3$jscomp$4.Platform.Browser = "Chrome";
        C3$jscomp$4.Platform.BrowserVersion = p[1];
        C3$jscomp$4.Platform.BrowserEngine = "Chromium"
    }
    );
    a(/edg\/([\d\.]+)/i, p=>{
        C3$jscomp$4.Platform.Browser = "Edge";
        C3$jscomp$4.Platform.BrowserVersion = p[1];
        C3$jscomp$4.Platform.BrowserEngine = "Chromium"
    }
    );
    a(/OPR\/([\d\.]+)/, p=>{
        C3$jscomp$4.Platform.Browser = "Opera";
        C3$jscomp$4.Platform.BrowserVersion = p[1];
        C3$jscomp$4.Platform.BrowserEngine = "Chromium"
    }
    );
    a(/chromium\/([\d\.]+)/i, p=>{
        C3$jscomp$4.Platform.Browser = "Chromium";
        C3$jscomp$4.Platform.BrowserVersion = p[1];
        C3$jscomp$4.Platform.BrowserEngine = "Chromium"
    }
    );
    a(/nwjs\/[0-9.]+/i, p=>{
        C3$jscomp$4.Platform.Browser = "NW.js";
        C3$jscomp$4.Platform.BrowserVersion = p[1];
        C3$jscomp$4.Platform.BrowserEngine = "Chromium";
        C3$jscomp$4.Platform.Context = "nwjs"
    }
    );
    a(/firefox\/([\d\.]+)/i, p=>{
        C3$jscomp$4.Platform.Browser = "Firefox";
        C3$jscomp$4.Platform.BrowserVersion = p[1];
        C3$jscomp$4.Platform.BrowserEngine = "Gecko"
    }
    );
    !k || b || d || c || e || g || (C3$jscomp$4.Platform.Browser = "Safari",
    C3$jscomp$4.Platform.BrowserEngine = "WebKit",
    a(/version\/([\d\.]+)/i, p=>{
        C3$jscomp$4.Platform.BrowserVersion = p[1]
    }
    ),
    a(/crios\/([\d\.]+)/i, p=>{
        C3$jscomp$4.Platform.Browser = "Chrome for iOS";
        C3$jscomp$4.Platform.BrowserVersion = p[1]
    }
    ),
    a(/fxios\/([\d\.]+)/i, p=>{
        C3$jscomp$4.Platform.Browser = "Firefox for iOS";
        C3$jscomp$4.Platform.BrowserVersion = p[1]
    }
    ),
    a(/edgios\/([\d\.]+)/i, p=>{
        C3$jscomp$4.Platform.Browser = "Edge for iOS";
        C3$jscomp$4.Platform.BrowserVersion = p[1]
    }
    ));
    "(unknown)" === C3$jscomp$4.Platform.BrowserEngine && l && (C3$jscomp$4.Platform.BrowserEngine = "WebKit");
    "Android" === C3$jscomp$4.Platform.OS && "Safari" === C3$jscomp$4.Platform.Browser && (C3$jscomp$4.Platform.Browser = "Stock");
    const n = (new Set(["Windows", "macOS", "Linux", "Chrome OS"])).has(C3$jscomp$4.Platform.OS) || "nwjs" === C3$jscomp$4.Platform.Context;
    C3$jscomp$4.Platform.IsDesktop = n;
    C3$jscomp$4.Platform.IsMobile = !n
}
"Chrome" === C3$jscomp$4.Platform.Browser && "browser" === C3$jscomp$4.Platform.Context && /wv\)/.test(uaStr) && (C3$jscomp$4.Platform.Context = "webview");
"nwjs" !== C3$jscomp$4.Platform.Context && "undefined" !== typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone) && (C3$jscomp$4.Platform.Context = "webapp");
C3$jscomp$4.Platform.BrowserVersionNumber = parseFloat(C3$jscomp$4.Platform.BrowserVersion);
"macOS" === C3$jscomp$4.Platform.OS && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints && (C3$jscomp$4.Platform.OS = "iOS",
C3$jscomp$4.Platform.OSVersion = C3$jscomp$4.Platform.BrowserVersion,
C3$jscomp$4.Platform.IsDesktop = !1,
C3$jscomp$4.Platform.IsMobile = !0,
C3$jscomp$4.Platform.IsIpadOS = !0);
C3$jscomp$4.Platform.IsAppleOS = "macOS" === C3$jscomp$4.Platform.OS || "iOS" === C3$jscomp$4.Platform.OS;
"use strict";
const DATABASE_PROMISE_MAP = new Map
  , SUPPORTS_GETALL = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAll
  , SUPPORTS_GETALLKEYS = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAllKeys;
function asyncifyRequest(a) {
    return new Promise((b,d)=>{
        a.onsuccess = ()=>b(a.result);
        a.onerror = ()=>d(a.error)
    }
    )
}
function asyncifyTransaction(a) {
    return new Promise((b,d)=>{
        a.oncomplete = ()=>b();
        a.onerror = ()=>d(a.error);
        a.onabort = ()=>d(a.error)
    }
    )
}
function openReadOnlyTransaction(a, b) {
    return openTransaction(a, b)
}
function openWriteTransaction(a, b) {
    return openTransaction(a, b, !0)
}
async function openTransaction(a, b, d=!1, c=!0) {
    const e = await lazyOpenDatabase(a);
    try {
        const g = e.transaction(["keyvaluepairs"], d ? "readwrite" : "readonly");
        return b(g)
    } catch (g) {
        if (c && "InvalidStateError" === g.name)
            return DATABASE_PROMISE_MAP.delete(a),
            openTransaction(a, b, d, !1);
        throw g;
    }
}
function lazyOpenDatabase(a) {
    RequireString(a);
    let b = DATABASE_PROMISE_MAP.get(a);
    b instanceof Promise || (b = openDatabase$jscomp$1(a),
    DATABASE_PROMISE_MAP.set(a, b),
    b.catch(d=>DATABASE_PROMISE_MAP.delete(a)));
    return b
}
async function openDatabase$jscomp$1(a) {
    RequireString(a);
    const b = indexedDB.open(a, 2);
    b.addEventListener("upgradeneeded", d=>{
        try {
            d.target.result.createObjectStore("keyvaluepairs")
        } catch (c) {
            console.error(`Failed to create objectstore for database ${a}`, c)
        }
    }
    );
    return asyncifyRequest(b)
}
function RequireString(a) {
    if ("string" !== typeof a)
        throw new TypeError("expected string");
}
function getEntriesFromCursor(a, b) {
    const d = a.objectStore("keyvaluepairs").openCursor();
    return new Promise(c=>{
        const e = [];
        d.onsuccess = g=>{
            if (g = g.target.result) {
                switch (b) {
                case "entries":
                    e.push([g.key, g.value]);
                    break;
                case "keys":
                    e.push(g.key);
                    break;
                case "values":
                    e.push(g.value)
                }
                g.continue()
            } else
                c(e)
        }
    }
    )
}
class KVStorageContainer {
    constructor(a) {
        RequireString(a);
        this.name = a
    }
    async ready() {
        await lazyOpenDatabase(this.name)
    }
    set(a, b) {
        RequireString(a);
        return openWriteTransaction(this.name, async d=>{
            var c = d.objectStore("keyvaluepairs").put(b, a);
            c = asyncifyRequest(c);
            d = asyncifyTransaction(d);
            await Promise.all([d, c])
        }
        )
    }
    get(a) {
        RequireString(a);
        return openReadOnlyTransaction(this.name, async b=>{
            var d = b.objectStore("keyvaluepairs").get(a);
            d = asyncifyRequest(d);
            b = asyncifyTransaction(b);
            [,b] = await Promise.all([b, d]);
            return b
        }
        )
    }
    delete(a) {
        RequireString(a);
        return openWriteTransaction(this.name, async b=>{
            var d = b.objectStore("keyvaluepairs").delete(a);
            d = asyncifyRequest(d);
            b = asyncifyTransaction(b);
            await Promise.all([b, d])
        }
        )
    }
    clear() {
        return openWriteTransaction(this.name, async a=>{
            var b = a.objectStore("keyvaluepairs").clear();
            b = asyncifyRequest(b);
            a = asyncifyTransaction(a);
            await Promise.all([a, b])
        }
        )
    }
    keys() {
        return openReadOnlyTransaction(this.name, async a=>{
            if (SUPPORTS_GETALLKEYS) {
                var b = a.objectStore("keyvaluepairs").getAllKeys();
                b = asyncifyRequest(b)
            } else
                b = getEntriesFromCursor(a, "keys");
            a = asyncifyTransaction(a);
            [,a] = await Promise.all([a, b]);
            return a
        }
        )
    }
    values() {
        return openReadOnlyTransaction(this.name, async a=>{
            if (SUPPORTS_GETALL) {
                var b = a.objectStore("keyvaluepairs").getAll();
                b = asyncifyRequest(b)
            } else
                b = getEntriesFromCursor(a, "values");
            a = asyncifyTransaction(a);
            [,a] = await Promise.all([a, b]);
            return a
        }
        )
    }
    entries() {
        return openReadOnlyTransaction(this.name, async a=>{
            var b = getEntriesFromCursor(a, "entries");
            a = asyncifyTransaction(a);
            [,b] = await Promise.all([a, b]);
            return b
        }
        )
    }
}
self.KVStorageContainer = KVStorageContainer;
"use strict";
const KVStorageContainer$jscomp$1 = self.KVStorageContainer
  , CRITICAL_ERRORS = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i]
  , memoryStorage = new WeakMap;
let isInMemory = !1;
"undefined" === typeof indexedDB && (isInMemory = !0,
console.warn("Unable to use local storage because indexedDB is not defined"));
function NOT_IMPLEMENTED(a) {
    throw Error(`"${a}" is not implemented`);
}
function DISALLOW_CALLBACK(a) {
    if ("function" === typeof a)
        throw Error("localforage callback API is not implemented; please use the promise API instead");
}
function StructuredClone(a) {
    return "object" === typeof a ? new Promise(b=>{
        const {port1: d, port2: c} = new MessageChannel;
        c.onmessage = e=>b(e.data);
        d.postMessage(a)
    }
    ) : Promise.resolve(a)
}
class ForageAdaptor {
    constructor(a) {
        this._inst = a;
        memoryStorage.set(this, new Map)
    }
    _MaybeSwitchToMemoryFallback(a) {
        if (!isInMemory)
            for (const b of CRITICAL_ERRORS)
                if (a && b.test(a.message)) {
                    console.error("Unable to use local storage, reverting to in-memory store: ", a, a.message);
                    isInMemory = !0;
                    break
                }
    }
    async _getItemFallback(a) {
        a = memoryStorage.get(this).get(a);
        a = await StructuredClone(a);
        return "undefined" === typeof a ? null : a
    }
    async _setItemFallback(a, b) {
        b = await StructuredClone(b);
        memoryStorage.get(this).set(a, b)
    }
    _removeItemFallback(a) {
        memoryStorage.get(this).delete(a)
    }
    _clearFallback() {
        memoryStorage.get(this).clear()
    }
    _keysFallback() {
        return Array.from(memoryStorage.get(this).keys())
    }
    IsUsingFallback() {
        return isInMemory
    }
    async getItem(a, b) {
        DISALLOW_CALLBACK(b);
        if (isInMemory)
            return await this._getItemFallback(a);
        let d;
        try {
            d = await this._inst.get(a)
        } catch (c) {
            this._MaybeSwitchToMemoryFallback(c);
            if (isInMemory)
                return await this._getItemFallback(a);
            console.error(`Error reading '${a}' from storage, returning null: `, c);
            return null
        }
        return "undefined" === typeof d ? null : d
    }
    async setItem(a, b, d) {
        DISALLOW_CALLBACK(d);
        "undefined" === typeof b && (b = null);
        if (isInMemory)
            await this._setItemFallback(a, b);
        else
            try {
                await this._inst.set(a, b)
            } catch (c) {
                if (this._MaybeSwitchToMemoryFallback(c),
                isInMemory)
                    await this._setItemFallback(a, b);
                else
                    throw c;
            }
    }
    async removeItem(a, b) {
        DISALLOW_CALLBACK(b);
        if (isInMemory)
            this._removeItemFallback(a);
        else
            try {
                await this._inst.delete(a)
            } catch (d) {
                this._MaybeSwitchToMemoryFallback(d),
                isInMemory ? this._removeItemFallback(a) : console.error(`Error removing '${a}' from storage: `, d)
            }
    }
    async clear(a) {
        DISALLOW_CALLBACK(a);
        if (isInMemory)
            this._clearFallback();
        else
            try {
                await this._inst.clear()
            } catch (b) {
                this._MaybeSwitchToMemoryFallback(b),
                isInMemory ? this._clearFallback() : console.error("Error clearing storage: ", b)
            }
    }
    async keys(a) {
        DISALLOW_CALLBACK(a);
        if (isInMemory)
            return this._keysFallback();
        a = [];
        try {
            a = await this._inst.keys()
        } catch (b) {
            this._MaybeSwitchToMemoryFallback(b);
            if (isInMemory)
                return this._keysFallback();
            console.error("Error getting storage keys: ", b)
        }
        return a
    }
    ready(a) {
        DISALLOW_CALLBACK(a);
        return isInMemory ? Promise.resolve(!0) : this._inst.ready()
    }
    createInstance(a) {
        if ("object" !== typeof a)
            throw new TypeError("invalid options object");
        a = a.name;
        if ("string" !== typeof a)
            throw new TypeError("invalid store name");
        a = new KVStorageContainer$jscomp$1(a);
        return new ForageAdaptor(a)
    }
    length(a) {
        NOT_IMPLEMENTED("localforage.length()")
    }
    key(a, b) {
        NOT_IMPLEMENTED("localforage.key()")
    }
    iterate(a, b) {
        NOT_IMPLEMENTED("localforage.iterate()")
    }
    setDriver(a) {
        NOT_IMPLEMENTED("localforage.setDriver()")
    }
    config(a) {
        NOT_IMPLEMENTED("localforage.config()")
    }
    defineDriver(a) {
        NOT_IMPLEMENTED("localforage.defineDriver()")
    }
    driver() {
        NOT_IMPLEMENTED("localforage.driver()")
    }
    supports(a) {
        NOT_IMPLEMENTED("localforage.supports()")
    }
    dropInstance() {
        NOT_IMPLEMENTED("localforage.dropInstance()")
    }
    disableMemoryMode() {
        isInMemory = !1
    }
}
self.localforage = new ForageAdaptor(new KVStorageContainer$jscomp$1("localforage"));
"use strict";
const C3$jscomp$5 = self.C3;
C3$jscomp$5.Supports = {};
C3$jscomp$5.Supports.WebAnimations = (()=>{
    try {
        if ("Safari" === C3$jscomp$5.Platform.Browser || "undefined" === typeof document)
            return !1;
        const a = document.createElement("div");
        return "undefined" === typeof a.animate ? !1 : "undefined" !== typeof a.animate([{
            opacity: "0"
        }, {
            opacity: "1"
        }], 1E3).reverse
    } catch (a) {
        return !1
    }
}
)();
C3$jscomp$5.Supports.DialogElement = "undefined" !== typeof HTMLDialogElement;
C3$jscomp$5.Supports.RequestIdleCallback = !!self.requestIdleCallback;
C3$jscomp$5.Supports.ImageBitmap = !!self.createImageBitmap;
C3$jscomp$5.Supports.ImageBitmapOptions = !1;
C3$jscomp$5.Supports.ImageBitmapOptionsResize = !1;
if (C3$jscomp$5.Supports.ImageBitmap) {
    try {
        self.createImageBitmap(new ImageData(32,32), {
            premultiplyAlpha: "none"
        }).then(()=>{
            C3$jscomp$5.Supports.ImageBitmapOptions = !0
        }
        ).catch(()=>{
            C3$jscomp$5.Supports.ImageBitmapOptions = !1
        }
        )
    } catch (a) {
        C3$jscomp$5.Supports.ImageBitmapOptions = !1
    }
    try {
        self.createImageBitmap(new ImageData(32,32), {
            resizeWidth: 10,
            resizeHeight: 10
        }).then(a=>{
            C3$jscomp$5.Supports.ImageBitmapOptionsResize = 10 === a.width && 10 === a.height
        }
        ).catch(()=>{
            C3$jscomp$5.Supports.ImageBitmapOptionsResize = !1
        }
        )
    } catch (a) {
        C3$jscomp$5.Supports.ImageBitmapOptionsResize = !1
    }
}
C3$jscomp$5.Supports.ClipboardReadText = !(!navigator.clipboard || !navigator.clipboard.readText || "Firefox" === C3$jscomp$5.Platform.Browser);
C3$jscomp$5.Supports.PermissionsQuery = !(!navigator.permissions || !navigator.permissions.query);
C3$jscomp$5.Supports.ClipboardPermissionsQuery = !1;
C3$jscomp$5.Supports.PermissionsQuery && navigator.permissions.query({
    name: "clipboard-read"
}).then(()=>{
    C3$jscomp$5.Supports.ClipboardPermissionsQuery = !0
}
).catch(()=>{
    C3$jscomp$5.Supports.ClipboardPermissionsQuery = !1
}
);
C3$jscomp$5.Supports.AsyncClipboardApi = !!(navigator.permissions && navigator.clipboard && self.ClipboardItem);
C3$jscomp$5.Supports.Proxies = "undefined" !== typeof Proxy;
C3$jscomp$5.Supports.DownloadAttribute = (()=>"undefined" === typeof document ? !1 : "undefined" !== typeof document.createElement("a").download)();
C3$jscomp$5.Supports.Fetch = "function" === typeof fetch;
C3$jscomp$5.Supports.PersistentStorage = !!(self.isSecureContext && "Opera" !== C3$jscomp$5.Platform.Browser && navigator.storage && navigator.storage.persist);
C3$jscomp$5.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate);
C3$jscomp$5.Supports.Fullscreen = (()=>{
    if ("undefined" === typeof document || "iOS" === C3$jscomp$5.Platform.OS)
        return !1;
    const a = document.documentElement;
    return !!(a.requestFullscreen || a.msRequestFullscreen || a.mozRequestFullScreen || a.webkitRequestFullscreen)
}
)();
C3$jscomp$5.Supports.ImageDecoder = "undefined" !== typeof self.ImageDecoder;
C3$jscomp$5.Supports.WebCodecs = !!self.VideoEncoder;
C3$jscomp$5.Supports.NativeFileSystemAPI = !!self.showOpenFilePicker;
C3$jscomp$5.Supports.QueryLocalFonts = !!self.queryLocalFonts;
C3$jscomp$5.Supports.UserActivation = !!navigator.userActivation;
C3$jscomp$5.Supports.CanvasToBlobWebP = !1;
(async()=>{
    let a;
    "undefined" === typeof document ? a = new OffscreenCanvas(32,32) : (a = document.createElement("canvas"),
    a.width = 32,
    a.height = 32);
    var b = a.getContext("2d");
    b.fillStyle = "blue";
    b.fillRect(0, 0, 32, 32);
    b = null;
    try {
        a.toBlob ? b = await new Promise(d=>a.toBlob(d, "image/webp", 1)) : a.convertToBlob && (b = await a.convertToBlob({
            type: "image/webp",
            quality: 1
        })),
        C3$jscomp$5.Supports.CanvasToBlobWebP = b && "image/webp" === b.type
    } catch (d) {
        C3$jscomp$5.Supports.CanvasToBlobWebP = !1
    }
}
)();
"use strict";
const C3$jscomp$6 = self.C3;
if (!String.prototype.trimStart) {
    const a = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
    String.prototype.trimStart = function() {
        return this.replace(a, "")
    }
}
if (!String.prototype.trimEnd) {
    const a = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
    String.prototype.trimEnd = function() {
        return this.replace(a, "")
    }
}
String.prototype.replaceAll || (String.prototype.replaceAll = function(a, b) {
    return this.replace(new RegExp(C3$jscomp$6.EscapeRegex(a),"g"), b)
}
);
Array.prototype.values || (Array.prototype.values = function*() {
    for (const a of this)
        yield a
}
);
if (!Array.prototype.flat) {
    function a(b, d) {
        return b.reduce((c,e)=>{
            0 < d && Array.isArray(e) ? Array.prototype.push.apply(c, a(e, d - 1)) : c.push(e);
            return c
        }
        , [])
    }
    Array.prototype.flat = function(b=1) {
        return a(this, b)
    }
}
Array.prototype.at || (Array.prototype.at = function(a) {
    a = Math.trunc(a) || 0;
    0 > a && (a += this.length);
    if (!(0 > a || a >= this.length))
        return this[a]
}
);
String.prototype.at || (String.prototype.at = function(a) {
    a = Math.trunc(a) || 0;
    0 > a && (a += this.length);
    if (!(0 > a || a >= this.length))
        return this[a]
}
);
RegExp.escape || (RegExp.escape = function(a) {
    return String(a).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")
}
);
navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
    return new Promise((a,b)=>navigator.webkitTemporaryStorage.queryUsageAndQuota((d,c)=>a({
        usage: d,
        quota: c
    }), b))
}
);
"undefined" === typeof self.isSecureContext && (self.isSecureContext = "https:" === location.protocol);
"undefined" === typeof self.globalThis && (self.globalThis = self);
"use strict";
const C3$jscomp$7 = self.C3;
function assertFail(a) {
    let b = C3$jscomp$7.GetCallStack();
    console.error("Assertion failure: " + a + "\n\nStack trace:\n" + b)
}
self.assert = function(a, b) {
    a || assertFail(b)
}
;
"use strict";
const C3$jscomp$8 = self.C3
  , C3X = self.C3X;
C3$jscomp$8.IsNumber = function(a) {
    return "number" === typeof a
}
;
C3$jscomp$8.IsFiniteNumber = function(a) {
    return C3$jscomp$8.IsNumber(a) && isFinite(a)
}
;
C3$jscomp$8.RequireNumber = function(a) {
    if (!C3$jscomp$8.IsNumber(a))
        throw new TypeError("expected number");
}
;
C3$jscomp$8.RequireOptionalNumber = function(a) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.RequireNumberInRange = function(a, b, d) {
    if (!C3$jscomp$8.IsNumber(a) || isNaN(a) || b > a || d < a)
        throw new RangeError("number outside of range");
}
;
C3$jscomp$8.RequireAllNumber = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$8.RequireFiniteNumber = function(a) {
    if (!C3$jscomp$8.IsFiniteNumber(a))
        throw new TypeError("expected finite number");
}
;
C3$jscomp$8.RequireOptionalFiniteNumber = function(a) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.RequireAllFiniteNumber = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$8.IsString = function(a) {
    return "string" === typeof a
}
;
C3$jscomp$8.RequireString = function(a) {
    if (!C3$jscomp$8.IsString(a))
        throw new TypeError("expected string");
}
;
C3$jscomp$8.RequireOptionalString = function(a) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.RequireAllString = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$8.IsSimpleObject = function(a) {
    return "object" !== typeof a || null === a ? !1 : (a = Object.getPrototypeOf(a)) ? a.constructor === Object : null === a
}
;
C3$jscomp$8.RequireSimpleObject = function(a) {
    if (!C3$jscomp$8.IsSimpleObject(a))
        throw new TypeError("expected simple object");
}
;
C3$jscomp$8.RequireOptionalSimpleObject = function(a) {
    if (!C3$jscomp$8.IsNullOrUndefined(a) && !C3$jscomp$8.IsSimpleObject(a))
        throw new TypeError("expected simple object");
}
;
C3$jscomp$8.IsObject = function(a) {
    return "object" === typeof a && null !== a && !Array.isArray(a)
}
;
C3$jscomp$8.RequireObject = function(a) {
    if (!C3$jscomp$8.IsObject(a))
        throw new TypeError("expected object");
}
;
C3$jscomp$8.RequireOptionalObject = function(a) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.RequireAllObject = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$8.IsFileLike = function(a) {
    return C3$jscomp$8.WeakIsInstanceOf(a, Blob) && "string" === typeof a.name
}
;
C3$jscomp$8.RequireFileLike = function(a) {
    if (!C3$jscomp$8.IsFileLike(a))
        throw new TypeError("expected file");
}
;
C3$jscomp$8.RequireOptionalFileLike = function(a) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.IsArray = function(a) {
    return Array.isArray(a)
}
;
C3$jscomp$8.RequireArray = function(a) {
    if (!C3$jscomp$8.IsArray(a))
        throw new TypeError("expected array");
}
;
C3$jscomp$8.RequireOptionalArray = function(a) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.RequireAllArray = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$8.Is2DArray = function(a) {
    return C3$jscomp$8.IsArray(a) ? a.length ? C3$jscomp$8.IsArray(a[0]) ? !0 : !1 : !0 : !1
}
;
C3$jscomp$8.Require2DArray = function(a) {
    if (!C3$jscomp$8.Is2DArray(a))
        throw new TypeError("expected 2d array");
    for (let b of a)
        if (!C3$jscomp$8.IsArray(b))
            throw new TypeError("expected 2d array");
}
;
C3$jscomp$8.RequireOptional2DArray = function(a) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.IsFunction = function(a) {
    return "function" === typeof a
}
;
C3$jscomp$8.RequireFunction = function(a, b) {
    if (!C3$jscomp$8.IsFunction(a))
        throw new TypeError("expected function");
    if (!C3$jscomp$8.IsNullOrUndefined(b) && a !== b)
        throw new TypeError("expected same function reference");
}
;
C3$jscomp$8.RequireOptionalFunction = function(a) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.RequireAllFunction = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$8.RequireAnyFunction = function(a, ...b) {
    if (!C3$jscomp$8.IsFunction(a))
        throw new TypeError("expected function");
    if (!b.length)
        throw Error("missing comparison functions");
    for (let d of b)
        if (!C3$jscomp$8.IsNullOrUndefined(d) && a === d)
            return;
    throw new TypeError("expected same function reference");
}
;
C3$jscomp$8.RequireOptionalAllFunction = function(...a) {
    if (!C3$jscomp$8.IsNullOrUndefined(a))
        for (let b of a)
            ;
}
;
C3$jscomp$8.IsInstanceOf = function(a, b) {
    return a instanceof b
}
;
C3$jscomp$8.IsInstanceOfAny = function(a, ...b) {
    for (let d of b)
        if (C3$jscomp$8.IsInstanceOf(a, d))
            return !0;
    return !1
}
;
C3$jscomp$8.RequireInstanceOf = function(a, b) {
    if (!C3$jscomp$8.IsInstanceOf(a, b))
        throw new TypeError("unexpected type");
}
;
C3$jscomp$8.RequireOptionalInstanceOf = function(a, b) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.RequireAllInstanceOf = function(a, ...b) {
    for (let d of b)
        ;
}
;
C3$jscomp$8.RequireAnyInstanceOf = function(a, ...b) {
    if (!C3$jscomp$8.IsInstanceOfAny(a, ...b))
        throw new TypeError("unexpected type");
}
;
C3$jscomp$8.RequireAnyOptionalInstanceOf = function(a, ...b) {
    if (!C3$jscomp$8.IsNullOrUndefined(a) && !C3$jscomp$8.IsInstanceOfAny(a, ...b))
        throw new TypeError("unexpected type");
}
;
C3$jscomp$8.IsArrayOf = function(a, b) {
    for (let d of a)
        if (!C3$jscomp$8.IsInstanceOf(d, b))
            return !1;
    return !0
}
;
C3$jscomp$8.IsArrayOfFiniteNumbers = function(a) {
    for (let b of a)
        if (!C3$jscomp$8.IsFiniteNumber(b))
            return !1;
    return !0
}
;
C3$jscomp$8.RequireArrayOf = function(a, b) {
    for (let d of a)
        ;
}
;
C3$jscomp$8.RequireOptionalArrayOf = function(a, b) {
    if (!C3$jscomp$8.IsNullOrUndefined(a))
        for (let d of a)
            ;
}
;
C3$jscomp$8.RequireArrayOfAny = function(a, ...b) {
    for (let d of a)
        ;
}
;
C3$jscomp$8.RequireOptionalArrayOfAny = function(a, ...b) {
    if (!C3$jscomp$8.IsNullOrUndefined(a))
        for (let d of a)
            ;
}
;
C3$jscomp$8.IsDOMNode = function(a, b) {
    return C3$jscomp$8.IsNullOrUndefined(a) || !C3$jscomp$8.IsString(a.nodeName) ? !1 : !b || C3$jscomp$8.equalsNoCase(a.nodeName, b)
}
;
C3$jscomp$8.RequireDOMNode = function(a, b) {
    if (C3$jscomp$8.IsNullOrUndefined(a) || !C3$jscomp$8.IsString(a.nodeName))
        throw new TypeError("expected DOM node");
    if (b && !C3$jscomp$8.equalsNoCase(a.nodeName, b))
        throw new TypeError(`expected DOM '${b}' node`);
}
;
C3$jscomp$8.RequireOptionalDOMNode = function(a, b) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.IsHTMLElement = function(a, b) {
    return C3$jscomp$8.IsNullOrUndefined(a) || !C3$jscomp$8.IsString(a.tagName) ? !1 : !b || C3$jscomp$8.equalsNoCase(a.tagName, b)
}
;
C3$jscomp$8.RequireHTMLElement = function(a, b) {
    if (C3$jscomp$8.IsNullOrUndefined(a) || !C3$jscomp$8.IsString(a.tagName))
        throw new TypeError("expected HTML element");
    if (b && !C3$jscomp$8.equalsNoCase(a.tagName, b))
        throw new TypeError(`expected HTML '${b}' element`);
}
;
C3$jscomp$8.RequireOptionalHTMLElement = function(a, b) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.IsDrawable = function(a) {
    return C3$jscomp$8.IsHTMLElement(a, "img") || C3$jscomp$8.IsHTMLElement(a, "canvas") || C3$jscomp$8.IsHTMLElement(a, "video") || "undefined" !== typeof OffscreenCanvas && a instanceof OffscreenCanvas || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap
}
;
C3$jscomp$8.RequireDrawable = function(a) {
    if (!C3$jscomp$8.IsDrawable(a))
        throw new TypeError("expected drawable");
}
;
C3$jscomp$8.RequireOptionalDrawable = function(a) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.IsDrawableOrImageData = function(a) {
    return a instanceof ImageData ? !0 : C3$jscomp$8.IsDrawable(a)
}
;
C3$jscomp$8.RequireDrawableOrImageData = function(a) {
    if (!C3$jscomp$8.IsDrawableOrImageData(a))
        throw new TypeError("expected drawable or image data");
}
;
C3$jscomp$8.RequireOptionalDrawableOrImageData = function(a) {
    if (!C3$jscomp$8.IsNullOrUndefined(a) && !C3$jscomp$8.IsDrawableOrImageData(a))
        throw new TypeError("expected drawable or image data");
}
;
C3$jscomp$8.IsStringLike = function(a) {
    return "string" === typeof a || C3$jscomp$8.HtmlString && a instanceof C3$jscomp$8.HtmlString || a instanceof C3$jscomp$8.BBString
}
;
C3$jscomp$8.RequireStringLike = function(a) {
    if (!C3$jscomp$8.IsStringLike(a))
        throw new TypeError("expected string-like");
}
;
C3$jscomp$8.RequireOptionalStringLike = function(a) {
    C3$jscomp$8.IsNullOrUndefined(a)
}
;
C3$jscomp$8.RequireAllStringLike = function(...a) {
    for (let b of a)
        ;
}
;
C3$jscomp$8.RequireOverride = function() {
    throw Error("must be overridden");
}
;
C3$jscomp$8.NotYetImplemented = function() {
    throw Error("not yet implemented");
}
;
C3$jscomp$8.IsDefined = function(a, ...b) {
    if ("undefined" === typeof a)
        return !1;
    for (let d of b) {
        if ("undefined" === typeof a[d])
            return !1;
        a = a[d]
    }
    return !0
}
;
C3$jscomp$8.IsNullOrUndefined = function(a) {
    return "undefined" === typeof a || null === a
}
;
C3$jscomp$8.AreArrayElementsOfSameType = function(a) {
    let b = a[0].constructor;
    for (let d of a)
        if (d.constructor !== b)
            return !1;
    return b
}
;
C3$jscomp$8.AreArrayElementsOfType = function(a, b) {
    for (let d of a)
        if (!(d instanceof b))
            return !1;
    return !0
}
;
const TypedArray$jscomp$1 = Object.getPrototypeOf(Uint8Array);
C3$jscomp$8.IsTypedArray = function(a) {
    return C3$jscomp$8.IsInstanceOf(a, TypedArray$jscomp$1)
}
;
C3$jscomp$8.RequireTypedArray = function(a) {}
;
C3$jscomp$8.WeakRequireTypedArray = function(a) {
    C3$jscomp$8.WeakRequireInstanceOf(a, TypedArray$jscomp$1)
}
;
C3$jscomp$8.WeakRequireAnyInstanceOf = function(a, ...b) {
    if (!C3$jscomp$8.WeakIsAnyInstanceOf(a, ...b))
        throw new TypeError("unexpected type");
}
;
C3$jscomp$8.WeakIsAnyInstanceOf = function(a, ...b) {
    for (const d of b)
        if (C3$jscomp$8.WeakIsInstanceOf(a, d))
            return !0;
    return !1
}
;
C3$jscomp$8.WeakRequireInstanceOf = function(a, b) {
    if (!C3$jscomp$8.WeakIsInstanceOf(a, b))
        throw new TypeError("unexpected type");
}
;
C3$jscomp$8.WeakIsInstanceOf = function(a, b) {
    for (; a = Object.getPrototypeOf(a); )
        if (a.constructor.name === b.name)
            return !0;
    return !1
}
;
C3X.RequireNumber = C3$jscomp$8.RequireNumber;
C3X.RequireOptionalNumber = C3$jscomp$8.RequireOptionalNumber;
C3X.RequireFiniteNumber = C3$jscomp$8.RequireFiniteNumber;
C3X.RequireOptionalFiniteNumber = C3$jscomp$8.RequireOptionalFiniteNumber;
C3X.RequireString = C3$jscomp$8.RequireString;
C3X.RequireOptionalString = C3$jscomp$8.RequireOptionalString;
C3X.RequireObject = C3$jscomp$8.RequireObject;
C3X.RequireOptionalObject = C3$jscomp$8.RequireOptionalObject;
C3X.RequireArray = C3$jscomp$8.RequireArray;
C3X.RequireOptionalArray = C3$jscomp$8.RequireOptionalArray;
C3X.RequireFunction = C3$jscomp$8.RequireFunction;
C3X.RequireOptionalFunction = C3$jscomp$8.RequireOptionalFunction;
C3X.RequireInstanceOf = C3$jscomp$8.RequireInstanceOf;
C3X.RequireOptionalInstanceOf = C3$jscomp$8.RequireOptionalInstanceOf;
C3X.IsNullOrUndefined = C3$jscomp$8.IsNullOrUndefined;
"use strict";
const C3$jscomp$9 = self.C3
  , logRafIds = new Map;
C3$jscomp$9.ColorLog = function(a, b) {
    console.log(`%c ${a}`, `font-weight: bold; color:${b}`)
}
;
C3$jscomp$9.RafLog = function(a, ...b) {
    logRafIds.has(a) || logRafIds.set(a, -1);
    -1 === logRafIds.get(a) && logRafIds.set(a, requestAnimationFrame(()=>{
        console.log(`%c ${a}`, "font-weight: bold", ...b);
        logRafIds.set(a, -1)
    }
    ))
}
;
let measures;
C3$jscomp$9.StartMeasure = function(a) {
    performance.mark(a);
    measures || (measures = new Map);
    measures.has(a) || measures.set(a, {
        current: 0,
        total: 0,
        average: 0,
        calls: 1,
        toString: function() {
            return `${a} :: current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ${this.calls}`
        }
    })
}
;
C3$jscomp$9.EndMeasure = function(a) {
    performance.measure(`measure-${a}`, a);
    const b = performance.getEntriesByName(`measure-${a}`)[0]
      , d = measures.get(a);
    d.current = b.duration;
    d.total += d.current;
    d.average = d.total / d.calls;
    console.log(d.toString());
    d.calls++;
    performance.clearMarks(a);
    performance.clearMeasures(`measure-${a}`)
}
;
C3$jscomp$9.GetCallStack = function() {
    return Error().stack
}
;
C3$jscomp$9.Debugger = function() {
    debugger
}
;
C3$jscomp$9.cast = function(a, b) {
    return a && a instanceof b ? a : null
}
;
C3$jscomp$9.getName = function(a) {
    return "undefined" === typeof a ? "undefined" : null === a ? "null" : "boolean" === typeof a ? "<boolean>" : C3$jscomp$9.IsNumber(a) ? "<number>" : C3$jscomp$9.IsString(a) ? "<string>" : C3$jscomp$9.IsArray(a) ? "<array>" : "symbol" === typeof a ? "<" + a.toString() + ">" : C3$jscomp$9.IsFunction(a) ? a.name && "Function" !== a.name ? a.name : "<anonymous function>" : "object" === typeof a ? a.constructor && a.constructor.name && "Object" !== a.constructor.name ? a.constructor.name : "<anonymous object>" : "<unknown>"
}
;
C3$jscomp$9.getType = function(a) {
    return null === a ? "null" : Array.isArray(a) ? "array" : typeof a
}
;
C3$jscomp$9.range = function*(a, b) {
    if (!isFinite(Math.abs(a - b)))
        throw Error("Invalid parameters");
    if (a > b)
        for (--a; a >= b; a--)
            yield a;
    else
        for (; a < b; a++)
            yield a
}
;
function isValidTypeChange(a, b) {
    a = C3$jscomp$9.getType(a);
    b = C3$jscomp$9.getType(b);
    return "null" === a || "null" === b ? !0 : "undefined" === a || "undefined" === b ? !1 : a === b
}
let ctorObjectToProxy = new Map
  , ctorProxyToObject = new Map
  , proxyToObject = new WeakMap
  , releasedObjects = new WeakMap;
C3$jscomp$9.DefendHandler = {};
const VALID_GET_MISSING_KEYS = new Set(["then", "splice"]);
function logDefendedObjectWarning(a) {
    console.warn("[Defence] " + a + " @", C3$jscomp$9.GetCallStack())
}
C3$jscomp$9.DefendHandler.get = function(a, b) {
    b in a || "symbol" === typeof b || VALID_GET_MISSING_KEYS.has(b) || logDefendedObjectWarning(`Accessed missing property '${b}' from defended object '${C3$jscomp$9.getName(a)}', returning undefined`);
    releasedObjects.has(a) && "symbol" !== typeof b && !VALID_GET_MISSING_KEYS.has(b) && logDefendedObjectWarning(`Accessed property '${b}' on a released object '${C3$jscomp$9.getName(a)}'\nObject was originally released at: ${releasedObjects.get(a)})\nCall stack at access: `);
    return a[b]
}
;
C3$jscomp$9.DefendHandler.set = function(a, b, d) {
    b in a || ctorObjectToProxy.has(a) || logDefendedObjectWarning(`Set non-existent property '${b}' to '${d}' on defended object '${C3$jscomp$9.getName(a)}'`);
    isValidTypeChange(a[b], d) || ctorObjectToProxy.has(a) || logDefendedObjectWarning(`Set '${C3$jscomp$9.getType(a[b])}' property '${b}' to type '${C3$jscomp$9.getType(d)}' on defended object '${C3$jscomp$9.getName(a)}'`);
    releasedObjects.has(a) && logDefendedObjectWarning(`Set property '${b}' on a released object '${C3$jscomp$9.getName(a)}'\nObject was originally released at: ${releasedObjects.get(a)})\nCall stack at access: `);
    a[b] = d;
    return !0
}
;
C3$jscomp$9.DefendHandler.deleteProperty = function(a, b) {
    throw new ReferenceError(`Cannot delete property '${b}' from defended object '${C3$jscomp$9.getName(a)}'`);
}
;
C3$jscomp$9.DefendHandler.defineProperty = function(a, b, d) {
    throw new ReferenceError(`Cannot define property '${b}' on defended object '${C3$jscomp$9.getName(a)}'`);
}
;
C3$jscomp$9.DefendHandler.enumerate = function(a) {
    throw new ReferenceError(`Cannot enumerate defended object '${C3$jscomp$9.getName(a)}'`);
}
;
let checkRafId = -1;
function CheckDefendedObjectsUsedCorrectly() {
    checkRafId = -1;
    if (0 < ctorObjectToProxy.size || 0 < ctorProxyToObject.size) {
        let a = [...(new Set([...ctorObjectToProxy.keys()].map(b=>C3$jscomp$9.getName(b))))].join();
        console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${a}`);
        ctorObjectToProxy.clear();
        ctorProxyToObject.clear()
    }
}
C3$jscomp$9.DefendedBase = class {
    constructor() {
        if (C3$jscomp$9.isDebugDefend && C3$jscomp$9.Supports.Proxies) {
            var a = new.target;
            a = Object.create(a.prototype);
            var b = new Proxy(a,C3$jscomp$9.DefendHandler);
            ctorObjectToProxy.set(a, b);
            ctorProxyToObject.set(b, a);
            proxyToObject.set(b, a);
            -1 === checkRafId && (checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly));
            return b
        }
    }
}
;
C3$jscomp$9.debugDefend = function(a) {
    if (C3$jscomp$9.isDebugDefend && C3$jscomp$9.Supports.Proxies && a instanceof C3$jscomp$9.DefendedBase) {
        if (!ctorProxyToObject.has(a))
            return a;
        let b = ctorProxyToObject.get(a);
        ctorProxyToObject.delete(a);
        ctorObjectToProxy.delete(b);
        return a
    }
    return C3$jscomp$9.isDebug ? Object.seal(a) : a
}
;
C3$jscomp$9.New = function(a, ...b) {
    let d;
    try {
        d = new a(...b)
    } catch (c) {
        throw ctorProxyToObject.clear(),
        ctorObjectToProxy.clear(),
        c;
    }
    C3$jscomp$9.isDebugDefend && VerifyObjectPropertiesConsistent(a, d);
    return C3$jscomp$9.debugDefend(d)
}
;
C3$jscomp$9.Release = function(a) {
    (a = proxyToObject.get(a)) && releasedObjects.set(a, C3$jscomp$9.GetCallStack())
}
;
C3$jscomp$9.WasReleased = function(a) {
    return (a = proxyToObject.get(a)) ? !!releasedObjects.get(a) : !1
}
;
let typeProperties = new Map;
function getObjectPropertySet(a) {
    let b = new Set;
    for (let d in a)
        b.add(d);
    return b
}
function VerifyObjectPropertiesConsistent(a, b) {
    b = getObjectPropertySet(b);
    let d = typeProperties.get(a);
    if (d) {
        let c = [];
        for (let e of d.values())
            b.has(e) ? b.delete(e) : c.push(e);
        C3$jscomp$9.appendArray(c, [...b]);
        c.length && console.warn(`[Defence] '${C3$jscomp$9.getName(a)}' constructor creates inconsistent properties: ${c.join(", ")}`)
    } else
        typeProperties.set(a, b)
}
C3$jscomp$9.PerfMark = class {
    constructor(a) {
        this._name = "";
        a && this.start(a)
    }
    start(a) {
        C3$jscomp$9.isPerformanceProfiling && (this._name = a,
        performance.mark(this._name + "-Start"))
    }
    end() {
        C3$jscomp$9.isPerformanceProfiling && (performance.mark(this._name + "-End"),
        performance.measure(this._name, this._name + "-Start", this._name + "-End"))
    }
    next(a) {
        C3$jscomp$9.isPerformanceProfiling && (this.end(),
        this._name = a,
        performance.mark(this._name + "-Start"))
    }
}
;
"use strict";
const C3$jscomp$10 = self.C3
  , TWO_PI = 2 * Math.PI
  , D_TO_R = Math.PI / 180
  , R_TO_D = 180 / Math.PI;
C3$jscomp$10.wrap = function(a, b, d) {
    a = Math.floor(a);
    b = Math.floor(b);
    d = Math.floor(d);
    const c = d - b;
    return 0 === c ? d : a < b ? (a = d - (b - a) % c,
    a === d ? 0 : a) : b + (a - b) % c
}
;
C3$jscomp$10.mapToRange = function(a, b, d, c, e) {
    return (a - b) * (e - c) / (d - b) + c
}
;
C3$jscomp$10.normalize = function(a, b, d) {
    return (a - b) / (d - b)
}
;
C3$jscomp$10.clamp = function(a, b, d) {
    return a < b ? b : a > d ? d : a
}
;
C3$jscomp$10.clampAngle = function(a) {
    a %= TWO_PI;
    0 > a && (a += TWO_PI);
    return a
}
;
C3$jscomp$10.toRadians = function(a) {
    return a * D_TO_R
}
;
C3$jscomp$10.toDegrees = function(a) {
    return a * R_TO_D
}
;
C3$jscomp$10.distanceTo = function(a, b, d, c) {
    return Math.hypot(d - a, c - b)
}
;
C3$jscomp$10.distanceSquared = function(a, b, d, c) {
    a = d - a;
    b = c - b;
    return a * a + b * b
}
;
C3$jscomp$10.angleTo = function(a, b, d, c) {
    return Math.atan2(c - b, d - a)
}
;
C3$jscomp$10.angleDiff = function(a, b) {
    if (a === b)
        return 0;
    a = Math.sin(a) * Math.sin(b) + Math.cos(a) * Math.cos(b);
    return 1 <= a ? 0 : -1 >= a ? Math.PI : Math.acos(a)
}
;
C3$jscomp$10.angleRotate = function(a, b, d) {
    let c = Math.sin(a)
      , e = Math.cos(a)
      , g = Math.sin(b)
      , k = Math.cos(b);
    return Math.acos(c * g + e * k) > d ? 0 < e * g - c * k ? C3$jscomp$10.clampAngle(a + d) : C3$jscomp$10.clampAngle(a - d) : C3$jscomp$10.clampAngle(b)
}
;
C3$jscomp$10.angleClockwise = function(a, b) {
    return 0 >= Math.cos(a) * Math.sin(b) - Math.sin(a) * Math.cos(b)
}
;
C3$jscomp$10.angleLerp = function(a, b, d, c=0) {
    let e = C3$jscomp$10.angleDiff(a, b);
    c *= TWO_PI;
    return C3$jscomp$10.angleClockwise(b, a) ? C3$jscomp$10.clampAngle(a + (e + c) * d) : C3$jscomp$10.clampAngle(a - (e + c) * d)
}
;
C3$jscomp$10.angleLerpClockwise = function(a, b, d, c=0) {
    const e = C3$jscomp$10.angleDiff(a, b);
    c *= TWO_PI;
    return C3$jscomp$10.angleClockwise(b, a) ? C3$jscomp$10.clampAngle(a + (e + c) * d) : C3$jscomp$10.clampAngle((TWO_PI - e + c) * d)
}
;
C3$jscomp$10.angleLerpAntiClockwise = function(a, b, d, c=0) {
    const e = C3$jscomp$10.angleDiff(a, b);
    c *= TWO_PI;
    return C3$jscomp$10.angleClockwise(b, a) ? C3$jscomp$10.clampAngle((-TWO_PI + e - c) * d) : C3$jscomp$10.clampAngle(a - (e + c) * d)
}
;
C3$jscomp$10.lerp = function(a, b, d) {
    return a + d * (b - a)
}
;
C3$jscomp$10.unlerp = function(a, b, d) {
    return a === b ? 0 : (d - a) / (b - a)
}
;
C3$jscomp$10.relerp = function(a, b, d, c, e) {
    return C3$jscomp$10.lerp(c, e, C3$jscomp$10.unlerp(a, b, d))
}
;
C3$jscomp$10.qarp = function(a, b, d, c) {
    return C3$jscomp$10.lerp(C3$jscomp$10.lerp(a, b, c), C3$jscomp$10.lerp(b, d, c), c)
}
;
C3$jscomp$10.cubic = function(a, b, d, c, e) {
    return C3$jscomp$10.lerp(C3$jscomp$10.qarp(a, b, d, e), C3$jscomp$10.qarp(b, d, c, e), e)
}
;
C3$jscomp$10.cosp = function(a, b, d) {
    return (a + b + (a - b) * Math.cos(d * Math.PI)) / 2
}
;
C3$jscomp$10.isPOT = function(a) {
    return 0 < a && 0 === (a - 1 & a)
}
;
C3$jscomp$10.nextHighestPowerOfTwo = function(a) {
    --a;
    for (let b = 1; 32 > b; b <<= 1)
        a |= a >> b;
    return a + 1
}
;
C3$jscomp$10.roundToNearestFraction = function(a, b) {
    return Math.round(a * b) / b
}
;
C3$jscomp$10.floorToNearestFraction = function(a, b) {
    return Math.floor(a * b) / b
}
;
C3$jscomp$10.roundToDp = function(a, b) {
    b = Math.max(Math.floor(b), 0);
    b = Math.pow(10, b);
    return Math.round(a * b) / b
}
;
C3$jscomp$10.toFixed = function(a, b) {
    a = a.toFixed(b);
    for (b = a.length - 1; 0 <= b && "0" === a.charAt(b); --b)
        ;
    0 <= b && "." === a.charAt(b) && --b;
    return 0 > b ? a : a.substr(0, b + 1)
}
;
C3$jscomp$10.PackRGB = function(a, b, d) {
    return C3$jscomp$10.clamp(a, 0, 255) | C3$jscomp$10.clamp(b, 0, 255) << 8 | C3$jscomp$10.clamp(d, 0, 255) << 16
}
;
const ALPHAEX_SHIFT = 1024;
C3$jscomp$10.PackRGBAEx = function(a, b, d, c) {
    a = C3$jscomp$10.clamp(Math.floor(1024 * a), -8192, 8191);
    b = C3$jscomp$10.clamp(Math.floor(1024 * b), -8192, 8191);
    d = C3$jscomp$10.clamp(Math.floor(1024 * d), -8192, 8191);
    c = C3$jscomp$10.clamp(Math.floor(1023 * c), 0, 1023);
    0 > a && (a += 16384);
    0 > b && (b += 16384);
    0 > d && (d += 16384);
    return -(268435456 * a * ALPHAEX_SHIFT + 16384 * b * ALPHAEX_SHIFT + d * ALPHAEX_SHIFT + c)
}
;
C3$jscomp$10.PackRGBEx = function(a, b, d) {
    return C3$jscomp$10.PackRGBAEx(a, b, d, 1)
}
;
function isNegativeZero(a) {
    return 0 === a && 0 > 1 / a
}
C3$jscomp$10.GetRValue = function(a) {
    if (0 <= a)
        return (a & 255) / 255;
    a = Math.floor(-a / (268435456 * ALPHAEX_SHIFT));
    8191 < a && (a -= 16384);
    return a / 1024
}
;
C3$jscomp$10.GetGValue = function(a) {
    if (0 <= a)
        return ((a & 65280) >> 8) / 255;
    a = Math.floor(-a % (268435456 * ALPHAEX_SHIFT) / (16384 * ALPHAEX_SHIFT));
    8191 < a && (a -= 16384);
    return a / 1024
}
;
C3$jscomp$10.GetBValue = function(a) {
    if (0 <= a)
        return ((a & 16711680) >> 16) / 255;
    a = Math.floor(-a % (16384 * ALPHAEX_SHIFT) / ALPHAEX_SHIFT);
    8191 < a && (a -= 16384);
    return a / 1024
}
;
C3$jscomp$10.GetAValue = function(a) {
    return isNegativeZero(a) ? 0 : 0 <= a ? 1 : Math.floor(-a % ALPHAEX_SHIFT) / 1023
}
;
C3$jscomp$10.greatestCommonDivisor = function(a, b) {
    a = Math.floor(a);
    for (b = Math.floor(b); 0 !== b; ) {
        let d = b;
        b = a % b;
        a = d
    }
    return a
}
;
const COMMON_ASPECT_RATIOS = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];
C3$jscomp$10.getAspectRatio = function(a, b) {
    a = Math.floor(a);
    b = Math.floor(b);
    if (a === b)
        return [1, 1];
    for (var d of COMMON_ASPECT_RATIOS) {
        let c = a / d[0] * d[1];
        if (1 > Math.abs(b - c))
            return d.slice(0);
        c = a / d[1] * d[0];
        if (1 > Math.abs(b - c))
            return [d[1], d[0]]
    }
    d = C3$jscomp$10.greatestCommonDivisor(a, b);
    return [a / d, b / d]
}
;
C3$jscomp$10.segmentsIntersect = function(a, b, d, c, e, g, k, l) {
    var n = Math.min(a, d)
      , p = Math.max(e, k);
    if (Math.max(a, d) < Math.min(e, k) || n > p)
        return !1;
    n = Math.min(b, c);
    p = Math.max(g, l);
    if (Math.max(b, c) < Math.min(g, l) || n > p)
        return !1;
    n = e - a + k - d;
    p = g - b + l - c;
    a = d - a;
    b = c - b;
    e = k - e;
    g = l - g;
    l = Math.abs(b * e - g * a);
    return Math.abs(e * p - g * n) > l ? !1 : Math.abs(a * p - b * n) <= l
}
;
C3$jscomp$10.segmentsIntersectPreCalc = function(a, b, d, c, e, g, k, l, n, p, t, w) {
    const z = Math.max(n, t);
    if (g < Math.min(n, t) || e > z)
        return !1;
    e = Math.max(p, w);
    if (l < Math.min(p, w) || k > e)
        return !1;
    k = n - a + t - d;
    l = p - b + w - c;
    a = d - a;
    b = c - b;
    n = t - n;
    p = w - p;
    w = Math.abs(b * n - p * a);
    return Math.abs(n * l - p * k) > w ? !1 : Math.abs(a * l - b * k) <= w
}
;
C3$jscomp$10.segmentIntersectsQuad = function(a, b, d, c, e) {
    const g = Math.min(a, d)
      , k = Math.max(a, d)
      , l = Math.min(b, c)
      , n = Math.max(b, c)
      , p = e.getTlx()
      , t = e.getTly()
      , w = e.getTrx()
      , z = e.getTry()
      , B = e.getBrx()
      , C = e.getBry()
      , E = e.getBlx();
    e = e.getBly();
    return C3$jscomp$10.segmentsIntersectPreCalc(a, b, d, c, g, k, l, n, p, t, w, z) || C3$jscomp$10.segmentsIntersectPreCalc(a, b, d, c, g, k, l, n, w, z, B, C) || C3$jscomp$10.segmentsIntersectPreCalc(a, b, d, c, g, k, l, n, B, C, E, e) || C3$jscomp$10.segmentsIntersectPreCalc(a, b, d, c, g, k, l, n, E, e, p, t)
}
;
C3$jscomp$10.segmentIntersectsAnyN = function(a, b, d, c, e) {
    const g = Math.min(a, d)
      , k = Math.max(a, d)
      , l = Math.min(b, c)
      , n = Math.max(b, c);
    let p = 0;
    for (let t = e.length - 4; p <= t; p += 2)
        if (C3$jscomp$10.segmentsIntersectPreCalc(a, b, d, c, g, k, l, n, e[p], e[p + 1], e[p + 2], e[p + 3]))
            return !0;
    return C3$jscomp$10.segmentsIntersectPreCalc(a, b, d, c, g, k, l, n, e[p], e[p + 1], e[0], e[1])
}
;
C3$jscomp$10.rayIntersect = function(a, b, d, c, e, g, k, l) {
    d -= a;
    g = l - g;
    const n = d * g - (c - b) * (k - e);
    if (0 === n)
        return 2;
    c = ((b - c) * (k - a) + d * (l - b)) / n;
    return 0 < c && 1.000001 > c ? (g * (k - a) + (e - k) * (l - b)) / n : 2
}
;
C3$jscomp$10.rayIntersectExtended = function(a, b, d, c, e, g, k, l, n) {
    const p = (k - e) * n;
    n *= l - g;
    return C3$jscomp$10.rayIntersect(a, b, d, c, e - p, g - n, k + p, l + n)
}
;
C3$jscomp$10.isPointInTriangleInclusive = function(a, b, d, c, e, g, k, l) {
    e -= d;
    g -= c;
    k -= d;
    l -= c;
    a -= d;
    d = b - c;
    b = e * e + g * g;
    c = e * k + g * l;
    e = e * a + g * d;
    g = k * k + l * l;
    k = k * a + l * d;
    l = 1 / (b * g - c * c);
    g = (g * e - c * k) * l;
    e = (b * k - c * e) * l;
    return 0 <= g && 0 <= e && 1 >= g + e
}
;
C3$jscomp$10.triangleCartesianToBarycentric = function(a, b, d, c, e, g, k, l) {
    e -= d;
    g -= c;
    k -= d;
    l -= c;
    a -= d;
    const n = b - c;
    b = e * e + g * g;
    c = e * k + g * l;
    d = k * k + l * l;
    e = a * e + n * g;
    g = a * k + n * l;
    k = b * d - c * c;
    l = (d * e - c * g) / k;
    e = (b * g - c * e) / k;
    return [1 - l - e, l, e]
}
;
C3$jscomp$10.triangleBarycentricToCartesian = function(a, b, d, c, e, g, k, l, n) {
    return [a * c + b * g + d * l, a * e + b * k + d * n]
}
;
"use strict";
const C3$jscomp$11 = self.C3;
let mainDocument = null
  , baseHref = "";
if ("undefined" !== typeof document) {
    mainDocument = document;
    const a = document.querySelector("base");
    if (baseHref = a && a.hasAttribute("href") ? a.getAttribute("href") : "")
        baseHref.startsWith("/") && (baseHref = baseHref.substr(1)),
        baseHref.endsWith("/") || (baseHref += "/")
}
C3$jscomp$11.GetBaseHref = function() {
    return baseHref
}
;
C3$jscomp$11.GetBaseURL = function() {
    if (!mainDocument)
        return "";
    const a = mainDocument.location;
    return C3$jscomp$11.GetPathFromURL(a.origin + a.pathname) + baseHref
}
;
C3$jscomp$11.GetPathFromURL = function(a) {
    if (!a.length || a.endsWith("/") || a.endsWith("\\"))
        return a;
    const b = Math.max(a.lastIndexOf("/"), a.lastIndexOf("\\"));
    return -1 === b ? "" : a.substr(0, b + 1)
}
;
C3$jscomp$11.GetFilenameFromURL = function(a) {
    if (!a.length)
        return a;
    if (a.endsWith("/") || a.endsWith("\\"))
        return "";
    const b = Math.max(a.lastIndexOf("/"), a.lastIndexOf("\\"));
    return -1 === b ? a : a.substr(b + 1)
}
;
C3$jscomp$11.GetFileExtension = function(a) {
    let b = a.lastIndexOf(".");
    return 1 > b ? "" : a.substr(b)
}
;
C3$jscomp$11.SetFileExtension = function(a, b) {
    const d = a.lastIndexOf(".");
    return -1 === d ? a + "." + b : a.substr(0, d + 1) + b
}
;
C3$jscomp$11.GetFileNamePart = function(a) {
    let b = a.lastIndexOf(".");
    return 1 > b ? a : a.substr(0, b)
}
;
C3$jscomp$11.NormalizeFileSeparator = function(a) {
    return a.replace(/\\/g, "/")
}
;
C3$jscomp$11.IsFileExtension = function(a, b) {
    a = a ? C3$jscomp$11.GetFileExtension(a).slice(1) : "";
    return b === a
}
;
C3$jscomp$11.FileNameEquals = function(a, b) {
    let d, c;
    C3$jscomp$11.IsFileLike(a) && (d = C3$jscomp$11.GetFileNamePart(a.name));
    C3$jscomp$11.IsString(a) && (d = C3$jscomp$11.GetFileNamePart(a));
    C3$jscomp$11.IsFileLike(b) && (c = C3$jscomp$11.GetFileNamePart(b.name));
    C3$jscomp$11.IsString(b) && (c = C3$jscomp$11.GetFileNamePart(b));
    return d === c
}
;
C3$jscomp$11.ParseFilePath = function(a) {
    a = C3$jscomp$11.NormalizeFileSeparator(a);
    let b = /^\w:\//.exec(a);
    b ? (b = b[0],
    a = a.slice(3),
    "/" !== a[0] && (a = "/" + a)) : b = "";
    a = a.replace(/\/{2,}/g, "/");
    1 < a.length && "/" === a.slice(-1) && (a = a.slice(0, -1));
    var d = a.lastIndexOf("/") + 1;
    let c = ""
      , e = a
      , g = "";
    0 < d && (c = a.slice(0, d),
    e = a.slice(d));
    a = e;
    d = e.lastIndexOf(".");
    0 < d && (g = e.slice(d),
    a = e.slice(0, -g.length));
    return {
        dir: c,
        base: e,
        name: a,
        root: b,
        ext: g,
        full: b + c + e
    }
}
;
C3$jscomp$11.Wait = function(a, b) {
    return new Promise((d,c)=>{
        self.setTimeout(d, a, b)
    }
    )
}
;
C3$jscomp$11.swallowException = function(a) {
    try {
        a()
    } catch (b) {
        C3$jscomp$11.isDebug && console.warn("Swallowed exception: ", b)
    }
}
;
C3$jscomp$11.noop = function() {}
;
C3$jscomp$11.equalsNoCase = function(a, b) {
    return "string" !== typeof a || "string" !== typeof b ? !1 : a === b || a.normalize().toLowerCase() === b.normalize().toLowerCase()
}
;
C3$jscomp$11.equalsCase = function(a, b) {
    return "string" !== typeof a || "string" !== typeof b ? !1 : a === b ? !0 : a.normalize() === b.normalize()
}
;
C3$jscomp$11.typedArraySet16 = function(a, b, d) {
    a[d++] = b[0];
    a[d++] = b[1];
    a[d++] = b[2];
    a[d++] = b[3];
    a[d++] = b[4];
    a[d++] = b[5];
    a[d++] = b[6];
    a[d++] = b[7];
    a[d++] = b[8];
    a[d++] = b[9];
    a[d++] = b[10];
    a[d++] = b[11];
    a[d++] = b[12];
    a[d++] = b[13];
    a[d++] = b[14];
    a[d] = b[15]
}
;
C3$jscomp$11.truncateArray = function(a, b) {
    a.length = b
}
;
C3$jscomp$11.clearArray = function(a) {
    a && 0 !== a.length && C3$jscomp$11.truncateArray(a, 0)
}
;
C3$jscomp$11.clear2DArray = function(a) {
    if (a) {
        for (let b = 0; b < a.length; b++)
            C3$jscomp$11.truncateArray(a[b], 0);
        C3$jscomp$11.truncateArray(a, 0)
    }
}
;
C3$jscomp$11.extendArray = function(a, b, d) {
    b |= 0;
    var c = a.length;
    if (!(b <= c))
        for (; c < b; ++c)
            a.push(d)
}
;
C3$jscomp$11.resizeArray = function(a, b, d) {
    b |= 0;
    const c = a.length;
    b < c ? C3$jscomp$11.truncateArray(a, b) : b > c && C3$jscomp$11.extendArray(a, b, d)
}
;
C3$jscomp$11.shallowAssignArray = function(a, b) {
    C3$jscomp$11.clearArray(a);
    C3$jscomp$11.appendArray(a, b)
}
;
C3$jscomp$11.appendArray = function(a, b) {
    if (1E4 > b.length)
        a.push(...b);
    else
        for (let d = 0, c = b.length; d < c; ++d)
            a.push(b[d])
}
;
C3$jscomp$11.arrayRemove = function(a, b) {
    b = Math.floor(b);
    if (!(0 > b || b >= a.length)) {
        for (var d = a.length - 1; b < d; ++b)
            a[b] = a[b + 1];
        C3$jscomp$11.truncateArray(a, d)
    }
}
;
C3$jscomp$11.arrayFindRemove = function(a, b) {
    b = a.indexOf(b);
    0 <= b && a.splice(b, 1)
}
;
C3$jscomp$11.arraysEqual = function(a, b) {
    let d = a.length;
    if (b.length !== d)
        return !1;
    for (let c = 0; c < d; ++c)
        if (a[c] !== b[c])
            return !1;
    return !0
}
;
C3$jscomp$11.arrayFilterOut = function(a, b) {
    let d = []
      , c = 0;
    for (let e = 0, g = a.length; e < g; ++e) {
        let k = a[e];
        b(k) ? d.push(k) : (a[c] = k,
        ++c)
    }
    C3$jscomp$11.truncateArray(a, c);
    return d
}
;
C3$jscomp$11.arrayRemoveAllInSet = function(a, b) {
    const d = a.length;
    let c = 0;
    for (let e = 0, g = a.length; e < g; ++e) {
        let k = a[e];
        b.has(k) || (a[c++] = k)
    }
    C3$jscomp$11.truncateArray(a, c);
    return d - c
}
;
C3$jscomp$11.isArrayIndexInBounds = function(a, b) {
    return a !== Math.floor(a) ? !1 : 0 <= a && a < b.length
}
;
C3$jscomp$11.validateArrayIndex = function(a, b) {
    if (!C3$jscomp$11.isArrayIndexInBounds(a, b))
        throw new RangeError("array index out of bounds");
}
;
C3$jscomp$11.cloneArray = function(a) {
    return a.slice()
}
;
C3$jscomp$11.deepCloneArray = function(a, b) {
    let d = [];
    for (let c of a)
        if (C3$jscomp$11.IsObject(c)) {
            a = b(c);
            if (!a)
                throw Error("missing clone");
            if (a.constructor !== c.constructor)
                throw Error("object is not a clone");
            d.push(a)
        } else
            C3$jscomp$11.IsArray(c) ? d.push(C3$jscomp$11.deepCloneArray(c, b)) : d.push(c);
    return d
}
;
C3$jscomp$11.clone2DArray = function(a) {
    let b = [];
    for (let d of a)
        b.push(d.slice());
    return b
}
;
C3$jscomp$11.mergeSets = function(a, b) {
    return new Set([...a, ...b])
}
;
C3$jscomp$11.mergeSetsInPlace = function(a, b) {
    for (const d of b)
        a.add(d);
    return a
}
;
C3$jscomp$11.first = function(a) {
    for (let b of a)
        return b;
    return null
}
;
C3$jscomp$11.xor = function(a, b) {
    return !a !== !b
}
;
C3$jscomp$11.compare = function(a, b, d) {
    switch (b) {
    case 0:
        return a === d;
    case 1:
        return a !== d;
    case 2:
        return a < d;
    case 3:
        return a <= d;
    case 4:
        return a > d;
    case 5:
        return a >= d;
    default:
        return !1
    }
}
;
C3$jscomp$11.hasAnyOwnProperty = function(a) {
    for (let b in a)
        if (a.hasOwnProperty(b))
            return !0;
    return !1
}
;
C3$jscomp$11.PromiseAllWithProgress = function(a, b) {
    return a.length ? new Promise((d,c)=>{
        const e = [];
        let g = 0
          , k = !1;
        for (let l = 0, n = a.length; l < n; ++l)
            e.push(void 0),
            a[l].then(p=>{
                k || (e[l] = p,
                ++g,
                g === a.length ? d(e) : b(g, a.length))
            }
            ).catch(p=>{
                k = !0;
                c(p)
            }
            )
    }
    ) : Promise.resolve([])
}
;
let memoryCallbacks = [];
C3$jscomp$11.AddLibraryMemoryCallback = function(a) {
    memoryCallbacks.push(a)
}
;
C3$jscomp$11.GetEstimatedLibraryMemoryUsage = function() {
    let a = 0;
    for (let b of memoryCallbacks) {
        let d = b();
        a += d
    }
    return Math.floor(a)
}
;
let nextTaskId = 1;
const activeTaskIds = new Map
  , taskMessageChannel = new MessageChannel;
taskMessageChannel.port2.onmessage = function(a) {
    a = a.data;
    const b = activeTaskIds.get(a);
    activeTaskIds.delete(a);
    b && b(performance.now())
}
;
C3$jscomp$11.RequestUnlimitedAnimationFrame = function(a) {
    const b = nextTaskId++;
    activeTaskIds.set(b, a);
    taskMessageChannel.port1.postMessage(b);
    return b
}
;
C3$jscomp$11.CancelUnlimitedAnimationFrame = function(a) {
    activeTaskIds.delete(a)
}
;
C3$jscomp$11.PostTask = C3$jscomp$11.RequestUnlimitedAnimationFrame;
C3$jscomp$11.WaitForNextTask = function() {
    return new Promise(a=>C3$jscomp$11.PostTask(a))
}
;
const activeRPAFids = new Set;
C3$jscomp$11.RequestPostAnimationFrame = function(a) {
    const b = self.requestAnimationFrame(async d=>{
        await C3$jscomp$11.WaitForNextTask();
        activeRPAFids.has(b) && (activeRPAFids.delete(b),
        a(d))
    }
    );
    activeRPAFids.add(b);
    return b
}
;
C3$jscomp$11.CancelPostAnimationFrame = function(a) {
    activeRPAFids.has(a) && (self.cancelAnimationFrame(a),
    activeRPAFids.delete(a))
}
;
"use strict";
const C3$jscomp$12 = self.C3;
C3$jscomp$12.IsAbsoluteURL = function(a) {
    return /^(?:[a-z\-]+:)?\/\//.test(a) || "data:" === a.substr(0, 5) || "blob:" === a.substr(0, 5)
}
;
C3$jscomp$12.IsRelativeURL = function(a) {
    return !C3$jscomp$12.IsAbsoluteURL(a)
}
;
C3$jscomp$12.ThrowIfNotOk = function(a) {
    if (!a.ok)
        throw Error(`fetch '${a.url}' response returned ${a.status} ${a.statusText}`);
}
;
C3$jscomp$12.FetchOk = function(a, b) {
    return fetch(a, b).then(d=>{
        C3$jscomp$12.ThrowIfNotOk(d);
        return d
    }
    )
}
;
C3$jscomp$12.FetchText = function(a) {
    return C3$jscomp$12.FetchOk(a).then(b=>b.text())
}
;
C3$jscomp$12.FetchJson = function(a) {
    return C3$jscomp$12.FetchOk(a).then(b=>b.json())
}
;
C3$jscomp$12.FetchBlob = function(a) {
    return C3$jscomp$12.FetchOk(a).then(b=>b.blob())
}
;
C3$jscomp$12.FetchArrayBuffer = function(a) {
    return C3$jscomp$12.FetchOk(a).then(b=>b.arrayBuffer())
}
;
C3$jscomp$12.FetchImage = function(a) {
    return new Promise((b,d)=>{
        const c = new Image;
        c.onload = ()=>b(c);
        c.onerror = e=>d(e);
        c.src = a
    }
    )
}
;
C3$jscomp$12.BlobToArrayBuffer = function(a) {
    return "function" === typeof a.arrayBuffer ? a.arrayBuffer() : new Promise((b,d)=>{
        const c = new FileReader;
        c.onload = ()=>b(c.result);
        c.onerror = ()=>d(c.error);
        c.readAsArrayBuffer(a)
    }
    )
}
;
C3$jscomp$12.BlobToString = function(a) {
    return "function" === typeof a.text ? a.text() : new Promise((b,d)=>{
        const c = new FileReader;
        c.onload = ()=>b(c.result);
        c.onerror = ()=>d(c.error);
        c.readAsText(a)
    }
    )
}
;
C3$jscomp$12.BlobToJson = function(a) {
    return C3$jscomp$12.BlobToString(a).then(b=>JSON.parse(b))
}
;
C3$jscomp$12.BlobToImage = async function(a, b) {
    a = URL.createObjectURL(a);
    try {
        const d = await C3$jscomp$12.FetchImage(a);
        URL.revokeObjectURL(a);
        a = "";
        b && "function" === typeof d.decode && await d.decode();
        return d
    } finally {
        a && URL.revokeObjectURL(a)
    }
}
;
C3$jscomp$12.CreateCanvas = function(a, b) {
    if ("undefined" !== typeof document && "function" === typeof document.createElement) {
        const d = document.createElement("canvas");
        d.width = a;
        d.height = b;
        return d
    }
    return new OffscreenCanvas(a,b)
}
;
C3$jscomp$12.CanvasToBlob = function(a, b, d) {
    "number" !== typeof d && (d = 1);
    b = b || "image/png";
    d = C3$jscomp$12.clamp(d, 0, 1);
    if (a.toBlob)
        return new Promise(c=>a.toBlob(c, b, d));
    if (a.convertToBlob)
        return a.convertToBlob({
            type: b,
            quality: d
        });
    throw Error("could not convert canvas to blob");
}
;
C3$jscomp$12.DrawableToBlob = function(a, b, d) {
    const c = C3$jscomp$12.CreateCanvas(a.width, a.height);
    c.getContext("2d").drawImage(a, 0, 0);
    return C3$jscomp$12.CanvasToBlob(c, b, d)
}
;
C3$jscomp$12.ImageDataToBlob = function(a, b, d) {
    if (C3$jscomp$12.Supports.ImageBitmapOptions)
        return createImageBitmap(a, {
            premultiplyAlpha: "none"
        }).then(e=>C3$jscomp$12.DrawableToBlob(e, b, d));
    if (C3$jscomp$12.Supports.ImageBitmap)
        return createImageBitmap(a).then(e=>C3$jscomp$12.DrawableToBlob(e, b, d));
    const c = C3$jscomp$12.CreateCanvas(a.width, a.height);
    c.getContext("2d").putImageData(a, 0, 0);
    return C3$jscomp$12.CanvasToBlob(c, b, d)
}
;
C3$jscomp$12.CopySet = function(a, b) {
    a.clear();
    for (const d of b)
        a.add(d)
}
;
C3$jscomp$12.MapToObject = function(a) {
    const b = Object.create(null);
    for (const [d,c] of a.entries())
        b[d] = c;
    return b
}
;
C3$jscomp$12.ObjectToMap = function(a, b) {
    b.clear();
    for (const [d,c] of Object.entries(a))
        b.set(d, c)
}
;
C3$jscomp$12.ToSuperJSON = function ToSuperJSON(a) {
    if ("object" === typeof a && null !== a) {
        if (a instanceof Set)
            return {
                _c3type_: "set",
                data: [...a].map(c=>ToSuperJSON(c))
            };
        if (a instanceof Map)
            return {
                _c3type_: "map",
                data: [...a].map(c=>[c[0], ToSuperJSON(c[1])])
            };
        const d = Object.create(null);
        for (const [c,e] of Object.entries(a))
            d[c] = ToSuperJSON(e);
        return d
    }
    return a
}
;
C3$jscomp$12.FromSuperJSON = function FromSuperJSON(a) {
    if ("object" === typeof a & null !== a) {
        if ("set" === a._c3type_)
            return new Set(a.data.map(c=>FromSuperJSON(c)));
        if ("map" === a._c3type_)
            return new Map(a.data.map(c=>[c[0], FromSuperJSON(c[1])]));
        const d = Object.create(null);
        for (const [c,e] of Object.entries(a))
            d[c] = FromSuperJSON(e);
        return d
    }
    return a
}
;
C3$jscomp$12.CSSToCamelCase = function(a) {
    if (a.startsWith("--"))
        return a;
    let b = ""
      , d = !1;
    for (const c of a)
        "-" === c ? d = !0 : d ? (b += c.toUpperCase(),
        d = !1) : b += c;
    return b
}
;
C3$jscomp$12.IsIterator = function(a) {
    return "object" === typeof a && "function" === typeof a.next
}
;
C3$jscomp$12.MakeFilledArray = function(a, b) {
    const d = [];
    if ("function" === typeof b)
        for (var c = 0; c < a; ++c)
            d.push(b());
    else
        for (c = 0; c < a; ++c)
            d.push(b);
    return d
}
;
"use strict";
const C3$jscomp$13 = self.C3
  , HSL_TEST = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?/i
  , HSLA_TEST = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])/i;
function padTwoDigits(a) {
    return 0 === a.length ? "00" : 1 === a.length ? "0" + a : a
}
function hueToRGB(a, b, d) {
    0 > d && (d += 1);
    1 < d && --d;
    return d < 1 / 6 ? a + 6 * (b - a) * d : .5 > d ? b : d < 2 / 3 ? a + (b - a) * (2 / 3 - d) * 6 : a
}
C3$jscomp$13.Color = class {
    constructor(a, b, d, c) {
        this._a = this._b = this._g = this._r = 0;
        a instanceof C3$jscomp$13.Color ? this.set(a) : this.setRgba(a || 0, b || 0, d || 0, c || 0)
    }
    setRgb(a, b, d) {
        this._r = +a;
        this._g = +b;
        this._b = +d;
        this.clamp();
        return this
    }
    setRgba(a, b, d, c) {
        this._r = +a;
        this._g = +b;
        this._b = +d;
        this._a = +c;
        this.clamp();
        return this
    }
    set(a) {
        this._r = a._r;
        this._g = a._g;
        this._b = a._b;
        this._a = a._a;
        return this
    }
    copy(a) {
        return this.set(a)
    }
    add(a) {
        this._r += a._r;
        this._g += a._g;
        this._b += a._b;
        this._a += a._a;
        this.clamp()
    }
    addRgb(a, b, d, c=0) {
        this._r += +a;
        this._g += +b;
        this._b += +d;
        this._a += +c;
        this.clamp()
    }
    diff(a) {
        this.setR(Math.max(this._r, a._r) - Math.min(this._r, a._r));
        this.setG(Math.max(this._g, a._g) - Math.min(this._g, a._g));
        this.setB(Math.max(this._b, a._b) - Math.min(this._b, a._b));
        this.setA(Math.max(this._a, a._a) - Math.min(this._a, a._a));
        this.clamp()
    }
    copyRgb(a) {
        this._r = a._r;
        this._g = a._g;
        this._b = a._b
    }
    setR(a) {
        this._r = C3$jscomp$13.clamp(+a, 0, 1)
    }
    getR() {
        return this._r
    }
    setG(a) {
        this._g = C3$jscomp$13.clamp(+a, 0, 1)
    }
    getG() {
        return this._g
    }
    setB(a) {
        this._b = C3$jscomp$13.clamp(+a, 0, 1)
    }
    getB() {
        return this._b
    }
    setA(a) {
        this._a = C3$jscomp$13.clamp(+a, 0, 1)
    }
    getA() {
        return this._a
    }
    clone() {
        return C3$jscomp$13.New(C3$jscomp$13.Color, this._r, this._g, this._b, this._a)
    }
    toArray() {
        return [this._r, this._g, this._b, this._a]
    }
    toTypedArray() {
        return new Float64Array(this.toArray())
    }
    writeToTypedArray(a, b) {
        a[b++] = this._r;
        a[b++] = this._g;
        a[b++] = this._b;
        a[b] = this._a
    }
    writeRGBToTypedArray(a, b) {
        a[b++] = this._r;
        a[b++] = this._g;
        a[b] = this._b
    }
    equals(a) {
        return this._r === a._r && this._g === a._g && this._b === a._b && this._a === a._a
    }
    equalsIgnoringAlpha(a) {
        return this._r === a._r && this._g === a._g && this._b === a._b
    }
    equalsRgb(a, b, d) {
        return this._r === a && this._g === b && this._b === d
    }
    equalsRgba(a, b, d, c) {
        return this._r === a && this._g === b && this._b === d && this._a === c
    }
    equalsF32Array(a, b) {
        return a[b] === Math.fround(this._r) && a[b + 1] === Math.fround(this._g) && a[b + 2] === Math.fround(this._b) && a[b + 3] === Math.fround(this._a)
    }
    equalsRGBF32Array(a, b) {
        return a[b] === Math.fround(this._r) && a[b + 1] === Math.fround(this._g) && a[b + 2] === Math.fround(this._b)
    }
    multiply(a) {
        this._r *= a._r;
        this._g *= a._g;
        this._b *= a._b;
        this._a *= a._a
    }
    multiplyAlpha(a) {
        this._r *= a;
        this._g *= a;
        this._b *= a;
        this._a *= a
    }
    premultiply() {
        this._r *= this._a;
        this._g *= this._a;
        this._b *= this._a;
        return this
    }
    unpremultiply() {
        this._r /= this._a;
        this._g /= this._a;
        this._b /= this._a;
        return this
    }
    clamp() {
        this._r = C3$jscomp$13.clamp(this._r, 0, 1);
        this._g = C3$jscomp$13.clamp(this._g, 0, 1);
        this._b = C3$jscomp$13.clamp(this._b, 0, 1);
        this._a = C3$jscomp$13.clamp(this._a, 0, 1);
        return this
    }
    setFromRgbValue(a) {
        this._r = C3$jscomp$13.GetRValue(a);
        this._g = C3$jscomp$13.GetGValue(a);
        this._b = C3$jscomp$13.GetBValue(a);
        this._a = C3$jscomp$13.GetAValue(a)
    }
    getCssRgb(a, b, d) {
        a = C3$jscomp$13.IsFiniteNumber(a) ? a : this.getR();
        b = C3$jscomp$13.IsFiniteNumber(b) ? b : this.getG();
        d = C3$jscomp$13.IsFiniteNumber(d) ? d : this.getB();
        return `rgb(${100 * a}%, ${100 * b}%, ${100 * d}%)`
    }
    getCssRgba(a, b, d, c) {
        a = C3$jscomp$13.IsFiniteNumber(a) ? a : this.getR();
        b = C3$jscomp$13.IsFiniteNumber(b) ? b : this.getG();
        d = C3$jscomp$13.IsFiniteNumber(d) ? d : this.getB();
        c = C3$jscomp$13.IsFiniteNumber(c) ? c : this.getA();
        return `rgba(${100 * a}%, ${100 * b}%, ${100 * d}%, ${c})`
    }
    toHexString() {
        const a = Math.round(255 * this.getR())
          , b = Math.round(255 * this.getG())
          , d = Math.round(255 * this.getB());
        return "#" + padTwoDigits(a.toString(16)) + padTwoDigits(b.toString(16)) + padTwoDigits(d.toString(16))
    }
    parseHexString(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.trim();
        "#" === a.charAt(0) && (a = a.substr(1));
        let b, d;
        if (3 === a.length)
            b = parseInt(a[0], 16) / 15,
            d = parseInt(a[1], 16) / 15,
            a = parseInt(a[2], 16) / 15;
        else if (6 === a.length)
            b = parseInt(a.substr(0, 2), 16) / 255,
            d = parseInt(a.substr(2, 2), 16) / 255,
            a = parseInt(a.substr(4, 2), 16) / 255;
        else
            return !1;
        isFinite(b) && this.setR(b);
        isFinite(d) && this.setG(d);
        isFinite(a) && this.setB(a);
        this.setA(1);
        return !0
    }
    toCommaSeparatedRgb() {
        const a = Math.round(255 * this.getR())
          , b = Math.round(255 * this.getG())
          , d = Math.round(255 * this.getB());
        return `${a}, ${b}, ${d}`
    }
    toRgbArray() {
        const a = Math.round(255 * this.getR())
          , b = Math.round(255 * this.getG())
          , d = Math.round(255 * this.getB());
        return [a, b, d]
    }
    parseCommaSeparatedRgb(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgb\(|\)|%/, "");
        var b = a.split(",");
        if (3 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 255;
        const d = parseInt(b[1].trim(), 10) / 255;
        b = parseInt(b[2].trim(), 10) / 255;
        isFinite(a) && this.setR(a);
        isFinite(d) && this.setG(d);
        isFinite(b) && this.setB(b);
        this.setA(1);
        return !0
    }
    parseCommaSeparatedPercentageRgb(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgb\(|\)|%/, "");
        var b = a.split(",");
        if (3 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 100;
        const d = parseInt(b[1].trim(), 10) / 100;
        b = parseInt(b[2].trim(), 10) / 100;
        isFinite(a) && this.setR(a);
        isFinite(d) && this.setG(d);
        isFinite(b) && this.setB(b);
        this.setA(1);
        return !0
    }
    parseCommaSeparatedRgba(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgba\(|\)|%/, "");
        var b = a.split(",");
        if (4 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 255;
        const d = parseInt(b[1].trim(), 10) / 255
          , c = parseInt(b[2].trim(), 10) / 255;
        b = parseFloat(b[3].trim());
        isFinite(a) && this.setR(a);
        isFinite(d) && this.setG(d);
        isFinite(c) && this.setB(c);
        isFinite(b) && this.setA(b);
        return !0
    }
    parseCommaSeparatedPercentageRgba(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgba\(|\)|%/, "");
        var b = a.split(",");
        if (4 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 100;
        const d = parseInt(b[1].trim(), 10) / 100
          , c = parseInt(b[2].trim(), 10) / 100;
        b = parseFloat(b[3].trim());
        isFinite(a) && this.setR(a);
        isFinite(d) && this.setG(d);
        isFinite(c) && this.setB(c);
        isFinite(b) && this.setA(b);
        return !0
    }
    parseString(a) {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/\s+/, "");
        if (a.includes(",")) {
            if (a.startsWith("rgb("))
                return a.includes("%") ? this.parseCommaSeparatedPercentageRgb(a) : this.parseCommaSeparatedRgb(a);
            if (a.startsWith("rgba("))
                return a.includes("%") ? this.parseCommaSeparatedPercentageRgba(a) : this.parseCommaSeparatedRgba(a);
            if (a.startsWith("hsl(") || a.startsWith("hsla("))
                return this.parseHSLString(a);
            const b = a.split(",");
            if (a.includes("%")) {
                if (3 === b.length)
                    return this.parseCommaSeparatedPercentageRgb(a);
                if (4 === b.length)
                    return this.parseCommaSeparatedPercentageRgba(a)
            } else {
                if (3 === b.length)
                    return this.parseCommaSeparatedRgb(a);
                if (4 === b.length)
                    return this.parseCommaSeparatedRgba(a)
            }
            return !1
        }
        return this.parseHexString(a)
    }
    toJSON() {
        return [this._r, this._g, this._b, this._a]
    }
    setFromHSLA(a, b, d, c) {
        a %= 360;
        b = C3$jscomp$13.clamp(b, 0, 100);
        d = C3$jscomp$13.clamp(d, 0, 100);
        c = C3$jscomp$13.clamp(c, 0, 1);
        a /= 360;
        b /= 100;
        d /= 100;
        if (0 === b)
            d = b = a = d;
        else {
            const e = .5 > d ? d * (1 + b) : d + b - d * b
              , g = 2 * d - e;
            d = hueToRGB(g, e, a + 1 / 3);
            b = hueToRGB(g, e, a);
            a = hueToRGB(g, e, a - 1 / 3)
        }
        this.setR(d);
        this.setG(b);
        this.setB(a);
        this.setA(c);
        return this
    }
    parseHSLString(a) {
        var b = a.replace(/ |hsl|hsla|\(|\)|;/gi, "");
        a = HSL_TEST.exec(b);
        b = HSLA_TEST.exec(b);
        return a && 4 === a.length ? (this.setFromHSLA(+a[1], +a[2], +a[3], 1),
        !0) : b && 5 === b.length ? (this.setFromHSLA(+a[1], +a[2], +a[3], +a[4]),
        !0) : !1
    }
    toHSLAString() {
        var a = this._r;
        const b = this._g
          , d = this._b
          , c = this._a
          , e = C3$jscomp$13.Color.GetHue(a, b, d)
          , g = C3$jscomp$13.Color.GetSaturation(a, b, d);
        a = C3$jscomp$13.Color.GetLuminosity(a, b, d);
        return `hsla(${e}, ${g}%, ${a}%, ${c})`
    }
    toHSLAArray() {
        const a = this._r
          , b = this._g
          , d = this._b;
        return [C3$jscomp$13.Color.GetHue(a, b, d), C3$jscomp$13.Color.GetSaturation(a, b, d), C3$jscomp$13.Color.GetLuminosity(a, b, d), this._a]
    }
    setFromJSON(a) {
        !Array.isArray(a) || 3 > a.length || (this._r = a[0],
        this._g = a[1],
        this._b = a[2],
        this._a = 4 <= a.length ? a[3] : 1)
    }
    set r(a) {
        this.setR(a)
    }
    get r() {
        return this.getR()
    }
    set g(a) {
        this.setG(a)
    }
    get g() {
        return this.getG()
    }
    set b(a) {
        this.setB(a)
    }
    get b() {
        return this.getB()
    }
    set a(a) {
        this.setA(a)
    }
    get a() {
        return this.getA()
    }
    setAtIndex(a, b) {
        switch (a) {
        case 0:
            this.setR(b);
            break;
        case 1:
            this.setG(b);
            break;
        case 2:
            this.setB(b);
            break;
        case 3:
            this.setA(b);
            break;
        default:
            throw new RangeError("invalid color index");
        }
    }
    getAtIndex(a) {
        switch (a) {
        case 0:
            return this.getR();
        case 1:
            return this.getG();
        case 2:
            return this.getB();
        case 3:
            return this.getA();
        default:
            throw new RangeError("invalid color index");
        }
    }
    static Equals(a, b) {
        let d;
        if (Array.isArray(a))
            d = new C3$jscomp$13.Color,
            d.setFromJSON(a);
        else if (a instanceof C3$jscomp$13.Color)
            d = a;
        else
            throw Error("unexpected type");
        if (Array.isArray(b))
            a = new C3$jscomp$13.Color,
            a.setFromJSON(b);
        else if (b instanceof C3$jscomp$13.Color)
            a = b;
        else
            throw Error("unexpected type");
        return d.equals(a)
    }
    static DiffChannel(a, b) {
        return C3$jscomp$13.clamp(Math.max(a, b) - Math.min(a, b), 0, 1)
    }
    static Diff(a, b) {
        const d = new C3$jscomp$13.Color;
        d.setR(Math.max(a._r, b._r) - Math.min(a._r, b._r));
        d.setG(Math.max(a._g, b._g) - Math.min(a._g, b._g));
        d.setB(Math.max(a._b, b._b) - Math.min(a._b, b._b));
        d.setA(Math.max(a._a, b._a) - Math.min(a._a, b._a));
        return d
    }
    static DiffNoAlpha(a, b) {
        const d = new C3$jscomp$13.Color(0,0,0,1);
        d.setR(Math.max(a._r, b._r) - Math.min(a._r, b._r));
        d.setG(Math.max(a._g, b._g) - Math.min(a._g, b._g));
        d.setB(Math.max(a._b, b._b) - Math.min(a._b, b._b));
        return d
    }
    static GetHue(a, b, d) {
        const c = Math.max(a, b, d)
          , e = Math.min(a, b, d);
        if (c === e)
            return 0;
        let g = 0;
        switch (c) {
        case a:
            g = (b - d) / (c - e) + (b < d ? 6 : 0);
            break;
        case b:
            g = (d - a) / (c - e) + 2;
            break;
        case d:
            g = (a - b) / (c - e) + 4
        }
        return Math.round(g / 6 * 360)
    }
    static GetSaturation(a, b, d) {
        const c = Math.max(a, b, d);
        a = Math.min(a, b, d);
        if (c === a)
            return 0;
        b = c - a;
        return Math.round(100 * (.5 < (c + a) / 2 ? b / (2 - c - a) : b / (c + a)))
    }
    static GetLuminosity(a, b, d) {
        const c = Math.max(a, b, d);
        return c ? Math.round((c + Math.min(a, b, d)) / 2 * 100) : 0
    }
}
;
C3$jscomp$13.Color.White = Object.freeze(C3$jscomp$13.New(C3$jscomp$13.Color, 1, 1, 1, 1));
C3$jscomp$13.Color.Black = Object.freeze(C3$jscomp$13.New(C3$jscomp$13.Color, 0, 0, 0, 1));
C3$jscomp$13.Color.TransparentBlack = Object.freeze(C3$jscomp$13.New(C3$jscomp$13.Color, 0, 0, 0, 0));
"use strict";
const C3$jscomp$14 = self.C3;
C3$jscomp$14.Vector2 = class {
    constructor(a, b) {
        this._y = this._x = 0;
        a instanceof C3$jscomp$14.Vector2 ? this.copy(a) : this.set(a || 0, b || 0)
    }
    set(a, b) {
        this._x = +a;
        this._y = +b
    }
    copy(a) {
        this._x = a._x;
        this._y = a._y
    }
    equals(a) {
        return this._x === a._x && this._y === a._y
    }
    equalsValues(a, b) {
        return this._x === a && this._y === b
    }
    equalsF32Array(a, b) {
        return a[b] === Math.fround(this._x) && a[b + 1] === Math.fround(this._y)
    }
    setX(a) {
        this._x = +a
    }
    getX() {
        return this._x
    }
    setY(a) {
        this._y = +a
    }
    getY() {
        return this._y
    }
    toArray() {
        return [this._x, this._y]
    }
    toTypedArray() {
        return new Float64Array(this.toArray())
    }
    writeToTypedArray(a, b) {
        a[b++] = this._x;
        a[b] = this._y
    }
    offset(a, b) {
        this._x += +a;
        this._y += +b
    }
    scale(a, b) {
        this._x *= a;
        this._y *= b
    }
    divide(a, b) {
        this._x /= a;
        this._y /= b
    }
    round() {
        this._x = Math.round(this._x);
        this._y = Math.round(this._y)
    }
    floor() {
        this._x = Math.floor(this._x);
        this._y = Math.floor(this._y)
    }
    ceil() {
        this._x = Math.ceil(this._x);
        this._y = Math.ceil(this._y)
    }
    angle() {
        return C3$jscomp$14.angleTo(0, 0, this._x, this._y)
    }
    lengthSquared() {
        return this._x * this._x + this._y * this._y
    }
    length() {
        return Math.hypot(this._x, this._y)
    }
    rotatePrecalc(a, b) {
        const d = this._x * b - this._y * a;
        this._y = this._y * b + this._x * a;
        this._x = d
    }
    rotate(a) {
        0 !== a && this.rotatePrecalc(Math.sin(a), Math.cos(a))
    }
    rotateAbout(a, b, d) {
        0 === a || b === this._x && d === this._y || (this._x -= b,
        this._y -= d,
        this.rotatePrecalc(Math.sin(a), Math.cos(a)),
        this._x += +b,
        this._y += +d)
    }
    move(a, b) {
        0 !== b && (this._x += Math.cos(a) * b,
        this._y += Math.sin(a) * b)
    }
    normalize() {
        const a = this.length();
        0 !== a && 1 !== a && (this._x /= a,
        this._y /= a)
    }
    clamp(a, b) {
        this._x = C3$jscomp$14.clamp(this._x, a, b);
        this._y = C3$jscomp$14.clamp(this._y, a, b)
    }
}
;
"use strict";
const C3$jscomp$15 = self.C3;
C3$jscomp$15.Rect = class {
    constructor(a, b, d, c) {
        this._bottom = this._right = this._top = this._left = 0;
        a instanceof C3$jscomp$15.Rect ? this.copy(a) : this.set(a || 0, b || 0, d || 0, c || 0)
    }
    set(a, b, d, c) {
        this._left = +a;
        this._top = +b;
        this._right = +d;
        this._bottom = +c
    }
    setWH(a, b, d, c) {
        a = +a;
        b = +b;
        this._left = a;
        this._top = b;
        this._right = a + +d;
        this._bottom = b + +c
    }
    copy(a) {
        this._left = +a._left;
        this._top = +a._top;
        this._right = +a._right;
        this._bottom = +a._bottom
    }
    clone() {
        return new C3$jscomp$15.Rect(this._left,this._top,this._right,this._bottom)
    }
    static Merge(a, b) {
        const d = new C3$jscomp$15.Rect;
        d.setLeft(Math.min(a._left, b._left));
        d.setTop(Math.min(a._top, b._top));
        d.setRight(Math.max(a._right, b._right));
        d.setBottom(Math.max(a._bottom, b._bottom));
        return d
    }
    static FromObject(a) {
        return new C3$jscomp$15.Rect(a.left,a.top,a.right,a.bottom)
    }
    equals(a) {
        return this._left === a._left && this._top === a._top && this._right === a._right && this._bottom === a._bottom
    }
    equalsWH(a, b, d, c) {
        return this._left === a && this._top === b && this.width() === d && this.height() === c
    }
    equalsF32Array(a, b) {
        return a[b] === Math.fround(this._left) && a[b + 1] === Math.fround(this._top) && a[b + 2] === Math.fround(this._right) && a[b + 3] === Math.fround(this._bottom)
    }
    setLeft(a) {
        this._left = +a
    }
    getLeft() {
        return this._left
    }
    setTop(a) {
        this._top = +a
    }
    getTop() {
        return this._top
    }
    setRight(a) {
        this._right = +a
    }
    getRight() {
        return this._right
    }
    setBottom(a) {
        this._bottom = +a
    }
    getBottom() {
        return this._bottom
    }
    toArray() {
        return [this._left, this._top, this._right, this._bottom]
    }
    toTypedArray() {
        return new Float64Array(this.toArray())
    }
    toDOMRect() {
        return new DOMRect(this._left,this._top,this.width(),this.height())
    }
    writeToTypedArray(a, b) {
        a[b++] = this._left;
        a[b++] = this._top;
        a[b++] = this._right;
        a[b] = this._bottom
    }
    writeAsQuadToTypedArray(a, b) {
        a[b++] = this._left;
        a[b++] = this._top;
        a[b++] = this._right;
        a[b++] = this._top;
        a[b++] = this._right;
        a[b++] = this._bottom;
        a[b++] = this._left;
        a[b] = this._bottom
    }
    writeAsQuadToTypedArray3D(a, b, d) {
        a[b++] = this._left;
        a[b++] = this._top;
        a[b++] = d;
        a[b++] = this._right;
        a[b++] = this._top;
        a[b++] = d;
        a[b++] = this._right;
        a[b++] = this._bottom;
        a[b++] = d;
        a[b++] = this._left;
        a[b++] = this._bottom;
        a[b] = d
    }
    width() {
        return this._right - this._left
    }
    height() {
        return this._bottom - this._top
    }
    midX() {
        return (this._left + this._right) / 2
    }
    midY() {
        return (this._top + this._bottom) / 2
    }
    offset(a, b) {
        a = +a;
        b = +b;
        this._left += a;
        this._top += b;
        this._right += a;
        this._bottom += b
    }
    offsetLeft(a) {
        this._left += +a
    }
    offsetTop(a) {
        this._top += +a
    }
    offsetRight(a) {
        this._right += +a
    }
    offsetBottom(a) {
        this._bottom += +a
    }
    toSquare(a) {
        if ("x" !== a)
            throw Error("invalid axis, only 'x' supported");
        this._bottom = this._top < this._bottom ? this._left < this._right ? this._top + this.width() : this._top - this.width() : this._left < this._right ? this._top - this.width() : this._top + this.width()
    }
    inflate(a, b) {
        a = +a;
        b = +b;
        this._left -= a;
        this._top -= b;
        this._right += a;
        this._bottom += b
    }
    deflate(a, b) {
        a = +a;
        b = +b;
        this._left += a;
        this._top += b;
        this._right -= a;
        this._bottom -= b
    }
    multiply(a, b) {
        this._left *= a;
        this._top *= b;
        this._right *= a;
        this._bottom *= b
    }
    divide(a, b) {
        this._left /= a;
        this._top /= b;
        this._right /= a;
        this._bottom /= b
    }
    mirrorAround(a) {
        this._left = +a - this._left;
        this._right = +a - this._right
    }
    flipAround(a) {
        this._top = +a - this._top;
        this._bottom = +a - this._bottom
    }
    rotate90DegreesAround(a, b) {
        const d = this.width()
          , c = this.height()
          , e = this.getLeft() + d * a
          , g = this.getTop() + c * b;
        this.setWH(e - c * b, g - d * a, c, d)
    }
    swapLeftRight() {
        const a = this._left;
        this._left = this._right;
        this._right = a
    }
    swapTopBottom() {
        const a = this._top;
        this._top = this._bottom;
        this._bottom = a
    }
    shuntY(a) {
        const b = this._top;
        this._top = +a - this._bottom;
        this._bottom = +a - b
    }
    round() {
        this._left = Math.round(this._left);
        this._top = Math.round(this._top);
        this._right = Math.round(this._right);
        this._bottom = Math.round(this._bottom)
    }
    roundInner() {
        this._left = Math.ceil(this._left);
        this._top = Math.ceil(this._top);
        this._right = Math.floor(this._right);
        this._bottom = Math.floor(this._bottom)
    }
    roundOuter() {
        this._left = Math.floor(this._left);
        this._top = Math.floor(this._top);
        this._right = Math.ceil(this._right);
        this._bottom = Math.ceil(this._bottom)
    }
    floor() {
        this._left = Math.floor(this._left);
        this._top = Math.floor(this._top);
        this._right = Math.floor(this._right);
        this._bottom = Math.floor(this._bottom)
    }
    ceil() {
        this._left = Math.ceil(this._left);
        this._top = Math.ceil(this._top);
        this._right = Math.ceil(this._right);
        this._bottom = Math.ceil(this._bottom)
    }
    clamp(a, b, d, c) {
        this._left < a && (this._left = +a);
        this._top < b && (this._top = +b);
        this._right > d && (this._right = +d);
        this._bottom > c && (this._bottom = +c)
    }
    clampFlipped(a, b, d, c) {
        this._left < a && (this._left = +a);
        this._top > b && (this._top = +b);
        this._right > d && (this._right = +d);
        this._bottom < c && (this._bottom = +c)
    }
    normalize() {
        this._left > this._right && this.swapLeftRight();
        this._top > this._bottom && this.swapTopBottom()
    }
    intersectsRect(a) {
        return !(a._right < this._left || a._bottom < this._top || a._left > this._right || a._top > this._bottom)
    }
    intersectsRectOffset(a, b, d) {
        return !(a._right + b < this._left || a._bottom + d < this._top || a._left + b > this._right || a._top + d > this._bottom)
    }
    containsPoint(a, b) {
        return a >= this._left && a <= this._right && b >= this._top && b <= this._bottom
    }
    containsRect(a) {
        return a._left >= this._left && a._top >= this._top && a._right <= this._right && a._bottom <= this._bottom
    }
    expandToContain(a) {
        a._left < this._left && (this._left = +a._left);
        a._top < this._top && (this._top = +a._top);
        a._right > this._right && (this._right = +a._right);
        a._bottom > this._bottom && (this._bottom = +a._bottom)
    }
    lerpInto(a) {
        this._left = C3$jscomp$15.lerp(a._left, a._right, this._left);
        this._top = C3$jscomp$15.lerp(a._top, a._bottom, this._top);
        this._right = C3$jscomp$15.lerp(a._left, a._right, this._right);
        this._bottom = C3$jscomp$15.lerp(a._top, a._bottom, this._bottom)
    }
}
;
"use strict";
const C3$jscomp$16 = self.C3;
C3$jscomp$16.Quad = class {
    constructor(a, b, d, c, e, g, k, l) {
        this._bly = this._blx = this._bry = this._brx = this._try = this._trx = this._tly = this._tlx = 0;
        a instanceof C3$jscomp$16.Quad ? this.copy(a) : this.set(a || 0, b || 0, d || 0, c || 0, e || 0, g || 0, k || 0, l || 0)
    }
    set(a, b, d, c, e, g, k, l) {
        this._tlx = +a;
        this._tly = +b;
        this._trx = +d;
        this._try = +c;
        this._brx = +e;
        this._bry = +g;
        this._blx = +k;
        this._bly = +l
    }
    setRect(a, b, d, c) {
        this.set(a, b, d, b, d, c, a, c)
    }
    copy(a) {
        this._tlx = a._tlx;
        this._tly = a._tly;
        this._trx = a._trx;
        this._try = a._try;
        this._brx = a._brx;
        this._bry = a._bry;
        this._blx = a._blx;
        this._bly = a._bly
    }
    equals(a) {
        return this._tlx === a._tlx && this._tly === a._tly && this._trx === a._trx && this._try === a._try && this._brx === a._brx && this._bry === a._bry && this._blx === a._blx && this._bly === a._bly
    }
    setTlx(a) {
        this._tlx = +a
    }
    getTlx() {
        return this._tlx
    }
    setTly(a) {
        this._tly = +a
    }
    getTly() {
        return this._tly
    }
    setTrx(a) {
        this._trx = +a
    }
    getTrx() {
        return this._trx
    }
    setTry(a) {
        this._try = +a
    }
    getTry() {
        return this._try
    }
    setBrx(a) {
        this._brx = +a
    }
    getBrx() {
        return this._brx
    }
    setBry(a) {
        this._bry = +a
    }
    getBry() {
        return this._bry
    }
    setBlx(a) {
        this._blx = +a
    }
    getBlx() {
        return this._blx
    }
    setBly(a) {
        this._bly = +a
    }
    getBly() {
        return this._bly
    }
    toDOMQuad() {
        return new DOMQuad(new DOMPoint(this._tlx,this._tly),new DOMPoint(this._trx,this._try),new DOMPoint(this._brx,this._bry),new DOMPoint(this._blx,this._bly))
    }
    toArray() {
        return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly]
    }
    toTypedArray() {
        return new Float64Array(this.toArray())
    }
    writeToTypedArray(a, b) {
        a[b++] = this._tlx;
        a[b++] = this._tly;
        a[b++] = this._trx;
        a[b++] = this._try;
        a[b++] = this._brx;
        a[b++] = this._bry;
        a[b++] = this._blx;
        a[b] = this._bly
    }
    writeToTypedArray3D(a, b, d) {
        a[b++] = this._tlx;
        a[b++] = this._tly;
        a[b++] = d;
        a[b++] = this._trx;
        a[b++] = this._try;
        a[b++] = d;
        a[b++] = this._brx;
        a[b++] = this._bry;
        a[b++] = d;
        a[b++] = this._blx;
        a[b++] = this._bly;
        a[b] = d
    }
    offset(a, b) {
        a = +a;
        b = +b;
        this._tlx += a;
        this._tly += b;
        this._trx += a;
        this._try += b;
        this._brx += a;
        this._bry += b;
        this._blx += a;
        this._bly += b
    }
    round() {
        this._tlx = Math.round(this._tlx);
        this._tly = Math.round(this._tly);
        this._trx = Math.round(this._trx);
        this._try = Math.round(this._try);
        this._brx = Math.round(this._brx);
        this._bry = Math.round(this._bry);
        this._blx = Math.round(this._blx);
        this._bly = Math.round(this._bly)
    }
    floor() {
        this._tlx = Math.floor(this._tlx);
        this._tly = Math.floor(this._tly);
        this._trx = Math.floor(this._trx);
        this._try = Math.floor(this._try);
        this._brx = Math.floor(this._brx);
        this._bry = Math.floor(this._bry);
        this._blx = Math.floor(this._blx);
        this._bly = Math.floor(this._bly)
    }
    ceil() {
        this._tlx = Math.ceil(this._tlx);
        this._tly = Math.ceil(this._tly);
        this._trx = Math.ceil(this._trx);
        this._try = Math.ceil(this._try);
        this._brx = Math.ceil(this._brx);
        this._bry = Math.ceil(this._bry);
        this._blx = Math.ceil(this._blx);
        this._bly = Math.ceil(this._bly)
    }
    setFromRect(a) {
        this._tlx = a._left;
        this._tly = a._top;
        this._trx = a._right;
        this._try = a._top;
        this._brx = a._right;
        this._bry = a._bottom;
        this._blx = a._left;
        this._bly = a._bottom
    }
    setFromRotatedRect(a, b) {
        0 === b ? this.setFromRect(a) : this.setFromRotatedRectPrecalc(a, Math.sin(b), Math.cos(b))
    }
    setFromRotatedRectPrecalc(a, b, d) {
        const c = a._left * b
          , e = a._top * b
          , g = a._right * b;
        b *= a._bottom;
        const k = a._left * d
          , l = a._top * d
          , n = a._right * d;
        a = a._bottom * d;
        this._tlx = k - e;
        this._tly = l + c;
        this._trx = n - e;
        this._try = l + g;
        this._brx = n - b;
        this._bry = a + g;
        this._blx = k - b;
        this._bly = a + c
    }
    getBoundingBox(a) {
        a.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly))
    }
    containsPoint(a, b) {
        var d = this._trx - this._tlx
          , c = this._try - this._tly;
        const e = this._brx - this._tlx
          , g = this._bry - this._tly;
        a -= this._tlx;
        b -= this._tly;
        var k = d * d + c * c;
        let l = d * e + c * g;
        c = d * a + c * b;
        const n = e * e + g * g
          , p = e * a + g * b;
        let t = 1 / (k * n - l * l);
        d = (n * c - l * p) * t;
        k = (k * p - l * c) * t;
        if (0 <= d && 0 < k && 1 > d + k)
            return !0;
        d = this._blx - this._tlx;
        c = this._bly - this._tly;
        k = d * d + c * c;
        l = d * e + c * g;
        c = d * a + c * b;
        t = 1 / (k * n - l * l);
        d = (n * c - l * p) * t;
        k = (k * p - l * c) * t;
        return 0 <= d && 0 < k && 1 > d + k
    }
    midX() {
        return (this._tlx + this._trx + this._brx + this._blx) / 4
    }
    midY() {
        return (this._tly + this._try + this._bry + this._bly) / 4
    }
    intersectsSegment(a, b, d, c) {
        return this.containsPoint(a, b) || this.containsPoint(d, c) ? !0 : C3$jscomp$16.segmentIntersectsQuad(a, b, d, c, this)
    }
    intersectsQuad(a) {
        var b = a.midX()
          , d = a.midY();
        if (this.containsPoint(b, d))
            return !0;
        b = this.midX();
        d = this.midY();
        if (a.containsPoint(b, d))
            return !0;
        b = this._tlx;
        d = this._tly;
        const c = this._trx
          , e = this._try
          , g = this._brx
          , k = this._bry
          , l = this._blx
          , n = this._bly;
        return C3$jscomp$16.segmentIntersectsQuad(b, d, c, e, a) || C3$jscomp$16.segmentIntersectsQuad(c, e, g, k, a) || C3$jscomp$16.segmentIntersectsQuad(g, k, l, n, a) || C3$jscomp$16.segmentIntersectsQuad(l, n, b, d, a)
    }
    rotatePointsAnticlockwise() {
        const a = this._tlx
          , b = this._tly;
        this._tlx = this._trx;
        this._tly = this._try;
        this._trx = this._brx;
        this._try = this._bry;
        this._brx = this._blx;
        this._bry = this._bly;
        this._blx = a;
        this._bly = b
    }
    mirror() {
        this._swap(0, 2);
        this._swap(1, 3);
        this._swap(6, 4);
        this._swap(7, 5)
    }
    flip() {
        this._swap(0, 6);
        this._swap(1, 7);
        this._swap(2, 4);
        this._swap(3, 5)
    }
    diag() {
        this._swap(2, 6);
        this._swap(3, 7)
    }
    _swap(a, b) {
        const d = this._getAtIndex(a);
        this._setAtIndex(a, this._getAtIndex(b));
        this._setAtIndex(b, d)
    }
    _getAtIndex(a) {
        switch (a) {
        case 0:
            return this._tlx;
        case 1:
            return this._tly;
        case 2:
            return this._trx;
        case 3:
            return this._try;
        case 4:
            return this._brx;
        case 5:
            return this._bry;
        case 6:
            return this._blx;
        case 7:
            return this._bly;
        default:
            throw new RangeError("invalid quad point index");
        }
    }
    _setAtIndex(a, b) {
        b = +b;
        switch (a) {
        case 0:
            this._tlx = b;
            break;
        case 1:
            this._tly = b;
            break;
        case 2:
            this._trx = b;
            break;
        case 3:
            this._try = b;
            break;
        case 4:
            this._brx = b;
            break;
        case 5:
            this._bry = b;
            break;
        case 6:
            this._blx = b;
            break;
        case 7:
            this._bly = b;
            break;
        default:
            throw new RangeError("invalid quad point index");
        }
    }
}
;
"use strict";
const C3$jscomp$17 = self.C3
  , DEFAULT_POLY_POINTS = [0, 0, 1, 0, 1, 1, 0, 1]
  , tempQuad = C3$jscomp$17.New(C3$jscomp$17.Quad);
C3$jscomp$17.CollisionPoly = class extends C3$jscomp$17.DefendedBase {
    constructor(a, b=!0) {
        super();
        a || (a = DEFAULT_POLY_POINTS);
        this._ptsArr = Float64Array.from(a);
        this._bbox = new C3$jscomp$17.Rect;
        this._isBboxChanged = !0;
        this._enabled = b
    }
    Release() {}
    pointsArr() {
        return this._ptsArr
    }
    pointCount() {
        return this._ptsArr.length / 2
    }
    setPoints(a) {
        this._ptsArr.length === a.length ? this._ptsArr.set(a) : this._ptsArr = Float64Array.from(a);
        this._isBboxChanged = !0
    }
    setDefaultPoints() {
        this.setPoints(DEFAULT_POLY_POINTS)
    }
    copy(a) {
        this.setPoints(a._ptsArr)
    }
    setBboxChanged() {
        this._isBboxChanged = !0
    }
    _updateBbox() {
        if (this._isBboxChanged) {
            var a = this._ptsArr
              , b = a[0]
              , d = a[1]
              , c = b
              , e = d;
            for (let g = 0, k = a.length; g < k; g += 2) {
                const l = a[g]
                  , n = a[g + 1];
                l < b && (b = l);
                l > c && (c = l);
                n < d && (d = n);
                n > e && (e = n)
            }
            this._bbox.set(b, d, c, e);
            this._isBboxChanged = !1
        }
    }
    setFromRect(a, b, d) {
        let c = this._ptsArr;
        8 !== c.length && (this._ptsArr = c = new Float64Array(8));
        c[0] = a.getLeft() - b;
        c[1] = a.getTop() - d;
        c[2] = a.getRight() - b;
        c[3] = a.getTop() - d;
        c[4] = a.getRight() - b;
        c[5] = a.getBottom() - d;
        c[6] = a.getLeft() - b;
        c[7] = a.getBottom() - d;
        this._bbox.copy(a);
        0 === b && 0 === d || this._bbox.offset(-b, -d);
        this._isBboxChanged = !1
    }
    setFromQuad(a, b, d) {
        tempQuad.copy(a);
        tempQuad.offset(b, d);
        this.setPoints(tempQuad.toArray());
        this._isBboxChanged = !0
    }
    transform(a, b, d) {
        let c = 0
          , e = 1;
        0 !== d && (c = Math.sin(d),
        e = Math.cos(d));
        this.transformPrecalc(a, b, c, e)
    }
    transformPrecalc(a, b, d, c) {
        const e = this._ptsArr;
        for (let g = 0, k = e.length; g < k; g += 2) {
            const l = g + 1
              , n = e[g] * a
              , p = e[l] * b;
            e[g] = n * c - p * d;
            e[l] = p * c + n * d
        }
        this._isBboxChanged = !0
    }
    offset(a, b) {
        const d = this._ptsArr;
        for (let c = 0, e = d.length; c < e; c += 2)
            d[c] += a,
            d[c + 1] += b
    }
    containsPoint(a, b) {
        const d = this._ptsArr;
        if (a === d[0] && b === d[1])
            return !0;
        this._updateBbox();
        var c = this._bbox;
        const e = c.getLeft() - 110
          , g = c.getTop() - 101
          , k = c.getRight() + 131;
        c = c.getBottom() + 120;
        let l, n, p, t, w, z, B, C;
        e < a ? (l = e,
        p = a) : (l = a,
        p = e);
        g < b ? (n = g,
        t = b) : (n = b,
        t = g);
        k < a ? (w = k,
        B = a) : (w = a,
        B = k);
        c < b ? (z = c,
        C = b) : (z = b,
        C = c);
        let E = 0
          , F = 0;
        for (let K = 0, M = d.length; K < M; K += 2) {
            var J = (K + 2) % M;
            const U = d[K]
              , X = d[K + 1]
              , R = d[J];
            J = d[J + 1];
            C3$jscomp$17.segmentsIntersectPreCalc(e, g, a, b, l, p, n, t, U, X, R, J) && ++E;
            C3$jscomp$17.segmentsIntersectPreCalc(k, c, a, b, w, B, z, C, U, X, R, J) && ++F
        }
        return 1 === E % 2 || 1 === F % 2
    }
    intersectsPoly(a, b, d) {
        const c = a._ptsArr
          , e = this._ptsArr;
        if (this.containsPoint(c[0] + b, c[1] + d) || a.containsPoint(e[0] - b, e[1] - d))
            return !0;
        for (let k = 0, l = e.length; k < l; k += 2) {
            var g = (k + 2) % l;
            a = e[k];
            const n = e[k + 1]
              , p = e[g];
            g = e[g + 1];
            let t, w, z, B;
            a < p ? (t = a,
            z = p) : (t = p,
            z = a);
            n < g ? (w = n,
            B = g) : (w = g,
            B = n);
            for (let C = 0, E = c.length; C < E; C += 2) {
                const F = (C + 2) % E;
                if (C3$jscomp$17.segmentsIntersectPreCalc(a, n, p, g, t, z, w, B, c[C] + b, c[C + 1] + d, c[F] + b, c[F + 1] + d))
                    return !0
            }
        }
        return !1
    }
    intersectsSegment(a, b, d, c, e, g) {
        if (this.containsPoint(d - a, c - b) || this.containsPoint(e - a, g - b))
            return !0;
        let k, l, n, p;
        d < e ? (k = d,
        n = e) : (k = e,
        n = d);
        c < g ? (l = c,
        p = g) : (l = g,
        p = c);
        const t = this._ptsArr;
        for (let w = 0, z = t.length; w < z; w += 2) {
            const B = (w + 2) % z;
            if (C3$jscomp$17.segmentsIntersectPreCalc(d, c, e, g, k, n, l, p, t[w] + a, t[w + 1] + b, t[B] + a, t[B + 1] + b))
                return !0
        }
        return !1
    }
    mirror(a) {
        const b = this._ptsArr;
        for (let d = 0, c = b.length; d < c; d += 2)
            b[d] = 2 * a - b[d];
        this._isBboxChanged = !0
    }
    flip(a) {
        const b = this._ptsArr;
        for (let d = 0, c = b.length; d < c; d += 2) {
            const e = d + 1;
            b[e] = 2 * a - b[e]
        }
        this._isBboxChanged = !0
    }
    diag() {
        const a = this._ptsArr;
        for (let b = 0, d = a.length; b < d; b += 2) {
            const c = b + 1
              , e = a[b];
            a[b] = a[c];
            a[c] = e
        }
        this._isBboxChanged = !0
    }
    GetMidX() {
        const a = this._ptsArr;
        let b = 0;
        for (let d = 0, c = a.length; d < c; d += 2)
            b += a[d];
        return b / this.pointCount()
    }
    GetMidY() {
        const a = this._ptsArr;
        let b = 0;
        for (let d = 0, c = a.length; d < c; d += 2)
            b += a[d + 1];
        return b / this.pointCount()
    }
    GetPointsArray() {
        return this._ptsArr
    }
    GetPointCount() {
        return this.pointCount()
    }
    IsEnabled() {
        return this._enabled
    }
}
;
"use strict";
const C3$jscomp$18 = self.C3;
C3$jscomp$18.PairMap = class extends C3$jscomp$18.DefendedBase {
    constructor(a) {
        super();
        this._firstMap = new Map;
        if (a)
            for (const [b,d,c] of a)
                this.Set(b, d, c)
    }
    Release() {
        this.Clear();
        this._firstMap = null
    }
    Clear() {
        const a = this._firstMap;
        for (const b of a.values())
            b.clear();
        a.clear()
    }
    Set(a, b, d) {
        const c = this._firstMap;
        let e = c.get(a);
        e || (e = new Map,
        c.set(a, e));
        e.set(b, d)
    }
    Get(a, b) {
        return (a = this._firstMap.get(a)) ? a.get(b) : a
    }
    Has(a, b) {
        return (a = this._firstMap.get(a)) ? a.has(b) : !1
    }
    Delete(a, b) {
        const d = this._firstMap
          , c = d.get(a);
        if (!c)
            return !1;
        (b = c.delete(b)) && 0 === c.size && d.delete(a);
        return b
    }
    DeleteEither(a) {
        const b = this._firstMap
          , d = b.get(a);
        d && (d.clear(),
        b.delete(a));
        for (const [c,e] of b.entries())
            e.delete(a) && 0 === e.size && b.delete(c)
    }
    GetSize() {
        let a = 0;
        for (const b of this._firstMap.values())
            a += b.size;
        return a
    }
    *values() {
        for (const a of this._firstMap.values())
            yield*a.values()
    }
    *keyPairs() {
        for (const [a,b] of this._firstMap.entries())
            for (const d of b.keys())
                yield[a, d]
    }
    *entries() {
        for (const [a,b] of this._firstMap.entries())
            for (const [d,c] of b.entries())
                yield[a, d, c]
    }
}
;
"use strict";
const C3$jscomp$19 = self.C3;
C3$jscomp$19.ArraySet = class extends C3$jscomp$19.DefendedBase {
    constructor() {
        super();
        this._set = new Set;
        this._arr = [];
        this._needToRebuildArray = !1
    }
    Release() {
        this.Clear()
    }
    Clear() {
        this._set.clear();
        C3$jscomp$19.clearArray(this._arr);
        this._needToRebuildArray = !1
    }
    Add(a) {
        this._set.has(a) || (this._set.add(a),
        this._needToRebuildArray || this._arr.push(a))
    }
    Has(a) {
        return this._set.has(a)
    }
    Delete(a) {
        this._set.delete(a) && (this._needToRebuildArray = !0)
    }
    GetSize() {
        return this._set.size
    }
    IsEmpty() {
        return 0 === this._set.size
    }
    GetArray() {
        this._needToRebuildArray && (this._RebuildArray(),
        this._needToRebuildArray = !1);
        return this._arr
    }
    _RebuildArray() {
        const a = this._arr;
        C3$jscomp$19.clearArray(a);
        for (const b of this._set)
            a.push(b)
    }
}
;
"use strict";
const C3$jscomp$20 = self.C3
  , EASE_MAP = new Map
  , PREDEFINED_EASE_MAP = new Map
  , CUSTOM_EASE_EDITOR_MAP = new Map
  , CUSTOM_EASE_RUNTIME_MAP = new Map
  , PRIVATE_EASE_MAP = new Map
  , BUILT_IN_TRANSITION_MAP = new Map
  , ALIAS_MAP = new Map;
ALIAS_MAP.set("linear", "noease");
ALIAS_MAP.set("default", "noease");
const EASE_TRANSLATION_KEYS = "default noease easeinquad easeoutquad easeinoutquad easeincubic easeoutcubic easeinoutcubic easeinquart easeoutquart easeinoutquart easeinquint easeoutquint easeinoutquint easeinsine easeoutsine easeinoutsine easeinexpo easeoutexpo easeinoutexpo easeincirc easeoutcirc easeinoutcirc easeinelastic easeoutelastic easeinoutelastic easeinback easeoutback easeinoutback easeinbounce easeoutbounce easeinoutbounce".split(" ")
  , SHORT_EASE_TRANSLATION_KEYS = "default noease quad cubic quart quint sine expo circ elastic back bounce".split(" ")
  , EASE_API2INTERNAL_NAMES = new Map([["linear", "noease"], ["in-sine", "easeinsine"], ["out-sine", "easeoutsine"], ["in-out-sine", "easeinoutsine"], ["in-elastic", "easeinelastic"], ["out-elastic", "easeoutelastic"], ["in-out-elastic", "easeinoutelastic"], ["in-back", "easeinback"], ["out-back", "easeoutback"], ["in-out-back", "easeinoutback"], ["in-bounce", "easeinbounce"], ["out-bounce", "easeoutbounce"], ["in-out-bounce", "easeinoutbounce"], ["in-cubic", "easeincubic"], ["out-cubic", "easeoutcubic"], ["in-out-cubic", "easeinoutcubic"], ["in-quadratic", "easeinquad"], ["out-quadratic", "easeoutquad"], ["in-out-quadratic", "easeinoutquad"], ["in-quartic", "easeinquart"], ["out-quartic", "easeoutquart"], ["in-out-quartic", "easeinoutquart"], ["in-quintic", "easeinquint"], ["out-quintic", "easeoutquint"], ["in-out-quintic", "easeinoutquint"], ["in-circular", "easeincirc"], ["out-circular", "easeoutcirc"], ["in-out-circular", "easeinoutcirc"], ["in-exponential", "easeinexpo"], ["out-exponential", "easeoutexpo"], ["in-out-exponential", "easeinoutexpo"]]);
self.Ease = class a {
    constructor() {}
    static InheritEase() {
        return "default"
    }
    static DefaultEase() {
        return "noease"
    }
    static ToInternal(b) {
        return EASE_API2INTERNAL_NAMES.get(b)
    }
    static GetEditorEaseNames(b, ...d) {
        this._CreateEaseMap();
        b ? (CUSTOM_EASE_EDITOR_MAP.has(b) || CUSTOM_EASE_EDITOR_MAP.set(b, new Map),
        b = CUSTOM_EASE_EDITOR_MAP.get(b)) : b = CUSTOM_EASE_RUNTIME_MAP;
        b = [...b.keys()];
        b.sort();
        return [...PREDEFINED_EASE_MAP.keys()].concat(b).filter(c=>!d.includes(c))
    }
    static GetRuntimeEaseNames() {
        this._CreateEaseMap();
        const b = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
        b.sort();
        return [...PREDEFINED_EASE_MAP.keys()].concat(b)
    }
    static GetCustomRuntimeEaseNames() {
        this._CreateEaseMap();
        const b = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
        b.sort();
        return b
    }
    static IsPredefinedTranslatedName(b) {
        for (const d of EASE_TRANSLATION_KEYS)
            if (self.lang(`ui.bars.timeline.eases.${d}`) === b)
                return !0;
        for (const d of SHORT_EASE_TRANSLATION_KEYS)
            if (self.lang(`ui.bars.timeline.short-eases.${d}`) === b)
                return !0
    }
    static IsNamePredefined(b) {
        this._CreateEaseMap();
        return [...PREDEFINED_EASE_MAP.keys()].includes(b)
    }
    static _GetEase(b) {
        const d = ALIAS_MAP.get(b);
        if (d)
            return EASE_MAP.get(d);
        if (a.IsNamePredefined(b))
            return EASE_MAP.get(b);
        if (PRIVATE_EASE_MAP.has(b))
            return PRIVATE_EASE_MAP.get(b)
    }
    static GetBuiltInTransition(b) {
        this._CreateEaseMap();
        return BUILT_IN_TRANSITION_MAP.get(b)
    }
    static GetEditorEase(b, d) {
        this._CreateEaseMap();
        const c = a._GetEase(b);
        if (c)
            return c;
        if (!d)
            throw Error("missing ease function");
        return CUSTOM_EASE_EDITOR_MAP.get(d).get(b)
    }
    static GetRuntimeEase(b) {
        this._CreateEaseMap();
        const d = a._GetEase(b);
        return d ? d : CUSTOM_EASE_RUNTIME_MAP.get(b)
    }
    static GetEaseFromIndex(b) {
        this._CreateEaseMap();
        return this.GetRuntimeEaseNames()[b]
    }
    static GetIndexForEase(b, d) {
        this._CreateEaseMap();
        return this.GetEditorEaseNames(d).indexOf(b)
    }
    static GetIndexForEaseAtRuntime(b) {
        return this.GetIndexForEase(b)
    }
    static _CreateEaseMap() {
        0 === EASE_MAP.size && (this._AddPredifinedEase("default", ()=>{}
        ),
        this._AddPredifinedEase("noease", [{
            x: 0,
            y: 0,
            sax: .336,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.336,
            eay: 0,
            se: !1,
            ee: !0
        }], !0),
        this._AddPredifinedEase("easeinsine", [{
            x: 0,
            y: 0,
            sax: .485,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.038,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutsine", [{
            x: 0,
            y: 0,
            sax: .038,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.485,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutsine", [{
            x: 0,
            y: 0,
            sax: .336,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.336,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinelastic", [{
            x: 0,
            y: 0,
            sax: .018,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .116,
            y: .002,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .266,
            y: -.005,
            sax: .024,
            say: 0,
            eax: -.021,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .416,
            y: .016,
            sax: .024,
            say: 0,
            eax: -.026,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .566,
            y: -.045,
            sax: .061,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .716,
            y: .132,
            sax: .072,
            say: -.004,
            eax: -.045,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .866,
            y: -.373,
            sax: .06,
            say: 0,
            eax: -.049,
            eay: -.002,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.038,
            eay: -.263,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutelastic", [{
            x: 0,
            y: 0,
            sax: .038,
            say: .263,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .136,
            y: 1.373,
            sax: .049,
            say: .002,
            eax: -.06,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .286,
            y: .868,
            sax: .045,
            say: 0,
            eax: -.072,
            eay: .004,
            se: !0,
            ee: !0
        }, {
            x: .436,
            y: 1.045,
            sax: .025,
            say: 0,
            eax: -.061,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .586,
            y: .984,
            sax: .026,
            say: 0,
            eax: -.024,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .736,
            y: 1.005,
            sax: .021,
            say: 0,
            eax: -.024,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .886,
            y: .998,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.018,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutelastic", [{
            x: 0,
            y: 0,
            sax: .025,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .067,
            y: .001,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .18,
            y: -.005,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .292,
            y: .025,
            sax: .053,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .405,
            y: -.118,
            sax: .069,
            say: 0,
            eax: -.027,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .597,
            y: 1.118,
            sax: .027,
            say: 0,
            eax: -.069,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .71,
            y: .975,
            sax: .025,
            say: 0,
            eax: -.053,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .822,
            y: 1.005,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .935,
            y: .999,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinback", [{
            x: 0,
            y: 0,
            sax: .35,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.34,
            eay: -1.579,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutback", [{
            x: 0,
            y: 0,
            sax: .34,
            say: 1.579,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.35,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutback", [{
            x: 0,
            y: 0,
            sax: .035,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .242,
            y: -.1,
            sax: .258,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .76,
            y: 1.1,
            sax: .025,
            say: 0,
            eax: -.26,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.035,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinbounce", [{
            x: 0,
            y: 0,
            sax: .033,
            say: .025,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .092,
            y: 0,
            sax: .026,
            say: .078,
            eax: -.033,
            eay: .025,
            se: !0,
            ee: !0
        }, {
            x: .274,
            y: 0,
            sax: .097,
            say: .319,
            eax: -.026,
            eay: .078,
            se: !0,
            ee: !0
        }, {
            x: .637,
            y: 0,
            sax: .105,
            say: .625,
            eax: -.097,
            eay: .319,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.125,
            eay: -.004,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutbounce", [{
            x: 0,
            y: 0,
            sax: .125,
            say: .004,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .365,
            y: 1,
            sax: .097,
            say: -.319,
            eax: -.105,
            eay: -.625,
            se: !0,
            ee: !0
        }, {
            x: .728,
            y: 1,
            sax: .026,
            say: -.078,
            eax: -.097,
            eay: -.319,
            se: !0,
            ee: !0
        }, {
            x: .91,
            y: 1,
            sax: .033,
            say: -.025,
            eax: -.026,
            eay: -.078,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.033,
            eay: -.025,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutbounce", [{
            x: 0,
            y: 0,
            sax: .01,
            say: .006,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .046,
            y: 0,
            sax: .021,
            say: .038,
            eax: -.01,
            eay: .006,
            se: !0,
            ee: !0
        }, {
            x: .137,
            y: 0,
            sax: .059,
            say: .158,
            eax: -.021,
            eay: .038,
            se: !0,
            ee: !0
        }, {
            x: .319,
            y: 0,
            sax: .117,
            say: .744,
            eax: -.059,
            eay: .158,
            se: !0,
            ee: !0
        }, {
            x: .683,
            y: 1,
            sax: .059,
            say: -.158,
            eax: -.117,
            eay: -.744,
            se: !0,
            ee: !0
        }, {
            x: .865,
            y: 1,
            sax: .021,
            say: -.038,
            eax: -.059,
            eay: -.158,
            se: !0,
            ee: !0
        }, {
            x: .956,
            y: 1,
            sax: .01,
            say: -.006,
            eax: -.021,
            eay: -.038,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.01,
            eay: -.006,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeincubic", [{
            x: 0,
            y: 0,
            sax: .75,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.138,
            eay: -.321,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutcubic", [{
            x: 0,
            y: 0,
            sax: .138,
            say: .321,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.75,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutcubic", [{
            x: 0,
            y: 0,
            sax: .285,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .5,
            y: .5,
            sax: .081,
            say: .272,
            eax: -.081,
            eay: -.272,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.285,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinquad", [{
            x: 0,
            y: 0,
            sax: .4,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.178,
            eay: -.392,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutquad", [{
            x: 0,
            y: 0,
            sax: .178,
            say: .392,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.4,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutquad", [{
            x: 0,
            y: 0,
            sax: .25,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .5,
            y: .5,
            sax: .03,
            say: .065,
            eax: -.03,
            eay: -.065,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.25,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinquart", [{
            x: 0,
            y: 0,
            sax: .264,
            say: .079,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.329,
            eay: -1.287,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutquart", [{
            x: 0,
            y: 0,
            sax: .329,
            say: 1.287,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.264,
            eay: -.079,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutquart", [{
            x: 0,
            y: 0,
            sax: .765,
            say: .03,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.765,
            eay: -.03,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinquint", [{
            x: 0,
            y: 0,
            sax: .6,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.2,
            eay: -1,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutquint", [{
            x: 0,
            y: 0,
            sax: .2,
            say: 1,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.6,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutquint", [{
            eax: 0,
            eay: 0,
            ee: !1,
            sax: .84,
            say: 0,
            se: !0,
            x: 0,
            y: 0
        }, {
            eax: -.84,
            eay: 0,
            ee: !0,
            sax: 0,
            say: 0,
            se: !1,
            x: 1,
            y: 1
        }]),
        this._AddPredifinedEase("easeincirc", [{
            x: 0,
            y: 0,
            sax: .25,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.024,
            eay: -.808,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutcirc", [{
            x: 0,
            y: 0,
            sax: .024,
            say: .808,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.25,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutcirc", [{
            x: 0,
            y: 0,
            sax: .125,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .5,
            y: .5,
            sax: .02,
            say: .428,
            eax: -.02,
            eay: -.428,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.125,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinexpo", [{
            x: 0,
            y: 0,
            sax: .66,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.14,
            eay: -1,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeoutexpo", [{
            x: 0,
            y: 0,
            sax: .14,
            say: 1,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.66,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinoutexpo", [{
            eax: 0,
            eay: 0,
            ee: !1,
            sax: .345,
            say: 0,
            se: !0,
            x: 0,
            y: 0
        }, {
            eax: -.06,
            eay: -.5,
            ee: !0,
            sax: .06,
            say: .5,
            se: !0,
            x: .5,
            y: .5
        }, {
            eax: -.335,
            eay: 0,
            ee: !0,
            sax: 0,
            say: 0,
            se: !1,
            x: 1,
            y: 1
        }]),
        this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier),
        this._AddPrivateCustomEase("spline", this.EaseSpline))
    }
    static _AddPredifinedEase(b, d, c=!1) {
        if ("function" === typeof d)
            a._AddEase(b, d, "predefined");
        else if (C3$jscomp$20.IsArray(d))
            if (self.BuiltInTransition) {
                const e = C3$jscomp$20.New(self.BuiltInTransition, b, c);
                e.SetFromJson(d);
                a._AddEase(b, (g,k,l,n)=>e.Interpolate(g, k, l, n), "predefined");
                BUILT_IN_TRANSITION_MAP.set(b, e)
            } else {
                const e = C3$jscomp$20.New(C3$jscomp$20.Transition, [b, d.map(g=>[g.x, g.y, g.sax, g.say, g.eax, g.eay, g.se, g.ee])], !1);
                e.MakeLinear(c);
                a._AddEase(b, (g,k,l,n)=>e.Interpolate(g, k, l, n), "predefined")
            }
        else
            throw Error("unexpected arguments");
    }
    static _AddPrivateCustomEase(b, d) {
        a._AddEase(b, d, "private")
    }
    static AddCustomEase(b, d, c) {
        this._CreateEaseMap();
        a._AddEase(b, d, "custom", c)
    }
    static RemoveCustomEase(b, d) {
        this.IsNamePredefined(b) || [...PRIVATE_EASE_MAP.keys()].includes(b) || (d = CUSTOM_EASE_EDITOR_MAP.get(d)) && d.delete(b)
    }
    static _AddEase(b, d, c, e) {
        switch (c) {
        case "predefined":
            EASE_MAP.set(b, d);
            PREDEFINED_EASE_MAP.set(b, d);
            break;
        case "custom":
            e ? (CUSTOM_EASE_EDITOR_MAP.has(e) || CUSTOM_EASE_EDITOR_MAP.set(e, new Map),
            CUSTOM_EASE_EDITOR_MAP.get(e).set(b, d)) : CUSTOM_EASE_RUNTIME_MAP.set(b, d);
            break;
        case "private":
            EASE_MAP.set(b, d);
            PRIVATE_EASE_MAP.set(b, d);
            break;
        default:
            throw Error("unexpected ease mode");
        }
    }
    static NoEase(b, d, c, e) {
        return c * b / e + d
    }
    static EaseInQuad(b, d, c, e) {
        return c * (b /= e) * b + d
    }
    static EaseOutQuad(b, d, c, e) {
        return -c * (b /= e) * (b - 2) + d
    }
    static EaseInOutQuad(b, d, c, e) {
        return 1 > (b /= e / 2) ? c / 2 * b * b + d : -c / 2 * (--b * (b - 2) - 1) + d
    }
    static EaseInCubic(b, d, c, e) {
        return c * (b /= e) * b * b + d
    }
    static EaseOutCubic(b, d, c, e) {
        return c * ((b = b / e - 1) * b * b + 1) + d
    }
    static EaseInOutCubic(b, d, c, e) {
        return 1 > (b /= e / 2) ? c / 2 * b * b * b + d : c / 2 * ((b -= 2) * b * b + 2) + d
    }
    static EaseInQuart(b, d, c, e) {
        return c * (b /= e) * b * b * b + d
    }
    static EaseOutQuart(b, d, c, e) {
        return -c * ((b = b / e - 1) * b * b * b - 1) + d
    }
    static EaseInOutQuart(b, d, c, e) {
        return 1 > (b /= e / 2) ? c / 2 * b * b * b * b + d : -c / 2 * ((b -= 2) * b * b * b - 2) + d
    }
    static EaseInQuint(b, d, c, e) {
        return c * (b /= e) * b * b * b * b + d
    }
    static EaseOutQuint(b, d, c, e) {
        return c * ((b = b / e - 1) * b * b * b * b + 1) + d
    }
    static EaseInOutQuint(b, d, c, e) {
        return 1 > (b /= e / 2) ? c / 2 * b * b * b * b * b + d : c / 2 * ((b -= 2) * b * b * b * b + 2) + d
    }
    static EaseInSine(b, d, c, e) {
        return -c * Math.cos(b / e * (Math.PI / 2)) + c + d
    }
    static EaseOutSine(b, d, c, e) {
        return c * Math.sin(b / e * (Math.PI / 2)) + d
    }
    static EaseInOutSine(b, d, c, e) {
        return -c / 2 * (Math.cos(Math.PI * b / e) - 1) + d
    }
    static EaseInExpo(b, d, c, e) {
        return 0 === b ? d : c * Math.pow(2, 10 * (b / e - 1)) + d
    }
    static EaseOutExpo(b, d, c, e) {
        return b === e ? d + c : c * (-Math.pow(2, -10 * b / e) + 1) + d
    }
    static EaseInOutExpo(b, d, c, e) {
        return 0 === b ? d : b === e ? d + c : 1 > (b /= e / 2) ? c / 2 * Math.pow(2, 10 * (b - 1)) + d : c / 2 * (-Math.pow(2, -10 * --b) + 2) + d
    }
    static EaseInCirc(b, d, c, e) {
        return -c * (Math.sqrt(1 - (b /= e) * b) - 1) + d
    }
    static EaseOutCirc(b, d, c, e) {
        return c * Math.sqrt(1 - (b = b / e - 1) * b) + d
    }
    static EaseInOutCirc(b, d, c, e) {
        return 1 > (b /= e / 2) ? -c / 2 * (Math.sqrt(1 - b * b) - 1) + d : c / 2 * (Math.sqrt(1 - (b -= 2) * b) + 1) + d
    }
    static EaseInElastic(b, d, c, e) {
        let g = 0
          , k = c;
        if (0 === b)
            return d;
        if (1 === (b /= e))
            return d + c;
        g || (g = .3 * e);
        k < Math.abs(c) ? (k = c,
        c = g / 4) : c = g / (2 * Math.PI) * Math.asin(c / k);
        return -(k * Math.pow(2, 10 * --b) * Math.sin(2 * (b * e - c) * Math.PI / g)) + d
    }
    static EaseOutElastic(b, d, c, e) {
        let g, k = 0, l = c;
        if (0 === b)
            return d;
        if (1 === (b /= e))
            return d + c;
        k || (k = .3 * e);
        l < Math.abs(c) ? (l = c,
        g = k / 4) : g = k / (2 * Math.PI) * Math.asin(c / l);
        return l * Math.pow(2, -10 * b) * Math.sin(2 * (b * e - g) * Math.PI / k) + c + d
    }
    static EaseInOutElastic(b, d, c, e) {
        let g, k = 0, l = c;
        if (0 === b)
            return d;
        if (2 === (b /= e / 2))
            return d + c;
        k || (k = .3 * e * 1.5);
        l < Math.abs(c) ? (l = c,
        g = k / 4) : g = k / (2 * Math.PI) * Math.asin(c / l);
        return 1 > b ? -.5 * l * Math.pow(2, 10 * --b) * Math.sin(2 * (b * e - g) * Math.PI / k) + d : l * Math.pow(2, -10 * --b) * Math.sin(2 * (b * e - g) * Math.PI / k) * .5 + c + d
    }
    static EaseInBack(b, d, c, e, g) {
        void 0 === g && (g = 1.70158);
        return c * (b /= e) * b * ((g + 1) * b - g) + d
    }
    static EaseOutBack(b, d, c, e, g) {
        void 0 === g && (g = 1.70158);
        return c * ((b = b / e - 1) * b * ((g + 1) * b + g) + 1) + d
    }
    static EaseInOutBack(b, d, c, e, g) {
        void 0 === g && (g = 1.70158);
        return 1 > (b /= e / 2) ? c / 2 * b * b * (((g *= 1.525) + 1) * b - g) + d : c / 2 * ((b -= 2) * b * (((g *= 1.525) + 1) * b + g) + 2) + d
    }
    static EaseInBounce(b, d, c, e) {
        return c - a.EaseOutBounce(e - b, 0, c, e) + d
    }
    static EaseOutBounce(b, d, c, e) {
        return (b /= e) < 1 / 2.75 ? 7.5625 * c * b * b + d : b < 2 / 2.75 ? c * (7.5625 * (b -= 1.5 / 2.75) * b + .75) + d : b < 2.5 / 2.75 ? c * (7.5625 * (b -= 2.25 / 2.75) * b + .9375) + d : c * (7.5625 * (b -= 2.625 / 2.75) * b + .984375) + d
    }
    static EaseInOutBounce(b, d, c, e) {
        return b < e / 2 ? .5 * a.EaseInBounce(2 * b, 0, c, e) + d : .5 * a.EaseOutBounce(2 * b - e, 0, c, e) + .5 * c + d
    }
    static EaseCubicBezier(b, d, c, e, g) {
        return d + 3 * b * (c - d) + 3 * b ** 2 * (d + e - 2 * c) + b ** 3 * (g - d + 3 * c - 3 * e)
    }
    static EaseSpline(b, d, c, e, g, k, l, n, p, t) {
        if (e === g && k === l)
            return b;
        b = get_t_for_x(b, d, e, k, n, t);
        d = a$jscomp$281(c, g, l, p);
        e = b$jscomp$150(c, g, l, p);
        c = c$jscomp$42(c, g, l, p);
        return calc_bezier(b, d, e, c)
    }
    static GetBezierSamples(b, d, c, e) {
        const g = []
          , k = a$jscomp$281(b, d, c, e)
          , l = b$jscomp$150(b, d, c, e);
        b = c$jscomp$42(b, d, c, e);
        for (d = 0; 11 > d; ++d)
            c = calc_bezier(d * SAMPLE_STEP, k, l, b),
            g.push(c);
        return g
    }
}
;
const SAMPLE_STEP = .1
  , a$jscomp$281 = (a,b,d,c)=>c - 3 * d + 3 * b - a
  , b$jscomp$150 = (a,b,d,c)=>3 * d - 6 * b + 3 * a
  , c$jscomp$42 = (a,b,d,c)=>3 * (b - a)
  , calc_bezier = (a,b,d,c)=>((b * a + d) * a + c) * a
  , get_slope = (a,b,d,c)=>3 * b * a * a + 2 * d * a + c
  , get_t_for_x = (a,b,d,c,e,g)=>{
    if (1 == a)
        return 1;
    for (var k = 0, l = 1, n = g[l]; 10 != l && n <= a; )
        l++,
        n = g[l],
        k += SAMPLE_STEP;
    l--;
    n = g[l];
    g = k + (a - n) / (g[l + 1] - n) * SAMPLE_STEP;
    l = a$jscomp$281(b, d, c, e);
    n = b$jscomp$150(b, d, c, e);
    b = c$jscomp$42(b, d, c, e);
    d = get_slope(g, l, n, b);
    if (0 !== d)
        if (.01 <= d)
            for (k = 0; 4 > k; ++k)
                d = calc_bezier(g, l, n, b) - a,
                c = get_slope(g, l, n, b),
                g -= d / c;
        else {
            d = k;
            k += SAMPLE_STEP;
            c = 0;
            let p;
            do
                g = d + (k - d) / 2,
                e = calc_bezier(g, l, n, b) - a,
                0 < e ? k = g : d = g,
                e = 1E-7 < Math.abs(e),
                p = 10 > ++c;
            while (e && p)
        }
    return g
}
;
"use strict";
const C3$jscomp$21 = self.C3;
function RequireStringOrNumber(a) {
    C3$jscomp$21.IsString(a)
}
C3$jscomp$21.ProbabilityTable = class {
    constructor(a) {
        this._items = [];
        this._name = a || "";
        this._totalWeight = 0
    }
    Release() {
        this.Clear();
        this._items = null
    }
    GetName() {
        return this._name
    }
    Clear() {
        C3$jscomp$21.clear2DArray(this._items);
        this._totalWeight = 0
    }
    GetTotalWeight() {
        return this._totalWeight
    }
    Sample(a=Math.random() * this.GetTotalWeight()) {
        let b = 0;
        for (const [d,c] of this._items)
            if (b += d,
            a < b)
                return c;
        return 0
    }
    AddItem(a, b) {
        RequireStringOrNumber(b);
        this._totalWeight += a;
        this._items.push([a, b])
    }
    RemoveItem(a, b) {
        RequireStringOrNumber(b);
        const d = 0 === a;
        for (let c = 0; c < this._items.length; c++) {
            const e = this._items[c]
              , g = e[1] === b;
            if ((d || e[0] === a) && g) {
                this._items.splice(c, 1);
                this._totalWeight -= e[0];
                break
            }
        }
    }
    asJSON() {
        return JSON.stringify(this._items)
    }
    static fromJSON(a) {
        const b = new C3$jscomp$21.ProbabilityTable;
        a = JSON.parse(a);
        for (const d of a)
            b.AddItem(d[0], d[1]);
        return b
    }
}
;
"use strict";
let nextId = 0;
self.C3.ScreenReaderText = class {
    constructor(a, b) {
        this._runtime = a;
        this._text = b;
        this._id = nextId++;
        this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", {
            type: "create",
            id: this._id,
            text: this._text
        })
    }
    Release() {
        this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", {
            type: "release",
            id: this._id
        });
        this._runtime = null;
        this._text = "";
        this._id = -1
    }
    SetText(a) {
        this._text !== a && (this._text = a,
        this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", {
            type: "update",
            id: this._id,
            text: this._text
        }))
    }
}
;
"use strict";
self.C3.Event = class {
    constructor(a, b) {
        this.type = a;
        this.cancelable = !!b;
        this.isAsync = this.propagationStopped = this.defaultPrevented = !1
    }
    preventDefault() {
        if (!this.cancelable)
            throw Error(`event '${this.type}' is not cancelable`);
        this.defaultPrevented = !0
    }
    stopPropagation() {
        if (!this.cancelable)
            throw Error(`event '${this.type}' cannot be stopped`);
        if (this.isAsync)
            throw Error(`cannot stop async event '${this.type}' propagation`);
        this.propagationStopped = !0
    }
}
;
"use strict";
const C3$jscomp$24 = self.C3;
C3$jscomp$24.Event.Handler = class extends C3$jscomp$24.DefendedBase {
    constructor(a) {
        super();
        this._type = a;
        this._captureListeners = [];
        this._captureListenersSet = new Set;
        this._listeners = [];
        this._listenersSet = new Set;
        this._fireDepth = 0;
        this._queueModifyListeners = []
    }
    Release() {
        0 < this._fireDepth || (C3$jscomp$24.clearArray(this._captureListeners),
        this._captureListenersSet.clear(),
        C3$jscomp$24.clearArray(this._listeners),
        this._listenersSet.clear(),
        C3$jscomp$24.clearArray(this._queueModifyListeners),
        C3$jscomp$24.Release(this))
    }
    _AddListener(a, b) {
        this._IsFiring() ? this._queueModifyListeners.push({
            op: "add",
            func: a,
            capture: b
        }) : b ? this._captureListenersSet.has(a) || (this._captureListeners.push(a),
        this._captureListenersSet.add(a)) : this._listenersSet.has(a) || (this._listeners.push(a),
        this._listenersSet.add(a))
    }
    _RemoveListener(a, b) {
        this._IsFiring() ? this._queueModifyListeners.push({
            op: "remove",
            func: a,
            capture: b
        }) : b ? this._captureListenersSet.has(a) && (this._captureListenersSet.delete(a),
        C3$jscomp$24.arrayFindRemove(this._captureListeners, a)) : this._listenersSet.has(a) && (this._listenersSet.delete(a),
        C3$jscomp$24.arrayFindRemove(this._listeners, a))
    }
    _IsEmpty() {
        return !this._captureListeners.length && !this._listeners.length
    }
    _IsFiring() {
        return 0 < this._fireDepth
    }
    _ProcessQueuedListeners() {
        const a = new Set
          , b = new Set;
        for (const d of this._queueModifyListeners)
            if ("add" === d.op)
                this._AddListener(d.func, d.capture),
                d.capture ? b.delete(d.func) : a.delete(d.func);
            else if ("remove" === d.op)
                d.capture ? (this._captureListenersSet.delete(d.func),
                b.add(d.func)) : (this._listenersSet.delete(d.func),
                a.add(d.func));
            else
                throw Error("invalid op");
        C3$jscomp$24.arrayRemoveAllInSet(this._listeners, a);
        C3$jscomp$24.arrayRemoveAllInSet(this._captureListeners, b);
        C3$jscomp$24.clearArray(this._queueModifyListeners)
    }
    _FireCancellable(a) {
        this._IncreaseFireDepth();
        let b = !1;
        for (let d = 0, c = this._captureListeners.length; d < c; ++d)
            if (this._captureListeners[d](a),
            a.propagationStopped) {
                b = !0;
                break
            }
        if (!b)
            for (let d = 0, c = this._listeners.length; d < c && (this._listeners[d](a),
            !a.propagationStopped); ++d)
                ;
        this._DecreaseFireDepth();
        return !a.defaultPrevented
    }
    _FireNonCancellable(a) {
        this._IncreaseFireDepth();
        for (let b = 0, d = this._captureListeners.length; b < d; ++b)
            this._captureListeners[b](a);
        for (let b = 0, d = this._listeners.length; b < d; ++b)
            this._listeners[b](a);
        this._DecreaseFireDepth();
        return !0
    }
    _IncreaseFireDepth() {
        this._fireDepth++
    }
    _DecreaseFireDepth() {
        this._fireDepth--;
        0 === this._fireDepth && 0 < this._queueModifyListeners.length && this._ProcessQueuedListeners()
    }
    SetDelayRemoveEventsEnabled(a) {
        a ? this._IncreaseFireDepth() : this._DecreaseFireDepth()
    }
    _FireAsync(a) {
        let b = [];
        for (let d = 0, c = this._captureListeners.length; d < c; ++d) {
            let e = this._captureListeners[d];
            b.push(C3$jscomp$24.Asyncify(()=>e(a)))
        }
        for (let d = 0, c = this._listeners.length; d < c; ++d) {
            let e = this._listeners[d];
            b.push(C3$jscomp$24.Asyncify(()=>e(a)))
        }
        return Promise.all(b).then(()=>!a.defaultPrevented)
    }
    _FireAndWait_AsyncOptional(a) {
        const b = [];
        this._IncreaseFireDepth();
        for (let c = 0, e = this._captureListeners.length; c < e; ++c) {
            var d = this._captureListeners[c](a);
            d instanceof Promise && b.push(d)
        }
        for (let c = 0, e = this._listeners.length; c < e; ++c)
            d = this._listeners[c](a),
            d instanceof Promise && b.push(d);
        this._DecreaseFireDepth();
        return b.length ? Promise.all(b).then(()=>!a.defaultPrevented) : !a.defaultPrevented
    }
    async _FireAndWaitAsync(a) {
        return await this._FireAndWait_AsyncOptional(a)
    }
    async _FireAndWaitAsyncSequential(a) {
        this._IncreaseFireDepth();
        for (let d = 0, c = this._captureListeners.length; d < c; ++d) {
            var b = this._captureListeners[d](a);
            b instanceof Promise && await b
        }
        for (let d = 0, c = this._listeners.length; d < c; ++d)
            b = this._listeners[d](a),
            b instanceof Promise && await b;
        this._DecreaseFireDepth();
        return !a.defaultPrevented
    }
    *_FireAsGenerator(a) {
        this._IncreaseFireDepth();
        for (let d = 0, c = this._captureListeners.length; d < c; ++d) {
            var b = this._captureListeners[d](a);
            C3$jscomp$24.IsIterator(b) && (yield*b)
        }
        for (let d = 0, c = this._listeners.length; d < c; ++d)
            b = this._listeners[d](a),
            C3$jscomp$24.IsIterator(b) && (yield*b);
        this._DecreaseFireDepth()
    }
}
;
"use strict";
const C3$jscomp$25 = self.C3;
C3$jscomp$25.Event.Dispatcher = class extends C3$jscomp$25.DefendedBase {
    constructor() {
        super();
        this._eventHandlers = new Map;
        this._dispatcherWasReleased = !1
    }
    Release() {
        if (this._dispatcherWasReleased)
            throw Error("already released");
        this.ClearEvents();
        this._dispatcherWasReleased = !0;
        C3$jscomp$25.Release(this)
    }
    WasReleased() {
        return this._dispatcherWasReleased
    }
    ClearEvents() {
        for (let a of this._eventHandlers.values())
            a.Release();
        this._eventHandlers.clear()
    }
    _GetHandlerByType(a, b) {
        let d = this._eventHandlers.get(a);
        return d ? d : b ? (d = C3$jscomp$25.New(C3$jscomp$25.Event.Handler, a),
        this._eventHandlers.set(a, d),
        d) : null
    }
    HasAnyHandlerFor(a) {
        return this._eventHandlers.has(a)
    }
    addEventListener(a, b, d) {
        this._GetHandlerByType(a, !0)._AddListener(b, !!d)
    }
    removeEventListener(a, b, d) {
        let c = this._GetHandlerByType(a, !1);
        c && (c._RemoveListener(b, !!d),
        c._IsEmpty() && this._eventHandlers.delete(a))
    }
    dispatchEvent(a) {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? a.cancelable ? b._FireCancellable(a) : b._FireNonCancellable(a) : !0
    }
    dispatchEventAsync(a) {
        const b = this._GetHandlerByType(a.type, !1);
        if (!b)
            return Promise.resolve(!0);
        a.isAsync = !0;
        return b._FireAsync(a)
    }
    async dispatchEventAndClearAsync(a) {
        const b = this._GetHandlerByType(a.type, !1);
        if (!b)
            return !0;
        this._eventHandlers.delete(a.type);
        a.isAsync = !0;
        a = await b._FireAsync(a);
        b.Release();
        return a
    }
    async dispatchEventAndWaitAsync(a) {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? await b._FireAndWaitAsync(a) : !0
    }
    dispatchEventAndWait_AsyncOptional(a) {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? b._FireAndWait_AsyncOptional(a) : !0
    }
    async dispatchEventAndWaitAsyncSequential(a) {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? await b._FireAndWaitAsyncSequential(a) : !0
    }
    dispatchGeneratorEvent(a) {
        const b = this._GetHandlerByType(a.type, !1);
        if (!b)
            return null;
        if (a.cancelable)
            throw Error("not supported");
        return b._FireAsGenerator(a)
    }
    SetDelayRemoveEventsEnabled(a) {
        for (const b of this._eventHandlers.values())
            b.SetDelayRemoveEventsEnabled(a)
    }
}
;
"use strict";
const C3$jscomp$26 = self.C3
  , SETTIMEOUT_INTERVAL = 16
  , SUPPORTS_RIC = "undefined" !== typeof requestIdleCallback;
let workQueue = []
  , callbackId = -1
  , highThroughputMode = 0;
function SetNewCallback(a) {
    callbackId = SUPPORTS_RIC && 0 === highThroughputMode ? requestIdleCallback(DoAsyncifiedWork, {
        timeout: 35
    }) : setTimeout(DoAsyncifiedWork, 0 < highThroughputMode ? 1 : a)
}
function DoAsyncifiedWork(a) {
    callbackId = -1;
    if (workQueue.length) {
        var b = performance.now()
          , d = 0;
        do {
            DoNextAsyncifiedJob(workQueue.shift());
            var c = performance.now();
            ++d;
            var e = (c - b) / d * 1.1
        } while (workQueue.length && (SUPPORTS_RIC && 0 === highThroughputMode && "undefined" !== typeof a ? e < a.timeRemaining() : 12 > c - b + e));
        -1 === callbackId && workQueue.length && SetNewCallback(Math.max(SETTIMEOUT_INTERVAL - (c - b), 4))
    }
}
function DoNextAsyncifiedJob(a) {
    let b;
    try {
        b = a.func()
    } catch (d) {
        a.reject(d);
        return
    }
    a.resolve(b)
}
let asyncifyDisabled = C3$jscomp$26.QueryString.Has("disable-asyncify");
asyncifyDisabled && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.");
C3$jscomp$26.Asyncify = function(a) {
    let b = null;
    C3$jscomp$26.isDebug && (b = C3$jscomp$26.GetCallStack());
    return new Promise((d,c)=>{
        workQueue.push({
            func: a,
            resolve: d,
            reject: c,
            stack: b
        });
        asyncifyDisabled ? DoNextAsyncifiedJob(workQueue.pop()) : -1 === callbackId && SetNewCallback(SETTIMEOUT_INTERVAL)
    }
    )
}
;
C3$jscomp$26.Asyncify.SetHighThroughputMode = function(a) {
    if (a)
        ++highThroughputMode;
    else if (--highThroughputMode,
    0 > highThroughputMode)
        throw Error("already turned off high throughput mode");
}
;
"use strict";
const C3$jscomp$27 = self.C3
  , IDLE_CHECK_MIN_INTERVAL = 1E3
  , IDLE_CHECK_TIMER_OVERSHOOT = 100;
let cachedNowTime = -1;
function ClearTimeCache() {
    cachedNowTime = -1
}
C3$jscomp$27.FastGetDateNow = function() {
    -1 === cachedNowTime && (cachedNowTime = Date.now(),
    self.setTimeout(ClearTimeCache, 16));
    return cachedNowTime
}
;
let timerId = -1
  , nextDeadline = -1
  , activeIdleTimeouts = new Set;
function CheckActiveIdleTimeouts() {
    nextDeadline = timerId = -1;
    let a = Date.now();
    for (let b of activeIdleTimeouts)
        if (b._CheckTimeout(a)) {
            let d = b._GetDeadline();
            if (-1 === nextDeadline || d < nextDeadline)
                nextDeadline = d
        } else
            activeIdleTimeouts.delete(b);
    -1 !== nextDeadline && (timerId = self.setTimeout(CheckActiveIdleTimeouts, Math.max(nextDeadline - a + IDLE_CHECK_TIMER_OVERSHOOT, IDLE_CHECK_MIN_INTERVAL)))
}
C3$jscomp$27.IdleTimeout = class {
    constructor(a, b) {
        this._callback = a;
        this._timeout = 1E3 * b;
        this._deadline = 0;
        this._isActive = !1
    }
    Reset() {
        let a = C3$jscomp$27.FastGetDateNow();
        this._deadline = a + this._timeout;
        this._isActive || (activeIdleTimeouts.add(this),
        this._isActive = !0);
        -1 === timerId ? (nextDeadline = this._deadline,
        timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + IDLE_CHECK_TIMER_OVERSHOOT)) : this._deadline < nextDeadline && nextDeadline > a + IDLE_CHECK_MIN_INTERVAL && (self.clearTimeout(timerId),
        nextDeadline = this._deadline,
        timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + IDLE_CHECK_TIMER_OVERSHOOT))
    }
    _CheckTimeout(a) {
        return a >= this._deadline ? this._callback() ? (this._deadline = a + this._timeout,
        !0) : this._isActive = !1 : !0
    }
    _GetDeadline() {
        return this._deadline
    }
    Cancel() {
        this._isActive && (activeIdleTimeouts.delete(this),
        this._isActive = !1,
        0 === activeIdleTimeouts.size && -1 !== timerId && (self.clearTimeout(timerId),
        nextDeadline = timerId = -1))
    }
    Release() {
        this.Cancel();
        this._callback = null
    }
}
;
"use strict";
const C3$jscomp$28 = self.C3;
C3$jscomp$28.Disposable = class a {
    constructor(b) {
        this._disposed = !1;
        this._disposeAction = b
    }
    Dispose() {
        this._disposed || (this._disposed = !0,
        this._disposeAction && (this._disposeAction(),
        this._disposeAction = null))
    }
    IsDisposed() {
        return this._disposed
    }
    Release() {
        this.Dispose()
    }
    static Release(b) {
        return new a(()=>b.Release())
    }
    static From(b, d, c, e, g) {
        if ("undefined" === typeof e || null === e)
            e = !1;
        else if ("boolean" !== typeof e && "object" !== typeof e)
            throw new TypeError("invalid event listener options");
        g && (c = c.bind(g));
        if (d.includes(" ")) {
            d = d.split(" ");
            g = new C3$jscomp$28.CompositeDisposable;
            for (let k of d)
                b.addEventListener(k, c, e),
                g.Add(C3$jscomp$28.New(C3$jscomp$28.Disposable, ()=>b.removeEventListener(k, c, e)));
            return g
        }
        b.addEventListener(d, c, e);
        return C3$jscomp$28.New(C3$jscomp$28.Disposable, ()=>b.removeEventListener(d, c, e))
    }
}
;
C3$jscomp$28.StubDisposable = class extends C3$jscomp$28.Disposable {
    SetAction(a) {
        this._disposeAction = a
    }
}
;
C3$jscomp$28.CompositeDisposable = class extends C3$jscomp$28.Disposable {
    constructor(...a) {
        super();
        this._disposables = new Set;
        for (let b of a)
            this.Add(b)
    }
    Add(...a) {
        if (this._disposed)
            throw Error("already disposed");
        for (let b of a)
            this._disposables.add(b)
    }
    Remove(a) {
        if (this._disposed)
            throw Error("already disposed");
        this._disposables.delete(a)
    }
    RemoveAll() {
        if (this._disposed)
            throw Error("already disposed");
        if (this._disposables) {
            for (let a of this._disposables)
                a.Dispose();
            this._disposables.clear()
        }
    }
    IsDisposed() {
        return this._disposed
    }
    Dispose() {
        if (this._disposed)
            throw Error("already disposed");
        this._disposed = !0;
        for (let a of this._disposables)
            a.Dispose();
        this._disposables.clear();
        this._disposables = null
    }
    Release() {
        this.Dispose()
    }
}
;
"use strict";
const C3$jscomp$29 = self.C3;
C3$jscomp$29.KahanSum = class extends C3$jscomp$29.DefendedBase {
    constructor() {
        super();
        this._sum = this._t = this._y = this._c = 0
    }
    Add(a) {
        this._y = +a - this._c;
        this._t = this._sum + this._y;
        this._c = this._t - this._sum - this._y;
        this._sum = this._t
    }
    Subtract(a) {
        this._sum -= +a
    }
    Get() {
        return this._sum
    }
    Reset() {
        this._sum = this._t = this._y = this._c = 0
    }
    Set(a) {
        this._t = this._y = this._c = 0;
        this._sum = +a
    }
    Copy(a) {
        this._c = a._c;
        this._y = a._y;
        this._t = a._t;
        this._sum = a._sum
    }
    Release() {}
}
;
"use strict";
const C3$jscomp$30 = self.C3
  , js_cols = {
    RBnode: function(a) {
        this.tree = a;
        this.left = this.right = this.tree.sentinel;
        this.parent = null;
        this.color = !1;
        this.key = null
    },
    RedBlackSet: function(a) {
        this.size = 0;
        this.sentinel = new js_cols.RBnode(this);
        this.sentinel.color = !1;
        this.root = this.sentinel;
        this.root.parent = this.sentinel;
        this.compare = a || this.default_compare
    }
};
js_cols.RedBlackSet.prototype.default_compare = function(a, b) {
    return a < b ? -1 : b < a ? 1 : 0
}
;
js_cols.RedBlackSet.prototype.clone = function() {
    var a = new js_cols.RedBlackSet(this.compare);
    a.insertAll(this);
    return a
}
;
js_cols.RedBlackSet.prototype.clear = function() {
    this.size = 0;
    this.sentinel = new js_cols.RBnode(this);
    this.sentinel.color = !1;
    this.root = this.sentinel;
    this.root.parent = this.sentinel
}
;
js_cols.RedBlackSet.prototype.leftRotate = function(a) {
    var b = a.right;
    a.right = b.left;
    b.left != this.sentinel && (b.left.parent = a);
    b.parent = a.parent;
    a.parent == this.sentinel ? this.root = b : a == a.parent.left ? a.parent.left = b : a.parent.right = b;
    b.left = a;
    a.parent = b
}
;
js_cols.RedBlackSet.prototype.rightRotate = function(a) {
    var b = a.left;
    a.left = b.right;
    b.right != this.sentinel && (b.right.parent = a);
    b.parent = a.parent;
    a.parent == this.sentinel ? this.root = b : a == a.parent.right ? a.parent.right = b : a.parent.left = b;
    b.right = a;
    a.parent = b
}
;
js_cols.RedBlackSet.prototype.insert = function(a) {
    if (this.contains(a))
        this.get_(a).key = a;
    else {
        var b = new js_cols.RBnode(this);
        b.key = a;
        a = this.sentinel;
        for (var d = this.root; d != this.sentinel; )
            a = d,
            d = 0 > this.compare(b.key, d.key) ? d.left : d.right;
        b.parent = a;
        a == this.sentinel ? this.root = b : 0 > this.compare(b.key, a.key) ? a.left = b : a.right = b;
        b.left = this.sentinel;
        b.right = this.sentinel;
        b.color = !0;
        this.insertFixup(b);
        this.size++
    }
}
;
js_cols.RedBlackSet.prototype.insertFixup = function(a) {
    for (; a != this.sentinel && a != this.root && 1 == a.parent.color; )
        if (a.parent == a.parent.parent.left) {
            var b = a.parent.parent.right;
            1 == b.color ? (a.parent.color = !1,
            b.color = !1,
            a.parent.parent.color = !0,
            a = a.parent.parent) : (a == a.parent.right && (a = a.parent,
            this.leftRotate(a)),
            a.parent.color = !1,
            a.parent.parent.color = !0,
            a.parent.parent != this.sentinel && this.rightRotate(a.parent.parent))
        } else
            b = a.parent.parent.left,
            1 == b.color ? (a.parent.color = !1,
            b.color = !1,
            a.parent.parent.color = !0,
            a = a.parent.parent) : (a == a.parent.left && (a = a.parent,
            this.rightRotate(a)),
            a.parent.color = !1,
            a.parent.parent.color = !0,
            a.parent.parent != this.sentinel && this.leftRotate(a.parent.parent));
    this.root.color = !1
}
;
js_cols.RedBlackSet.prototype.delete_ = function(a) {
    var b = a.left == this.sentinel || a.right == this.sentinel ? a : this.successor_(a);
    var d = b.left != this.sentinel ? b.left : b.right;
    d.parent = b.parent;
    b.parent == this.sentinel ? this.root = d : b == b.parent.left ? b.parent.left = d : b.parent.right = d;
    b != a && (a.key = b.key);
    0 == b.color && this.deleteFixup(d);
    this.size--
}
;
js_cols.RedBlackSet.prototype.deleteFixup = function(a) {
    for (; a != this.root && 0 == a.color; )
        if (a == a.parent.left) {
            var b = a.parent.right;
            1 == b.color && (b.color = !1,
            a.parent.color = !0,
            this.leftRotate(a.parent),
            b = a.parent.right);
            0 == b.left.color && 0 == b.right.color ? (b.color = !0,
            a = a.parent) : (0 == b.right.color && (b.left.color = !1,
            b.color = !0,
            this.rightRotate(b),
            b = a.parent.right),
            b.color = a.parent.color,
            a.parent.color = !1,
            b.right.color = !1,
            this.leftRotate(a.parent),
            a = this.root)
        } else
            b = a.parent.left,
            1 == b.color && (b.color = !1,
            a.parent.color = !0,
            this.rightRotate(a.parent),
            b = a.parent.left),
            0 == b.right.color && 0 == b.left.color ? (b.color = !0,
            a = a.parent) : (0 == b.left.color && (b.right.color = !1,
            b.color = !0,
            this.leftRotate(b),
            b = a.parent.left),
            b.color = a.parent.color,
            a.parent.color = !1,
            b.left.color = !1,
            this.rightRotate(a.parent),
            a = this.root);
    a.color = !1
}
;
js_cols.RedBlackSet.prototype.remove = function(a) {
    a = this.get_(a);
    if (a != this.sentinel) {
        var b = a.key;
        this.delete_(a);
        return b
    }
    return null
}
;
js_cols.RedBlackSet.prototype.removeSwapped = function(a, b) {
    this.remove(b)
}
;
js_cols.RedBlackSet.prototype.min = function(a) {
    for (; a.left != this.sentinel; )
        a = a.left;
    return a
}
;
js_cols.RedBlackSet.prototype.max = function(a) {
    for (; a.right != this.sentinel; )
        a = a.right;
    return a
}
;
js_cols.RedBlackSet.prototype.successor_ = function(a) {
    if (a.right != this.sentinel)
        return this.min(a.right);
    for (var b = a.parent; b != this.sentinel && a == b.right; )
        a = b,
        b = b.parent;
    return b
}
;
js_cols.RedBlackSet.prototype.predeccessor_ = function(a) {
    if (a.left != this.sentinel)
        return this.max(a.left);
    for (var b = a.parent; b != this.sentinel && a == b.left; )
        a = b,
        b = b.parent;
    return b
}
;
js_cols.RedBlackSet.prototype.successor = function(a) {
    if (0 < this.size) {
        a = this.get_(a);
        if (a == this.sentinel)
            return null;
        if (a.right != this.sentinel)
            return this.min(a.right).key;
        for (var b = a.parent; b != this.sentinel && a == b.right; )
            a = b,
            b = b.parent;
        return b != this.sentinel ? b.key : null
    }
    return null
}
;
js_cols.RedBlackSet.prototype.predecessor = function(a) {
    if (0 < this.size) {
        a = this.get_(a);
        if (a == this.sentinel)
            return null;
        if (a.left != this.sentinel)
            return this.max(a.left).key;
        for (var b = a.parent; b != this.sentinel && a == b.left; )
            a = b,
            b = b.parent;
        return b != this.sentinel ? b.key : null
    }
    return null
}
;
js_cols.RedBlackSet.prototype.getMin = function() {
    return this.min(this.root).key
}
;
js_cols.RedBlackSet.prototype.getMax = function() {
    return this.max(this.root).key
}
;
js_cols.RedBlackSet.prototype.get_ = function(a) {
    for (var b = this.root; b != this.sentinel && 0 != this.compare(b.key, a); )
        b = 0 > this.compare(a, b.key) ? b.left : b.right;
    return b
}
;
js_cols.RedBlackSet.prototype.contains = function(a) {
    return null != this.get_(a).key
}
;
js_cols.RedBlackSet.prototype.getValues = function() {
    var a = [];
    this.forEach(function(b) {
        a.push(b)
    });
    return a
}
;
js_cols.RedBlackSet.prototype.insertAll = function(a) {
    if ("array" == js_cols.typeOf(a))
        for (var b = 0; b < a.length; b++)
            this.insert(a[b]);
    else if ("function" == js_cols.typeOf(a.forEach))
        a.forEach(this.insert, this);
    else if ("function" == js_cols.typeOf(a.getValues))
        for (a = a.getValues(),
        b = 0; b < a.length; b++)
            this.insert(a[b]);
    else if ("object" == js_cols.typeOf(a))
        for (b in a)
            this.insert(a[b])
}
;
js_cols.RedBlackSet.prototype.removeAll = function(a) {
    if ("array" == js_cols.typeOf(a))
        for (var b = 0; b < a.length; b++)
            this.remove(a[b]);
    else if ("function" == js_cols.typeOf(a.forEach))
        a.forEach(this.removeSwapped, this);
    else if ("function" == js_cols.typeOf(a.getValues))
        for (a = a.getValues(),
        b = 0; b < a.length; b++)
            this.remove(a[b]);
    else if ("object" == js_cols.typeOf(a))
        for (b in a)
            this.remove(a[b])
}
;
js_cols.RedBlackSet.prototype.containsAll = function(a) {
    if ("array" == js_cols.typeOf(a)) {
        for (var b = 0; b < a.length; b++)
            if (!this.contains(a[b]))
                return !1;
        return !0
    }
    if ("function" == js_cols.typeOf(a.forEach))
        return a.every(this.contains, this);
    if ("function" == js_cols.typeOf(a.getValues)) {
        a = a.getValues();
        for (b = 0; b < a.length; b++)
            if (!this.contains(a[b]))
                return !1;
        return !0
    }
    if ("object" == js_cols.typeOf(a)) {
        for (b in a)
            if (!this.contains(a[b]))
                return !1;
        return !0
    }
}
;
js_cols.RedBlackSet.prototype.range = function(a, b) {
    var d = [];
    this.traverseFromTo(function(c) {
        d.push(c)
    }, a, b);
    return d
}
;
js_cols.RedBlackSet.prototype.traverse = function(a, b) {
    if (!this.isEmpty())
        for (var d = this.min(this.root); d != this.sentinel && !a.call(b, d.key, this); )
            d = this.successor_(d)
}
;
js_cols.RedBlackSet.prototype.traverseFrom = function(a, b, d) {
    if (!this.isEmpty())
        for (b = this.get_(b); b != this.sentinel && !a.call(d, b.key, this); )
            b = this.successor_(b)
}
;
js_cols.RedBlackSet.prototype.traverseTo = function(a, b, d) {
    if (!this.isEmpty()) {
        var c = this.min(this.root);
        for (b = this.get_(b); c != b && !a.call(d, c.key, this); )
            c = this.successor_(c)
    }
}
;
js_cols.RedBlackSet.prototype.traverseFromTo = function(a, b, d, c) {
    if (!this.isEmpty())
        for (b = this.get_(b),
        d = this.get_(d); b != d && !a.call(c, b.key, this); )
            b = this.successor_(b)
}
;
js_cols.RedBlackSet.prototype.traverseBackwards = function(a, b) {
    if (!this.isEmpty())
        for (var d = this.max(this.root); d != this.sentinel && !a.call(b, d.key, this); )
            d = this.predeccessor_(d)
}
;
js_cols.RedBlackSet.prototype.forEach = function(a, b) {
    if (!this.isEmpty())
        for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d))
            a.call(b, d.key, d.key, this)
}
;
js_cols.RedBlackSet.prototype.some = function(a, b) {
    if (this.isEmpty())
        return !1;
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d))
        if (a.call(b, d.key, d.key, this))
            return !0;
    return !1
}
;
js_cols.RedBlackSet.prototype.every = function(a, b) {
    if (this.isEmpty())
        return !1;
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d))
        if (!a.call(b, d.key, d.key, this))
            return !1;
    return !0
}
;
js_cols.RedBlackSet.prototype.map = function(a, b) {
    var d = [];
    if (this.isEmpty())
        return d;
    for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
        d.push(a.call(b, c.key, c.key, this));
    return d
}
;
js_cols.RedBlackSet.prototype.filter = function(a, b) {
    var d = [];
    if (this.isEmpty())
        return d;
    for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
        a.call(b, c.key, c.key, this) && d.push(c.key);
    return d
}
;
js_cols.RedBlackSet.prototype.getCount = function() {
    return this.size
}
;
js_cols.RedBlackSet.prototype.isEmpty = function() {
    return 0 == this.size
}
;
js_cols.RedBlackSet.prototype.isSubsetOf = function(a) {
    var b = js_cols.getCount(a);
    if (this.getCount() > b)
        return !1;
    b = 0;
    if (this.isEmpty())
        return !0;
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d))
        js_cols.contains.call(a, a, d.key) && b++;
    return b == this.getCount()
}
;
js_cols.RedBlackSet.prototype.intersection = function(a) {
    var b = new js_cols.RedBlackSet(this.compare);
    if (this.isEmpty())
        return b;
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d))
        a.contains.call(a, d.key, d.key, this) && b.insert(d.key);
    return b
}
;
C3$jscomp$30.RedBlackSet = class extends C3$jscomp$30.DefendedBase {
    constructor(a) {
        super();
        this._rbSet = new js_cols.RedBlackSet(a);
        this._enableQueue = !1;
        this._queueInsert = new Set;
        this._queueRemove = new Set
    }
    Add(a) {
        this._enableQueue ? this._rbSet.contains(a) ? this._queueRemove.delete(a) : this._queueInsert.add(a) : this._rbSet.insert(a)
    }
    Remove(a) {
        this._enableQueue ? this._rbSet.contains(a) ? this._queueRemove.add(a) : this._queueInsert.delete(a) : this._rbSet.remove(a)
    }
    Has(a) {
        return this._enableQueue ? this._queueInsert.has(a) ? !0 : !this._queueRemove.has(a) && this._rbSet.contains(a) : this._rbSet.contains(a)
    }
    Clear() {
        this._rbSet.clear();
        this._queueInsert.clear();
        this._queueRemove.clear()
    }
    toArray() {
        if (this._enableQueue)
            throw Error("cannot be used in queueing mode");
        return this._rbSet.getValues()
    }
    GetSize() {
        return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size
    }
    IsEmpty() {
        return 0 === this.GetSize()
    }
    Front() {
        if (this.IsEmpty())
            throw Error("empty set");
        if (this._enableQueue)
            throw Error("cannot be used in queueing mode");
        const a = this._rbSet;
        return a.min(a.root).key
    }
    Shift() {
        if (this.IsEmpty())
            throw Error("empty set");
        if (this._enableQueue)
            throw Error("cannot be used in queueing mode");
        const a = this.Front();
        this.Remove(a);
        return a
    }
    SetQueueingEnabled(a) {
        a = !!a;
        if (this._enableQueue !== a && (this._enableQueue = a,
        !a)) {
            for (const b of this._queueRemove)
                this._rbSet.remove(b);
            this._queueRemove.clear();
            for (const b of this._queueInsert)
                this._rbSet.insert(b);
            this._queueInsert.clear()
        }
    }
    ForEach(a) {
        this._rbSet.forEach(a)
    }
    *values() {
        if (!this.IsEmpty()) {
            var a = this._rbSet;
            for (let b = a.min(a.root); b != a.sentinel; b = a.successor_(b))
                yield b.key
        }
    }
    [Symbol.iterator]() {
        return this.values()
    }
}
;
"use strict";
const C3$jscomp$31 = self.C3;
C3$jscomp$31.PromiseThrottle = class {
    constructor(a=C3$jscomp$31.hardwareConcurrency) {
        this._maxParallel = a;
        this._queue = [];
        this._activeCount = 0
    }
    Add(a) {
        return new Promise((b,d)=>{
            this._queue.push({
                func: a,
                resolve: b,
                reject: d
            });
            this._MaybeStartNext()
        }
        )
    }
    _FindInQueue(a) {
        for (let b = 0, d = this._queue.length; b < d; ++b)
            if (this._queue[b].func === a)
                return b;
        return -1
    }
    RemoveAndResolve(a, b) {
        a = this._FindInQueue(a);
        if (-1 === a)
            throw Error("cannot find promise to resolve");
        this._queue[a].resolve(b);
        this._queue.splice(a, 1)
    }
    RemoveAndReject(a, b) {
        a = this._FindInQueue(a);
        if (-1 === a)
            throw Error("cannot find promise to reject");
        this._queue[a].reject(b);
        this._queue.splice(a, 1)
    }
    async _MaybeStartNext() {
        if (this._queue.length && !(this._activeCount >= this._maxParallel)) {
            this._activeCount++;
            var a = this._queue.shift();
            try {
                const b = await a.func();
                a.resolve(b)
            } catch (b) {
                a.reject(b)
            }
            this._activeCount--;
            this._MaybeStartNext()
        }
    }
    static async Batch(a, b) {
        const d = [];
        let c = !1;
        const e = async k=>{
            for (; (k = b.pop()) && !c; )
                try {
                    d.push(await k())
                } catch (l) {
                    throw c = !0,
                    l;
                }
        }
          , g = [];
        for (; a--; )
            g.push(e());
        await Promise.all(g);
        return d
    }
}
;
"use strict";
const C3$jscomp$32 = self.C3;
C3$jscomp$32.RateLimiter = class {
    constructor(a, b, d) {
        this._callback = a;
        this._interval = b;
        this._intervalOnBattery = d || 2 * b;
        this._timerId = -1;
        this._lastCallTime = -Infinity;
        this._timerCallFunc = ()=>this._OnTimer();
        this._canRunImmediate = this._ignoreReset = !1;
        this._callbackArguments = null
    }
    SetCanRunImmediate(a) {
        this._canRunImmediate = !!a
    }
    _GetInterval() {
        return "undefined" !== typeof C3$jscomp$32.Battery && C3$jscomp$32.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval
    }
    Call(...a) {
        if (-1 === this._timerId) {
            this._callbackArguments = a;
            a = C3$jscomp$32.FastGetDateNow();
            var b = a - this._lastCallTime
              , d = this._GetInterval();
            b >= d && this._canRunImmediate ? (this._lastCallTime = a,
            this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(d - b, 4))
        }
    }
    _RunCallback() {
        this._ignoreReset = !0;
        const a = this._callbackArguments;
        this._callbackArguments = null;
        a ? this._callback(...a) : this._callback();
        this._ignoreReset = !1
    }
    Reset() {
        this._ignoreReset || (this._CancelTimer(),
        this._callbackArguments = null,
        this._lastCallTime = C3$jscomp$32.FastGetDateNow())
    }
    _OnTimer() {
        this._timerId = -1;
        this._lastCallTime = C3$jscomp$32.FastGetDateNow();
        this._RunCallback()
    }
    _CancelTimer() {
        -1 !== this._timerId && (self.clearTimeout(this._timerId),
        this._timerId = -1)
    }
    Release() {
        this._CancelTimer();
        this._timerCallFunc = this._callbackArguments = this._callback = null
    }
}
;
"use strict";
const C3$jscomp$33 = self.C3;
C3$jscomp$33.SVGRasterManager = class {
    constructor() {
        this._images = new Map;
        this._allowNpotSurfaces = !1;
        this._redrawCallback = this._releaseResultCallback = this._rasterAtSizeCallback = this._getBaseSizeCallback = null
    }
    SetNpotSurfaceAllowed(a) {
        this._allowNpotSurfaces = !!a
    }
    IsNpotSurfaceAllowed() {
        return this._allowNpotSurfaces
    }
    SetGetBaseSizeCallback(a) {
        this._getBaseSizeCallback = a
    }
    GetBaseSize(a) {
        if (!this._getBaseSizeCallback)
            throw Error("no get base size callback set");
        return this._getBaseSizeCallback(a)
    }
    SetRasterAtSizeCallback(a) {
        this._rasterAtSizeCallback = a
    }
    RasterAtSize(a, b, d, c, e, g) {
        if (!this._rasterAtSizeCallback)
            throw Error("no raster at size callback set");
        return this._rasterAtSizeCallback(a, b, d, c, e, g)
    }
    SetReleaseResultCallback(a) {
        this._releaseResultCallback = a
    }
    ReleaseResult(a) {
        if (!this._releaseResultCallback)
            throw Error("no release result callback set");
        this._releaseResultCallback(a)
    }
    SetRedrawCallback(a) {
        this._redrawCallback = a
    }
    Redraw() {
        if (!this._redrawCallback)
            throw Error("no redraw callback set");
        this._redrawCallback()
    }
    AddImage(a) {
        let b = this._images.get(a);
        b || (b = C3$jscomp$33.New(C3$jscomp$33.SVGRasterImage, this, a),
        this._images.set(a, b));
        b.IncReference();
        return b
    }
    _RemoveImage(a) {
        this._images.delete(a.GetDataSource())
    }
    OnTexturesChanged() {
        for (const a of this._images.values())
            a.ReleaseRasterizedResult(),
            a.ForceRasterAgain()
    }
}
;
"use strict";
const C3$jscomp$34 = self.C3;
C3$jscomp$34.SVGRasterImage = class {
    constructor(a, b) {
        this._manager = a;
        this._dataSource = b;
        this._baseHeight = this._baseWidth = this._refCount = 0;
        this._getBaseSizePromise = this._manager.GetBaseSize(b).then(d=>{
            this._manager && (this._baseWidth = d[0],
            this._baseHeight = d[1],
            this._manager.Redraw())
        }
        ).catch(d=>{
            console.error("[SVG] Error loading SVG: ", d);
            this._hadError = !0;
            this._manager && this._manager.Redraw()
        }
        );
        this._rasterImageHeight = this._rasterImageWidth = this._rasterSurfaceHeight = this._rasterSurfaceWidth = 0;
        this._isRasterizing = !1;
        this._rasterizedResult = null;
        this._hadError = this._forceRaster = !1
    }
    Release() {
        if (0 >= this._refCount)
            throw Error("already released");
        this._refCount--;
        0 === this._refCount && this._Release()
    }
    ReleaseRasterizedResult() {
        this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult),
        this._rasterizedResult = null)
    }
    _Release() {
        this.ReleaseRasterizedResult();
        this._manager._RemoveImage(this);
        this._manager = null
    }
    GetDataSource() {
        return this._dataSource
    }
    IncReference() {
        this._refCount++
    }
    HasReferences() {
        return 0 < this._refCount
    }
    GetRasterizedResult() {
        return this._rasterizedResult
    }
    ForceRasterAgain() {
        this._forceRaster = !0
    }
    async StartRasterForSize(a, b, d) {
        if (0 !== b && 0 !== d && !this._hadError && !this._isRasterizing) {
            var c = C3$jscomp$34.nextHighestPowerOfTwo(Math.ceil(b))
              , e = C3$jscomp$34.nextHighestPowerOfTwo(Math.ceil(d))
              , g = Math.max(c, e);
            4096 < g && (g = 4096 / g,
            b *= g,
            d *= g,
            c = Math.min(Math.ceil(c * g), 4096),
            e = Math.min(Math.ceil(e * g), 4096));
            b < c && d < e && (d = b / d,
            c / e > d ? (b = e * d,
            d = e) : (b = c,
            d = c / d));
            this._manager.IsNpotSurfaceAllowed() && (c = Math.ceil(b),
            e = Math.ceil(d));
            c <= this._rasterSurfaceWidth && e <= this._rasterSurfaceHeight && !this._forceRaster || (this._isRasterizing = !0,
            this._rasterSurfaceWidth = c,
            this._rasterSurfaceHeight = e,
            a = await this._manager.RasterAtSize(this._dataSource, a, this._rasterSurfaceWidth, this._rasterSurfaceHeight, b, d),
            this._manager && (this.ReleaseRasterizedResult(),
            this._rasterizedResult = a,
            this._rasterImageWidth = b,
            this._rasterImageHeight = d,
            this._forceRaster = this._isRasterizing = !1,
            this._manager.Redraw()))
        }
    }
    WhenBaseSizeReady() {
        return this._getBaseSizePromise
    }
    GetBaseWidth() {
        return this._baseWidth
    }
    GetBaseHeight() {
        return this._baseHeight
    }
    GetRasterWidth() {
        return this._rasterImageWidth
    }
    GetRasterHeight() {
        return this._rasterImageHeight
    }
    HadError() {
        return this._hadError
    }
}
;
"use strict";
const C3$jscomp$35 = self.C3;
C3$jscomp$35.UTF8_BOM = "\ufeff";
const NUMERIC_CHARS = new Set([..."0123456789"]);
C3$jscomp$35.IsNumericChar = function(a) {
    return NUMERIC_CHARS.has(a)
}
;
const WHITESPACE_CHARS = new Set([..." \t\n\r\u00a0\u0085\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000"]);
C3$jscomp$35.IsWhitespaceChar = function(a) {
    return WHITESPACE_CHARS.has(a)
}
;
C3$jscomp$35.FilterWhitespace = function(a) {
    return [...a].filter(b=>!C3$jscomp$35.IsWhitespaceChar(b)).join("")
}
;
C3$jscomp$35.IsStringAllWhitespace = function(a) {
    for (const b of a)
        if (!C3$jscomp$35.IsWhitespaceChar(b))
            return !1;
    return !0
}
;
C3$jscomp$35.IsCharArrayAllWhitespace = function(a) {
    for (const b of a)
        if (!C3$jscomp$35.IsWhitespaceChar(b))
            return !1;
    return !0
}
;
C3$jscomp$35.IsUnprintableChar = function(a) {
    return 1 === a.length && 32 > a.charCodeAt(0)
}
;
C3$jscomp$35.FilterUnprintableChars = function(a) {
    return [...a].filter(b=>!C3$jscomp$35.IsUnprintableChar(b)).join("")
}
;
const NUMERIC_STRING_CHARS = new Set([..."0123456789.+-e"]);
C3$jscomp$35.IsStringNumber = function(a) {
    a = a.trim();
    if (!a.length)
        return !1;
    let b = a.charAt(0);
    if ("-" !== b && !NUMERIC_CHARS.has(b))
        return !1;
    for (let d of a)
        if (!NUMERIC_STRING_CHARS.has(d))
            return !1;
    return !0
}
;
C3$jscomp$35.RemoveTrailingDigits = function(a) {
    let b = a.length;
    for (; 0 < b; ) {
        let d = a.charAt(b - 1);
        if (!C3$jscomp$35.IsNumericChar(d))
            break;
        --b
    }
    return a.substr(0, b)
}
;
C3$jscomp$35.IncrementNumberAtEndOf = function(a) {
    let b = C3$jscomp$35.RemoveTrailingDigits(a);
    a = (a = a.substr(b.length)) ? (parseInt(a, 10) + 1).toString() : "2";
    return b + a
}
;
const HTML_ENTITY_MAP = new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ['"', "&quot;"], ["'", "&#39;"]]);
function lookupHtmlEntity(a) {
    return HTML_ENTITY_MAP.get(a)
}
const HTML_ENTITY_REGEX = /[&<>"']/g;
C3$jscomp$35.EscapeHTML = function(a) {
    return a.replace(HTML_ENTITY_REGEX, lookupHtmlEntity)
}
;
C3$jscomp$35.EscapeJS = function(a) {
    a = C3$jscomp$35.ReplaceAll(a, "\\", "\\\\");
    a = C3$jscomp$35.ReplaceAll(a, '"', '\\"');
    a = C3$jscomp$35.ReplaceAll(a, "\t", "\\t");
    a = C3$jscomp$35.ReplaceAll(a, "\r", "");
    return C3$jscomp$35.ReplaceAll(a, "\n", "\\n")
}
;
C3$jscomp$35.EscapeXML = function(a) {
    a = C3$jscomp$35.ReplaceAll(a, "&", "&amp;");
    a = C3$jscomp$35.ReplaceAll(a, "<", "&lt;");
    a = C3$jscomp$35.ReplaceAll(a, ">", "&gt;");
    return C3$jscomp$35.ReplaceAll(a, '"', "&quot;")
}
;
const ESCAPE_REGEX = /[-[\]{}()*+?.,\\^$|#\s]/g;
C3$jscomp$35.EscapeRegex = function(a) {
    return a.replace(ESCAPE_REGEX, "\\$&")
}
;
C3$jscomp$35.CountCharsInString = function(a, b) {
    let d = 0;
    for (const c of a)
        c === b && ++d;
    return d
}
;
C3$jscomp$35.FindAll = function(a, b, d=!1) {
    if (!b)
        return [];
    d || (a = a.toLowerCase(),
    b = b.toLowerCase());
    d = b.length;
    var c = 0;
    let e = [];
    for (; -1 < (c = a.indexOf(b, c)); )
        e.push(c),
        c += d;
    return e
}
;
C3$jscomp$35.ReplaceAll = function(a, b, d) {
    return a.replaceAll(b, ()=>d)
}
;
C3$jscomp$35.ReplaceAllCaseInsensitive = function(a, b, d) {
    return a.replace(new RegExp(C3$jscomp$35.EscapeRegex(b),"gi"), ()=>d)
}
;
C3$jscomp$35.SetElementContent = function(a, b) {
    "string" === typeof b ? a.textContent = b : b.isPlainText() ? a.textContent = b.toString() : (a.innerHTML = b.toHTML(),
    b instanceof C3$jscomp$35.BBString && b.attachLinkHandlers(a))
}
;
C3$jscomp$35.StringLikeEquals = function(a, b) {
    return a instanceof C3$jscomp$35.HtmlString || a instanceof C3$jscomp$35.BBString ? a.equals(b) : b instanceof C3$jscomp$35.HtmlString || b instanceof C3$jscomp$35.BBString ? b.equals(a) : a === b
}
;
C3$jscomp$35.StringSubstitute = function(a, ...b) {
    let d = a;
    for (let c = 0, e = b.length; c < e; ++c) {
        const g = `{${c}}`;
        if (!a.includes(g))
            throw Error(`missing placeholder '${g}' in string substitution`);
        d = d.replace(g, b[c].toString())
    }
    return d
}
;
C3$jscomp$35.StringSubstituteAllowMissing = function(a, ...b) {
    let d = a
      , c = -1
      , e = -1;
    for (let g = 0, k = b.length; g < k; ++g) {
        const l = `{${g}}`;
        a.includes(l) ? (e = g,
        d = d.replace(l, b[g].toString())) : -1 === c && (c = g)
    }
    if (0 <= c && 0 <= e && c < e)
        throw Error(`missing placeholder '${c}' in string substitution`);
    return d
}
;
C3$jscomp$35.StringSubstituteMap = function(a, b) {
    for (let[d,c] of Object.entries(b))
        a = a.replaceAll(d, c.toString());
    return a
}
;
C3$jscomp$35.SortAZ = function(a, b) {
    return a > b ? 1 : a < b ? -1 : 0
}
;
C3$jscomp$35.SortAZCaseInsensitive = function(a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    return a > b ? 1 : a < b ? -1 : 0
}
;
let intlSegmenter = null
  , graphemeSplitter = null;
self.Intl && self.Intl.Segmenter ? intlSegmenter = new self.Intl.Segmenter : graphemeSplitter = new self.GraphemeSplitter;
C3$jscomp$35.SplitGraphemes = function(a) {
    if (intlSegmenter) {
        const b = [];
        for (const d of intlSegmenter.segment(a))
            b.push(d.segment);
        return b
    }
    return graphemeSplitter.splitGraphemes(a)
}
;
C3$jscomp$35.IterateGraphemes = function*(a) {
    if (intlSegmenter)
        for (const b of intlSegmenter.segment(a))
            yield b.segment;
    else
        yield*graphemeSplitter.iterateGraphemes(a)
}
;
C3$jscomp$35.CountGraphemes = function(a) {
    if (intlSegmenter) {
        let b = 0;
        for (const d of intlSegmenter.segment(a))
            ++b;
        return b
    }
    return graphemeSplitter.countGraphemes(a)
}
;
const MEGABYTE = 1048576
  , GIGABYTE = 1024 * MEGABYTE
  , TERABYTE = 1024 * GIGABYTE;
C3$jscomp$35.FormatDataSize = function(a, b) {
    b = "common." + (b ? "dataRates" : "dataSizes") + ".";
    const d = self.langSub;
    if (1024 > a)
        return d(b + "bytes", a);
    if (a < MEGABYTE)
        return a /= 1024,
        a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a),
        d(b + "kilobytes", a);
    if (a < GIGABYTE)
        return a /= MEGABYTE,
        a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a),
        d(b + "megabytes", a);
    if (a < TERABYTE)
        return a /= GIGABYTE,
        a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a),
        d(b + "gigabytes", a);
    a /= TERABYTE;
    a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a);
    return d(b + "terabytes", a)
}
;
const DEFAULT_FORMATTIME_OPTS = {
    approximate: !1,
    days: !0,
    hours: !0,
    minutes: !0,
    seconds: !0
};
C3$jscomp$35.FormatTime = function(a, b) {
    b = Object.assign({}, DEFAULT_FORMATTIME_OPTS, b);
    C3$jscomp$35.Lang.PushContext("common.time");
    const d = []
      , c = self.lang
      , e = self.langPluralSub;
    if (b.days) {
        var g = Math.floor(a / 86400);
        0 < g && (a -= 86400 * g,
        d.push(e(".days", null, g)))
    }
    b.hours && (g = Math.floor(a / 3600),
    0 < g || d.length) && (a -= 3600 * g,
    d.push(e(".hours", null, g)));
    b.minutes && (g = Math.floor(a / 60),
    0 < g || d.length || !b.seconds) && (a -= 60 * g,
    d.push(e(".minutes", null, g)));
    b.seconds && d.push(e(".seconds", null, Math.floor(a % 60)));
    a = (b.approximate ? c(".approx-prefix") : "") + d.join(c(".separator"));
    C3$jscomp$35.Lang.PopContext();
    return a
}
;
C3$jscomp$35.ZeroPad = function(a, b) {
    let d = 0 > a ? "-" : "";
    a = Math.abs(a);
    a = a.toString();
    b -= a.length;
    for (let c = 0; c < b; ++c)
        d += "0";
    return d + a
}
;
C3$jscomp$35.StringToTitleCase = function(a) {
    return a.toLowerCase().replace(/\b\w/g, b=>b.toUpperCase())
}
;
C3$jscomp$35.CompareVersionStrings = function(a, b) {
    a = a.split(".").map(d=>d.trim());
    b = b.split(".").map(d=>d.trim());
    C3$jscomp$35.resizeArray(a, 4, "0");
    C3$jscomp$35.resizeArray(b, 4, "0");
    a = a.map(d=>parseInt(d, 10));
    b = b.map(d=>parseInt(d, 10));
    for (let d = 0; 4 > d; ++d) {
        const c = a[d] - b[d];
        if (0 !== c)
            return 0 > c ? -1 : 1
    }
    return 0
}
;
C3$jscomp$35.CreateGUID = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, a=>{
        const b = Math.floor(16 * Math.random());
        return ("x" === a ? b : b & 3 | 8).toString(16)
    }
    )
}
;
C3$jscomp$35.StringHammingDistance = function(a, b) {
    if (a.length !== b.length)
        throw Error("strings must be same length");
    let d = 0;
    for (let c = 0, e = a.length; c < e; ++c)
        a.charAt(c) !== b.charAt(c) && ++d;
    return d
}
;
C3$jscomp$35.StringLevenshteinDistance = function(a, b) {
    if (0 === a.length)
        return b.length;
    if (0 === b.length)
        return a.length;
    let d, c, e, g;
    if (a.length > b.length) {
        var k = a;
        a = b;
        b = k
    }
    g = Array(a.length + 1);
    for (k = 0; k <= a.length; k++)
        g[k] = k;
    for (k = 1; k <= b.length; k++) {
        c = k;
        for (d = 1; d <= a.length; d++)
            e = b[k - 1] === a[d - 1] ? g[d - 1] : Math.min(g[d - 1] + 1, Math.min(c + 1, g[d] + 1)),
            g[d - 1] = c,
            c = e;
        g[a.length] = c
    }
    return g[a.length]
}
;
"use strict";
const C3$jscomp$36 = self.C3
  , BB_CODE_MAP = new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["sub", "sub"], ["sup", "sup"], ["small", "small"], ["mark", "mark"], ["code", "code"], ["a1", "a"], ["a2", "a"], ["a3", "a"], ["a4", "a"], ["a5", "a"], ["a6", "a"], ["a7", "a"], ["a8", "a"], ["a9", "a"], ["tip1", "abbr"], ["tip2", "abbr"], ["tip3", "abbr"], ["tip4", "abbr"], ["tip5", "abbr"], ["tip6", "abbr"], ["tip7", "abbr"], ["tip8", "abbr"], ["tip9", "abbr"], ["bad", ["span", "bbCodeBad"]], ["good", ["span", "bbCodeGood"]], ["info", ["span", "bbCodeInfo"]], ["h1", ["span", "bbCodeH1"]], ["h2", ["span", "bbCodeH2"]], ["h3", ["span", "bbCodeH3"]], ["h4", ["span", "bbCodeH4"]], ["item", ["span", "bbCodeItem"]]])
  , BBREGEX = /\[(\/?)([a-zA-Z0-9]+)\]/g
  , CUSTOM_BBREGEX = /\[(\/?)([^\[\n]*?)\]/g;
let linkActions = null
  , tipList = null
  , classIndex = 0;
function bbToHtmlReplacerFunc(a, b, d) {
    var c = BB_CODE_MAP.get(d);
    if (c) {
        if ("string" === typeof c) {
            if ("a" === c && 0 === linkActions.length || "abbr" === c && 0 === tipList.length)
                return a;
            if ("a" !== c || b) {
                if ("abbr" !== c || b)
                    return "<" + b + c + ">";
                b = parseInt(d.substring(3), 10) - 1;
                if (0 > b || b >= tipList.length)
                    throw Error("invalid bbcode tip substitution");
                b = tipList[b];
                c = "";
                "string" === typeof b ? c = b : "function" === typeof b && (c = b());
                if ("string" !== typeof c)
                    throw new TypeError("invalid bbcode tip");
                return `<abbr title="${C3$jscomp$36.ReplaceAll(c, '"', "&quot;")}">`
            }
            b = parseInt(d.substring(1), 10) - 1;
            if (0 > b || b >= linkActions.length)
                throw Error("invalid bbcode link substitution");
            c = linkActions[b];
            if ("string" === typeof c)
                return `<a href="${linkActions[b]}">`;
            if ("function" === typeof c)
                return `<a class="bblink ${b}">`;
            throw new TypeError("invalid bbcode link action");
        }
        if (Array.isArray(c))
            return a = c[0],
            c = c[1],
            b ? "</" + a + ">" : `<${a} class="${c}">`
    } else
        return "class" === d ? b ? "</span>" : `<span class="bbclass ${classIndex++}">` : a
}
const LINEBREAK_REGEX = /\n/g;
C3$jscomp$36.BBString = class {
    constructor(a, b) {
        this._bbstr = b && b.noEscape ? a : C3$jscomp$36.EscapeHTML(a);
        this._htmlstr = "";
        this._convertLineBreaks = !1;
        this._linkActions = [];
        this._tipList = [];
        if (b) {
            this._convertLineBreaks = !!b.convertLineBreaks;
            if (b.links) {
                if (9 < b.links.length)
                    throw Error("too many links");
                this._linkActions = b.links
            }
            if (b.tips) {
                if (9 < b.tips.length)
                    throw Error("too many tips");
                this._tipList = b.tips
            }
        }
        this._hasAnyBBtags = this._bbstr.includes("[");
        this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes("\n");
        this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes("&");
        this._hasParsedFragments = !1;
        this._fragments = []
    }
    toString() {
        return this._bbstr
    }
    valueOf() {
        return this._bbstr
    }
    isPlainText() {
        return this._isPlain
    }
    toPlainText() {
        return this._hasAnyBBtags ? this._bbstr.replace(BBREGEX, "") : this._bbstr
    }
    toHTML() {
        if (this._isPlain)
            return this._bbstr;
        if (!this._htmlstr && this._bbstr) {
            let a = this._bbstr;
            this._hasAnyBBtags && (classIndex = 0,
            linkActions = this._linkActions,
            tipList = this._tipList,
            a = a.replace(BBREGEX, bbToHtmlReplacerFunc),
            tipList = linkActions = null);
            this._needsLineBreakConversion && (a = a.replace(LINEBREAK_REGEX, "<br>"));
            this._htmlstr = a
        }
        return this._htmlstr
    }
    attachLinkHandlers(a) {
        if (this._linkActions.length)
            for (let b = 0, d = this._linkActions.length; b < d; ++b) {
                const c = this._linkActions[b];
                if ("function" !== typeof c)
                    continue;
                const e = a.querySelector(".bblink" + b);
                if (!e)
                    throw Error("unable to attach BBString link handler");
                e.onclick = c
            }
    }
    equals(a) {
        return a instanceof C3$jscomp$36.HtmlString ? this.toHTML() === a.toHTML() : a instanceof C3$jscomp$36.BBString ? this._bbstr === a._bbstr : this._bbstr === a
    }
    toFragmentList() {
        if (this._hasParsedFragments)
            return this._fragments;
        const a = this._bbstr
          , b = [];
        let d = CUSTOM_BBREGEX.lastIndex = 0;
        for (var c; null !== (c = CUSTOM_BBREGEX.exec(a)); ) {
            var e = c.index;
            if (0 < e && "\\" === a.charAt(e - 1))
                continue;
            var g = c[0]
              , k = c[1];
            c = c[2];
            const l = a.substring(d, e);
            d = e + g.length;
            l && this._fragments.push({
                text: l,
                styles: b.slice(0)
            });
            if (c)
                if (k)
                    for (c = c.toLowerCase(),
                    e = b.length - 1; 0 <= e; --e) {
                        if (b[e].tag === c) {
                            b.splice(e, 1);
                            break
                        }
                    }
                else
                    e = c,
                    g = null,
                    k = c.indexOf("="),
                    -1 !== k ? (e = c.substring(0, k).toLowerCase(),
                    g = c.substring(k + 1)) : e = e.toLowerCase(),
                    b.push({
                        tag: e,
                        param: g
                    })
        }
        d < a.length && this._fragments.push({
            text: a.substring(d),
            styles: b.slice(0)
        });
        for (const l of this._fragments)
            l.text = this._ProcessBBCodeEscapeSequences(l.text);
        this._hasParsedFragments = !0;
        return this._fragments
    }
    _ProcessBBCodeEscapeSequences(a) {
        a = C3$jscomp$36.ReplaceAll(a, "\\[", "[");
        return C3$jscomp$36.ReplaceAll(a, "\\\\", "\\")
    }
    static StripTags(a) {
        return C3$jscomp$36.New(C3$jscomp$36.BBString, a, {
            noEscape: !0
        }).toPlainText()
    }
    static StripAnyTags(a) {
        return a.replace(CUSTOM_BBREGEX, "")
    }
}
;
"use strict";
const C3$jscomp$37 = self.C3;
function IsWordBreakWhiteSpace(a) {
    return "\u00a0" === a || "\u202f" === a ? !1 : C3$jscomp$37.IsWhitespaceChar(a)
}
function WordBreakTrimEnd(a) {
    for (; 0 < a.length && IsWordBreakWhiteSpace(a.at(-1)); )
        a.pop()
}
function IsNewline(a) {
    return "\n" === a || "\r\n" === a
}
C3$jscomp$37.WordWrap = class {
    constructor() {
        this._lines = []
    }
    GetLines() {
        return this._lines
    }
    GetLineCount() {
        return this._lines.length
    }
    _MeasureLine(a, b) {
        let d = 0
          , c = 0
          , e = 0
          , g = 0
          , k = 0;
        for (const l of a)
            -1 === l.width && (a = b(l.chArr, l.styles),
            l.width = a.width,
            l.height = a.height,
            l.fontBoundingBoxAscent = a.fontBoundingBoxAscent || 0,
            l.fontBoundingBoxDescent = a.fontBoundingBoxDescent || 0,
            l.topToAlphabeticDistance = a.topToAlphabeticDistance || 0),
            d += l.width,
            c = Math.max(c, l.height),
            e = Math.max(e, l.fontBoundingBoxAscent),
            g = Math.max(g, l.fontBoundingBoxDescent),
            k = Math.max(k, l.topToAlphabeticDistance);
        return {
            width: d,
            height: c,
            fontBoundingBoxAscent: e,
            fontBoundingBoxDescent: g,
            topToAlphabeticDistance: k
        }
    }
    _AddLine(a, b, d, c, e, g) {
        this._lines.push({
            fragments: a,
            width: b,
            height: d,
            fontBoundingBoxAscent: c,
            fontBoundingBoxDescent: e,
            topToAlphabeticDistance: g
        })
    }
    WordWrap(a, b, d, c, e) {
        "string" === typeof a && (a = [{
            text: a,
            styles: []
        }]);
        C3$jscomp$37.clearArray(this._lines);
        if (!(!a.length || 1 === a.length && !a[0].text.length || 2 > d)) {
            a = a.map(k=>({
                chArr: C3$jscomp$37.SplitGraphemes(k.text),
                styles: k.styles
            }));
            if (1 === a.length) {
                var g = a[0];
                const k = g.chArr;
                g = g.styles;
                if (100 >= k.length && !k.includes("\n")) {
                    let {width: l, height: n, fontBoundingBoxAscent: p, fontBoundingBoxDescent: t, topToAlphabeticDistance: w} = b(k, g);
                    l += e;
                    p = p || 0;
                    t = t || 0;
                    w = w || 0;
                    if (l <= d) {
                        this._AddLine([{
                            chArr: k,
                            styles: g,
                            width: l,
                            height: n,
                            fontBoundingBoxAscent: p,
                            fontBoundingBoxDescent: t,
                            topToAlphabeticDistance: w
                        }], l, n, p, t, w);
                        return
                    }
                }
            }
            if ("word" === c)
                c = this._TokeniseWords(a);
            else {
                c = [];
                for (const k of a)
                    C3$jscomp$37.appendArray(c, k.chArr.map(l=>[{
                        chArr: [l],
                        styles: k.styles
                    }]))
            }
            this._WrapText(c, b, d, e)
        }
    }
    _TokeniseWords(a) {
        const b = [];
        let d = []
          , c = !1;
        for (const g of a) {
            var e = g.chArr;
            a = g.styles;
            for (const k of e)
                IsNewline(k) ? (0 < d.length && b.push(d),
                b.push([{
                    chArr: ["\n"],
                    styles: a
                }]),
                d = []) : 0 === d.length ? (d.push({
                    chArr: [k],
                    styles: a
                }),
                c = IsWordBreakWhiteSpace(k)) : (e = IsWordBreakWhiteSpace(k),
                e === c ? (e = d.at(-1),
                e.styles === a ? e.chArr.push(k) : d.push({
                    chArr: [k],
                    styles: a
                })) : (b.push(d),
                d = [],
                d.push({
                    chArr: [k],
                    styles: a
                }),
                c = e))
        }
        0 < d.length && b.push(d);
        return b
    }
    _CopyLine(a) {
        return a.map(b=>({
            chArr: b.chArr.slice(0),
            styles: b.styles,
            width: b.width,
            height: b.height,
            fontBoundingBoxAscent: b.fontBoundingBoxAscent,
            fontBoundingBoxDescent: b.fontBoundingBoxDescent,
            topToAlphabeticDistance: b.topToAlphabeticDistance
        }))
    }
    _AddWordToLine(a, b) {
        var d = a.length ? a.at(-1) : null;
        let c = 0;
        d && b[0].styles === d.styles && (C3$jscomp$37.appendArray(d.chArr, b[0].chArr),
        d.width = -1,
        d.height = -1,
        d.fontBoundingBoxAscent = -1,
        d.fontBoundingBoxDescent = -1,
        d.topToAlphabeticDistance = -1,
        c = 1);
        for (d = b.length; c < d; ++c) {
            const e = b[c];
            a.push({
                chArr: e.chArr.slice(0),
                styles: e.styles,
                width: -1,
                height: -1,
                fontBoundingBoxAscent: -1,
                fontBoundingBoxDescent: -1,
                topToAlphabeticDistance: -1
            })
        }
    }
    _WrapText(a, b, d, c) {
        let e = []
          , g = 0
          , k = 0
          , l = 0
          , n = 0;
        var p = 0;
        for (const t of a) {
            if (1 === t.length && 1 === t[0].chArr.length && IsNewline(t[0].chArr[0])) {
                0 === k && (p = b([" "], t[0].styles),
                k = p.height,
                l = p.fontBoundingBoxAscent || 0,
                n = p.fontBoundingBoxDescent || 0,
                p = p.topToAlphabeticDistance || 0);
                this._AddLine(e, g, k, l, n, p);
                e = [];
                p = n = l = k = g = 0;
                continue
            }
            a = this._CopyLine(e);
            this._AddWordToLine(a, t);
            const w = this._MeasureLine(a, b)
              , z = w.width;
            z >= d ? (0 < e.length && this._AddLine(e, g, k, l, n, p),
            e = [],
            C3$jscomp$37.IsCharArrayAllWhitespace(t[0].chArr) ? p = n = l = k = g = 0 : (this._AddWordToLine(e, t),
            p = this._MeasureLine(e, b),
            g = p.width,
            k = p.height,
            l = p.fontBoundingBoxAscent,
            n = p.fontBoundingBoxDescent,
            p = p.topToAlphabeticDistance)) : (e = a,
            g = z,
            k = w.height,
            l = w.fontBoundingBoxAscent,
            n = w.fontBoundingBoxDescent,
            p = w.topToAlphabeticDistance)
        }
        0 < e.length && this._AddLine(e, g, k, l, n, p);
        this._TrimLinesTrailingWhitespace(b, c)
    }
    _TrimLinesTrailingWhitespace(a, b) {
        for (const c of this._lines) {
            const e = c.fragments;
            if (!e.length)
                continue;
            let g = e.at(-1);
            var d = g.chArr;
            const k = d.slice(0);
            WordBreakTrimEnd(k);
            if (0 === k.length)
                c.width -= g.width,
                e.pop();
            else if (k.length < d.length) {
                d = a(k, g.styles).width;
                const l = g.width - d;
                g.width = d;
                g.chArr = k;
                c.width -= l
            }
            0 !== b && 0 < e.length && (g = e.at(-1),
            g.width += b,
            c.width += b)
        }
    }
    Clear() {
        C3$jscomp$37.clearArray(this._lines)
    }
    GetMaxLineWidth() {
        return this._lines.reduce((a,b)=>Math.max(a, b.width), 0)
    }
    GetTotalLineHeight() {
        return this._lines.reduce((a,b)=>a + b.height, 0)
    }
}
;
"use strict";
const C3$jscomp$38 = self.C3
  , glMatrix = self.glMatrix
  , vec3$jscomp$1 = glMatrix.vec3
  , vec4$jscomp$1 = glMatrix.vec4
  , mat4$jscomp$1 = glMatrix.mat4
  , tempVec3a = vec3$jscomp$1.create()
  , tempVec3b = vec3$jscomp$1.create()
  , tempVec3c = vec3$jscomp$1.create()
  , tempVec4 = vec4$jscomp$1.create()
  , tempMat4 = mat4$jscomp$1.create()
  , neartl = vec3$jscomp$1.create()
  , neartr = vec3$jscomp$1.create()
  , nearbl = vec3$jscomp$1.create()
  , nearbr = vec3$jscomp$1.create()
  , fartl = vec3$jscomp$1.create()
  , fartr = vec3$jscomp$1.create()
  , farbl = vec3$jscomp$1.create()
  , farbr = vec3$jscomp$1.create()
  , unitViewport = vec4$jscomp$1.fromValues(0, 0, 1, 1);
C3$jscomp$38.Gfx = {
    Project(a, b, d, c, e, g, k) {
        const l = c[0] * a + c[4] * b + c[8] * d + c[12]
          , n = c[1] * a + c[5] * b + c[9] * d + c[13]
          , p = c[2] * a + c[6] * b + c[10] * d + c[14];
        c = c[3] * a + c[7] * b + c[11] * d + c[15];
        a = e[0] * l + e[4] * n + e[8] * p + e[12] * c;
        b = e[1] * l + e[5] * n + e[9] * p + e[13] * c;
        d = e[2] * l + e[6] * n + e[10] * p + e[14] * c;
        e = e[3] * l + e[7] * n + e[11] * p + e[15] * c;
        if (0 === e)
            return !1;
        e = 1 / e;
        k[0] = (a * e * .5 + .5) * g[2] + g[0];
        k[1] = (b * e * .5 + .5) * g[3] + g[1];
        k[2] = .5 * (1 + d * e);
        return !0
    },
    Unproject(a, b, d, c, e, g, k) {
        mat4$jscomp$1.multiply(tempMat4, e, c);
        if (null === mat4$jscomp$1.invert(tempMat4, tempMat4))
            return !1;
        tempVec4[0] = (a - g[0]) / g[2] * 2 - 1;
        tempVec4[1] = (b - g[1]) / g[3] * 2 - 1;
        tempVec4[2] = 2 * d - 1;
        tempVec4[3] = 1;
        vec4$jscomp$1.transformMat4(tempVec4, tempVec4, tempMat4);
        if (0 === tempVec4[3])
            return !1;
        tempVec4[3] = 1 / tempVec4[3];
        k[0] = tempVec4[0] * tempVec4[3];
        k[1] = tempVec4[1] * tempVec4[3];
        k[2] = tempVec4[2] * tempVec4[3];
        return !0
    },
    UnprojectScreenToWorldZ(a, b, d, c, e, g, k) {
        const l = tempVec3a;
        if (!C3$jscomp$38.Gfx.Unproject(a, b, 0, c, e, g, l) || !C3$jscomp$38.Gfx.Unproject(a, b, 1, c, e, g, tempVec3b))
            return !1;
        vec3$jscomp$1.subtract(tempVec3b, tempVec3b, l);
        a = tempVec3c;
        vec3$jscomp$1.set(a, 0, 0, 1);
        d = -d;
        b = vec3$jscomp$1.dot(a, tempVec3b);
        c = 0;
        if (0 === b) {
            if (0 !== vec3$jscomp$1.dot(a, l) + d)
                return !1
        } else if (c = -(vec3$jscomp$1.dot(l, a) + d) / b,
        0 > c)
            return !1;
        vec3$jscomp$1.scaleAndAdd(k, l, tempVec3b, c);
        return !0
    }
};
function PlaneFromPoints(a, b, d, c) {
    vec3$jscomp$1.subtract(tempVec3a, d, b);
    vec3$jscomp$1.subtract(tempVec3b, a, b);
    vec3$jscomp$1.cross(tempVec3c, tempVec3a, tempVec3b);
    vec3$jscomp$1.normalize(tempVec3c, tempVec3c);
    c.set(tempVec3c[0], tempVec3c[1], tempVec3c[2], vec3$jscomp$1.dot(a, tempVec3c))
}
function IsInFrontOfPlane(a, b, d, c, e, g, k) {
    const l = k.x
      , n = k.y
      , p = k.z
      , t = k.w
      , w = k.xF
      , z = k.yF;
    k = k.zF;
    const B = 1 - w
      , C = 1 - z
      , E = 1 - k;
    return l * a * w + l * c * B + n * b * z + n * e * C + p * d * k + p * g * E >= t ? !0 : l * c * w + l * a * B + n * e * z + n * b * C + p * g * k + p * d * E > t
}
function IsPointInFrontOfPlane(a, b, d, c) {
    return c.x * a + c.y * b + c.z * d >= c.w
}
class Plane {
    constructor() {
        this.zF = this.yF = this.xF = this.w = this.z = this.y = this.x = NaN
    }
    set(a, b, d, c) {
        this.x = a;
        this.y = b;
        this.z = d;
        this.w = c;
        this.xF = 0 < a ? 1 : 0;
        this.yF = 0 < b ? 1 : 0;
        this.zF = 0 < d ? 1 : 0
    }
}
C3$jscomp$38.Gfx.ViewFrustum = class {
    constructor() {
        this._leftP = new Plane;
        this._topP = new Plane;
        this._rightP = new Plane;
        this._bottomP = new Plane;
        this._nearP = new Plane;
        this._farP = new Plane
    }
    CalculatePlanes(a, b) {
        C3$jscomp$38.Gfx.Unproject(0, 1, 0, a, b, unitViewport, neartl);
        C3$jscomp$38.Gfx.Unproject(1, 1, 0, a, b, unitViewport, neartr);
        C3$jscomp$38.Gfx.Unproject(0, 0, 0, a, b, unitViewport, nearbl);
        C3$jscomp$38.Gfx.Unproject(1, 0, 0, a, b, unitViewport, nearbr);
        C3$jscomp$38.Gfx.Unproject(0, 1, 1, a, b, unitViewport, fartl);
        C3$jscomp$38.Gfx.Unproject(1, 1, 1, a, b, unitViewport, fartr);
        C3$jscomp$38.Gfx.Unproject(0, 0, 1, a, b, unitViewport, farbl);
        C3$jscomp$38.Gfx.Unproject(1, 0, 1, a, b, unitViewport, farbr);
        PlaneFromPoints(nearbl, neartl, fartl, this._leftP);
        PlaneFromPoints(neartl, neartr, fartr, this._topP);
        PlaneFromPoints(neartr, nearbr, farbr, this._rightP);
        PlaneFromPoints(nearbr, nearbl, farbl, this._bottomP);
        PlaneFromPoints(farbl, fartl, fartr, this._farP);
        PlaneFromPoints(nearbr, neartr, neartl, this._nearP)
    }
    ContainsAABB(a, b, d, c, e, g) {
        return IsInFrontOfPlane(a, b, d, c, e, g, this._leftP) && IsInFrontOfPlane(a, b, d, c, e, g, this._topP) && IsInFrontOfPlane(a, b, d, c, e, g, this._rightP) && IsInFrontOfPlane(a, b, d, c, e, g, this._bottomP) && IsInFrontOfPlane(a, b, d, c, e, g, this._nearP) && IsInFrontOfPlane(a, b, d, c, e, g, this._farP)
    }
    IsBehindNearPlane(a, b, d) {
        return !IsPointInFrontOfPlane(a, b, d, this._nearP)
    }
}
;
"use strict";
const C3$jscomp$39 = self.C3
  , glMatrix$jscomp$1 = self.glMatrix
  , vec3$jscomp$2 = glMatrix$jscomp$1.vec3
  , vec4$jscomp$2 = glMatrix$jscomp$1.vec4
  , mat4$jscomp$2 = glMatrix$jscomp$1.mat4
  , tempMat4$jscomp$1 = mat4$jscomp$2.create()
  , tmpVec3a = vec3$jscomp$2.fromValues(0, 0, 0)
  , tmpVec3b = vec3$jscomp$2.fromValues(0, 0, 0)
  , tmpVec3c = vec3$jscomp$2.fromValues(0, 0, 0)
  , defaultUpVector = vec3$jscomp$2.fromValues(0, 1, 0);
vec4$jscomp$2.fromValues(0, 0, 0, 0);
const tmpQuad = new C3$jscomp$39.Quad
  , tmpRect = new C3$jscomp$39.Rect
  , defaultTexCoordsQuad = new C3$jscomp$39.Quad(0,0,1,0,1,1,0,1)
  , DEFAULT_RENDERERBASE_OPTS = {
    nearZ: 1,
    farZ: 1E4
};
C3$jscomp$39.Gfx.RendererBase = class {
    constructor(a) {
        a = Object.assign({}, DEFAULT_RENDERERBASE_OPTS, a);
        this._height = this._width = 0;
        this._fovY = C3$jscomp$39.toRadians(45);
        this._tan_fovY_2 = Math.tan(this._fovY / 2);
        this._matP = mat4$jscomp$2.create();
        this._matMV = mat4$jscomp$2.create();
        this._zAxisScale = !1;
        this._nearZ = a.nearZ;
        this._farZ = a.farZ;
        this._allShaderPrograms = [];
        this._shaderProgramsByName = new Map;
        this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spPenumbraFill = this._spLinearGradientFill = this._spColorFill = this._spTileRandomization = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
        this._stateGroups = new Map;
        this._currentStateGroup = null;
        this._blendModeTable = [];
        this._namedBlendModeMap = new Map;
        this._currentZ = this._baseZ = 0;
        this._lineWidth = 1;
        this._lineWidthStack = [this._lineWidth];
        this._lineCap = 1;
        this._lineCapStack = [this._lineCap];
        this._lineOffset = .5;
        this._lineOffsetStack = [this._lineOffset];
        this._frameNumber = 0;
        this._enableMipmaps = !0;
        this._hasMajorPerformanceCaveat = !1
    }
    FillIndexBufferData(a) {
        let b = 0
          , d = a.length
          , c = 0;
        for (; b < d; )
            a[b++] = c,
            a[b++] = c + 1,
            a[b++] = c + 2,
            a[b++] = c,
            a[b++] = c + 2,
            a[b++] = c + 3,
            c += 4
    }
    _ClearState() {
        this._currentZ = this._baseZ = 0;
        this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spPenumbraFill = this._spLinearGradientFill = this._spColorFill = this._spTileRandomization = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
        this._ClearAllShaderPrograms()
    }
    InitState() {
        this._ClearState();
        this._currentStateGroup = null
    }
    OnDeviceOrContextLost() {
        for (const a of this._allShaderPrograms)
            a.Release();
        this._ClearState()
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    GetDefaultCameraZ(a) {
        return this.IsZAxisScaleNormalized() ? 100 : a / (2 * this._GetTanFovYDiv2())
    }
    GetZAxisScaleFactor(a) {
        return this.IsZAxisScaleNormalized() ? a / (2 * this._GetTanFovYDiv2()) / this.GetDefaultCameraZ(a) : 1
    }
    SetNearZ(a) {
        this._nearZ = a
    }
    GetNearZ() {
        return this._nearZ
    }
    SetFarZ(a) {
        this._farZ = a
    }
    GetFarZ() {
        return this._farZ
    }
    SetFovY(a) {
        this._fovY = a;
        this._tan_fovY_2 = Math.tan(this._fovY / 2)
    }
    GetFovY() {
        return this._fovY
    }
    _GetTanFovYDiv2() {
        return this._tan_fovY_2
    }
    SetZAxisScaleNormalized() {
        this._zAxisScale = !1
    }
    SetZAxisScaleRegular() {
        this._zAxisScale = !0
    }
    IsZAxisScaleNormalized() {
        return !this._zAxisScale
    }
    IsZAxisScaleRegular() {
        return this._zAxisScale
    }
    CalculatePerspectiveMatrix(a, b, d=.5, c=.5) {
        const e = this.GetNearZ()
          , g = this.GetFarZ();
        var k = this.GetFovY();
        if (.5 === d && .5 === c)
            this.IsWebGPU() ? mat4$jscomp$2.perspectiveZO(a, k, b, e, g) : mat4$jscomp$2.perspective(a, k, b, e, g);
        else {
            d = 1 - d;
            k = 2 * d - 2;
            d *= 2;
            const l = 2 * c - 2;
            c *= 2;
            const n = this._GetTanFovYDiv2() * e;
            b *= n;
            mat4$jscomp$2.frustum(a, k * b, d * b, l * n, c * n, e, g)
        }
    }
    CalculateOrthographicMatrix(a, b, d, c=1) {
        var e = self.devicePixelRatio;
        const g = 2 * this.GetDefaultCameraZ(d) * e * this._GetTanFovYDiv2() / d;
        b = b * g / (2 * e * c);
        d = d * g / (2 * e * c);
        c = -b;
        e = -d;
        this.IsWebGPU() ? mat4$jscomp$2.orthoZO(a, c, b, e, d, this.GetNearZ(), this.GetFarZ()) : mat4$jscomp$2.ortho(a, c, b, e, d, this.GetNearZ(), this.GetFarZ())
    }
    CalculateLookAtModelView(a, b, d, c, e, g=1) {
        let k = 1;
        this.IsZAxisScaleNormalized() && (k = 200 * this._GetTanFovYDiv2() / e);
        vec3$jscomp$2.set(tmpVec3c, k, -k, 1);
        vec3$jscomp$2.multiply(tmpVec3a, b, tmpVec3c);
        vec3$jscomp$2.multiply(tmpVec3b, d, tmpVec3c);
        mat4$jscomp$2.lookAt(a, tmpVec3a, tmpVec3b, c || defaultUpVector);
        tmpVec3c[2] = g;
        mat4$jscomp$2.scale(a, a, tmpVec3c)
    }
    CalculateLookAtModelView2(a, b, d, c, e, g, k, l) {
        vec3$jscomp$2.set(tmpVec3a, a, b, d);
        vec3$jscomp$2.set(tmpVec3b, c, e, g);
        this.CalculateLookAtModelView(tempMat4$jscomp$1, tmpVec3a, tmpVec3b, defaultUpVector, k, l);
        return tempMat4$jscomp$1
    }
    _AddShaderProgram(a) {
        this._allShaderPrograms.push(a);
        this._shaderProgramsByName.set(a.GetName(), a)
    }
    _RemoveShaderProgram(a) {
        const b = this._allShaderPrograms.indexOf(a);
        -1 !== b && this._allShaderPrograms.splice(b, 1);
        this._shaderProgramsByName.delete(a.GetName())
    }
    _ClearAllShaderPrograms() {
        C3$jscomp$39.clearArray(this._allShaderPrograms);
        this._shaderProgramsByName.clear()
    }
    GetShaderProgramByName(a) {
        return this._shaderProgramsByName.get(a) || null
    }
    GetTextureFillShaderProgram() {
        return this._spTextureFill
    }
    SetTextureFillMode() {
        this.SetProgram(this._spTextureFill)
    }
    GetPointsRenderingProgram() {
        return this._spPoints
    }
    SetPointsRenderingProgram() {
        this.SetProgram(this._spPoints)
    }
    SetTilemapFillMode() {
        this.SetProgram(this._spTilemapFill)
    }
    SetTileRandomizationMode() {
        this.SetProgram(this._spTileRandomization)
    }
    SetColorFillMode() {
        this.SetProgram(this._spColorFill)
    }
    SetLinearGradientFillMode() {
        this.SetProgram(this._spLinearGradientFill)
    }
    SetPenumbraFillMode() {
        this.SetProgram(this._spPenumbraFill)
    }
    SetHardEllipseFillMode() {
        this.SetProgram(this._spHardEllipseFill)
    }
    SetHardEllipseOutlineMode() {
        this.SetProgram(this._spHardEllipseOutline)
    }
    SetSmoothEllipseFillMode() {
        this.SetProgram(this._spSmoothEllipseFill)
    }
    SetSmoothEllipseOutlineMode() {
        this.SetProgram(this._spSmoothEllipseOutline)
    }
    SetSmoothLineFillMode() {
        this.SetProgram(this._spSmoothLineFill)
    }
    _SetCurrentStateGroup(a) {
        this._currentStateGroup = a
    }
    GetCurrentStateGroup() {
        return this._currentStateGroup
    }
    AcquireStateGroup(a, b, d, c) {
        const e = C3$jscomp$39.Gfx.StateGroup.MakeKey(a, b, d, c);
        let g = this._stateGroups.get(e);
        g || (g = C3$jscomp$39.New(C3$jscomp$39.Gfx.StateGroup, this, a, b, d, c),
        this._stateGroups.set(e, g));
        g.AddRef();
        return g
    }
    ReleaseStateGroup(a) {
        a.DecRef();
        0 === a._GetRefCount() && (this._currentStateGroup === a && (this._currentStateGroup = null),
        this._stateGroups.delete(a.GetKey()),
        a.Release())
    }
    _InitBlendModeData(a) {
        C3$jscomp$39.clearArray(this._blendModeTable);
        this._namedBlendModeMap.clear();
        let b = 0;
        for (const d of a) {
            a = d[0];
            const c = d[1]
              , e = d[2];
            this._blendModeTable.push([c, e]);
            this._namedBlendModeMap.set(a, {
                number: b,
                srcBlend: c,
                destBlend: e
            });
            b++
        }
    }
    _GetBlendByIndex(a) {
        return this._blendModeTable[a]
    }
    GetSrcBlendByIndex(a) {
        return this._GetBlendByIndex(a)[0]
    }
    GetDestBlendByIndex(a) {
        return this._GetBlendByIndex(a)[1]
    }
    GetNamedBlend(a) {
        a = this._namedBlendModeMap.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid blend name");
        return a
    }
    NamedBlendToNumber(a) {
        a = this._namedBlendModeMap.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid blend name");
        return a.number
    }
    SetBaseZ(a) {
        this._baseZ = a
    }
    GetBaseZ() {
        return this._baseZ
    }
    SetCurrentZ(a) {
        this._currentZ = a;
        this._currentStateGroup = null
    }
    GetCurrentZ() {
        return this._currentZ
    }
    Line(a, b, d, c) {
        var e = C3$jscomp$39.angleTo(a, b, d, c)
          , g = .5 * this._lineWidth;
        const k = Math.sin(e) * g;
        e = Math.cos(e) * g;
        g = this._lineCap;
        2 === g ? this.LinePreCalc_LineCap2(a, b, 0, d, c, 0, k, e) : 1 === g ? this.LinePreCalc_LineCap1(a, b, 0, d, c, 0, k, e) : this.LinePreCalc_LineCap0(a, b, 0, d, c, 0, k, e)
    }
    Line3D(a, b, d, c, e, g) {
        var k = C3$jscomp$39.angleTo(a, b, c, e)
          , l = .5 * this._lineWidth;
        const n = Math.sin(k) * l;
        k = Math.cos(k) * l;
        l = this._lineCap;
        2 === l ? this.LinePreCalc_LineCap2(a, b, d, c, e, g, n, k) : 1 === l ? this.LinePreCalc_LineCap1(a, b, d, c, e, g, n, k) : this.LinePreCalc_LineCap0(a, b, d, c, e, g, n, k)
    }
    LinePreCalc_LineCap2(a, b, d, c, e, g, k, l) {
        var n = this._lineOffset;
        a = a + n - l;
        b = b + n - k;
        c = c + n + l;
        e = e + n + k;
        n = 2 * l;
        const p = 2 * k;
        this.Quad3D2(a + k, b - l, d, c + k, e - l, g, c - k - n, e + l - p, g, a - k + n, b + l + p, d, defaultTexCoordsQuad)
    }
    LinePreCalc_LineCap1(a, b, d, c, e, g, k, l) {
        const n = this._lineOffset;
        a = a + n - l;
        b = b + n - k;
        c = c + n + l;
        e = e + n + k;
        this.Quad3D2(a + k, b - l, d, c + k, e - l, g, c - k, e + l, g, a - k, b + l, d, defaultTexCoordsQuad)
    }
    LinePreCalc_LineCap0(a, b, d, c, e, g, k, l) {
        const n = this._lineOffset;
        a += n;
        b += n;
        c += n;
        e += n;
        this.Quad3D2(a + k, b - l, d, c + k, e - l, g, c - k, e + l, g, a - k, b + l, d, defaultTexCoordsQuad)
    }
    TexturedLine(a, b, d, c, e, g) {
        var k = C3$jscomp$39.angleTo(a, b, d, c)
          , l = .5 * this._lineWidth;
        const n = Math.sin(k) * l;
        k = Math.cos(k) * l;
        l = this._lineCap;
        2 === l ? this.TexturedLinePreCalc_LineCap2(a, b, d, c, n, k, e, g) : 1 === l ? this.TexturedLinePreCalc_LineCap1(a, b, d, c, n, k, e, g) : this.TexturedLinePreCalc_LineCap0(a, b, d, c, n, k, e, g)
    }
    TexturedLinePreCalc_LineCap2(a, b, d, c, e, g, k, l) {
        var n = this._lineOffset;
        a = a + n - g;
        b = b + n - e;
        d = d + n + g;
        c = c + n + e;
        n = 2 * g;
        const p = 2 * e;
        tmpQuad.set(a + e, b - g, d + e, c - g, d - e - n, c + g - p, a - e + n, b + g + p);
        tmpRect.set(k, 0, l, 0);
        this.Quad3(tmpQuad, tmpRect)
    }
    TexturedLinePreCalc_LineCap1(a, b, d, c, e, g, k, l) {
        const n = this._lineOffset;
        a = a + n - g;
        b = b + n - e;
        d = d + n + g;
        c = c + n + e;
        tmpQuad.set(a + e, b - g, d + e, c - g, d - e, c + g, a - e, b + g);
        tmpRect.set(k, 0, l, 0);
        this.Quad3(tmpQuad, tmpRect)
    }
    TexturedLinePreCalc_LineCap0(a, b, d, c, e, g, k, l) {
        const n = this._lineOffset;
        a += n;
        b += n;
        d += n;
        c += n;
        tmpQuad.set(a + e, b - g, d + e, c - g, d - e, c + g, a - e, b + g);
        tmpRect.set(k, 0, l, 0);
        this.Quad3(tmpQuad, tmpRect)
    }
    LineRect(a, b, d, c) {
        const e = .5 * this._lineWidth
          , g = this._lineCap;
        2 === g ? this._LineRectPreCalc_LineCap2(a, b, d, c, e) : 1 === g ? this._LineRectPreCalc_LineCap1(a, b, d, c, e) : this._LineRectPreCalc_LineCap0(a, b, d, c, e)
    }
    _LineRectPreCalc_LineCap2(a, b, d, c, e) {
        this.LinePreCalc_LineCap2(a, b, 0, d, b, 0, 0, e);
        this.LinePreCalc_LineCap2(d, b, 0, d, c, 0, e, 0);
        this.LinePreCalc_LineCap2(d, c, 0, a, c, 0, 0, -e);
        this.LinePreCalc_LineCap2(a, c, 0, a, b, 0, -e, 0)
    }
    _LineRectPreCalc_LineCap1(a, b, d, c, e) {
        this.LinePreCalc_LineCap1(a, b, 0, d, b, 0, 0, e);
        this.LinePreCalc_LineCap1(d, b, 0, d, c, 0, e, 0);
        this.LinePreCalc_LineCap1(d, c, 0, a, c, 0, 0, -e);
        this.LinePreCalc_LineCap1(a, c, 0, a, b, 0, -e, 0)
    }
    _LineRectPreCalc_LineCap0(a, b, d, c, e) {
        this.LinePreCalc_LineCap0(a, b, 0, d, b, 0, 0, e);
        this.LinePreCalc_LineCap0(d, b, 0, d, c, 0, e, 0);
        this.LinePreCalc_LineCap0(d, c, 0, a, c, 0, 0, -e);
        this.LinePreCalc_LineCap0(a, c, 0, a, b, 0, -e, 0)
    }
    LineRect2(a) {
        this.LineRect(a.getLeft(), a.getTop(), a.getRight(), a.getBottom())
    }
    LineQuad(a) {
        var b = C3$jscomp$39.angleTo(a.getTlx(), a.getTly(), a.getTrx(), a.getTry())
          , d = .5 * this._lineWidth;
        const c = Math.sin(b) * d;
        b = Math.cos(b) * d;
        d = this._lineCap;
        2 === d ? this._LineQuadPreCalc_LineCap2(a, c, b) : 1 === d ? this._LineQuadPreCalc_LineCap1(a, c, b) : this._LineQuadPreCalc_LineCap0(a, c, b)
    }
    _LineQuadPreCalc_LineCap2(a, b, d) {
        this.LinePreCalc_LineCap2(a.getTlx(), a.getTly(), 0, a.getTrx(), a.getTry(), 0, b, d);
        this.LinePreCalc_LineCap2(a.getTrx(), a.getTry(), 0, a.getBrx(), a.getBry(), 0, d, -b);
        this.LinePreCalc_LineCap2(a.getBrx(), a.getBry(), 0, a.getBlx(), a.getBly(), 0, -b, -d);
        this.LinePreCalc_LineCap2(a.getBlx(), a.getBly(), 0, a.getTlx(), a.getTly(), 0, -d, b)
    }
    _LineQuadPreCalc_LineCap1(a, b, d) {
        this.LinePreCalc_LineCap1(a.getTlx(), a.getTly(), 0, a.getTrx(), a.getTry(), 0, b, d);
        this.LinePreCalc_LineCap1(a.getTrx(), a.getTry(), 0, a.getBrx(), a.getBry(), 0, d, -b);
        this.LinePreCalc_LineCap1(a.getBrx(), a.getBry(), 0, a.getBlx(), a.getBly(), 0, -b, -d);
        this.LinePreCalc_LineCap1(a.getBlx(), a.getBly(), 0, a.getTlx(), a.getTly(), 0, -d, b)
    }
    _LineQuadPreCalc_LineCap0(a, b, d) {
        this.LinePreCalc_LineCap0(a.getTlx(), a.getTly(), 0, a.getTrx(), a.getTry(), 0, b, d);
        this.LinePreCalc_LineCap0(a.getTrx(), a.getTry(), 0, a.getBrx(), a.getBry(), 0, d, -b);
        this.LinePreCalc_LineCap0(a.getBrx(), a.getBry(), 0, a.getBlx(), a.getBly(), 0, -b, -d);
        this.LinePreCalc_LineCap0(a.getBlx(), a.getBly(), 0, a.getTlx(), a.getTly(), 0, -d, b)
    }
    SetLineWidth(a) {
        this._lineWidth = a;
        this._lineWidthStack[this._lineWidthStack.length - 1] = a
    }
    GetLineWidth() {
        return this._lineWidth
    }
    PushLineWidth(a) {
        if (100 <= this._lineWidthStack.length)
            throw Error("pushed too many line widths - check push/pop pairs");
        this._lineWidthStack.push(a);
        this._lineWidth = a
    }
    PopLineWidth() {
        if (1 >= this._lineWidthStack.length)
            throw Error("cannot pop last line width - check push/pop pairs");
        this._lineWidthStack.pop();
        this._lineWidth = this._lineWidthStack.at(-1)
    }
    SetLineCapButt() {
        this._lineCap = 0;
        this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    SetLineCapSquare() {
        this._lineCap = 1;
        this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    SetLineCapZag() {
        this._lineCap = 2;
        this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    PushLineCap(a) {
        if ("butt" === a)
            this.PushLineCapButt();
        else if ("square" === a)
            this.PushLineCapSquare();
        else if ("zag" === a)
            this.PushLineCapZag();
        else
            throw Error("invalid line cap");
    }
    PushLineCapButt() {
        if (100 <= this._lineCapStack.length)
            throw Error("pushed too many line caps - check push/pop pairs");
        this._lineCapStack.push(0);
        this._lineCap = 0
    }
    PushLineCapSquare() {
        if (100 <= this._lineCapStack.length)
            throw Error("pushed too many line caps - check push/pop pairs");
        this._lineCapStack.push(1);
        this._lineCap = 1
    }
    PushLineCapZag() {
        if (100 <= this._lineCapStack.length)
            throw Error("pushed too many line caps - check push/pop pairs");
        this._lineCapStack.push(2);
        this._lineCap = 2
    }
    PopLineCap() {
        if (1 >= this._lineCapStack.length)
            throw Error("cannot pop last line cap - check push/pop pairs");
        this._lineCapStack.pop();
        this._lineCap = this._lineCapStack.at(-1)
    }
    SetLineOffset(a) {
        this._lineOffset = a;
        this._lineOffsetStack[this._lineOffsetStack.length - 1] = a
    }
    GetLineOffset() {
        return this._lineOffset
    }
    PushLineOffset(a) {
        if (100 <= this._lineOffsetStack.length)
            throw Error("pushed too many line offsets - check push/pop pairs");
        this._lineOffsetStack.push(a);
        this._lineOffset = a
    }
    PopLineOffset() {
        if (1 >= this._lineOffsetStack.length)
            throw Error("cannot pop last line offset - check push/pop pairs");
        this._lineOffsetStack.pop();
        this._lineOffset = this._lineOffsetStack.at(-1)
    }
    ConvexPoly(a) {
        var b = a.length / 2;
        if (3 > b)
            throw Error("need at least 3 points");
        b -= 2;
        const d = b - 1
          , c = a[0]
          , e = a[1];
        for (let g = 0; g < b; g += 2) {
            const k = 2 * g
              , l = a[k + 2]
              , n = a[k + 3]
              , p = a[k + 4]
              , t = a[k + 5];
            g === d ? this.Quad2(c, e, l, n, p, t, p, t) : this.Quad2(c, e, l, n, p, t, a[k + 6], a[k + 7])
        }
    }
    GetNumVertexComponents() {
        return 3
    }
    Finish() {
        this.EndBatch(!0);
        this._frameNumber++
    }
    GetFrameNumber() {
        return this._frameNumber
    }
    IncrementFrameNumber() {
        this._frameNumber++
    }
    SetMipmapsEnabled(a) {
        this._enableMipmaps = !!a
    }
    AreMipmapsEnabled() {
        return this._enableMipmaps
    }
    SetHasMajorPerformanceCaveat(a) {
        this._hasMajorPerformanceCaveat = !!a
    }
    HasMajorPerformanceCaveat() {
        return this._hasMajorPerformanceCaveat
    }
    IsWebGL() {
        return !1
    }
    IsWebGPU() {
        return !1
    }
}
;
"use strict";
self.C3.Gfx.ShaderProgramBase = class {
    constructor(a, b) {
        this._name = b.name;
        this._renderer = a;
        this._extendBoxHorizontal = b.extendBoxHorizontal || 0;
        this._extendBoxVertical = b.extendBoxVertical || 0;
        this._crossSampling = !!b.crossSampling;
        this._mustPreDraw = !!b.mustPreDraw;
        this._preservesOpaqueness = !!b.preservesOpaqueness;
        this._animated = !!b.animated;
        this._blendsBackground = !!b.blendsBackground;
        this._usesDepth = !!b.usesDepth;
        this._usesAnySrcRectOrPixelSize = !1;
        this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
    }
    Release() {
        this._renderer = null
    }
    GetRenderer() {
        return this._renderer
    }
    GetName() {
        return this._name
    }
    ExtendsBox() {
        return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
    }
    GetBoxExtendHorizontal() {
        return this._extendBoxHorizontal
    }
    GetBoxExtendVertical() {
        return this._extendBoxVertical
    }
    UsesCrossSampling() {
        return this._crossSampling
    }
    MustPreDraw() {
        return this._mustPreDraw
    }
    PreservesOpaqueness() {
        return this._preservesOpaqueness
    }
    IsAnimated() {
        return this._animated
    }
    BlendsBackground() {
        return this._blendsBackground
    }
    UsesDepth() {
        return this._usesDepth
    }
    UsesAnySrcRectOrPixelSize() {
        return this._usesAnySrcRectOrPixelSize
    }
    NeedsPostDrawOrExtendsBox() {
        return this._needsPostDrawOrExtendBox
    }
    UsesIsSrcTexRotated() {
        return !1
    }
}
;
"use strict";
const C3$jscomp$41 = self.C3;
C3$jscomp$41.Gfx.StateGroup = class {
    constructor(a, b, d, c, e) {
        this._renderer = a;
        this._refCount = 0;
        this._shaderProgram = null;
        this._shaderProgramName = "";
        this._blendMode = d;
        this._color = C3$jscomp$41.New(C3$jscomp$41.Color);
        this._color.set(c);
        this._zElevation = e;
        "string" === typeof b ? this._shaderProgramName = b : (this._shaderProgram = b,
        this._shaderProgramName = this._shaderProgram.GetName())
    }
    Release() {
        if (0 < this._refCount)
            throw Error("releasing state group still in use");
        this._shaderProgram = this._renderer = null;
        this._shaderProgramName = ""
    }
    Apply() {
        const a = this._renderer;
        a.SetProgram(this._shaderProgram);
        a.SetBlendMode(this._blendMode);
        a.SetColor(this._color);
        a.SetCurrentZ(this._zElevation);
        a._SetCurrentStateGroup(this)
    }
    GetKey() {
        return C3$jscomp$41.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation)
    }
    AddRef() {
        ++this._refCount
    }
    DecRef() {
        --this._refCount
    }
    _GetRefCount() {
        return this._refCount
    }
    OnContextLost() {
        this._shaderProgram = null
    }
    OnContextRestored(a) {
        this._shaderProgram = a.GetShaderProgramByName(this._shaderProgramName);
        if (!this._shaderProgram)
            throw Error("failed to restore shader program");
    }
    static MakeKey(a, b, d, c) {
        return ("string" === typeof a ? a : a.GetName()) + "," + b + "," + d.getR() + "," + d.getG() + "," + d.getB() + "," + d.getA() + "," + c
    }
}
;
"use strict";
const C3$jscomp$42 = self.C3
  , tempQuadTex = C3$jscomp$42.New(C3$jscomp$42.Quad);
function interpolateQuad(a, b, d) {
    const c = d.getTlx()
      , e = d.getTly()
      , g = d.getTrx() - c
      , k = d.getTry() - e
      , l = d.getBlx() - c;
    d = d.getBly() - e;
    return [c + g * a + l * b, e + k * a + d * b]
}
C3$jscomp$42.Gfx.MeshPoint = class {
    constructor(a, b, d) {
        this._mesh = a;
        this._col = b;
        this._row = d;
        this._v = this._u = this._zElevation = this._y = this._x = 0
    }
    _Init(a, b, d, c) {
        this._x = a;
        this._y = b;
        this._u = d;
        this._v = c
    }
    GetX() {
        return this._x
    }
    SetX(a) {
        this._x !== a && (this._x = a,
        this._mesh._SetPointsChanged())
    }
    GetY() {
        return this._y
    }
    SetY(a) {
        this._y !== a && (this._y = a,
        this._mesh._SetPointsChanged())
    }
    GetZElevation() {
        return this._zElevation
    }
    SetZElevation(a) {
        this._zElevation !== a && (this._zElevation = Math.max(a, 0),
        this._mesh._SetPointsChanged())
    }
    GetU() {
        return this._u
    }
    SetU(a) {
        this._u = a
    }
    GetV() {
        return this._v
    }
    SetV(a) {
        this._v = a
    }
    _Interpolate_TexRect(a, b, d) {
        [this._x,this._y] = interpolateQuad(a._x, a._y, b);
        this._zElevation = a._zElevation;
        this._u = C3$jscomp$42.lerp(d.getLeft(), d.getRight(), a._u);
        this._v = C3$jscomp$42.lerp(d.getTop(), d.getBottom(), a._v)
    }
    _Interpolate_TexQuad(a, b, d) {
        [this._x,this._y] = interpolateQuad(a._x, a._y, b);
        this._zElevation = a._zElevation;
        [this._u,this._v] = interpolateQuad(a._u, a._v, d)
    }
    SaveToJson() {
        return {
            x: this.GetX(),
            y: this.GetY(),
            z: this.GetZElevation(),
            u: this.GetU(),
            v: this.GetV()
        }
    }
    LoadFromJson(a) {
        this.SetX(a.x);
        this.SetY(a.y);
        a.hasOwnProperty("z") && this.SetZElevation(a.z);
        this.SetU(a.u);
        this.SetV(a.v)
    }
    GetMesh() {
        return this._mesh
    }
    GetColumn() {
        return this._col
    }
    GetRow() {
        return this._row
    }
}
;
C3$jscomp$42.Gfx.Mesh = class {
    constructor(a, b, d) {
        if (2 > a || 2 > b)
            throw Error("invalid mesh size");
        this._hsize = a;
        this._vsize = b;
        this._owner = d || null;
        this._pts = [];
        this._minY = this._minX = 0;
        this._maxY = this._maxX = 1;
        this._maxZ = 0;
        this._pointsChanged = !1;
        d = a - 1;
        const c = b - 1;
        for (let e = 0; e < b; ++e) {
            const g = [];
            for (let k = 0; k < a; ++k) {
                const l = C3$jscomp$42.New(C3$jscomp$42.Gfx.MeshPoint, this, k, e)
                  , n = k / d
                  , p = e / c;
                l._Init(n, p, n, p);
                g.push(l)
            }
            this._pts.push(g)
        }
    }
    Release() {
        C3$jscomp$42.clearArray(this._pts)
    }
    GetHSize() {
        return this._hsize
    }
    GetVSize() {
        return this._vsize
    }
    GetOwner() {
        return this._owner
    }
    _GetPoints() {
        return this._pts
    }
    _SetPointsChanged() {
        this._pointsChanged = !0
    }
    _MaybeComputeBounds() {
        if (this._pointsChanged) {
            var a = Infinity
              , b = Infinity
              , d = -Infinity
              , c = -Infinity
              , e = 0;
            for (const g of this._pts)
                for (const k of g) {
                    const l = k.GetX()
                      , n = k.GetY();
                    a = Math.min(a, l);
                    b = Math.min(b, n);
                    d = Math.max(d, l);
                    c = Math.max(c, n);
                    e = Math.max(e, k.GetZElevation())
                }
            this._minX = a;
            this._minY = b;
            this._maxX = d;
            this._maxY = c;
            this._maxZ = e;
            this._pointsChanged = !1
        }
    }
    GetMinX() {
        this._MaybeComputeBounds();
        return this._minX
    }
    GetMinY() {
        this._MaybeComputeBounds();
        return this._minY
    }
    GetMaxX() {
        this._MaybeComputeBounds();
        return this._maxX
    }
    GetMaxY() {
        this._MaybeComputeBounds();
        return this._maxY
    }
    GetMaxZ() {
        this._MaybeComputeBounds();
        return this._maxZ
    }
    HasAnyZElevation() {
        return 0 < this.GetMaxZ()
    }
    GetMeshPointAt(a, b) {
        a = Math.floor(a);
        b = Math.floor(b);
        return 0 > a || a >= this._hsize || 0 > b || b >= this._vsize ? null : this._pts[b][a]
    }
    CalculateTransformedMesh(a, b, d) {
        const c = d instanceof C3$jscomp$42.Rect;
        if (a.GetHSize() !== this.GetHSize() || a.GetVSize() !== this.GetVSize())
            throw Error("source mesh wrong size");
        a = a._pts;
        const e = this._pts;
        for (let g = 0, k = e.length; g < k; ++g) {
            const l = a[g]
              , n = e[g];
            for (let p = 0, t = n.length; p < t; ++p) {
                const w = l[p]
                  , z = n[p];
                c ? z._Interpolate_TexRect(w, b, d) : z._Interpolate_TexQuad(w, b, d)
            }
        }
    }
    Draw(a) {
        const b = this._pts;
        let d = b[0];
        for (let c = 1, e = b.length; c < e; ++c) {
            const g = b[c];
            let k = d[0]
              , l = g[0];
            for (let n = 1, p = g.length; n < p; ++n) {
                const t = d[n]
                  , w = g[n];
                tempQuadTex.set(k.GetU(), k.GetV(), t.GetU(), t.GetV(), w.GetU(), w.GetV(), l.GetU(), l.GetV());
                a.Quad3D2(k.GetX(), k.GetY(), k.GetZElevation(), t.GetX(), t.GetY(), t.GetZElevation(), w.GetX(), w.GetY(), w.GetZElevation(), l.GetX(), l.GetY(), l.GetZElevation(), tempQuadTex);
                k = t;
                l = w
            }
            d = g
        }
    }
    Outline(a, b) {
        b || (b = (e,g,k)=>[e, g, k]);
        const d = this._pts;
        let c = d[0];
        for (let e = 1, g = d.length; e < g; ++e) {
            const k = d[e];
            let l = c[0]
              , n = k[0];
            for (let p = 1, t = k.length; p < t; ++p) {
                const w = c[p]
                  , z = k[p]
                  , [B,C,E] = b(l.GetX(), l.GetY(), l.GetZElevation())
                  , [F,J,K] = b(w.GetX(), w.GetY(), w.GetZElevation())
                  , [M,U,X] = b(z.GetX(), z.GetY(), z.GetZElevation())
                  , [R,T,P] = b(n.GetX(), n.GetY(), n.GetZElevation());
                a.Line3D(B, C, E, F, J, K);
                a.Line3D(B, C, E, M, U, X);
                a.Line3D(B, C, E, R, T, P);
                p === t - 1 && a.Line3D(F, J, K, M, U, X);
                e === g - 1 && a.Line3D(R, T, P, M, U, X);
                l = w;
                n = z
            }
            c = k
        }
    }
    InsertPolyMeshVertices(a) {
        a = a.pointsArr();
        const b = []
          , d = this.GetHSize() - 1
          , c = this.GetVSize() - 1
          , e = 1 / d
          , g = 1 / c
          , k = d - 1
          , l = c - 1;
        let n = a[0]
          , p = a[1]
          , t = C3$jscomp$42.clamp(Math.floor(n * d), 0, k)
          , w = C3$jscomp$42.clamp(Math.floor(p * c), 0, l)
          , z = 0
          , B = 0
          , C = 0;
        var E = -1;
        const F = ()=>{
            n = C3$jscomp$42.clamp(C3$jscomp$42.lerp(n, z, C), 0, 1);
            p = C3$jscomp$42.clamp(C3$jscomp$42.lerp(p, B, C), 0, 1);
            b.push(n, p)
        }
        ;
        for (let J = 0, K = a.length; J < K; J += 2)
            for (n = a[J],
            p = a[J + 1],
            b.push(n, p),
            t = C3$jscomp$42.clamp(Math.floor(n * d), 0, k),
            w = C3$jscomp$42.clamp(Math.floor(p * c), 0, l),
            E = (J + 2) % K,
            z = a[E],
            B = a[E + 1],
            E = -1; ; ) {
                if (1E6 < b.length)
                    throw Error("Too many mesh poly points");
                const M = t * e
                  , U = w * g
                  , X = (t + 1) * e
                  , R = (w + 1) * g;
                C3$jscomp$42.isPointInTriangleInclusive(n, p, M, U, X, U, X, R);
                if (0 !== E && (C = C3$jscomp$42.rayIntersectExtended(n, p, z, B, M, U, X, R, -.001),
                0 <= C && .99999999 >= C)) {
                    F();
                    E = 0;
                    continue
                }
                if (0 < w && 2 !== E && (C = C3$jscomp$42.rayIntersectExtended(n, p, z, B, M, U, X, U, .001),
                0 <= C && .99999999 >= C)) {
                    F();
                    w--;
                    E = 4;
                    continue
                }
                if (t < k && 3 !== E && (C = C3$jscomp$42.rayIntersectExtended(n, p, z, B, X, U, X, R, .001),
                0 <= C && .99999999 >= C)) {
                    F();
                    t++;
                    E = 1;
                    continue
                }
                if (0 < t && 1 !== E && (C = C3$jscomp$42.rayIntersectExtended(n, p, z, B, M, U, M, R, .001),
                0 <= C && .99999999 >= C)) {
                    F();
                    t--;
                    E = 3;
                    continue
                }
                if (w < l && 4 !== E && (C = C3$jscomp$42.rayIntersectExtended(n, p, z, B, M, R, X, R, .001),
                0 <= C && .99999999 >= C)) {
                    F();
                    w++;
                    E = 2;
                    continue
                }
                break
            }
        return C3$jscomp$42.New(C3$jscomp$42.CollisionPoly, b)
    }
    TransformCollisionPoly(a, b) {
        a = this._TransformPolyPoints(a);
        this._SimplifyPoly(a);
        b.setPoints(a)
    }
    _TransformPolyPoints(a) {
        const b = [];
        a = a.pointsArr();
        for (let d = 0, c = a.length; d < c; d += 2) {
            const [e,g] = this.TransformPoint(a[d], a[d + 1]);
            b.push(e, g)
        }
        return b
    }
    TransformPoint(a, b) {
        var d = this.GetHSize() - 1
          , c = this.GetVSize() - 1
          , e = 1 / d
          , g = 1 / c;
        d = C3$jscomp$42.clamp(Math.floor(a * d), 0, d - 1);
        const k = C3$jscomp$42.clamp(Math.floor(b * c), 0, c - 1);
        c = d * e;
        const l = k * g
          , n = (d + 1) * e
          , p = (k + 1) * g
          , t = this.GetMeshPointAt(d, k)
          , w = this.GetMeshPointAt(d + 1, k + 1)
          , z = C3$jscomp$42.isPointInTriangleInclusive(a, b, c, l, n, l, n, p);
        e = z ? c + e : c;
        g = z ? l : l + g;
        d = this.GetMeshPointAt(d + (z ? 1 : 0), k + (z ? 0 : 1));
        const [B,C,E] = C3$jscomp$42.triangleCartesianToBarycentric(a, b, c, l, e, g, n, p);
        return C3$jscomp$42.triangleBarycentricToCartesian(B, C, E, t.GetX(), t.GetY(), d.GetX(), d.GetY(), w.GetX(), w.GetY())
    }
    _SimplifyPoly(a) {
        const b = [];
        let d = a[0]
          , c = a[1]
          , e = d - a.at(-2)
          , g = c - a.at(-1);
        for (let l = 0, n = a.length; l < n; l += 2) {
            var k = (l + 2) % n;
            const p = a[k];
            k = a[k + 1];
            const t = p - d
              , w = k - c
              , z = 1E-7 > Math.abs(w) && 1E-7 > Math.abs(g) && Math.sign(t) === Math.sign(e);
            (!(1E-7 > Math.abs(t) && 1E-7 > Math.abs(e) && Math.sign(w) === Math.sign(g) || z) && .001 < Math.abs(t / e - w / g) || 0 == t && 0 === w) && b.push(d, c);
            d = p;
            c = k;
            e = t;
            g = w
        }
        6 <= b.length && b.length < a.length && C3$jscomp$42.shallowAssignArray(a, b)
    }
    SaveToJson() {
        return {
            cols: this.GetHSize(),
            rows: this.GetVSize(),
            points: this._pts.map(a=>a.map(b=>b.SaveToJson()))
        }
    }
    LoadFromJson(a) {
        const b = this.GetHSize()
          , d = this.GetVSize();
        if (a.cols !== b || a.rows !== d)
            throw Error("mesh data wrong size");
        a = a.points;
        for (let c = 0; c < d; ++c) {
            const e = a[c];
            for (let g = 0; g < b; ++g)
                this.GetMeshPointAt(g, c).LoadFromJson(e[g])
        }
    }
}
;
"use strict";
const C3$jscomp$43 = self.C3
  , VALID_PIXEL_FORMATS = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"])
  , VALID_SAMPLINGS = new Set(["nearest", "bilinear", "trilinear"])
  , VALID_MIPMAP_QUALITIES = new Set(["default", "low", "high"])
  , VALID_WRAP_MODES = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);
function GetFormatSpecifiers(a, b) {
    let d, c;
    switch (a) {
    case "rgba8":
        a = b.RGBA8;
        c = d = b.RGBA;
        b = b.UNSIGNED_BYTE;
        break;
    case "rgb8":
        a = b.RGB8;
        c = d = b.RGB;
        b = b.UNSIGNED_BYTE;
        break;
    case "rgba4":
        a = b.RGBA4;
        c = d = b.RGBA;
        b = b.UNSIGNED_SHORT_4_4_4_4;
        break;
    case "rgb5_a1":
        a = b.RGB5_A1;
        c = d = b.RGBA;
        b = b.UNSIGNED_SHORT_5_5_5_1;
        break;
    case "rgb565":
        a = b.RGB565;
        c = d = b.RGB;
        b = b.UNSIGNED_SHORT_5_6_5;
        break;
    default:
        throw Error("invalid pixel format");
    }
    return {
        sizedinternalformat: a,
        internalformat: d,
        format: c,
        type: b
    }
}
const CREATEFROM_DEFAULT_OPTIONS = {
    wrapX: "clamp-to-edge",
    wrapY: "clamp-to-edge",
    sampling: "trilinear",
    anisotropy: 0,
    pixelFormat: "rgba8",
    mipMap: !0,
    mipMapQuality: "default",
    premultiplyAlpha: !0,
    isSvg: !1,
    width: -1,
    height: -1
}
  , UPDATE_DEFAULT_OPTIONS = {
    premultiplyAlpha: !0,
    flipY: !1
}
  , allTextures = new Set;
C3$jscomp$43.Gfx.WebGLRendererTexture = class {
    constructor(a) {
        this._renderer = a;
        this._texture = null;
        this._height = this._width = 0;
        this._isStatic = !0;
        this._wrapY = this._wrapX = "clamp-to-edge";
        this._sampling = "trilinear";
        this._anisotropy = 0;
        this._pixelFormat = "rgba8";
        this._isMipMapped = !1;
        this._mipMapQuality = "default";
        this._refCount = 0
    }
    _CreateStatic(a, b) {
        if (!("undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && a instanceof OffscreenCanvas || a instanceof ImageData || a instanceof ArrayBuffer) && null !== a)
            throw Error("invalid texture source");
        b = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, b);
        if (this._texture)
            throw Error("already created texture");
        this._wrapX = b.wrapX;
        this._wrapY = b.wrapY;
        this._sampling = b.sampling;
        this._anisotropy = b.anisotropy;
        this._pixelFormat = b.pixelFormat;
        this._isMipMapped = !!b.mipMap && this._renderer.AreMipmapsEnabled();
        this._mipMapQuality = b.mipMapQuality;
        if (!VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY))
            throw Error("invalid wrap mode");
        if (!VALID_SAMPLINGS.has(this._sampling))
            throw Error("invalid sampling");
        if (!VALID_PIXEL_FORMATS.has(this._pixelFormat))
            throw Error("invalid pixel format");
        if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality))
            throw Error("invalid mipmap quality");
        this._isStatic = !0;
        if (a instanceof ArrayBuffer || null === a || b.isSvg) {
            if (this._width = b.width,
            this._height = b.height,
            a instanceof ArrayBuffer && a.byteLength !== this._width * this._height * 4)
                throw Error("ArrayBuffer wrong size");
        } else
            this._width = a.width,
            this._height = a.height;
        if (0 >= this._width || 0 >= this._height)
            throw Error("invalid texture data size");
        if (b.isSvg) {
            var d = C3$jscomp$43.CreateCanvas(this._width, this._height);
            d.getContext("2d").drawImage(a, 0, 0, this._width, this._height);
            a = d
        }
        var c = C3$jscomp$43.isPOT(this._width) && C3$jscomp$43.isPOT(this._height);
        d = this._renderer.GetMaxTextureSize();
        if (this._width > d || this._height > d)
            throw Error("texture data exceeds maximum texture size");
        d = this._renderer.GetContext();
        var e = this._renderer.GetWebGLVersionNumber();
        this._texture = d.createTexture();
        d.bindTexture(d.TEXTURE_2D, this._texture);
        d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
        d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, !1);
        b = GetFormatSpecifiers(this._pixelFormat, d);
        if (this._renderer.SupportsNPOTTextures() || c || !this._IsTiled())
            2 <= e ? (d.texStorage2D(d.TEXTURE_2D, this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, b.sizedinternalformat, this._width, this._height),
            a instanceof ArrayBuffer ? d.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, this._width, this._height, b.format, b.type, new Uint8Array(a)) : null !== a && d.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, b.format, b.type, a)) : a instanceof ArrayBuffer ? d.texImage2D(d.TEXTURE_2D, 0, b.internalformat, this._width, this._height, 0, b.format, b.type, new Uint8Array(a)) : null === a ? d.texImage2D(d.TEXTURE_2D, 0, b.internalformat, this._width, this._height, 0, b.format, b.type, null) : d.texImage2D(d.TEXTURE_2D, 0, b.internalformat, b.format, b.type, a);
        else {
            if (null === a)
                throw Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
            a instanceof ArrayBuffer && (a = new ImageData(new Uint8ClampedArray(a),this._width,this._height));
            a instanceof ImageData && (c = C3$jscomp$43.CreateCanvas(this._width, this._height),
            c.getContext("2d").putImageData(a, 0, 0),
            a = c);
            c = C3$jscomp$43.CreateCanvas(C3$jscomp$43.nextHighestPowerOfTwo(this._width), C3$jscomp$43.nextHighestPowerOfTwo(this._height));
            e = c.getContext("2d");
            e.imageSmoothingEnabled = "nearest" !== this._sampling;
            e.drawImage(a, 0, 0, this._width, this._height, 0, 0, c.width, c.height);
            d.texImage2D(d.TEXTURE_2D, 0, b.internalformat, b.format, b.type, c)
        }
        null !== a && this._SetTextureParameters(d);
        d.bindTexture(d.TEXTURE_2D, null);
        this._renderer._ResetLastTexture();
        this._refCount = 1;
        allTextures.add(this)
    }
    _CreateDynamic(a, b, d) {
        d = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, d);
        if (this._texture)
            throw Error("already created texture");
        this._wrapX = d.wrapX;
        this._wrapY = d.wrapY;
        this._sampling = d.sampling;
        this._pixelFormat = d.pixelFormat;
        this._isMipMapped = !!d.mipMap && this._renderer.AreMipmapsEnabled();
        this._mipMapQuality = d.mipMapQuality;
        if (!VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY))
            throw Error("invalid wrap mode");
        if (!VALID_SAMPLINGS.has(this._sampling))
            throw Error("invalid sampling");
        if (!VALID_PIXEL_FORMATS.has(this._pixelFormat))
            throw Error("invalid pixel format");
        if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality))
            throw Error("invalid mipmap quality");
        this._isStatic = !1;
        this._width = Math.floor(a);
        this._height = Math.floor(b);
        a = C3$jscomp$43.isPOT(this._width) && C3$jscomp$43.isPOT(this._height);
        b = this._renderer.GetMaxTextureSize();
        if (0 >= this._width || 0 >= this._height)
            throw Error("invalid texture size");
        if (this._width > b || this._height > b)
            throw Error("texture exceeds maximum texture size");
        if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !a)
            throw Error("non-power-of-two tiled textures not supported");
        a = this._renderer.GetContext();
        b = this._renderer.GetWebGLVersionNumber();
        this._texture = a.createTexture();
        a.bindTexture(a.TEXTURE_2D, this._texture);
        a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, d.premultiplyAlpha);
        a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1);
        d = GetFormatSpecifiers(this._pixelFormat, a);
        a.texImage2D(a.TEXTURE_2D, 0, 2 <= b ? d.sizedinternalformat : d.internalformat, this._width, this._height, 0, d.format, d.type, null);
        this._SetTextureParameters(a);
        a.bindTexture(a.TEXTURE_2D, null);
        this._renderer._ResetLastTexture();
        this._refCount = 1;
        allTextures.add(this)
    }
    _GetMipMapHint(a) {
        if ("default" === this._mipMapQuality)
            return this._isStatic ? a.NICEST : a.FASTEST;
        if ("low" === this._mipMapQuality)
            return a.FASTEST;
        if ("high" === this._mipMapQuality)
            return a.NICEST;
        throw Error("invalid mipmap quality");
    }
    _IsTiled() {
        return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY
    }
    _GetTextureWrapMode(a, b) {
        if ("clamp-to-edge" === b)
            return a.CLAMP_TO_EDGE;
        if ("repeat" === b)
            return a.REPEAT;
        if ("mirror-repeat" === b)
            return a.MIRRORED_REPEAT;
        throw Error("invalid wrap mode");
    }
    _SetTextureParameters(a) {
        var b = C3$jscomp$43.isPOT(this._width) && C3$jscomp$43.isPOT(this._height);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, this._GetTextureWrapMode(a, this._wrapX));
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, this._GetTextureWrapMode(a, this._wrapY));
        "nearest" === this._sampling ? (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST),
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST),
        this._isMipMapped = !1) : (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR),
        (b || this._renderer.SupportsNPOTTextures()) && this._isMipMapped ? (a.hint(a.GENERATE_MIPMAP_HINT, this._GetMipMapHint(a)),
        a.generateMipmap(a.TEXTURE_2D),
        b = "trilinear" === this._sampling && !this._renderer.HasMajorPerformanceCaveat(),
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, b ? a.LINEAR_MIPMAP_LINEAR : a.LINEAR_MIPMAP_NEAREST)) : (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR),
        this._isMipMapped = !1));
        (b = this._renderer._GetAnisotropicExtension()) && 0 < this._anisotropy && "nearest" !== this._sampling && a.texParameterf(a.TEXTURE_2D, b.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()))
    }
    _Update(a, b) {
        if (!("undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLVideoElement && a instanceof HTMLVideoElement || "undefined" !== typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && a instanceof OffscreenCanvas || a instanceof ImageData))
            throw Error("invalid texture source");
        if (!this._texture || 0 >= this._refCount)
            throw Error("texture not created");
        if (this._isStatic)
            throw Error("cannot update static texture");
        b = Object.assign({}, UPDATE_DEFAULT_OPTIONS, b);
        const d = a.width || a.videoWidth
          , c = a.height || a.videoHeight;
        var e = this._renderer.GetWebGLVersionNumber();
        const g = this._renderer.GetContext();
        g.bindTexture(g.TEXTURE_2D, this._texture);
        g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
        g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, !!b.flipY);
        b = GetFormatSpecifiers(this._pixelFormat, g);
        e = 2 <= e ? b.sizedinternalformat : b.internalformat;
        try {
            if (this._width === d && this._height === c) {
                const k = C3$jscomp$43.isPOT(this._width) && C3$jscomp$43.isPOT(this._height);
                g.texSubImage2D(g.TEXTURE_2D, 0, 0, 0, b.format, b.type, a);
                (k || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (g.hint(g.GENERATE_MIPMAP_HINT, this._GetMipMapHint(g)),
                g.generateMipmap(g.TEXTURE_2D))
            } else {
                this._width = d;
                this._height = c;
                const k = C3$jscomp$43.isPOT(this._width) && C3$jscomp$43.isPOT(this._height);
                if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !k)
                    throw Error("non-power-of-two tiled textures not supported");
                g.texImage2D(g.TEXTURE_2D, 0, e, b.format, b.type, a);
                (k || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (g.hint(g.GENERATE_MIPMAP_HINT, this._GetMipMapHint(g)),
                g.generateMipmap(g.TEXTURE_2D))
            }
        } catch (k) {
            console.error("Error updating WebGL texture: ", k)
        }
        g.bindTexture(g.TEXTURE_2D, null);
        this._renderer._ResetLastTexture()
    }
    _Delete() {
        if (0 < this._refCount)
            throw Error("texture still has references");
        if (!this._texture)
            throw Error("already deleted texture");
        allTextures.delete(this);
        this._renderer.GetContext().deleteTexture(this._texture);
        this._texture = null
    }
    IsValid() {
        return !!this._texture
    }
    _GetTexture() {
        return this._texture
    }
    GetRenderer() {
        return this._renderer
    }
    AddReference() {
        this._refCount++
    }
    SubtractReference() {
        if (0 >= this._refCount)
            throw Error("no more references");
        this._refCount--
    }
    GetReferenceCount() {
        return this._refCount
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    IsStatic() {
        return this._isStatic
    }
    GetEstimatedMemoryUsage() {
        let a = this._width * this._height;
        switch (this._pixelFormat) {
        case "rgba8":
            a *= 4;
            break;
        case "rgb8":
            a *= 3;
            break;
        case "rgba4":
        case "rgb5_a1":
        case "rgb565":
            a *= 2
        }
        this._isMipMapped && (a += Math.floor(a / 3));
        return a
    }
    static OnContextLost() {
        allTextures.clear()
    }
    static allTextures() {
        return allTextures.values()
    }
}
;
"use strict";
const C3$jscomp$44 = self.C3
  , glMatrix$jscomp$2 = self.glMatrix
  , mat4$jscomp$3 = glMatrix$jscomp$2.mat4
  , VALID_SAMPLINGS$jscomp$1 = new Set(["nearest", "bilinear", "trilinear"])
  , DEFAULT_RENDERTARGET_OPTIONS = {
    sampling: "trilinear",
    alpha: !0,
    depth: !1,
    isSampled: !0,
    isDefaultSize: !0,
    multisampling: 0
}
  , allRenderTargets = new Set;
C3$jscomp$44.Gfx.WebGLRenderTarget = class {
    constructor(a) {
        this._renderer = a;
        this._renderBuffer = this._texture = this._frameBufferNoDepth = this._frameBuffer = null;
        this._height = this._width = 0;
        this._isDefaultSize = !0;
        this._sampling = "trilinear";
        this._alpha = !0;
        this._depth = !1;
        this._isSampled = !0;
        this._multisampling = 0;
        this._projectionMatrix = mat4$jscomp$3.create();
        this._lastFarZ = this._lastNearZ = this._lastFov = 0
    }
    _Create(a, b, d) {
        d = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, d);
        const c = this._renderer.GetWebGLVersionNumber();
        if (this._texture || this._renderBuffer)
            throw Error("already created render target");
        this._sampling = d.sampling;
        this._alpha = !!d.alpha;
        this._depth = !!d.depth;
        this._isSampled = !!d.isSampled;
        this._isDefaultSize = !!d.isDefaultSize;
        this._multisampling = d.multisampling;
        if (!VALID_SAMPLINGS$jscomp$1.has(this._sampling))
            throw Error("invalid sampling");
        if (0 < this._multisampling && (2 > c || this._isSampled))
            throw Error("invalid use of multisampling");
        2 > c && (this._isSampled = !0);
        this._width = a;
        this._height = b;
        if (0 >= this._width || 0 >= this._height)
            throw Error("invalid render target size");
        this._CalculateProjection();
        a = this._renderer.GetContext();
        this._frameBuffer = a.createFramebuffer();
        this._depth && (this._frameBufferNoDepth = a.createFramebuffer());
        this._isSampled ? (this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, {
            sampling: this._sampling,
            pixelFormat: this._alpha ? "rgba8" : "rgb8",
            mipMap: !1
        }),
        b = this._texture._GetTexture(),
        a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, b, 0),
        this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth),
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, b, 0))) : (this._renderBuffer = a.createRenderbuffer(),
        a.bindRenderbuffer(a.RENDERBUFFER, this._renderBuffer),
        b = this._alpha ? a.RGBA8 : a.RGB8,
        0 < this._multisampling && ((d = a.getInternalformatParameter(a.RENDERBUFFER, b, a.SAMPLES)) && d[0] ? (d = d[0],
        this._multisampling > d && (this._multisampling = d)) : this._multisampling = 0),
        0 === this._multisampling ? a.renderbufferStorage(a.RENDERBUFFER, b, this._width, this._height) : a.renderbufferStorageMultisample(a.RENDERBUFFER, this._multisampling, b, this._width, this._height),
        a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, this._renderBuffer),
        this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth),
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, this._renderBuffer)),
        a.bindRenderbuffer(a.RENDERBUFFER, null));
        b = this._renderer._GetDepthBuffer();
        this._depth && b && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
        this._renderer._CanSampleDepth() ? a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, b, 0) : a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b));
        a.bindFramebuffer(a.FRAMEBUFFER, null);
        allRenderTargets.add(this)
    }
    _Resize(a, b) {
        if (this._width !== a || this._height !== b)
            this._width = a,
            this._height = b,
            this._CalculateProjection(),
            a = this._renderer.GetContext(),
            a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
            this._texture ? this._texture._Update(new ImageData(this._width,this._height)) : (a.bindRenderbuffer(a.RENDERBUFFER, this._renderBuffer),
            a.renderbufferStorage(a.RENDERBUFFER, this._alpha ? a.RGBA8 : a.RGB8, this._width, this._height),
            a.bindRenderbuffer(a.RENDERBUFFER, null)),
            b = this._renderer._GetDepthBuffer(),
            this._depth && b && (this._renderer._CanSampleDepth() ? a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, b, 0) : a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)),
            a.bindFramebuffer(a.FRAMEBUFFER, null)
    }
    _Delete() {
        if (!this._texture && !this._renderBuffer)
            throw Error("already deleted render target");
        allRenderTargets.delete(this);
        var a = this._renderer.GetContext();
        this._texture ? (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, null, 0),
        this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth),
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, null, 0)),
        this._renderer.DeleteTexture(this._texture),
        this._texture = null) : this._renderBuffer && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, null),
        this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth),
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, null)),
        a.deleteRenderbuffer(this._renderBuffer),
        this._renderBuffer = null);
        a.bindFramebuffer(a.FRAMEBUFFER, null);
        2 <= this._renderer.GetWebGLVersionNumber() && (a.bindFramebuffer(a.READ_FRAMEBUFFER, null),
        a.bindFramebuffer(a.DRAW_FRAMEBUFFER, null));
        a.deleteFramebuffer(this._frameBuffer);
        this._depth && a.deleteFramebuffer(this._frameBufferNoDepth);
        a = this._renderer.GetBatchState();
        a.currentFramebuffer = null;
        this._frameBuffer = a.currentFramebufferNoDepth = null
    }
    _CalculateProjection() {
        this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height);
        this._lastFov = this._renderer.GetFovY();
        this._lastNearZ = this._renderer.GetNearZ();
        this._lastFarZ = this._renderer.GetFarZ()
    }
    _GetFramebuffer() {
        return this._frameBuffer
    }
    _GetFramebufferNoDepth() {
        return this._frameBufferNoDepth
    }
    GetRenderer() {
        return this._renderer
    }
    GetTexture() {
        return this._texture
    }
    GetProjectionMatrix() {
        this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection();
        return this._projectionMatrix
    }
    IsLinearSampling() {
        return "nearest" !== this._sampling
    }
    HasAlpha() {
        return this._alpha
    }
    IsSampled() {
        return this._isSampled
    }
    HasDepthBuffer() {
        return this._depth
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    IsDefaultSize() {
        return this._isDefaultSize
    }
    GetMultisampling() {
        return this._multisampling
    }
    GetOptions() {
        const a = {
            sampling: this._sampling,
            alpha: this._alpha,
            isSampled: this._isSampled
        };
        this._isDefaultSize || (a.width = this._width,
        a.height = this._height);
        return a
    }
    IsCompatibleWithOptions(a) {
        a = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, a);
        return "nearest" !== a.sampling !== this.IsLinearSampling() || !!a.alpha !== this.HasAlpha() || !!a.depth !== this.HasDepthBuffer() || 2 <= this._renderer.GetWebGLVersionNumber() && !!a.isSampled !== this.IsSampled() ? !1 : "number" === typeof a.width || "number" === typeof a.height ? !this.IsDefaultSize() && this.GetWidth() === a.width && this.GetHeight() === a.height : this.IsDefaultSize()
    }
    _GetWebGLTexture() {
        return this._texture ? this._texture._GetTexture() : null
    }
    GetEstimatedMemoryUsage() {
        return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3)
    }
    static async DebugReadPixelsToBlob(a, b) {
        a = await a.ReadBackRenderTargetToImageData(b, !0);
        return await C3$jscomp$44.ImageDataToBlob(a)
    }
    static OnContextLost() {
        allRenderTargets.clear()
    }
    static allRenderTargets() {
        return allRenderTargets.values()
    }
    static ResizeAll(a, b) {
        for (const d of allRenderTargets)
            d.IsDefaultSize() && d._Resize(a, b)
    }
}
;
"use strict";
const C3$jscomp$45 = self.C3
  , RESERVED_UNIFORM_NAMES = new Set("aPos aTex aPoints matP matMV samplerFront samplerBack samplerDepth destStart destEnd srcStart srcEnd srcOriginStart srcOriginEnd pixelSize seconds devicePixelRatio layerScale layerAngle layoutStart layoutEnd color color2_ pointTexStart pointTexEnd zElevation tileSize tileSpacing outlineThickness zNear zFar".split(" "));
C3$jscomp$45.Gfx.WebGLShaderProgram = class extends C3$jscomp$45.Gfx.ShaderProgramBase {
    static async Compile(a, b) {
        const d = a.GetContext();
        var c = b.src;
        const e = b.vertexSrc
          , g = b.name;
        b = d.createShader(d.FRAGMENT_SHADER);
        d.shaderSource(b, c);
        d.compileShader(b);
        c = d.createShader(d.VERTEX_SHADER);
        d.shaderSource(c, e);
        d.compileShader(c);
        const k = d.createProgram();
        d.attachShader(k, b);
        d.attachShader(k, c);
        d.bindAttribLocation(k, 0, "aPos");
        d.bindAttribLocation(k, 1, "aTex");
        d.bindAttribLocation(k, 2, "aPoints");
        d.linkProgram(k);
        const l = a._GetParallelShaderCompileExtension();
        l ? await a._WaitForObjectReady(()=>d.getProgramParameter(k, l.COMPLETION_STATUS_KHR)) : await C3$jscomp$45.Wait(5);
        if (!d.getShaderParameter(b, d.COMPILE_STATUS))
            throw a = d.getShaderInfoLog(b),
            d.deleteShader(b),
            d.deleteShader(c),
            d.deleteProgram(k),
            Error("Error compiling fragment shader: " + a);
        if (!d.getShaderParameter(c, d.COMPILE_STATUS))
            throw a = d.getShaderInfoLog(c),
            d.deleteShader(b),
            d.deleteShader(c),
            d.deleteProgram(k),
            Error("Error compiling vertex shader: " + a);
        if (!d.getProgramParameter(k, d.LINK_STATUS))
            throw a = d.getProgramInfoLog(k),
            d.deleteShader(b),
            d.deleteShader(c),
            d.deleteProgram(k),
            Error("Error linking shader program: " + a);
        (a = C3$jscomp$45.FilterUnprintableChars(d.getProgramInfoLog(k) || "").trim()) && !C3$jscomp$45.IsStringAllWhitespace(a) && console.info(`[WebGL] Shader program '${g}' compilation log: `, a);
        d.deleteShader(b);
        d.deleteShader(c);
        return k
    }
    static async Create(a, b) {
        const d = await C3$jscomp$45.Gfx.WebGLShaderProgram.Compile(a, b);
        return new C3$jscomp$45.Gfx.WebGLShaderProgram(a,d,b)
    }
    constructor(a, b, d) {
        super(a, d);
        const c = a.GetContext();
        var e = a.GetBatchState();
        a.EndBatch();
        c.useProgram(b);
        this._gl = c;
        this._shaderProgram = b;
        this._isDeviceTransform = "<default-device-transform>" === d.name;
        const g = c.getAttribLocation(b, "aPos")
          , k = c.getAttribLocation(b, "aTex");
        this._locAPoints = c.getAttribLocation(b, "aPoints");
        -1 !== g && (c.bindBuffer(c.ARRAY_BUFFER, a._vertexBuffer),
        c.vertexAttribPointer(g, a.GetNumVertexComponents(), c.FLOAT, !1, 0, 0),
        c.enableVertexAttribArray(g));
        -1 !== k && (c.bindBuffer(c.ARRAY_BUFFER, a._texcoordBuffer),
        c.vertexAttribPointer(k, 2, c.FLOAT, !1, 0, 0),
        c.enableVertexAttribArray(k));
        -1 !== this._locAPoints && (c.bindBuffer(c.ARRAY_BUFFER, a._pointBuffer),
        c.vertexAttribPointer(this._locAPoints, 4, c.FLOAT, !1, 0, 0),
        c.enableVertexAttribArray(this._locAPoints));
        c.bindBuffer(c.ARRAY_BUFFER, null);
        this._uMatP = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"matP","mat4");
        this._uMatMV = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"matMV","mat4");
        this._uColor = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"color","vec4");
        this._uSamplerFront = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"samplerFront","sampler");
        this._uPointTexStart = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"pointTexStart","vec2");
        this._uPointTexEnd = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"pointTexEnd","vec2");
        this._uZElevation = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"zElevation","float");
        this._uTileSize = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"tileSize","vec2");
        this._uTileSpacing = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"tileSpacing","vec2");
        this._uColor2 = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"color2_","vec4");
        this._uOutlineThickness = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"outlineThickness","float");
        this._uSamplerBack = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"samplerBack","sampler");
        this._uSamplerDepth = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"samplerDepth","sampler");
        this._uDestStart = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"destStart","vec2");
        this._uDestEnd = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"destEnd","vec2");
        this._uSrcStart = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"srcStart","vec2");
        this._uSrcEnd = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"srcEnd","vec2");
        this._uSrcOriginStart = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"srcOriginStart","vec2");
        this._uSrcOriginEnd = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"srcOriginEnd","vec2");
        this._uPixelSize = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"pixelSize","vec2");
        this._uSeconds = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"seconds","float");
        this._uDevicePixelRatio = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"devicePixelRatio","float");
        this._uLayerScale = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"layerScale","float");
        this._uLayerAngle = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"layerAngle","float");
        this._uLayoutStart = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"layoutStart","vec2");
        this._uLayoutEnd = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"layoutEnd","vec2");
        this._uZNear = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"zNear","float");
        this._uZFar = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,"zFar","float");
        this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());
        b = d.parameters || [];
        this._uCustomParameters = [];
        this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed();
        this._hasCurrentMatMV = this._hasCurrentMatP = !1;
        this._uColor.Init4f(1, 1, 1, 1);
        this._uColor2.Init4f(1, 1, 1, 1);
        this._uSamplerFront.Init1i(0);
        this._uSamplerBack.Init1i(1);
        this._uSamplerDepth.Init1i(2);
        this._uPointTexStart.Init2f(0, 0);
        this._uPointTexEnd.Init2f(1, 1);
        this._uZElevation.Init1f(0);
        this._uTileSize.Init2f(0, 0);
        this._uTileSpacing.Init2f(0, 0);
        this._uDestStart.Init2f(0, 0);
        this._uDestEnd.Init2f(1, 1);
        this._uSrcStart.Init2f(0, 0);
        this._uSrcEnd.Init2f(0, 0);
        this._uSrcOriginStart.Init2f(0, 0);
        this._uSrcOriginEnd.Init2f(0, 0);
        this._uPixelSize.Init2f(0, 0);
        this._uDevicePixelRatio.Init1f(1);
        this._uZNear.Init1f(a.GetNearZ());
        this._uZFar.Init1f(a.GetFarZ());
        this._uLayerScale.Init1f(1);
        this._uLayerAngle.Init1f(0);
        this._uSeconds.Init1f(0);
        this._uLayoutStart.Init2f(0, 0);
        this._uLayoutEnd.Init2f(0, 0);
        this._uOutlineThickness.Init1f(1);
        for (const l of b)
            a = l[2],
            b = new C3$jscomp$45.Gfx.WebGLShaderUniform(this,l[0],a),
            "color" === a ? b.Init3f(0, 0, 0) : b.Init1f(0),
            this._uCustomParameters.push(b);
        this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(e.currentMatP) : (this.UpdateMatP(e.currentMatP, !0),
        this.UpdateMatMV(e.currentMV, !0));
        e = e.currentShader;
        c.useProgram(e ? e._shaderProgram : null)
    }
    Release() {
        this._gl.deleteProgram(this._shaderProgram);
        this._shaderProgram = null;
        this._renderer._RemoveShaderProgram(this);
        this._gl = null;
        super.Release()
    }
    GetWebGLContext() {
        return this._gl
    }
    GetShaderProgram() {
        return this._shaderProgram
    }
    GetParameterCount() {
        return this._uCustomParameters.length
    }
    GetParameterType(a) {
        return 0 > a || a >= this._uCustomParameters.length ? null : this._uCustomParameters[a].GetType()
    }
    AreCustomParametersAlreadySetInBatch(a) {
        for (let b = 0, d = a.length; b < d; ++b)
            if (!this._uCustomParameters[b].IsSetToCustomInBatch(a[b]))
                return !1;
        return !0
    }
    SetCustomParametersInBatch(a) {
        for (let b = 0, d = a.length; b < d; ++b)
            this._uCustomParameters[b].SetBatchValueCustom(a[b])
    }
    AreOptionalUniformsAlreadySetInBatch(a, b, d, c, e, g, k, l, n, p) {
        return this._uSamplerBack.IsUsed() || this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(e, g) || this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(a.getLeft(), a.getTop()) || this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(a.getRight(), a.getBottom()) || this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(k) || this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(l) || this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(n) || this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(b.getLeft(), b.getTop()) || this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(b.getRight(), b.getBottom()) || this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(d.getLeft(), d.getTop()) || this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(d.getRight(), d.getBottom()) || this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(c.getLeft(), c.getTop()) || this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(c.getTop(), c.getBottom()) || this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(p) ? !1 : !0
    }
    SetOptionalUniformsInBatch(a, b, d, c, e, g, k, l, n, p) {
        this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(e, g),
        this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(a.getLeft(), a.getTop()),
        this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(a.getRight(), a.getBottom()),
        this._uDevicePixelRatio.IsUsed() && this._uDevicePixelRatio.SetBatch1(k),
        this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(l),
        this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(n),
        this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(b.getLeft(), b.getTop()),
        this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(b.getRight(), b.getBottom()),
        this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(d.getLeft(), d.getTop()),
        this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(d.getRight(), d.getBottom()),
        this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(c.getLeft(), c.getTop()),
        this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(c.getTop(), c.getBottom()),
        this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(p))
    }
    UpdateMatP(a, b) {
        this._hasCurrentMatP && !b || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(a),
        this._hasCurrentMatP = !0)
    }
    SetMatPStale() {
        this._hasCurrentMatP = !1
    }
    UpdateMatMV(a, b) {
        this._hasCurrentMatMV && !b || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(a),
        this._hasCurrentMatMV = !0)
    }
    SetMatMVStale() {
        this._hasCurrentMatMV = !1
    }
    _UpdateDeviceTransformUniforms(a) {
        if (!this._isDeviceTransform)
            throw Error("not device transform shader");
        this._uMatP.UpdateMatrix4fv(a);
        a = this._renderer;
        const b = a.GetWidth() / 2
          , d = a.GetHeight() / 2;
        a = a.CalculateLookAtModelView2(b, d, a.GetDefaultCameraZ(a.GetHeight()), b, d, 0, a.GetHeight());
        this._uMatMV.UpdateMatrix4fv(a)
    }
    UpdateColor(a) {
        this._uColor.IsUsed() && this._uColor.Update4f(a[0], a[1], a[2], a[3])
    }
    static GetReservedUniformNames() {
        return RESERVED_UNIFORM_NAMES
    }
    static GetDefaultVertexShaderSource(a) {
        a = a ? "highmedp" : "mediump";
        return ["#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nattribute highp vec3 aPos;", `attribute ${a} vec2 aTex;`, `varying ${a} vec2 vTex;`, "uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}"].join("\n")
    }
    static GetDefaultVertexShaderSource_WebGL2(a) {
        a = a ? "highp" : "mediump";
        return ["#version 300 es\nin highp vec3 aPos;", `in ${a} vec2 aTex;`, `out ${a} vec2 vTex;`, "uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}"].join("\n")
    }
    static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n}"
    }
    static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT() {
        return "#extension GL_EXT_frag_depth : enable\nvarying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTextureFillFragmentShaderSource_WebGL2() {
        return "#version 300 es\nin mediump vec2 vTex;\nout lowp vec4 outColor;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\toutColor = texture(samplerFront, vTex) * color;\n\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTilemapFragmentShaderSource_WebGL1_NoFragDepth() {
        return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n}"
    }
    static GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT() {
        return "#extension GL_EXT_frag_depth : enable\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTilemapFragmentShaderSource_WebGL2() {
        return "#version 300 es\nin highp vec2 vTex;\nout lowp vec4 outColor;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highp vec2 srcStart;\nuniform highp vec2 pixelSize;\nuniform highp vec2 tileSize;\nuniform highp vec2 tileSpacing;\nvoid main(void) {\n\thighp vec2 tile = floor(vTex);\n\thighp vec2 tex = fract(vTex);\n\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\toutColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTileRandomizationFragmentShaderSource(a, b, d) {
        let c = "";
        2 <= a ? c = "#version 300 es\n" : (b && (c = "#extension GL_EXT_frag_depth : enable\n"),
        d && (c += "#extension GL_EXT_shader_texture_lod : enable\n#extension GL_OES_standard_derivatives : enable\n"));
        return c + `
#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
precision highmedp float;
${2 <= a ? "in" : "varying"} vec2 vTex;
${2 <= a ? "out lowp vec4 outColor;" : ""}
uniform lowp vec4 color;
uniform lowp sampler2D samplerFront;
uniform vec2 pixelSize;

uniform vec2 tileSize;
uniform vec2 tileSpacing;
uniform float outlineThickness;

const float PI = 3.1415926;

lowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

vec3 randVec3(vec2 seed)
{
	return vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),
				fract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),
				fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));
}

lowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)
{
	vec2 posRandom = tileSize;
	float angleRandom = outlineThickness;

	vec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;

	float angle = angleRandom * rand.z * PI;
	float sin_a = sin(angle);
	float cos_a = cos(angle);
	float aspect = pixelSize.x / pixelSize.y;

	vec2 mid = tile + vec2(0.5, 0.5);
	vec2 dp = uv - mid;
	dp.x /= aspect;
	vec2 r = vec2(dp.x * cos_a - dp.y * sin_a,
				  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	vec2 p = mid + r + (posRandom * rand.xy / 2.0);

	${2 <= a ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}
	${2 > a && d ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}
	${2 > a && !d ? "return texture2D(samplerFront, p);" : ""}
}

void main(void) {

	${2 > a ? "lowp vec4 outColor;" : ""}

	float blendMarginX = tileSpacing.x;
	float blendMarginY = tileSpacing.y;

	vec2 tile = floor(vTex);
	vec2 tex = fract(vTex);
	vec2 ddx = ${2 <= a || d ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};
	vec2 ddy = ${2 <= a || d ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};

	vec4 curTile = sampleTile(tile, vTex, ddx, ddy);

	bool inLeftMargin = (tex.x < blendMarginX);
	bool inRightMargin = (tex.x > 1.0 - blendMarginX);
	bool inTopMargin = (tex.y < blendMarginY);
	bool inBottomMargin = (tex.y > 1.0 - blendMarginY);

	if (inLeftMargin)
	{
		lowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);
		float leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		lowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);

		if (inTopMargin)
		{
			lowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);

			outColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);

			outColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		lowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);
		float rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		lowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);

		if (inTopMargin)
		{
			lowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);

			outColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);

			outColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		lowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
		outColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		lowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
		outColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		outColor = curTile;
	}

	outColor *= color;
	${2 > a ? "gl_FragColor = outColor;" : ""}
	${2 <= a ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
	${2 > a && b ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
}
`
    }
    static GetPointVertexShaderSource_WebGL1() {
        return "attribute vec4 aPoints;\nvarying float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}"
    }
    static GetPointVertexShaderSource_WebGL2() {
        return "#version 300 es\nin vec4 aPoints;\nout float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}"
    }
    static GetPointFragmentShaderSource_WebGL1_NoFragDepth() {
        return "uniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\n\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\n\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\n}"
    }
    static GetPointFragmentShaderSource_WebGL1_FragDepthEXT() {
        return "#extension GL_EXT_frag_depth : enable\nuniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\n\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\n\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\n\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetPointFragmentShaderSource_WebGL2() {
        return "#version 300 es\nuniform lowp sampler2D samplerFront;\nin lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nout lowp vec4 outColor;\nvoid main(void) {\n\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\n\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\n\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\n\toutColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\n\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetColorFillFragmentShaderSource() {
        return "uniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = color;\n}"
    }
    static GetLinearGradientFillFragmentShaderSource() {
        return "precision lowp float;\nvarying mediump vec2 vTex;\nuniform vec4 color;\nuniform vec4 color2_;\nvec3 fromLinear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvec3 toLinear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvoid main(void) {\n\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\n\tfloat a = mix(color.a, color2_.a, vTex.x);\n\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\n}"
    }
    static GetPenumbraFillFragmentShaderSource() {
        return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nprecision lowp float;\nvarying highmedp vec2 vTex;\nuniform vec4 color;\nvoid main(void) {\n\thighmedp float grad = vTex.x / (1.0 - vTex.y);\n\tgl_FragColor = color * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);\n}"
    }
    static GetSmoothLineFillFragmentShaderSource() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\n\tgl_FragColor = color * f;\n}"
    }
    static GetHardEllipseFillFragmentShaderSource() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float f = step(diffSq.x + diffSq.y, 0.25);\n\tgl_FragColor = color * f;\n}"
    }
    static GetHardEllipseOutlineFragmentShaderSource() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump float innerF = step(distSq, 0.25);\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
    }
    static GetSmoothEllipseFillFragmentShaderSource() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\tgl_FragColor = color * f;\n}"
    }
    static GetSmoothEllipseOutlineFragmentShaderSource() {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 pxNorm = pixelSize * norm;\n\tmediump vec2 innerEdge1 = halfNorm - pxNorm;\n\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\n\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\n\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\n\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\n\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\n\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
    }
}
;
"use strict";
const C3$jscomp$46 = self.C3
  , mat4$jscomp$5 = self.glMatrix.mat4
  , TYPE_SIZES = new Map([["float", 1], ["percent", 1], ["sampler", 1], ["vec2", 2], ["vec3", 3], ["color", 3], ["vec4", 4], ["mat4", 16]]);
C3$jscomp$46.Gfx.WebGLShaderUniform = class {
    constructor(a, b, d) {
        if (!TYPE_SIZES.has(d))
            throw Error("invalid uniform type");
        this._owner = a;
        this._gl = this._owner.GetWebGLContext();
        this._name = b;
        this._type = d;
        this._isColorType = "color" === this._type;
        this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), b);
        this._isUsed = !!this._location;
        a = TYPE_SIZES.get(d);
        this._lastValue = new Float32Array(a);
        this._lastBatchValue = new Float32Array(a)
    }
    Release() {
        this._location = this._gl = this._owner = null
    }
    IsUsed() {
        return this._isUsed
    }
    GetType() {
        return this._type
    }
    IsColorType() {
        return this._isColorType
    }
    Init1f(a) {
        this.IsUsed() && (this._lastValue[0] = a,
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform1f(this._location, a))
    }
    Init1i(a) {
        this.IsUsed() && (this._lastValue[0] = a,
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform1i(this._location, a))
    }
    Init2f(a, b) {
        this.IsUsed() && (this._lastValue[0] = a,
        this._lastValue[1] = b,
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform2f(this._location, a, b))
    }
    Init3f(a, b, d) {
        this.IsUsed() && (this._lastValue[0] = a,
        this._lastValue[1] = b,
        this._lastValue[2] = d,
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform3f(this._location, a, b, d))
    }
    Init4f(a, b, d, c) {
        this.IsUsed() && (this._lastValue[0] = a,
        this._lastValue[1] = b,
        this._lastValue[2] = d,
        this._lastValue[3] = c,
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform4f(this._location, a, b, d, c))
    }
    Update1f(a) {
        a = Math.fround(a);
        const b = this._lastValue;
        b[0] !== a && (b[0] = a,
        this._gl.uniform1f(this._location, a))
    }
    Update1i(a) {
        const b = this._lastValue;
        b[0] !== a && (b[0] = a,
        this._gl.uniform1i(this._location, a))
    }
    Update2f(a, b) {
        a = Math.fround(a);
        b = Math.fround(b);
        const d = this._lastValue;
        if (d[0] !== a || d[1] !== b)
            d[0] = a,
            d[1] = b,
            this._gl.uniform2f(this._location, a, b)
    }
    Update3f(a, b, d) {
        a = Math.fround(a);
        b = Math.fround(b);
        d = Math.fround(d);
        const c = this._lastValue;
        if (c[0] !== a || c[1] !== b || c[2] !== d)
            c[0] = a,
            c[1] = b,
            c[2] = d,
            this._gl.uniform3f(this._location, a, b, d)
    }
    Update4f(a, b, d, c) {
        a = Math.fround(a);
        b = Math.fround(b);
        d = Math.fround(d);
        c = Math.fround(c);
        const e = this._lastValue;
        if (e[0] !== a || e[1] !== b || e[2] !== d || e[3] !== c)
            e[0] = a,
            e[1] = b,
            e[2] = d,
            e[3] = c,
            this._gl.uniform4f(this._location, a, b, d, c)
    }
    UpdateMatrix4fv(a) {
        const b = this._lastValue;
        mat4$jscomp$5.exactEquals(b, a) || (C3$jscomp$46.typedArraySet16(b, a, 0),
        this._gl.uniformMatrix4fv(this._location, !1, a))
    }
    IsSetToCustomInBatch(a) {
        const b = this._lastBatchValue;
        return this.IsColorType() ? b[0] === Math.fround(a.getR()) && b[1] === Math.fround(a.getG()) && b[2] === Math.fround(a.getB()) : b[0] === Math.fround(a)
    }
    SetBatchValueCustom(a) {
        const b = this._lastBatchValue;
        this.IsColorType() ? (b[0] = a.getR(),
        b[1] = a.getG(),
        b[2] = a.getB()) : b[0] = a
    }
    IsSetTo1InBatch(a) {
        return this._lastBatchValue[0] === Math.fround(a)
    }
    IsSetTo2InBatch(a, b) {
        const d = this._lastBatchValue;
        return d[0] === Math.fround(a) && d[1] === Math.fround(b)
    }
    SetBatch1(a) {
        this._lastBatchValue[0] = a
    }
    SetBatch2(a, b) {
        const d = this._lastBatchValue;
        d[0] = a;
        d[1] = b
    }
}
;
"use strict";
const C3$jscomp$47 = self.C3
  , glMatrix$jscomp$5 = self.glMatrix
  , vec4$jscomp$3 = glMatrix$jscomp$5.vec4
  , mat4$jscomp$6 = glMatrix$jscomp$5.mat4;
C3$jscomp$47.Gfx.BatchState = class {
    constructor(a) {
        this.renderer = a;
        this.currentMV = mat4$jscomp$6.create();
        this.currentMatP = mat4$jscomp$6.create();
        this.currentFramebufferNoDepth = this.currentFramebuffer = null;
        this.isDepthSamplingEnabled = !1;
        this.currentColor = vec4$jscomp$3.fromValues(1, 1, 1, 1);
        this.currentShader = null;
        this.pointTexCoords = new C3$jscomp$47.Rect;
        this.clearColor = C3$jscomp$47.New(C3$jscomp$47.Color, 0, 0, 0, 0)
    }
}
;
C3$jscomp$47.Gfx.WebGLBatchJob = class {
    constructor(a) {
        const b = new ArrayBuffer(96);
        this._type = 0;
        this._batchState = a;
        this._gl = a.renderer.GetContext();
        this._indexCount = this._startIndex = 0;
        this._texParam = null;
        this._mat4param = new Float32Array(b,0,16);
        this._colorParam = new Float32Array(b,64,4);
        this._srcOriginRect = new Float32Array(b,80,4);
        this._shaderParams = []
    }
    InitQuad(a, b) {
        this._type = 1;
        this._startIndex = a;
        this._indexCount = b
    }
    DoQuad() {
        const a = this._gl;
        a.drawElements(a.TRIANGLES, this._indexCount, a.UNSIGNED_SHORT, this._startIndex)
    }
    InitSetTexture(a) {
        this._type = 2;
        this._texParam = a
    }
    DoSetTexture() {
        const a = this._gl
          , b = this._texParam;
        a.bindTexture(a.TEXTURE_2D, b ? b._GetTexture() : null)
    }
    InitSetColor(a) {
        this._type = 3;
        a.writeToTypedArray(this._colorParam, 0)
    }
    DoSetColor() {
        const a = this._colorParam
          , b = this._batchState;
        vec4$jscomp$3.copy(b.currentColor, a);
        b.currentShader.UpdateColor(a)
    }
    InitSetGradientColor(a) {
        this._type = 21;
        a.writeToTypedArray(this._colorParam, 0)
    }
    DoSetGradientColor() {
        const a = this._colorParam
          , b = this._batchState.currentShader;
        b._uColor2.IsUsed() && b._uColor2.Update4f(a[0], a[1], a[2], a[3])
    }
    InitSetBlend(a, b) {
        this._type = 4;
        this._startIndex = a;
        this._indexCount = b
    }
    DoSetBlend() {
        this._gl.blendFunc(this._startIndex, this._indexCount)
    }
    InitSetViewport(a, b, d, c) {
        this._type = 5;
        const e = this._colorParam;
        e[0] = a;
        e[1] = b;
        e[2] = d;
        e[3] = c
    }
    DoSetViewport() {
        const a = this._colorParam;
        this._gl.viewport(a[0], a[1], a[2], a[3])
    }
    InitSetProjection(a) {
        this._type = 6;
        mat4$jscomp$6.copy(this._mat4param, a)
    }
    DoSetProjection() {
        const a = this._batchState
          , b = a.renderer._allShaderPrograms
          , d = a.currentShader
          , c = this._mat4param;
        for (let e = 0, g = b.length; e < g; ++e) {
            const k = b[e];
            k === d ? k.UpdateMatP(c, !0) : k.SetMatPStale()
        }
        mat4$jscomp$6.copy(a.currentMatP, c)
    }
    InitSetModelView(a) {
        this._type = 7;
        mat4$jscomp$6.copy(this._mat4param, a)
    }
    DoSetModelView() {
        const a = this._batchState
          , b = a.renderer._allShaderPrograms
          , d = a.currentShader
          , c = this._mat4param;
        for (let e = 0, g = b.length; e < g; ++e) {
            const k = b[e];
            k === d ? k.UpdateMatMV(c, !0) : k.SetMatMVStale()
        }
        mat4$jscomp$6.copy(a.currentMV, c)
    }
    InitSetRenderTarget(a) {
        this._type = 8;
        this._texParam = a
    }
    DoSetRenderTarget() {
        const a = this._gl
          , b = this._texParam
          , d = this._batchState;
        b ? (d.currentFramebuffer = b._GetFramebuffer(),
        d.currentFramebufferNoDepth = b._GetFramebufferNoDepth(),
        d.isDepthSamplingEnabled && d.currentFramebufferNoDepth ? a.bindFramebuffer(a.FRAMEBUFFER, d.currentFramebufferNoDepth) : a.bindFramebuffer(a.FRAMEBUFFER, d.currentFramebuffer)) : (d.currentFramebuffer = null,
        d.currentFramebufferNoDepth = null,
        a.bindFramebuffer(a.FRAMEBUFFER, null))
    }
    InitClearSurface(a) {
        this._type = 9;
        a.writeToTypedArray(this._mat4param, 0)
    }
    InitClearSurface2(a, b, d, c) {
        this._type = 9;
        const e = this._mat4param;
        e[0] = a;
        e[1] = b;
        e[2] = d;
        e[3] = c
    }
    DoClearSurface() {
        const a = this._gl;
        var b = this._mat4param;
        const d = this._batchState.clearColor
          , c = b[0]
          , e = b[1]
          , g = b[2];
        b = b[3];
        d.equalsRgba(c, e, g, b) || (a.clearColor(c, e, g, b),
        d.setRgba(c, e, g, b));
        a.clear(a.COLOR_BUFFER_BIT)
    }
    InitSetPointTexCoords(a) {
        this._type = 15;
        a.writeToTypedArray(this._mat4param, 0)
    }
    DoSetPointTextureCoords() {
        const a = this._mat4param;
        this._batchState.pointTexCoords.set(a[0], a[1], a[2], a[3])
    }
    InitPoints(a, b) {
        this._type = 10;
        this._startIndex = a;
        this._indexCount = 1;
        this._mat4param[0] = b
    }
    DoPoints() {
        const a = this._gl
          , b = this._batchState
          , d = b.renderer._spPoints;
        a.useProgram(d._shaderProgram);
        d.UpdateMatP(b.currentMatP, !1);
        d.UpdateMatMV(b.currentMV, !1);
        var c = b.pointTexCoords;
        d._uPointTexStart.IsUsed() && d._uPointTexStart.Update2f(c.getLeft(), c.getTop());
        d._uPointTexEnd.IsUsed() && d._uPointTexEnd.Update2f(c.getRight(), c.getBottom());
        c = this._mat4param[0];
        d._uZElevation.IsUsed() && d._uZElevation.Update1f(c);
        d._uColor.IsUsed() && (c = b.currentColor,
        d._uColor.Update4f(c[0], c[1], c[2], c[3]));
        a.drawArrays(a.POINTS, this._startIndex / 4, this._indexCount);
        a.useProgram(b.currentShader._shaderProgram)
    }
    InitSetProgram(a) {
        this._type = 11;
        this._texParam = a
    }
    DoSetProgram() {
        var a = this._gl;
        const b = this._batchState
          , d = this._texParam;
        b.currentShader = d;
        a.useProgram(d._shaderProgram);
        d.UpdateMatP(b.currentMatP, !1);
        d.UpdateMatMV(b.currentMV, !1);
        d._uColor.IsUsed() && (a = b.currentColor,
        d._uColor.Update4f(a[0], a[1], a[2], a[3]))
    }
    InitSetProgramParameters() {
        this._type = 12
    }
    DoSetProgramParameters() {
        const a = this._batchState.currentShader
          , b = this._gl
          , d = this._mat4param
          , c = this._colorParam
          , e = this._srcOriginRect;
        if (a._uSamplerBack.IsUsed()) {
            const g = this._batchState.renderer
              , k = this._texParam;
            g._lastTexture1 !== k && (b.activeTexture(b.TEXTURE1),
            b.bindTexture(b.TEXTURE_2D, k ? k._GetTexture() : null),
            g._lastTexture1 = k,
            b.activeTexture(b.TEXTURE0))
        }
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(d[0], d[1]);
        a._uDestStart.IsUsed() && a._uDestStart.Update2f(d[2], d[3]);
        a._uDestEnd.IsUsed() && a._uDestEnd.Update2f(d[4], d[5]);
        a._uDevicePixelRatio.IsUsed() && a._uDevicePixelRatio.Update1f(this._indexCount);
        a._uLayerScale.IsUsed() && a._uLayerScale.Update1f(d[6]);
        a._uLayerAngle.IsUsed() && a._uLayerAngle.Update1f(d[7]);
        a._uSrcStart.IsUsed() && a._uSrcStart.Update2f(d[12], d[13]);
        a._uSrcEnd.IsUsed() && a._uSrcEnd.Update2f(d[14], d[15]);
        a._uSrcOriginStart.IsUsed() && a._uSrcOriginStart.Update2f(e[0], e[1]);
        a._uSrcOriginEnd.IsUsed() && a._uSrcOriginEnd.Update2f(e[2], e[3]);
        a._uLayoutStart.IsUsed() && a._uLayoutStart.Update2f(c[0], c[1]);
        a._uLayoutEnd.IsUsed() && a._uLayoutEnd.Update2f(c[2], c[3]);
        a._uSeconds.IsUsed() && a._uSeconds.Update1f(this._startIndex)
    }
    InitSetProgramCustomParameters() {
        this._type = 13
    }
    DoSetProgramCustomParameters() {
        const a = this._batchState.currentShader._uCustomParameters
          , b = this._shaderParams;
        for (let d = 0, c = a.length; d < c; ++d) {
            const e = a[d]
              , g = b[d];
            e.IsColorType() ? e.Update3f(g.getR(), g.getG(), g.getB()) : e.Update1f(g)
        }
    }
    InitInvalidateFramebuffer(a) {
        this._type = 14;
        this._texParam = a
    }
    DoInvalidateFramebuffer() {
        const a = this._gl
          , b = this._texParam
          , d = this._batchState.currentFramebuffer;
        b !== d && a.bindFramebuffer(a.FRAMEBUFFER, b);
        a.invalidateFramebuffer(a.FRAMEBUFFER, [a.COLOR_ATTACHMENT0]);
        b !== d && a.bindFramebuffer(a.FRAMEBUFFER, d)
    }
    InitBlitFramebuffer(a, b, d) {
        this._type = 17;
        const c = this._mat4param
          , e = this._batchState.renderer;
        c[0] = a.GetWidth();
        c[1] = a.GetHeight();
        c[2] = b ? b.GetWidth() : e.GetWidth();
        c[3] = b ? b.GetHeight() : e.GetHeight();
        c[4] = a.IsLinearSampling() ? 1 : 0;
        c[5] = "stretch" === d;
        d = this._shaderParams;
        C3$jscomp$47.clearArray(d);
        d.push(a._GetFramebuffer());
        d.push(b ? b._GetFramebuffer() : null)
    }
    DoBlitFramebuffer() {
        var a = this._mat4param
          , b = this._shaderParams;
        const d = this._gl;
        var c = a[0]
          , e = a[1]
          , g = a[2];
        const k = a[3]
          , l = 0 !== a[4];
        a = 0 !== a[5];
        const n = b[1];
        d.bindFramebuffer(d.READ_FRAMEBUFFER, b[0]);
        d.bindFramebuffer(d.DRAW_FRAMEBUFFER, n);
        a ? d.blitFramebuffer(0, 0, c, e, 0, 0, g, k, d.COLOR_BUFFER_BIT, l ? d.LINEAR : d.NEAREST) : (b = Math.min(c, g),
        c = Math.min(e, k),
        g = Math.max(e - k, 0),
        e = Math.max(k - e, 0),
        d.blitFramebuffer(0, g, b, c + g, 0, e, b, c + e, d.COLOR_BUFFER_BIT, d.NEAREST))
    }
    InitStartQuery(a) {
        this._type = 18;
        this._texParam = a
    }
    DoStartQuery() {
        this._texParam.BeginTimeElapsed();
        this._texParam = null
    }
    InitEndQuery(a) {
        this._type = 19;
        this._texParam = a
    }
    DoEndQuery() {
        this._texParam.EndTimeElapsed();
        this._texParam = null
    }
    InitSetEllipseParams(a, b, d) {
        this._type = 20;
        const c = this._mat4param;
        c[0] = a;
        c[1] = b;
        c[2] = d
    }
    DoSetEllipseParams() {
        const a = this._batchState.currentShader
          , b = this._mat4param;
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(b[0], b[1]);
        a._uOutlineThickness.IsUsed() && a._uOutlineThickness.Update1f(b[2])
    }
    InitSetTilemapInfo(a, b, d, c, e, g, k) {
        this._type = 16;
        const l = this._mat4param;
        a.writeToTypedArray(l, 0);
        l[4] = 1 / b;
        l[5] = 1 / d;
        l[6] = c / b;
        l[7] = e / d;
        l[8] = g / b;
        l[9] = k / d
    }
    DoSetTilemapInfo() {
        const a = this._batchState.currentShader
          , b = this._mat4param;
        a._uSrcStart.IsUsed() && a._uSrcStart.Update2f(b[0], b[1]);
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(b[4], b[5]);
        a._uTileSize.IsUsed() && a._uTileSize.Update2f(b[6], b[7]);
        a._uTileSpacing.IsUsed() && a._uTileSpacing.Update2f(b[8], b[9])
    }
    InitSetTileRandomizationInfo(a, b, d, c, e, g, k) {
        this._type = 29;
        const l = this._mat4param;
        l[0] = 1 / a;
        l[1] = 1 / b;
        l[2] = d;
        l[3] = c;
        l[4] = e;
        l[5] = g;
        l[6] = k
    }
    DoSetTileRandomizationInfo() {
        const a = this._batchState.currentShader
          , b = this._mat4param;
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(b[0], b[1]);
        a._uTileSize.IsUsed() && a._uTileSize.Update2f(b[2], b[3]);
        a._uOutlineThickness.IsUsed() && a._uOutlineThickness.Update1f(b[4]);
        a._uTileSpacing.IsUsed() && a._uTileSpacing.Update2f(b[5], b[6])
    }
    InitClearDepth(a) {
        this._type = 22;
        this._startIndex = a ? 1 : 0
    }
    DoClearDepth() {
        const a = this._gl
          , b = 0 !== this._startIndex;
        b || a.depthMask(!0);
        a.clear(a.DEPTH_BUFFER_BIT);
        b || a.depthMask(!1)
    }
    InitSetDepthEnabled(a) {
        this._type = 23;
        this._startIndex = a ? 1 : 0
    }
    DoSetDepthEnabled() {
        const a = this._gl;
        0 === this._startIndex ? (a.disable(a.DEPTH_TEST),
        a.depthMask(!1)) : (a.enable(a.DEPTH_TEST),
        a.depthMask(!0))
    }
    InitSetDepthSamplingEnabled(a) {
        this._type = 24;
        this._startIndex = a ? 1 : 0
    }
    DoSetDepthSamplingEnabled() {
        const a = this._gl
          , b = this._batchState
          , d = b.renderer
          , c = 0 !== this._startIndex;
        b.isDepthSamplingEnabled = c;
        a.activeTexture(a.TEXTURE2);
        c ? (b.currentFramebufferNoDepth && a.bindFramebuffer(a.FRAMEBUFFER, b.currentFramebufferNoDepth),
        a.bindTexture(a.TEXTURE_2D, d._GetDepthBuffer())) : (a.bindTexture(a.TEXTURE_2D, null),
        b.currentFramebufferNoDepth && a.bindFramebuffer(a.FRAMEBUFFER, b.currentFramebuffer));
        a.activeTexture(a.TEXTURE0)
    }
    InitCoplanarStartStencilPass() {
        this._type = 25
    }
    DoCoplanarStartStencilPass() {
        const a = this._gl;
        a.clear(a.STENCIL_BUFFER_BIT);
        a.enable(a.STENCIL_TEST);
        a.stencilFunc(a.ALWAYS, 1, 1);
        a.stencilOp(a.KEEP, a.KEEP, a.REPLACE);
        a.colorMask(!1, !1, !1, !1)
    }
    InitCoplanarStartColorPass() {
        this._type = 26
    }
    DoCoplanarStartColorPass() {
        const a = this._gl;
        a.colorMask(!0, !0, !0, !0);
        a.stencilFunc(a.EQUAL, 1, 1);
        a.stencilOp(a.KEEP, a.KEEP, a.KEEP)
    }
    InitCoplanarRestore() {
        this._type = 27
    }
    DoCoplanarRestore() {
        const a = this._gl;
        a.disable(a.STENCIL_TEST)
    }
    InitSetScissor(a, b, d, c, e) {
        this._type = 28;
        this._startIndex = a ? 1 : 0;
        a = this._mat4param;
        a[0] = b;
        a[1] = d;
        a[2] = c;
        a[3] = e
    }
    DoSetScissor() {
        const a = this._gl
          , b = this._mat4param;
        1 === this._startIndex ? (a.enable(a.SCISSOR_TEST),
        a.scissor(b[0], b[1], b[2], b[3])) : a.disable(a.SCISSOR_TEST)
    }
    Run() {
        switch (this._type) {
        case 1:
            this.DoQuad();
            break;
        case 2:
            this.DoSetTexture();
            break;
        case 3:
            this.DoSetColor();
            break;
        case 4:
            this.DoSetBlend();
            break;
        case 5:
            this.DoSetViewport();
            break;
        case 6:
            this.DoSetProjection();
            break;
        case 7:
            this.DoSetModelView();
            break;
        case 8:
            this.DoSetRenderTarget();
            break;
        case 9:
            this.DoClearSurface();
            break;
        case 10:
            this.DoPoints();
            break;
        case 11:
            this.DoSetProgram();
            break;
        case 12:
            this.DoSetProgramParameters();
            break;
        case 13:
            this.DoSetProgramCustomParameters();
            break;
        case 14:
            this.DoInvalidateFramebuffer();
            break;
        case 15:
            this.DoSetPointTextureCoords();
            break;
        case 16:
            this.DoSetTilemapInfo();
            break;
        case 17:
            this.DoBlitFramebuffer();
            break;
        case 18:
            this.DoStartQuery();
            break;
        case 19:
            this.DoEndQuery();
            break;
        case 20:
            this.DoSetEllipseParams();
            break;
        case 21:
            this.DoSetGradientColor();
            break;
        case 22:
            this.DoClearDepth();
            break;
        case 23:
            this.DoSetDepthEnabled();
            break;
        case 24:
            this.DoSetDepthSamplingEnabled();
            break;
        case 25:
            this.DoCoplanarStartStencilPass();
            break;
        case 26:
            this.DoCoplanarStartColorPass();
            break;
        case 27:
            this.DoCoplanarRestore();
            break;
        case 28:
            this.DoSetScissor();
            break;
        case 29:
            this.DoSetTileRandomizationInfo()
        }
    }
}
;
"use strict";
const C3$jscomp$48 = self.C3
  , GENERIC_FONT_FAMILIES = new Set("serif sans-serif monospace cursive fantasy system-ui ui-serif ui-sans-serif ui-monospace ui-rounded math emoji fangsong".split(" "))
  , DEFAULT_OPTS = {
    timeout: 60
}
  , tempColor = new C3$jscomp$48.Color(0,0,0,1)
  , VALID_HORIZ_ALIGNMENTS = new Set(["left", "center", "right"])
  , VALID_VERT_ALIGNMENTS = new Set(["top", "center", "bottom"])
  , VALID_WORD_WRAP_MODES = new Set(["word", "character"])
  , allRendererTexts = new Set;
C3$jscomp$48.FontManager && C3$jscomp$48.FontManager.addEventListener("fontload", a=>{
    a = a.font.GetName();
    for (const b of allRendererTexts)
        (b.IsBBCodeEnabled() || C3$jscomp$48.equalsNoCase(b.GetFontName(), a)) && b._SetTextChanged()
}
);
function fillOrStrokeText(a, b, d, c, e, g) {
    b ? "Gecko" === C3$jscomp$48.Platform.BrowserEngine ? a.strokeText(d, c, e, g) : a.strokeText(d, c, e) : "Gecko" === C3$jscomp$48.Platform.BrowserEngine ? a.fillText(d, c, e, g) : a.fillText(d, c, e)
}
function fillOrStrokeRect(a, b, d, c, e, g) {
    b ? a.strokeRect(d, c, e, g) : a.fillRect(d, c, e, g)
}
function ptToPx(a) {
    return 4 / 3 * a
}
let didCheckFoundBoundingBoxSupport = !1
  , supportsFontBoundingBoxMeasurements = !1;
C3$jscomp$48.Gfx.RendererText = class {
    constructor(a, b) {
        b = Object.assign({}, DEFAULT_OPTS, b);
        this._renderer = a;
        this._fontName = "Arial";
        this._fontSize = 16;
        this._fontSizeScale = 1;
        this._lineHeight = 0;
        this._isItalic = this._isBold = !1;
        this._colorStr = "black";
        this._isBBcodeEnabled = !1;
        this.onloadfont = null;
        this._alreadyLoadedFonts = new Set;
        this._horizontalAlign = "left";
        this._verticalAlign = "top";
        this._text = "";
        this._bbString = null;
        this._wrappedText = C3$jscomp$48.New(C3$jscomp$48.WordWrap);
        this._wrapMode = "word";
        this._isUpdating = this._textChanged = !1;
        this._isAsync = !0;
        this._drawMaxCharCount = -1;
        this._height = this._width = this._cssHeight = this._cssWidth = this._drawCharCount = 0;
        this._zoom = 1;
        this._changed = !1;
        this._measureContextTop = this._measureContext = this._textContext = this._textCanvas = null;
        this._lastCanvasHeight = this._lastCanvasWidth = -1;
        this._lastTextCanvasFillStyle = this._lastMeasureCanvasFont = this._lastTextCanvasFont = "";
        this._lastTextCanvasLineWidth = this._lastTextCanvasOpacity = 1;
        this._measureTextCallback = (d,c)=>this._MeasureText(d, c);
        this._texture = null;
        this._textureHeight = this._textureWidth = 0;
        this._rcTex = new C3$jscomp$48.Rect;
        this._scaleFactor = 1;
        this._needToRecreateTexture = !1;
        this._textureTimeout = new C3$jscomp$48.IdleTimeout(()=>{
            this.ReleaseTexture();
            this._SetTextCanvasSize(8, 8)
        }
        ,b.timeout);
        this.ontextureupdate = null;
        this._wasReleased = !1;
        allRendererTexts.add(this)
    }
    Release() {
        this.onloadfont = null;
        this._alreadyLoadedFonts.clear();
        this._measureTextCallback = this._measureContextTop = this._measureContext = this._textContext = this._textCanvas = this._bbString = null;
        this._textureTimeout.Release();
        this.ontextureupdate = null;
        this.ReleaseTexture();
        this._wrappedText.Clear();
        this._renderer = this._wrappedText = null;
        this._wasReleased = !0;
        allRendererTexts.delete(this)
    }
    _SetChanged() {
        this._changed = !0
    }
    _SetTextChanged() {
        this._SetChanged();
        this._wrappedText.Clear();
        this._textChanged = !0
    }
    SetIsAsync(a) {
        this._isAsync = !!a
    }
    IsAsync() {
        return this._isAsync
    }
    SetBBCodeEnabled(a) {
        a = !!a;
        this._isBBcodeEnabled !== a && (a = (this._isBBcodeEnabled = a) ? "alphabetic" : "top",
        this._textContext && (this._textContext.textBaseline = a),
        this._measureContext && (this._measureContext.textBaseline = a),
        this._SetTextChanged())
    }
    IsBBCodeEnabled() {
        return this._isBBcodeEnabled
    }
    SetFontName(a) {
        a || (a = "serif");
        this._fontName !== a && (this._fontName = a,
        this._SetTextChanged())
    }
    GetFontName() {
        return this._fontName
    }
    SetFontSize(a) {
        .1 > a && (a = .1);
        this._fontSize !== a && (this._fontSize = a,
        this._SetTextChanged())
    }
    SetFontSizeScale(a) {
        this._fontSizeScale !== a && (this._fontSizeScale = a,
        this._SetTextChanged())
    }
    SetLineHeight(a) {
        this._lineHeight !== a && (this._lineHeight = a,
        this._SetChanged())
    }
    SetBold(a) {
        a = !!a;
        this._isBold !== a && (this._isBold = a,
        this._SetTextChanged())
    }
    SetItalic(a) {
        a = !!a;
        this._isItalic !== a && (this._isItalic = a,
        this._SetTextChanged())
    }
    SetDrawMaxCharacterCount(a) {
        a = Math.floor(a);
        this._drawMaxCharCount !== a && (this._drawMaxCharCount = a,
        this._SetChanged())
    }
    GetDrawMaxCharacterCount() {
        return this._drawMaxCharCount
    }
    _GetStyleTag(a, b) {
        for (let d = a.length - 1; 0 <= d; --d) {
            const c = a[d];
            if (c.tag === b)
                return c
        }
        return null
    }
    _HasStyleTag(a, b) {
        return !!this._GetStyleTag(a, b)
    }
    _GetFontString(a, b) {
        let d = [];
        (this._isBold || this._HasStyleTag(b, "b")) && d.push("bold");
        (this._isItalic || this._HasStyleTag(b, "i")) && d.push("italic");
        var c = this._GetStyleTag(b, "size");
        c = (c ? parseFloat(c.param) : this._fontSize) * this._fontSizeScale;
        a ? d.push(c + "pt") : d.push(c * this._scaleFactor * this._zoom * self.devicePixelRatio + "pt");
        a = this._fontName;
        (b = this._GetStyleTag(b, "font")) && b.param && (a = b.param,
        this.onloadfont && !this._alreadyLoadedFonts.has(a) && (this.onloadfont(a),
        this._alreadyLoadedFonts.add(a)));
        a && (GENERIC_FONT_FAMILIES.has(a) ? d.push(a) : d.push('"' + a + '"'));
        return d.join(" ")
    }
    SetColor(a) {
        a instanceof C3$jscomp$48.Color && (a = a.getCssRgb());
        this._colorStr !== a && (this._colorStr = a,
        this._SetChanged())
    }
    SetColorRgb(a, b, d) {
        tempColor.setRgb(a, b, d);
        this.SetColor(tempColor)
    }
    SetHorizontalAlignment(a) {
        if (!VALID_HORIZ_ALIGNMENTS.has(a))
            throw Error("invalid horizontal alignment");
        this._horizontalAlign !== a && (this._horizontalAlign = a,
        this._SetChanged())
    }
    SetVerticalAlignment(a) {
        if (!VALID_VERT_ALIGNMENTS.has(a))
            throw Error("invalid vertical alignment");
        this._verticalAlign !== a && (this._verticalAlign = a,
        this._SetChanged())
    }
    SetWordWrapMode(a) {
        if (!VALID_WORD_WRAP_MODES.has(a))
            throw Error("invalid word wrap mode");
        this._wrapMode !== a && (this._wrapMode = a,
        this._SetTextChanged())
    }
    SetText(a) {
        this._text !== a && (this._text = a,
        this._SetTextChanged())
    }
    SetSize(a, b, d) {
        "undefined" === typeof d && (d = 1);
        if (!(0 >= a || 0 >= a || this._cssWidth === a && this._cssHeight === b && this._zoom === d)) {
            1 === this._zoom !== (1 === d) && (this._needToRecreateTexture = !0);
            var c = this._cssWidth
              , e = this._zoom;
            this._cssWidth = a;
            this._cssHeight = b;
            this._zoom = d;
            a = self.devicePixelRatio;
            this._width = this._cssWidth * this._zoom * a;
            this._height = this._cssHeight * this._zoom * a;
            a = Math.max(this._width, this._height);
            b = Math.min(this._renderer.GetMaxTextureSize(), 4096);
            d = 1;
            a > b && (d = b / a,
            this._width = Math.min(this._width * d, b),
            this._height = Math.min(this._height * d, b));
            this._scaleFactor = d;
            0 < this._textureWidth && 0 < this._textureHeight && this._zoom === e && this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight);
            this._cssWidth !== c ? this._SetTextChanged() : this._SetChanged()
        }
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    GetTextWidth() {
        this._MaybeWrapText();
        return this._wrappedText.GetMaxLineWidth()
    }
    GetTextHeight() {
        this._MaybeWrapText();
        return this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + 4) - this._lineHeight
    }
    GetTexture() {
        this._textureTimeout.Reset();
        this._MaybeUpdate();
        return this._texture
    }
    _MaybeUpdate() {
        this._texture && !this._changed && !this._textChanged || this._isUpdating || 0 >= this._width || 0 >= this._height || (this._changed = !1,
        this._isUpdating = !0,
        this._isAsync ? C3$jscomp$48.Asyncify(()=>this._DoUpdate()) : this._DoUpdate())
    }
    _DoUpdate() {
        this._wasReleased || (this._SetTextCanvasSize(Math.ceil(this._width), Math.ceil(this._height)),
        this._MaybeWrapText(),
        this._DrawTextToCanvas(),
        this._UpdateTexture(),
        this._textureTimeout.Reset(),
        this._isUpdating = !1)
    }
    _SetTextCanvasSize(a, b) {
        this._textCanvas || (this._textCanvas = C3$jscomp$48.CreateCanvas(16, 16));
        let d = !1;
        if (this._lastCanvasWidth !== a || this._lastCanvasHeight !== b)
            this._lastCanvasWidth = a,
            this._lastCanvasHeight = b,
            this._textCanvas.width = a,
            this._textCanvas.height = b,
            d = !0;
        this._textContext || (this._textContext = this._textCanvas.getContext("2d"),
        d = !0);
        d ? (this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top",
        this._textContext.font = this._lastTextCanvasFont,
        this._textContext.fillStyle = this._lastTextCanvasFillStyle,
        this._textContext.strokeStyle = this._lastTextCanvasFillStyle,
        this._textContext.globalAlpha = this._lastTextCanvasOpacity,
        this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, a, b)
    }
    _MaybeCreateMeasureContext() {
        this._measureContext || (this._measureContext = C3$jscomp$48.CreateCanvas(16, 16).getContext("2d"),
        this._measureContextTop = C3$jscomp$48.CreateCanvas(16, 16).getContext("2d"),
        this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top",
        this._measureContextTop.textBaseline = "top")
    }
    _SetMeasureFontString(a) {
        this._lastMeasureCanvasFont !== a && (this._lastMeasureCanvasFont = a,
        this._measureContext.font = a,
        this._measureContextTop.font = a)
    }
    _SupportsFontBoundingBoxMeasurements() {
        if (!didCheckFoundBoundingBoxSupport) {
            didCheckFoundBoundingBoxSupport = !0;
            this._MaybeCreateMeasureContext();
            const a = this._measureContext.measureText("test");
            supportsFontBoundingBoxMeasurements = "number" === typeof a.fontBoundingBoxAscent && "number" === typeof a.fontBoundingBoxDescent
        }
        return supportsFontBoundingBoxMeasurements
    }
    _MaybeWrapText() {
        this._textChanged && (this._MaybeCreateMeasureContext(),
        !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C3$jscomp$48.BBString(this._text,{
            noEscape: !0
        })),
        this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0),
        this._textChanged = !1)
    }
    _MeasureText(a, b) {
        a = a.join("");
        this._SetMeasureFontString(this._GetFontString(!0, b));
        b = this._GetStyleTag(b, "size");
        b = (b ? parseFloat(b.param) : this._fontSize) * this._fontSizeScale;
        const d = this._measureContext.measureText(a);
        let c = 0;
        this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements() && (a = this._measureContextTop.measureText(a),
        c = d.fontBoundingBoxAscent - a.fontBoundingBoxAscent);
        return {
            width: d.width,
            height: ptToPx(b),
            fontBoundingBoxAscent: d.fontBoundingBoxAscent || 0,
            fontBoundingBoxDescent: d.fontBoundingBoxDescent || 0,
            topToAlphabeticDistance: c
        }
    }
    _SetDrawFontString(a) {
        this._lastTextCanvasFont !== a && (this._lastTextCanvasFont = a,
        this._textContext.font = a)
    }
    _SetDrawCanvasColor(a) {
        this._lastTextCanvasFillStyle !== a && (this._lastTextCanvasFillStyle = a,
        this._textContext.fillStyle = a,
        this._textContext.strokeStyle = a)
    }
    _SetDrawCanvasOpacity(a) {
        this._lastTextCanvasOpacity !== a && (this._lastTextCanvasOpacity = a,
        this._textContext.globalAlpha = a)
    }
    _SetDrawCanvasLineWith(a) {
        this._lastTextCanvasLineWidth !== a && (this._lastTextCanvasLineWidth = a,
        this._textContext.lineWidth = a)
    }
    _DrawTextToCanvas() {
        this._drawCharCount = 0;
        const a = this._scaleFactor * this._zoom * self.devicePixelRatio
          , b = (4 + this._lineHeight) * a;
        var d = 0;
        const c = this._wrappedText.GetLines();
        if (0 !== c.length) {
            var e = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements()
              , g = c[0].height * a;
            "center" === this._verticalAlign ? (d = c.reduce((k,l)=>k + l.height * a + b, 0) - b,
            d = Math.max(this._height / 2 - d / 2, 0),
            e && (g = c[0].topToAlphabeticDistance * a)) : "bottom" === this._verticalAlign && (d = c.reduce((k,l)=>k + l.height * a + b, 0) - this._lineHeight * a,
            e = e ? c.at(-1).fontBoundingBoxDescent * a : 0,
            d = this._height - d - e - 2);
            for (let k = 0, l = c.length; k < l; ++k) {
                e = c[k];
                const n = e.height * a
                  , p = d;
                if (this._isBBcodeEnabled) {
                    if (d += 0 === k ? g : n,
                    0 < k && d > this._height - 4 * a)
                        break
                } else if (0 < k && d >= this._height - n)
                    break;
                0 <= p && this._DrawTextLine(e, d, a);
                this._isBBcodeEnabled || (d += n);
                d += b
            }
        }
    }
    _DrawTextLine(a, b, d) {
        let c = 0;
        "center" === this._horizontalAlign ? c = (this._width - a.width * d) / 2 : "right" === this._horizontalAlign && (c = this._width - a.width * d);
        for (const e of a.fragments)
            this._DrawTextFragment(e, c, b, d, a.height),
            c += e.width * d
    }
    _DrawTextFragment(a, b, d, c, e) {
        const g = this._textContext
          , k = e / 16;
        e = a.width * c;
        const l = a.height * c
          , n = a.height / 16;
        var p = (4 + this._lineHeight) * c
          , t = a.styles
          , w = a.chArr;
        if (-1 !== this._drawMaxCharCount) {
            if (this._drawCharCount >= this._drawMaxCharCount)
                return;
            this._drawCharCount + w.length > this._drawMaxCharCount && (w = w.slice(0, this._drawMaxCharCount - this._drawCharCount),
            e = this._MeasureText(w, t).width * c);
            this._drawCharCount += w.length
        }
        var z = this._GetStyleTag(t, "background");
        a = this._HasStyleTag(t, "u");
        const B = this._HasStyleTag(t, "s");
        if ((!C3$jscomp$48.IsCharArrayAllWhitespace(w) || z || a || B) && !this._HasStyleTag(t, "hide")) {
            w = w.join("");
            var C = this._GetStyleTag(t, "offsetx");
            b += C ? parseFloat(C.param) * c : 0;
            C = this._GetStyleTag(t, "offsety");
            d += C ? parseFloat(C.param) * c : 0;
            z && (this._SetDrawCanvasColor(z.param),
            g.fillRect(b, d - l, e, l + p));
            p = this._GetStyleTag(t, "color");
            this._SetDrawCanvasColor(p ? p.param : this._colorStr);
            z = this._GetStyleTag(t, "opacity");
            this._SetDrawCanvasOpacity(z ? parseFloat(z.param) / 100 : 1);
            z = (z = this._GetStyleTag(t, "linethickness")) ? parseFloat(z.param) : 1;
            (C = this._HasStyleTag(t, "stroke")) && this._SetDrawCanvasLineWith(.5 * n * z * this._scaleFactor * this._zoom * self.devicePixelRatio);
            this._SetDrawFontString(this._GetFontString(!1, t));
            fillOrStrokeText(g, C, w, b, d, e);
            !C && (this._SetDrawCanvasLineWith(.5 * n * z * this._scaleFactor * this._zoom * self.devicePixelRatio),
            t = this._GetStyleTag(t, "outline")) && (this._SetDrawCanvasColor(t.param),
            fillOrStrokeText(g, !0, w, b, d, e));
            this._SetDrawCanvasColor(p ? p.param : this._colorStr);
            a && fillOrStrokeRect(g, C, b, d + c * k, e, c * k * z);
            B && (c *= n,
            g.fillRect(b, d - l / 4 + c / 2 - c * z / 2, e, c * z))
        }
    }
    _UpdateTexture() {
        if (!this._renderer.IsContextLost() && (this._textureWidth = Math.ceil(this._width),
        this._textureHeight = Math.ceil(this._height),
        this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight),
        this._needToRecreateTexture && (this.ReleaseTexture(),
        this._needToRecreateTexture = !1),
        this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textureWidth, this._textureHeight, {
            mipMap: 1 === this._zoom,
            mipMapQuality: "high"
        })),
        this._renderer.UpdateTexture(this._textCanvas, this._texture),
        this.ontextureupdate))
            this.ontextureupdate()
    }
    GetTexRect() {
        return this._rcTex
    }
    ReleaseTexture() {
        this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture),
        this._texture = null)
    }
    static OnContextLost() {
        for (const a of allRendererTexts)
            a.ReleaseTexture()
    }
    static GetAll() {
        return allRendererTexts.values()
    }
}
;
"use strict";
const C3$jscomp$49 = self.C3;
class WebGLRealTimeElapsedQuery {
    constructor(a) {
        this._gl = a.GetContext();
        this._version = a.GetWebGLVersionNumber();
        this._timerExt = a._GetDisjointTimerQueryExtension();
        this._query = null;
        this._hasResult = this._isActive = !1;
        this._result = 0;
        this._query = 1 === this._version ? this._timerExt.createQueryEXT() : this._gl.createQuery()
    }
    Release() {
        this._DeleteQueryObject();
        this._timerExt = this._gl = null;
        this._hasResult = !1
    }
    _DeleteQueryObject() {
        this._query && (1 === this._version ? this._timerExt.deleteQueryEXT(this._query) : this._gl.deleteQuery(this._query),
        this._query = null)
    }
    BeginTimeElapsed() {
        if (this._isActive)
            throw Error("query already active");
        1 === this._version ? this._timerExt.beginQueryEXT(this._timerExt.TIME_ELAPSED_EXT, this._query) : this._gl.beginQuery(this._timerExt.TIME_ELAPSED_EXT, this._query);
        this._isActive = !0
    }
    EndTimeElapsed() {
        if (!this._isActive)
            throw Error("query not active");
        1 === this._version ? this._timerExt.endQueryEXT(this._timerExt.TIME_ELAPSED_EXT) : this._gl.endQuery(this._timerExt.TIME_ELAPSED_EXT);
        this._isActive = !1
    }
    CheckForResult() {
        if (this._query && !this._hasResult && !this._isActive) {
            var a = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_AVAILABLE_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT_AVAILABLE);
            var b = this._gl.getParameter(this._timerExt.GPU_DISJOINT_EXT);
            a && !b && (this._result = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT),
            this._result /= 1E9,
            this._hasResult = !0);
            (a || b) && this._DeleteQueryObject()
        }
    }
    HasResult() {
        return this._hasResult
    }
    GetResult() {
        if (!this._hasResult)
            throw Error("no result available");
        return this._result
    }
}
C3$jscomp$49.Gfx.WebGLTimeElapsedQuery = class {
    constructor(a) {
        this._renderer = a;
        this._frameNumber = a.GetFrameNumber();
        this._isActive = !1;
        this._parentQuery = null;
        this._isNested = !1;
        this._realQuery = null;
        this._queries = []
    }
    Release() {
        for (const a of this._queries)
            a instanceof WebGLRealTimeElapsedQuery && a.Release();
        C3$jscomp$49.clearArray(this._queries);
        this._renderer = this._realQuery = this._parentQuery = null
    }
    BeginTimeElapsed() {
        if (this._isActive)
            throw Error("query already active");
        const a = this._renderer._GetTimeQueryStack();
        0 < a.length ? (this._isNested = !0,
        this._parentQuery = a.at(-1),
        this._parentQuery._EndReal(),
        this._parentQuery._queries.push(this)) : (this._isNested = !1,
        this._parentQuery = null);
        this._isActive = !0;
        a.push(this);
        this._StartReal()
    }
    EndTimeElapsed() {
        if (!this._isActive)
            throw Error("query not active");
        if (this._renderer._GetTimeQueryStack().pop() !== this)
            throw Error("can only end most nested query");
        this._isActive = !1;
        this._EndReal();
        this._parentQuery && (this._parentQuery._StartReal(),
        this._parentQuery = null)
    }
    _StartReal() {
        this._realQuery = C3$jscomp$49.New(WebGLRealTimeElapsedQuery, this._renderer);
        this._queries.push(this._realQuery);
        this._realQuery.BeginTimeElapsed()
    }
    _EndReal() {
        this._realQuery.EndTimeElapsed();
        this._realQuery = null
    }
    CheckForResult() {
        for (const a of this._queries)
            a.CheckForResult()
    }
    IsNested() {
        return this._isNested
    }
    HasResult() {
        return this._queries.every(a=>a.HasResult())
    }
    GetResult() {
        return this._queries.reduce((a,b)=>a + b.GetResult(), 0)
    }
    GetFrameNumber() {
        return this._frameNumber
    }
}
;
"use strict";
const C3$jscomp$50 = self.C3;
C3$jscomp$50.Gfx.WebGLQueryResultBuffer = class {
    constructor(a, b=1E3) {
        this._renderer = a;
        this._maxQueries = b;
        this._buffer = [];
        this._renderer._AddQueryResultBuffer(this)
    }
    Release() {
        this.Clear();
        this._renderer._RemoveQueryResultBuffer(this);
        this._renderer = null
    }
    Clear() {
        for (const a of this._buffer)
            a.Release();
        C3$jscomp$50.clearArray(this._buffer)
    }
    AddTimeElapsedQuery() {
        const a = new C3$jscomp$50.Gfx.WebGLTimeElapsedQuery(this._renderer);
        this._buffer.push(a);
        this._buffer.length > this._maxQueries && this._buffer.shift().Release();
        return a
    }
    CheckForResults(a) {
        for (const b of this._buffer) {
            if (b.GetFrameNumber() >= a)
                break;
            if (b.IsNested())
                break;
            b.CheckForResult()
        }
    }
    GetFrameRangeResultSum(a, b) {
        if (b <= a)
            return NaN;
        let d = 0;
        for (const c of this._buffer) {
            if (c.GetFrameNumber() >= b)
                break;
            if (!(c.GetFrameNumber() < a))
                if (c.HasResult())
                    d += c.GetResult();
                else
                    return NaN
        }
        return d
    }
    DeleteAllBeforeFrameNumber(a) {
        for (let b = 0, d = this._buffer.length; b < d; ++b) {
            const c = this._buffer[b];
            if (c.GetFrameNumber() < a)
                c.Release();
            else {
                0 < b && this._buffer.splice(0, b);
                break
            }
        }
    }
}
;
"use strict";
const C3$jscomp$51 = self.C3
  , glMatrix$jscomp$6 = self.glMatrix
  , vec4$jscomp$4 = glMatrix$jscomp$6.vec4
  , mat4$jscomp$7 = glMatrix$jscomp$6.mat4
  , DEFAULT_WEBGLRENDERER_OPTS = {
    powerPreference: "default",
    enableGpuProfiling: !0,
    alpha: !1,
    lowLatency: !1,
    depth: !1,
    canSampleDepth: !1,
    maxWebGLVersion: 2,
    failIfMajorPerformanceCaveat: !1
}
  , VALID_POWER_PREFERENCES = new Set(["default", "low-power", "high-performance"])
  , MAX_INDICES = 12E3
  , LAST_POINT = 7996
  , defaultTexCoordsQuad$jscomp$1 = new C3$jscomp$51.Quad(0,0,1,0,1,1,0,1)
  , tmpProjection = mat4$jscomp$7.create()
  , tmpModelView = mat4$jscomp$7.create()
  , tmpQuad$jscomp$1 = new C3$jscomp$51.Quad
  , tmpRect$jscomp$1 = new C3$jscomp$51.Rect;
let loseContextExtension = null;
C3$jscomp$51.isDebug && (self.debug_lose_webgl_context = function() {
    loseContextExtension ? loseContextExtension.loseContext() : console.warn("WEBGL_lose_context not supported")
}
,
self.debug_restore_webgl_context = function() {
    loseContextExtension ? loseContextExtension.restoreContext() : console.warn("WEBGL_lose_context not supported")
}
);
const pendingPolls = new Set;
let pollRafId = -1;
function CheckPendingPolls() {
    pollRafId = -1;
    for (const a of pendingPolls)
        a.checkFunc() && (a.resolve(),
        pendingPolls.delete(a));
    0 < pendingPolls.size && (pollRafId = self.requestAnimationFrame(CheckPendingPolls))
}
C3$jscomp$51.Gfx.WebGLRenderer = class extends C3$jscomp$51.Gfx.RendererBase {
    constructor(a, b) {
        super(b);
        b = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, b);
        if (!VALID_POWER_PREFERENCES.has(b.powerPreference))
            throw Error("invalid power preference");
        const d = {
            alpha: !!b.alpha,
            depth: !1,
            antialias: !1,
            powerPreference: b.powerPreference,
            failIfMajorPerformanceCaveat: !!b.failIfMajorPerformanceCaveat
        };
        b.lowLatency && (d.desynchronized = !0,
        d.preserveDrawingBuffer = !0);
        let c = null
          , e = 0;
        2 <= b.maxWebGLVersion && (c = a.getContext("webgl2", d),
        e = 2);
        c || (c = a.getContext("webgl", d),
        e = 1);
        if (!c)
            throw Error("renderer-unavailable (could not get WebGL context)");
        this._gl = c;
        this._attribs = c.getContextAttributes();
        b.lowLatency && !this._attribs.desynchronized && console.info("[WebGLRenderer] Low-latency mode specified but is not supported here");
        this._versionString = c.getParameter(c.VERSION);
        this._version = e;
        this._viewport = vec4$jscomp$4.create();
        this._didChangeTransform = !1;
        this._bbProjectionMatrix = mat4$jscomp$7.create();
        this._usesDepthBuffer = !!b.depth;
        this._canSampleDepth = !(!b.depth || !b.canSampleDepth);
        this._isDepthEnabled = this._usesDepthBuffer;
        this._isDepthSamplingEnabled = !1;
        this._depthBuffer = null;
        this._isAutoSizeDepthBuffer = !0;
        this._depthBufferHeight = this._depthBufferWidth = 0;
        this._pointBuffer = this._indexBuffer = this._texcoordBuffer = this._vertexBuffer = null;
        this._vertexData = new Float32Array(8E3 * this.GetNumVertexComponents());
        this._indexData = new Uint16Array(MAX_INDICES);
        this._texcoordData = new Float32Array(16E3);
        this._pointData = new Float32Array(32E3);
        this._lastVertexPtr = this._pointPtr = this._texPtr = this._vertexPtr = 0;
        this._spDeviceTransformTextureFill = this._lastProgram = null;
        this._batch = [];
        this._topOfBatch = this._batchPtr = 0;
        this._currentRenderTarget = null;
        this._lastPointZ = 0;
        this._batchState = C3$jscomp$51.New(C3$jscomp$51.Gfx.BatchState, this);
        this._lastColor = C3$jscomp$51.New(C3$jscomp$51.Color, 1, 1, 1, 1);
        this._lastTexture1 = this._lastTexture0 = null;
        this._lastDestBlend = this._lastSrcBlend = 0;
        this._lastPointTexCoords = new C3$jscomp$51.Rect;
        this._lastScissorRect = C3$jscomp$51.New(C3$jscomp$51.Rect, 0, 0, -1, -1);
        this._maxTextureSize = -1;
        this._highpPrecision = this._maxPointSize = this._minPointSize = 0;
        this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
        this._extensions = [];
        this._isInitialisingAfterContextRestored = !1;
        this._textureLodExt = this._stdDerivativesExt = this._fragDepthExt = this._depthTextureExt = this._anisotropicExt = this._parallelShaderCompileExt = null;
        this._maxAnisotropy = 0;
        this._isGpuProfilingEnabled = !!b.enableGpuProfiling;
        this._timerExt = null;
        this._allQueryResultBuffers = new Set;
        this._timeQueryStack = [];
        this.FillIndexBufferData(this._indexData)
    }
    IsWebGL() {
        return !0
    }
    async InitState() {
        super.InitState();
        var a = this._gl
          , b = this.GetNumVertexComponents();
        this._lastColor.setRgba(1, 1, 1, 1);
        this._lastTexture1 = this._lastTexture0 = null;
        this._pointPtr = this._vertexPtr = 0;
        this._lastVertexPtr = 8E3 * b - 4 * b;
        C3$jscomp$51.clearArray(this._batch);
        this._topOfBatch = this._batchPtr = 0;
        this._currentRenderTarget = this._lastProgram = null;
        this._lastPointTexCoords.set(0, 0, 1, 1);
        this._lastPointZ = 0;
        b = this._batchState;
        b.currentShader = null;
        b.currentFramebuffer = null;
        b.currentFramebufferNoDepth = null;
        vec4$jscomp$4.set(b.currentColor, 1, 1, 1, 1);
        b.clearColor.setRgba(0, 0, 0, 0);
        b.pointTexCoords.set(0, 0, 1, 1);
        a.clearColor(0, 0, 0, 0);
        a.clear(a.COLOR_BUFFER_BIT);
        a.enable(a.BLEND);
        a.blendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA);
        this._lastSrcBlend = a.ONE;
        this._lastDestBlend = a.ONE_MINUS_SRC_ALPHA;
        this._InitBlendModes(a);
        a.disable(a.CULL_FACE);
        a.disable(a.STENCIL_TEST);
        a.disable(a.DITHER);
        this._usesDepthBuffer ? (a.enable(a.DEPTH_TEST),
        a.depthMask(!0),
        a.depthFunc(a.LEQUAL)) : (a.disable(a.DEPTH_TEST),
        a.depthMask(!1));
        this._isDepthEnabled = this._usesDepthBuffer;
        this._isDepthSamplingEnabled = !1;
        this._pointBuffer = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._pointBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._pointData.byteLength, a.DYNAMIC_DRAW);
        this._vertexBuffer = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._vertexBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._vertexData.byteLength, a.DYNAMIC_DRAW);
        this._texcoordBuffer = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._texcoordBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._texcoordData.byteLength, a.DYNAMIC_DRAW);
        this._indexBuffer = a.createBuffer();
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indexData, a.STATIC_DRAW);
        a.activeTexture(a.TEXTURE0);
        a.bindTexture(a.TEXTURE_2D, null);
        this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
        b = a.getParameter(a.ALIASED_POINT_SIZE_RANGE);
        this._minPointSize = b[0];
        this._maxPointSize = b[1];
        b = a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT);
        var d = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT);
        this._highpPrecision = b && d ? Math.min(b.precision, d.precision) : 0;
        2048 < this._maxPointSize && (this._maxPointSize = 2048);
        this._extensions = a.getSupportedExtensions();
        if (b = a.getExtension("WEBGL_debug_renderer_info"))
            this._unmaskedVendor = a.getParameter(b.UNMASKED_VENDOR_WEBGL),
            this._unmaskedRenderer = a.getParameter(b.UNMASKED_RENDERER_WEBGL);
        this._parallelShaderCompileExt = a.getExtension("KHR_parallel_shader_compile");
        C3$jscomp$51.isDebug && (loseContextExtension = a.getExtension("WEBGL_lose_context"));
        if (this._isGpuProfilingEnabled)
            if (1 === this.GetWebGLVersionNumber()) {
                if ("Chromium" !== C3$jscomp$51.Platform.BrowserEngine || 81 <= C3$jscomp$51.Platform.BrowserVersionNumber || "undefined" !== typeof document)
                    this._timerExt = a.getExtension("EXT_disjoint_timer_query")
            } else
                this._timerExt = a.getExtension("EXT_disjoint_timer_query_webgl2") || a.getExtension("EXT_disjoint_timer_query");
        this._maxAnisotropy = (this._anisotropicExt = a.getExtension("EXT_texture_filter_anisotropic")) ? a.getParameter(this._anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        if (2 > this.GetWebGLVersionNumber() && this._usesDepthBuffer && this._canSampleDepth && (this._depthTextureExt = a.getExtension("WEBGL_depth_texture"),
        !this._depthTextureExt))
            throw Error("no depth texture support");
        2 > this.GetWebGLVersionNumber() && (this._fragDepthExt = a.getExtension("EXT_frag_depth"),
        this._stdDerivativesExt = a.getExtension("OES_standard_derivatives"),
        this._textureLodExt = a.getExtension("EXT_shader_texture_lod"));
        a = C3$jscomp$51.Gfx.WebGLShaderProgram;
        b = a.GetDefaultVertexShaderSource(!1);
        d = a.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth();
        let c = b
          , e = a.GetPointFragmentShaderSource_WebGL1_NoFragDepth()
          , g = a.GetPointVertexShaderSource_WebGL1()
          , k = a.GetTilemapFragmentShaderSource_WebGL1_NoFragDepth()
          , l = a.GetDefaultVertexShaderSource(!0);
        var n = !1;
        this._usesDepthBuffer && ("Safari" !== C3$jscomp$51.Platform.Browser || 15.5 <= C3$jscomp$51.Platform.BrowserVersionNumber) && (2 > this.GetWebGLVersionNumber() ? this._fragDepthExt && (d = a.GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT(),
        e = a.GetPointFragmentShaderSource_WebGL1_FragDepthEXT(),
        k = a.GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT(),
        n = !0) : (c = a.GetDefaultVertexShaderSource_WebGL2(),
        d = a.GetTextureFillFragmentShaderSource_WebGL2(),
        e = a.GetPointFragmentShaderSource_WebGL2(),
        g = a.GetPointVertexShaderSource_WebGL2(),
        k = a.GetTilemapFragmentShaderSource_WebGL2(),
        l = a.GetDefaultVertexShaderSource_WebGL2(!0)));
        n = a.GetTileRandomizationFragmentShaderSource(this.GetWebGLVersionNumber(), n, this._stdDerivativesExt && this._textureLodExt);
        const p = 2 <= this.GetWebGLVersionNumber() ? a.GetDefaultVertexShaderSource_WebGL2() : b;
        a = [[d, c, "<default>"], [d, c, "<default-device-transform>"], [e, g, "<point>"], [a.GetColorFillFragmentShaderSource(), b, "<fill>"], [a.GetLinearGradientFillFragmentShaderSource(), b, "<lineargradient>"], [a.GetPenumbraFillFragmentShaderSource(), b, "<penumbra>"], [a.GetHardEllipseFillFragmentShaderSource(), b, "<hardellipse>"], [a.GetHardEllipseOutlineFragmentShaderSource(), b, "<hardellipseoutline>"], [a.GetSmoothEllipseFillFragmentShaderSource(), b, "<smoothellipse>"], [a.GetSmoothEllipseOutlineFragmentShaderSource(), b, "<smoothellipseoutline>"], [a.GetSmoothLineFillFragmentShaderSource(), b, "<smoothline>"], [k, l, "<tilemap>"], [n, p, "<tilerandomization>"]];
        a = await Promise.all(a.map(t=>this.CreateShaderProgram({
            src: t[0],
            vertexSrc: t[1],
            name: t[2]
        })));
        this._spTextureFill = a[0];
        this._spDeviceTransformTextureFill = a[1];
        this._spPoints = a[2];
        this._spColorFill = a[3];
        this._spLinearGradientFill = a[4];
        this._spPenumbraFill = a[5];
        this._spHardEllipseFill = a[6];
        this._spHardEllipseOutline = a[7];
        this._spSmoothEllipseFill = a[8];
        this._spSmoothEllipseOutline = a[9];
        this._spSmoothLineFill = a[10];
        this._spTilemapFill = a[11];
        this._spTileRandomization = a[12];
        this.SetTextureFillMode()
    }
    async CreateShaderProgram(a) {
        a = await C3$jscomp$51.Gfx.WebGLShaderProgram.Create(this, a);
        this._AddShaderProgram(a);
        return a
    }
    ResetLastProgram() {
        this._lastProgram = null
    }
    SetSize(a, b, d) {
        if (this._width !== a || this._height !== b || d) {
            this.EndBatch();
            d = this._gl;
            var c = this._batchState;
            this._width = a;
            this._height = b;
            this._SetViewport(0, 0, a, b);
            this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, a / b);
            this.SetProjectionMatrix(this._bbProjectionMatrix);
            this._spDeviceTransformTextureFill && (d.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()),
            this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP),
            this._lastProgram = this._spDeviceTransformTextureFill,
            this._batchState.currentShader = this._spDeviceTransformTextureFill);
            d.bindTexture(d.TEXTURE_2D, null);
            d.activeTexture(d.TEXTURE1);
            d.bindTexture(d.TEXTURE_2D, null);
            d.activeTexture(d.TEXTURE0);
            this._lastTexture1 = this._lastTexture0 = null;
            this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height);
            this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height);
            d.bindFramebuffer(d.FRAMEBUFFER, null);
            this._currentRenderTarget = null;
            c.currentFramebuffer = null;
            c.currentFramebufferNoDepth = null
        }
    }
    _SetDepthBufferSize(a, b) {
        const d = this._gl;
        this._depthBuffer && this._depthBufferWidth === a && this._depthBufferHeight === b || (this._canSampleDepth ? (this._depthBuffer && d.deleteTexture(this._depthBuffer),
        this._depthBuffer = d.createTexture(),
        d.bindTexture(d.TEXTURE_2D, this._depthBuffer),
        d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.NEAREST),
        d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.NEAREST),
        d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE),
        d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE),
        2 <= this.GetWebGLVersionNumber() ? d.texImage2D(d.TEXTURE_2D, 0, d.DEPTH24_STENCIL8, a, b, 0, d.DEPTH_STENCIL, d.UNSIGNED_INT_24_8, null) : this._depthTextureExt && d.texImage2D(d.TEXTURE_2D, 0, d.DEPTH_STENCIL, a, b, 0, d.DEPTH_STENCIL, this._depthTextureExt.UNSIGNED_INT_24_8_WEBGL, null),
        d.bindTexture(d.TEXTURE_2D, null)) : (this._depthBuffer && d.deleteRenderbuffer(this._depthBuffer),
        this._depthBuffer = d.createRenderbuffer(),
        d.bindRenderbuffer(d.RENDERBUFFER, this._depthBuffer),
        d.renderbufferStorage(d.RENDERBUFFER, 2 <= this._version ? d.DEPTH24_STENCIL8 : d.DEPTH_STENCIL, a, b),
        d.bindRenderbuffer(d.RENDERBUFFER, null)),
        this._depthBufferWidth = a,
        this._depthBufferHeight = b)
    }
    SetFixedSizeDepthBuffer(a, b) {
        this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = !1,
        this._SetDepthBufferSize(a, b))
    }
    SetAutoSizeDepthBuffer() {
        this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = !0,
        this._SetDepthBufferSize(this._width, this._height))
    }
    _SetViewport(a, b, d, c) {
        const e = this._viewport;
        if (e[0] !== a || e[1] !== b || e[2] !== d || e[3] !== c)
            this.PushBatch().InitSetViewport(a, b, d, c),
            vec4$jscomp$4.set(e, a, b, d, c),
            this._topOfBatch = 0
    }
    SetFovY(a) {
        super.SetFovY(a);
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height)
    }
    SetNearZ(a) {
        super.SetNearZ(a);
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height)
    }
    SetFarZ(a) {
        super.SetFarZ(a);
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height)
    }
    SetProjectionMatrix(a) {
        mat4$jscomp$7.exactEquals(this._matP, a) || (this.PushBatch().InitSetProjection(a),
        mat4$jscomp$7.copy(this._matP, a),
        this._topOfBatch = 0,
        this._didChangeTransform = !0)
    }
    SetDefaultRenderTargetProjectionState() {
        let a, b;
        var d = this._currentRenderTarget;
        null === d ? (a = this._bbProjectionMatrix,
        b = this.GetWidth(),
        d = this.GetHeight()) : (a = d.GetProjectionMatrix(),
        b = d.GetWidth(),
        d = d.GetHeight());
        this.SetProjectionMatrix(a);
        this._SetViewport(0, 0, b, d)
    }
    SetModelViewMatrix(a) {
        mat4$jscomp$7.exactEquals(this._matMV, a) || (this.PushBatch().InitSetModelView(a),
        mat4$jscomp$7.copy(this._matMV, a),
        this._topOfBatch = 0,
        this._didChangeTransform = !0)
    }
    ResetDidChangeTransformFlag() {
        this._didChangeTransform = !1
    }
    DidChangeTransform() {
        return this._didChangeTransform
    }
    GetBatchState() {
        return this._batchState
    }
    PushBatch() {
        const a = this._batch;
        this._batchPtr === a.length && a.push(new C3$jscomp$51.Gfx.WebGLBatchJob(this._batchState));
        return a[this._batchPtr++]
    }
    EndBatch() {
        0 === this._batchPtr || this.IsContextLost() || (this._WriteBuffers(),
        this._ExecuteBatch(),
        this._topOfBatch = this._pointPtr = this._texPtr = this._vertexPtr = this._batchPtr = 0)
    }
    _WriteBuffers() {
        const a = this._gl;
        0 < this._pointPtr && (a.bindBuffer(a.ARRAY_BUFFER, this._pointBuffer),
        a.bufferSubData(a.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr)));
        0 < this._vertexPtr && (a.bindBuffer(a.ARRAY_BUFFER, this._vertexBuffer),
        a.bufferSubData(a.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)),
        a.bindBuffer(a.ARRAY_BUFFER, this._texcoordBuffer),
        a.bufferSubData(a.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)))
    }
    _ExecuteBatch() {
        const a = this._batch;
        for (let b = 0, d = this._batchPtr; b < d; ++b)
            a[b].Run()
    }
    GetOpacity() {
        return this._lastColor.getA()
    }
    SetColorRgba(a, b, d, c) {
        const e = this._lastColor;
        e.equalsRgba(a, b, d, c) || (e.setRgba(a, b, d, c),
        this.PushBatch().InitSetColor(e),
        this._topOfBatch = 0,
        this._currentStateGroup = null)
    }
    SetOpacity(a) {
        const b = this._lastColor;
        b.getA() !== a && (b.setA(a),
        this.PushBatch().InitSetColor(b),
        this._topOfBatch = 0,
        this._currentStateGroup = null)
    }
    SetColor(a) {
        const b = this._lastColor;
        b.equals(a) || (b.set(a),
        this.PushBatch().InitSetColor(b),
        this._topOfBatch = 0,
        this._currentStateGroup = null)
    }
    ResetColor() {
        this.SetColorRgba(1, 1, 1, 1)
    }
    GetColor() {
        return this._lastColor
    }
    SetTexture(a) {
        a !== this._lastTexture0 && (this.PushBatch().InitSetTexture(a),
        this._lastTexture0 = a,
        this._topOfBatch = 0)
    }
    _ResetLastTexture() {
        this._lastTexture0 = null
    }
    SetBlendMode(a) {
        a = this._GetBlendByIndex(a);
        this._SetBlend(a[0], a[1])
    }
    SetNamedBlendMode(a) {
        a = this.GetNamedBlend(a);
        this._SetBlend(a.srcBlend, a.destBlend)
    }
    _SetBlend(a, b) {
        if (a !== this._lastSrcBlend || b !== this._lastDestBlend)
            this.PushBatch().InitSetBlend(a, b),
            this._lastSrcBlend = a,
            this._lastDestBlend = b,
            this._topOfBatch = 0,
            this._currentStateGroup = null
    }
    IsPremultipliedAlphaBlend() {
        return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA
    }
    SetAlphaBlend() {
        this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)
    }
    SetNoPremultiplyAlphaBlend() {
        this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA)
    }
    SetCopyBlend() {
        this._SetBlend(this._gl.ONE, this._gl.ZERO)
    }
    Rect(a) {
        this.Rect2(a.getLeft(), a.getTop(), a.getRight(), a.getBottom())
    }
    Rect2(a, b, d, c) {
        this.Quad2(a, b, d, b, d, c, a, c)
    }
    _ExtendQuadBatch() {
        let a = this._vertexPtr;
        a >= this._lastVertexPtr && (this.EndBatch(),
        a = 0);
        1 === this._topOfBatch ? this._batch[this._batchPtr - 1]._indexCount += 6 : (this.PushBatch().InitQuad(a, 6),
        this._topOfBatch = 1)
    }
    _WriteQuadToVertexBuffer(a) {
        a.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ);
        this._vertexPtr += 12
    }
    Quad(a) {
        this._ExtendQuadBatch();
        this._WriteQuadToVertexBuffer(a);
        defaultTexCoordsQuad$jscomp$1.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad2(a, b, d, c, e, g, k, l) {
        this._ExtendQuadBatch();
        const n = this._vertexData;
        let p = this._vertexPtr;
        const t = this._baseZ + this._currentZ;
        n[p++] = a;
        n[p++] = b;
        n[p++] = t;
        n[p++] = d;
        n[p++] = c;
        n[p++] = t;
        n[p++] = e;
        n[p++] = g;
        n[p++] = t;
        n[p++] = k;
        n[p++] = l;
        n[p++] = t;
        this._vertexPtr = p;
        defaultTexCoordsQuad$jscomp$1.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad3(a, b) {
        this._ExtendQuadBatch();
        this._WriteQuadToVertexBuffer(a);
        b.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad4(a, b) {
        this._ExtendQuadBatch();
        this._WriteQuadToVertexBuffer(a);
        b.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad3D(a, b, d, c, e, g, k, l, n, p, t, w, z) {
        this._ExtendQuadBatch();
        const B = this._vertexData;
        let C = this._vertexPtr;
        const E = this._baseZ + this._currentZ;
        B[C++] = a;
        B[C++] = b;
        B[C++] = E + d;
        B[C++] = c;
        B[C++] = e;
        B[C++] = E + g;
        B[C++] = k;
        B[C++] = l;
        B[C++] = E + n;
        B[C++] = p;
        B[C++] = t;
        B[C++] = E + w;
        this._vertexPtr = C;
        z.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad3D2(a, b, d, c, e, g, k, l, n, p, t, w, z) {
        this._ExtendQuadBatch();
        const B = this._vertexData;
        let C = this._vertexPtr;
        const E = this._baseZ + this._currentZ;
        B[C++] = a;
        B[C++] = b;
        B[C++] = E + d;
        B[C++] = c;
        B[C++] = e;
        B[C++] = E + g;
        B[C++] = k;
        B[C++] = l;
        B[C++] = E + n;
        B[C++] = p;
        B[C++] = t;
        B[C++] = E + w;
        this._vertexPtr = C;
        z.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    FullscreenQuad(a, b) {
        mat4$jscomp$7.copy(tmpProjection, this._matP);
        mat4$jscomp$7.copy(tmpModelView, this._matMV);
        this.SetDefaultRenderTargetProjectionState();
        const [d,c] = this.GetRenderTargetSize(this._currentRenderTarget);
        var e = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ(c), 0, 0, 0, c);
        this.SetModelViewMatrix(e);
        if ("crop" === a && this._currentRenderTarget && b) {
            a = this._width / 2;
            e = this._height / 2;
            const l = b.GetWidth();
            b = b.GetHeight();
            var g = this._currentRenderTarget.GetWidth()
              , k = this._currentRenderTarget.GetHeight();
            g = Math.min(g, l);
            const n = Math.min(k, b)
              , p = Math.max(b - k, 0);
            k = Math.max(k - b, 0);
            tmpRect$jscomp$1.set(-a, e - k, -a + g, e - n - k);
            tmpQuad$jscomp$1.setFromRect(tmpRect$jscomp$1);
            tmpRect$jscomp$1.set(0, p, g, n + p);
            tmpRect$jscomp$1.divide(l, b);
            this.Quad3(tmpQuad$jscomp$1, tmpRect$jscomp$1)
        } else
            a = d / 2,
            e = c / 2,
            this.Rect2(-a, e, a, -e);
        this.SetProjectionMatrix(tmpProjection);
        this.SetModelViewMatrix(tmpModelView)
    }
    StartRenderingPoints(a) {
        this._lastPointTexCoords.equals(a) || (this._lastPointTexCoords.copy(a),
        this.PushBatch().InitSetPointTexCoords(a),
        this._topOfBatch = 0)
    }
    FinishRenderingPoints() {}
    Point(a, b, d, c) {
        this._pointPtr >= LAST_POINT && this.EndBatch();
        let e = this._pointPtr;
        var g = this._baseZ + this._currentZ;
        2 === this._topOfBatch && this._lastPointZ === g ? this._batch[this._batchPtr - 1]._indexCount++ : (this.PushBatch().InitPoints(e, g),
        this._topOfBatch = 2,
        this._lastPointZ = g);
        g = this._pointData;
        g[e++] = a;
        g[e++] = b;
        g[e++] = d;
        g[e++] = c;
        this._pointPtr = e
    }
    SetProgram(a) {
        this._lastProgram !== a && (this.PushBatch().InitSetProgram(a),
        this._lastProgram = a,
        this._topOfBatch = 0,
        this._currentStateGroup = null)
    }
    SetDeviceTransformTextureFillMode() {
        this.SetProgram(this._spDeviceTransformTextureFill)
    }
    SetGradientColor(a) {
        this.PushBatch().InitSetGradientColor(a);
        this._topOfBatch = 0
    }
    SetEllipseParams(a, b, d=1) {
        this.PushBatch().InitSetEllipseParams(a, b, d);
        this._topOfBatch = 0
    }
    SetTilemapInfo(a, b, d, c, e, g, k) {
        if (this._lastProgram !== this._spTilemapFill)
            throw Error("must set tilemap fill mode first");
        this.PushBatch().InitSetTilemapInfo(a, b, d, c, e, g, k);
        this._topOfBatch = 0
    }
    SetTileRandomizationInfo(a, b, d, c, e, g, k) {
        if (this._lastProgram !== this._spTileRandomization)
            throw Error("must set tile randomization mode first");
        this.PushBatch().InitSetTileRandomizationInfo(a, b, d, c, e, g, k);
        this._topOfBatch = 0
    }
    SetProgramParameters(a, b, d, c, e, g, k, l, n, p, t) {
        const w = this._lastProgram;
        t %= 10800;
        if (w._hasAnyOptionalUniforms && !w.AreOptionalUniformsAlreadySetInBatch(b, d, c, e, g, k, l, n, p, t)) {
            var z = this.PushBatch();
            z.InitSetProgramParameters();
            w.SetOptionalUniformsInBatch(b, d, c, e, g, k, l, n, p, t);
            var B = z._mat4param;
            B[0] = g;
            B[1] = k;
            b.writeToTypedArray(B, 2);
            B[6] = n;
            B[7] = p;
            d.writeToTypedArray(B, 12);
            b = z._colorParam;
            e.writeToTypedArray(b, 0);
            e = b[1];
            b[1] = b[3];
            b[3] = e;
            c.writeToTypedArray(z._srcOriginRect, 0);
            z._startIndex = t;
            z._indexCount = l;
            w._uSamplerBack.IsUsed() ? z._texParam = a ? a.GetTexture() : null : z._texParam = null;
            this._topOfBatch = 0
        }
    }
    SetProgramCustomParameters(a) {
        const b = this._lastProgram;
        if (0 !== a.length && !b.AreCustomParametersAlreadySetInBatch(a)) {
            var d = this.PushBatch();
            d.InitSetProgramCustomParameters();
            b.SetCustomParametersInBatch(a);
            C3$jscomp$51.shallowAssignArray(d._shaderParams, a);
            this._topOfBatch = 0
        }
    }
    ClearRgba(a, b, d, c) {
        this.PushBatch().InitClearSurface2(a, b, d, c);
        this._topOfBatch = 0
    }
    Clear(a) {
        this.PushBatch().InitClearSurface(a);
        this._topOfBatch = 0
    }
    Start() {}
    Finish() {
        super.Finish();
        this._gl.flush()
    }
    ClearDepth() {
        this._usesDepthBuffer && this._currentRenderTarget && this._currentRenderTarget.HasDepthBuffer() && (this.PushBatch().InitClearDepth(this._isDepthEnabled),
        this._topOfBatch = 0)
    }
    SetDepthEnabled(a) {
        a = !!a;
        this._isDepthEnabled !== a && this._usesDepthBuffer && (this._isDepthEnabled = a,
        this.PushBatch().InitSetDepthEnabled(a),
        this._topOfBatch = 0)
    }
    IsDepthEnabled() {
        return this._isDepthEnabled
    }
    _GetDepthBuffer() {
        return this._depthBuffer
    }
    _CanSampleDepth() {
        return this._canSampleDepth
    }
    SetDepthSamplingEnabled(a) {
        a = !!a;
        if (this._canSampleDepth && this._isDepthSamplingEnabled !== a) {
            if (a && this.IsDepthEnabled())
                throw Error("depth still enabled");
            this._isDepthSamplingEnabled = a;
            this.PushBatch().InitSetDepthSamplingEnabled(a);
            this._topOfBatch = 0
        }
    }
    SetScissorRect(a, b, d, c, e=0) {
        a = Math.floor(a);
        b = Math.floor(b);
        d = Math.floor(d);
        c = Math.floor(c);
        this._lastScissorRect.equalsWH(a, b, d, c) || (this._lastScissorRect.setWH(a, b, d, c),
        b = (e || this.GetRenderTargetSize(this.GetRenderTarget())[1]) - b - c,
        this.PushBatch().InitSetScissor(!0, a, b, d, c),
        this._topOfBatch = 0)
    }
    RemoveScissorRect() {
        -1 !== this._lastScissorRect.getRight() && (this._lastScissorRect.set(0, 0, -1, -1),
        this.PushBatch().InitSetScissor(!1, 0, 0, 0, 0),
        this._topOfBatch = 0)
    }
    CheckForQueryResults() {
        for (const a of this._allQueryResultBuffers)
            a.CheckForResults(this._frameNumber)
    }
    IsContextLost() {
        return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored
    }
    OnContextLost() {
        super.OnDeviceOrContextLost();
        C3$jscomp$51.Gfx.WebGLRendererTexture.OnContextLost();
        C3$jscomp$51.Gfx.WebGLRenderTarget.OnContextLost();
        C3$jscomp$51.Gfx.RendererText.OnContextLost();
        for (const a of this._allQueryResultBuffers)
            a.Clear();
        this._extensions = [];
        this._textureLodExt = this._stdDerivativesExt = this._fragDepthExt = this._depthTextureExt = this._anisotropicExt = this._parallelShaderCompileExt = this._timerExt = null;
        this._maxAnisotropy = 0;
        this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
        this._depthBuffer = this._spDeviceTransformTextureFill = this._lastProgram = null;
        for (const a of this._stateGroups.values())
            a.OnContextLost()
    }
    async OnContextRestored() {
        this._isInitialisingAfterContextRestored = !0;
        await this.InitState();
        this._isInitialisingAfterContextRestored = !1;
        for (const a of this._stateGroups.values())
            a.OnContextRestored(this);
        this.SetSize(this._width, this._height, !0)
    }
    CreateStaticTexture(a, b) {
        if (this.IsContextLost())
            throw Error("context lost");
        this.EndBatch();
        const d = C3$jscomp$51.New(C3$jscomp$51.Gfx.WebGLRendererTexture, this);
        d._CreateStatic(a, b);
        return d
    }
    async CreateStaticTextureAsync(a, b) {
        if (this.IsContextLost())
            throw Error("context lost");
        b = Object.assign({}, b);
        if (!C3$jscomp$51.Supports.ImageBitmapOptions || "Safari" === C3$jscomp$51.Platform.Browser && a instanceof ImageData && "undefined" !== typeof Image) {
            if (a instanceof Blob) {
                if ("undefined" === typeof Image)
                    throw Error("texture upload variant not supported in worker");
                a = await C3$jscomp$51.BlobToImage(a)
            }
            return await C3$jscomp$51.Asyncify(()=>this.CreateStaticTexture(a, b))
        }
        let d = await createImageBitmap(a, {
            premultiplyAlpha: "premultiply"
        });
        const c = b.wrapX && "clamp-to-edge" !== b.wrapX || b.wrapY && "clamp-to-edge" !== b.wrapY
          , e = C3$jscomp$51.isPOT(d.width) && C3$jscomp$51.isPOT(d.height);
        this.SupportsNPOTTextures() || e || !c ? b.premultiplyAlpha = !1 : C3$jscomp$51.Supports.ImageBitmapOptionsResize ? (d = await createImageBitmap(a, {
            premultiplyAlpha: "premultiply",
            resizeWidth: C3$jscomp$51.nextHighestPowerOfTwo(d.width),
            resizeHeight: C3$jscomp$51.nextHighestPowerOfTwo(d.height)
        }),
        b.premultiplyAlpha = !1) : d = await createImageBitmap(a, {
            premultiplyAlpha: "none"
        });
        return await C3$jscomp$51.Asyncify(()=>this.CreateStaticTexture(d, b))
    }
    CreateDynamicTexture(a, b, d) {
        this.EndBatch();
        const c = C3$jscomp$51.New(C3$jscomp$51.Gfx.WebGLRendererTexture, this);
        c._CreateDynamic(a, b, d);
        return c
    }
    UpdateTexture(a, b, d) {
        this.EndBatch();
        b._Update(a, d)
    }
    DeleteTexture(a) {
        a && (a.SubtractReference(),
        0 < a.GetReferenceCount() || (this.EndBatch(),
        a === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null),
        this._lastTexture0 = null),
        a === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1),
        this._gl.bindTexture(this._gl.TEXTURE_2D, null),
        this._gl.activeTexture(this._gl.TEXTURE0),
        this._lastTexture1 = null),
        a._Delete()))
    }
    CreateRenderTarget(a) {
        let b = this._width
          , d = this._height
          , c = !0;
        a && ("number" === typeof a.width && (b = a.width,
        c = !1),
        "number" === typeof a.height && (d = a.height,
        c = !1));
        if (0 >= b || 0 >= d)
            throw Error("invalid size");
        this.EndBatch();
        const e = C3$jscomp$51.New(C3$jscomp$51.Gfx.WebGLRenderTarget, this);
        e._Create(b, d, Object.assign({
            isDefaultSize: c
        }, a));
        this._currentRenderTarget = null;
        this._batchState.currentFramebuffer = null;
        this._batchState.currentFramebufferNoDepth = null;
        return e
    }
    SetRenderTarget(a, b=!0) {
        a !== this._currentRenderTarget && (a && a.IsDefaultSize() && a._Resize(this._width, this._height),
        this.PushBatch().InitSetRenderTarget(a),
        this._currentRenderTarget = a,
        this._topOfBatch = 0,
        b && this.SetDefaultRenderTargetProjectionState())
    }
    GetRenderTarget() {
        return this._currentRenderTarget
    }
    GetRenderTargetSize(a) {
        return a ? [a.GetWidth(), a.GetHeight()] : [this._width, this._height]
    }
    CopyRenderTarget(a, b="stretch") {
        2 > this._version || this._currentRenderTarget && 0 < this._currentRenderTarget.GetMultisampling() ? (this.SetCopyBlend(),
        this.ResetColor(),
        this.DrawRenderTarget(a, b)) : (this.PushBatch().InitBlitFramebuffer(a, this._currentRenderTarget, b),
        this._topOfBatch = 0)
    }
    DrawRenderTarget(a, b="stretch") {
        a = a.GetTexture();
        if (!a)
            throw Error("not a texture-backed render target");
        this.SetTexture(a);
        this.FullscreenQuad(b, a)
    }
    InvalidateRenderTarget(a) {
        2 > this._version || (this.PushBatch().InitInvalidateFramebuffer(a._GetFramebuffer()),
        this._topOfBatch = 0)
    }
    DeleteRenderTarget(a) {
        this.SetRenderTarget(null);
        this.EndBatch();
        const b = a.GetTexture();
        b === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null),
        this._lastTexture0 = null);
        b === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1),
        this._gl.bindTexture(this._gl.TEXTURE_2D, null),
        this._gl.activeTexture(this._gl.TEXTURE0),
        this._lastTexture1 = null);
        a._Delete()
    }
    async ReadBackRenderTargetToImageData(a, b, d) {
        this.EndBatch();
        const c = this._currentRenderTarget;
        if (a) {
            var e = a.GetWidth();
            var g = a.GetHeight();
            var k = a._GetFramebuffer()
        } else
            e = this.GetWidth(),
            g = this.GetHeight(),
            k = null;
        let l = a = 0;
        var n = e
          , p = g;
        d && (a = C3$jscomp$51.clamp(Math.floor(d.getLeft()), 0, e - 1),
        l = C3$jscomp$51.clamp(Math.floor(d.getTop()), 0, g - 1),
        n = d.width(),
        n = 0 === n ? e - a : C3$jscomp$51.clamp(Math.floor(n), 0, e - a),
        p = d.height(),
        p = 0 === p ? g - l : C3$jscomp$51.clamp(Math.floor(p), 0, g - l),
        l = g - (l + p));
        const t = this._gl;
        t.bindFramebuffer(t.FRAMEBUFFER, k);
        g = ()=>{
            t.bindFramebuffer(t.FRAMEBUFFER, null);
            this._currentRenderTarget = null;
            this._batchState.currentFramebuffer = null;
            this._batchState.currentFramebufferNoDepth = null;
            this.SetRenderTarget(c)
        }
        ;
        if (!b && 2 <= this.GetWebGLVersionNumber()) {
            t.bindFramebuffer(t.READ_FRAMEBUFFER, k);
            k = t.createBuffer();
            d = n * p * 4;
            e = t.PIXEL_PACK_BUFFER;
            t.bindBuffer(e, k);
            t.bufferData(e, d, t.STREAM_READ);
            t.readPixels(a, l, n, p, t.RGBA, t.UNSIGNED_BYTE, 0);
            t.bindFramebuffer(t.READ_FRAMEBUFFER, null);
            t.bindBuffer(e, null);
            g();
            const w = t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE, 0);
            await this._WaitForObjectReady(()=>t.getSyncParameter(w, t.SYNC_STATUS) === t.SIGNALED);
            t.deleteSync(w);
            b = new ImageData(n,p);
            t.bindBuffer(e, k);
            t.getBufferSubData(e, 0, new Uint8Array(b.data.buffer), 0, d);
            t.bindBuffer(e, null);
            t.deleteBuffer(k)
        } else
            b = new ImageData(n,p),
            t.readPixels(a, l, n, p, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(b.data.buffer)),
            g();
        return b
    }
    CoplanarStartStencilPass() {
        this.SetDepthEnabled(!0);
        this.PushBatch().InitCoplanarStartStencilPass();
        this._topOfBatch = 0
    }
    CoplanarStartColorPass() {
        this.SetDepthEnabled(!1);
        this.PushBatch().InitCoplanarStartColorPass();
        this._topOfBatch = 0
    }
    CoplanarRestoreStandardRendering() {
        this.SetDepthEnabled(!0);
        this.PushBatch().InitCoplanarRestore();
        this._topOfBatch = 0
    }
    StartQuery(a) {
        this.SupportsGPUProfiling() && (this.PushBatch().InitStartQuery(a),
        this._topOfBatch = 0)
    }
    EndQuery(a) {
        this.SupportsGPUProfiling() && (this.PushBatch().InitEndQuery(a),
        this._topOfBatch = 0)
    }
    _WaitForObjectReady(a) {
        const b = new Promise(d=>pendingPolls.add({
            resolve: d,
            checkFunc: a
        }));
        -1 === pollRafId && (pollRafId = self.requestAnimationFrame(CheckPendingPolls));
        return b
    }
    IsDesynchronized() {
        return !!this._attribs.desynchronized
    }
    GetEstimatedBackBufferMemoryUsage() {
        return this._width * this._height * (this._attribs.alpha ? 4 : 3)
    }
    GetEstimatedRenderBufferMemoryUsage() {
        let a = 0;
        for (const b of C3$jscomp$51.Gfx.WebGLRenderTarget.allRenderTargets())
            b.GetTexture() || (a += b.GetEstimatedMemoryUsage());
        return a
    }
    GetEstimatedTextureMemoryUsage() {
        let a = 0;
        for (const b of C3$jscomp$51.Gfx.WebGLRendererTexture.allTextures())
            a += b.GetEstimatedMemoryUsage();
        return a
    }
    GetEstimatedTotalMemoryUsage() {
        return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage()
    }
    GetWebGLVersionString() {
        return this._versionString
    }
    GetWebGLVersionNumber() {
        return this._version
    }
    GetDisplayName() {
        return "webgl" + this.GetWebGLVersionNumber()
    }
    SupportsNPOTTextures() {
        return 2 <= this.GetWebGLVersionNumber()
    }
    GetMaxTextureSize() {
        return this._maxTextureSize
    }
    GetMinPointSize() {
        return this._minPointSize
    }
    GetMaxPointSize() {
        return this._maxPointSize
    }
    SupportsHighP() {
        return 0 !== this._highpPrecision
    }
    GetHighPPrecision() {
        return this._highpPrecision
    }
    GetUnmaskedVendor() {
        return this._unmaskedVendor
    }
    GetUnmaskedRenderer() {
        return this._unmaskedRenderer
    }
    GetWebGLExtensionsAnalyticsString() {
        if (2 <= this.GetWebGLVersionNumber())
            return "webgl2";
        const a = [];
        this._fragDepthExt && a.push("EXT_frag_depth");
        this._stdDerivativesExt && a.push("OES_standard_derivatives");
        this._textureLodExt && a.push("EXT_shader_texture_lod");
        return 0 < a.length ? "webgl1:" + a.join(",") : "webgl1:none"
    }
    GetExtensions() {
        return this._extensions
    }
    SupportsGPUProfiling() {
        return !!this._timerExt
    }
    _GetDisjointTimerQueryExtension() {
        return this._timerExt
    }
    _GetParallelShaderCompileExtension() {
        return this._parallelShaderCompileExt
    }
    _GetAnisotropicExtension() {
        return this._anisotropicExt
    }
    _GetMaxAnisotropy() {
        return this._maxAnisotropy
    }
    _AddQueryResultBuffer(a) {
        this._allQueryResultBuffers.add(a)
    }
    _RemoveQueryResultBuffer(a) {
        this._allQueryResultBuffers.delete(a)
    }
    _GetTimeQueryStack() {
        return this._timeQueryStack
    }
    GetContext() {
        return this._gl
    }
    _InitBlendModes(a) {
        this._InitBlendModeData([["normal", a.ONE, a.ONE_MINUS_SRC_ALPHA], ["additive", a.ONE, a.ONE], ["xor", a.ONE, a.ONE_MINUS_SRC_ALPHA], ["copy", a.ONE, a.ZERO], ["destination-over", a.ONE_MINUS_DST_ALPHA, a.ONE], ["source-in", a.DST_ALPHA, a.ZERO], ["destination-in", a.ZERO, a.SRC_ALPHA], ["source-out", a.ONE_MINUS_DST_ALPHA, a.ZERO], ["destination-out", a.ZERO, a.ONE_MINUS_SRC_ALPHA], ["source-atop", a.DST_ALPHA, a.ONE_MINUS_SRC_ALPHA], ["destination-atop", a.ONE_MINUS_DST_ALPHA, a.SRC_ALPHA]])
    }
    CreateRendererText() {
        return C3$jscomp$51.New(C3$jscomp$51.Gfx.RendererText, this)
    }
    CreateWebGLText() {
        return this.CreateRendererText()
    }
}
;
"use strict";
const DEFAULT_CTOR_OPTS = {
    getDrawSize: null,
    getRenderTarget: null,
    releaseRenderTarget: null,
    getTime: null,
    redraw: null
};
self.C3.Gfx.EffectChainManager = class {
    constructor(a) {
        a = Object.assign({}, DEFAULT_CTOR_OPTS, a);
        this._cbGetDrawSize = a.getDrawSize;
        this._cbGetRenderTarget = a.getRenderTarget;
        this._cbReleaseRenderTarget = a.releaseRenderTarget;
        this._cbGetTime = a.getTime;
        this._cbRedraw = a.redraw;
        this._webgpuBackTexture = null;
        this._allEffectChains = new Set
    }
    _AddEffectChain(a) {
        this._allEffectChains.add(a)
    }
    _RemoveEffectChain(a) {
        this._allEffectChains.delete(a)
    }
    OnContextLost() {
        this._webgpuBackTexture = null;
        for (const a of this._allEffectChains)
            a.OnContextLost()
    }
    GetDrawSize(a) {
        return this._cbGetDrawSize ? this._cbGetDrawSize(a) : [a.GetWidth(), a.GetHeight()]
    }
    GetRenderTarget(a) {
        return this._cbGetRenderTarget(a)
    }
    ReleaseRenderTarget(a, b) {
        this._cbReleaseRenderTarget(a, b)
    }
    GetTime() {
        return this._cbGetTime()
    }
    Redraw(a) {
        this._cbRedraw(a)
    }
    _GetWebGPUBackTexture(a, b, d) {
        !this._webgpuBackTexture || this._webgpuBackTexture.GetWidth() === b && this._webgpuBackTexture.GetHeight() === d || (a.DeleteTexture(this._webgpuBackTexture),
        this._webgpuBackTexture = null);
        null === this._webgpuBackTexture && (this._webgpuBackTexture = a.CreateStaticTexture(null, {
            width: b,
            height: d,
            sampling: "nearest",
            mipMap: !1
        }));
        return this._webgpuBackTexture
    }
}
;
"use strict";
const C3$jscomp$53 = self.C3
  , mat4$jscomp$8 = self.glMatrix.mat4
  , tempRect = C3$jscomp$53.New(C3$jscomp$53.Rect)
  , tempRect2 = C3$jscomp$53.New(C3$jscomp$53.Rect)
  , tempRect3 = C3$jscomp$53.New(C3$jscomp$53.Rect)
  , tempRect4 = C3$jscomp$53.New(C3$jscomp$53.Rect)
  , tempMat4a = mat4$jscomp$8.create()
  , tempMat4b$jscomp$1 = mat4$jscomp$8.create()
  , DEFAULT_CTOR_OPTS$jscomp$1 = {
    drawContent: null,
    getSourceTextureInfo: null,
    getShaderParameters: null,
    invalidateRenderTargets: !1
}
  , DEFAULT_BUILDSTEPS_OPTS = {
    indexMap: null,
    forcePreDraw: !1,
    forcePostDraw: !1,
    is3D: !1,
    isSourceTextureRotated: !1,
    isRotatedOrNegativeSizeInstance: !1,
    useFullSurface: !1
};
C3$jscomp$53.Gfx.EffectChain = class {
    constructor(a, b) {
        b = Object.assign({}, DEFAULT_CTOR_OPTS$jscomp$1, b);
        this._manager = a;
        this._cbDrawContent = b.drawContent;
        this._cbGetSourceTextureInfo = b.getSourceTextureInfo;
        this._cbGetShaderParameters = b.getShaderParameters;
        this._cbDrawContentHook = null;
        this._shaderProgramList = [];
        this._shaderProgramIndices = [];
        this._steps = [];
        this._needsRebuild = !1;
        this._blendMode = 0;
        this._isSourceTextureRotated = this._useFullSurface = this._canUseFastPath = this._depthEnabledAtStart = this._didChangeTransform = this._useCopyTextureBackgroundSampling = this._isAnyIsSrcTexRotated = this._isAnyShaderCrossSampling = this._isAnyShaderBackgroundBlending = this._isAnyShaderDepthSampling = this._isAnyShaderAnimated = !1;
        this._numTempSurfacesRequired = 0;
        this._renderTargets = [null, null, null];
        this._invalidateRenderTargets = !!b.invalidateRenderTargets;
        this._drawHeight = this._drawWidth = this._boxExtendVertical = this._boxExtendHorizontal = 0;
        this._contextObject = this._contentObject = null;
        this._layoutRect = C3$jscomp$53.New(C3$jscomp$53.Rect);
        this._drawSurfaceRect = C3$jscomp$53.New(C3$jscomp$53.Rect);
        this._rcTexOriginal = C3$jscomp$53.New(C3$jscomp$53.Rect);
        this._rcTexBounce = C3$jscomp$53.New(C3$jscomp$53.Rect);
        this._rcTexDest = C3$jscomp$53.New(C3$jscomp$53.Rect);
        this._layerScale = this._devicePixelRatio = 1;
        this._time = this._layerAngle = 0;
        this._backTex = this._destRenderTarget = null;
        this._compositOffY = this._compositOffX = 0;
        this._updateOwnProjection = !1;
        this._projectionMatrix = mat4$jscomp$8.create();
        this._modelViewMatrix = mat4$jscomp$8.create();
        this._manager._AddEffectChain(this)
    }
    Release() {
        this._manager._RemoveEffectChain(this);
        C3$jscomp$53.clearArray(this._steps);
        C3$jscomp$53.clearArray(this._shaderProgramList);
        C3$jscomp$53.clearArray(this._shaderProgramIndices);
        this._cbGetShaderParameters = this._cbGetSourceTextureInfo = this._cbDrawContent = this._contextObject = this._contentObject = null
    }
    OnContextLost() {
        this._needsRebuild = !0;
        C3$jscomp$53.clearArray(this._steps);
        C3$jscomp$53.clearArray(this._shaderProgramList);
        C3$jscomp$53.clearArray(this._shaderProgramIndices)
    }
    NeedsRebuild() {
        return this._needsRebuild
    }
    BuildSteps(a, b) {
        b = Object.assign({}, DEFAULT_BUILDSTEPS_OPTS, b);
        C3$jscomp$53.clearArray(this._steps);
        this._boxExtendVertical = this._boxExtendHorizontal = 0;
        this._useCopyTextureBackgroundSampling = this._isAnyIsSrcTexRotated = this._isAnyShaderCrossSampling = this._isAnyShaderBackgroundBlending = this._isAnyShaderDepthSampling = this._isAnyShaderAnimated = !1;
        this._numTempSurfacesRequired = 0;
        this._isSourceTextureRotated = !!b.isSourceTextureRotated;
        this._useFullSurface = !!b.useFullSurface;
        this._needsRebuild = !1;
        C3$jscomp$53.shallowAssignArray(this._shaderProgramList, a);
        if (0 !== a.length) {
            if (b.indexMap) {
                if (b.indexMap.length !== a.length)
                    throw Error("incorrect indexMap length");
                C3$jscomp$53.shallowAssignArray(this._shaderProgramIndices, b.indexMap)
            } else {
                C3$jscomp$53.clearArray(this._shaderProgramIndices);
                for (let e = 0, g = a.length; e < g; ++e)
                    this._shaderProgramIndices.push(e)
            }
            for (var d of a)
                this._boxExtendHorizontal += d.GetBoxExtendHorizontal(),
                this._boxExtendVertical += d.GetBoxExtendVertical(),
                d.IsAnimated() && (this._isAnyShaderAnimated = !0),
                d.UsesDepth() && (this._isAnyShaderDepthSampling = !0),
                d.BlendsBackground() && (this._isAnyShaderBackgroundBlending = !0),
                d.UsesCrossSampling() && (this._isAnyShaderCrossSampling = !0),
                d.UsesIsSrcTexRotated() && (this._isAnyIsSrcTexRotated = !0);
            this._useCopyTextureBackgroundSampling = this._ShouldUseCopyTextureBackgroundSampling(a[0].GetRenderer());
            d = this._ShouldPreDraw(a[0], b);
            b = this._ShouldPostDraw(a.at(-1), b);
            if (1 !== a.length || d || b) {
                this._canUseFastPath = !1;
                var c = 0;
                d && (this._numTempSurfacesRequired = 1,
                this._steps.push(C3$jscomp$53.New(C3$jscomp$53.Gfx.EffectChain.Step.PreDraw, this, -1, 1)),
                c = 1);
                for (let e = 0, g = a.length; e < g; ++e)
                    0 !== e || d ? (a = 1 === c ? 2 : 1,
                    e !== g - 1 || b || (a = 0),
                    this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, a),
                    this._steps.push(C3$jscomp$53.New(C3$jscomp$53.Gfx.EffectChain.Step.Bounce, this, c, a, e)),
                    c = a) : (this._numTempSurfacesRequired = 1,
                    this._steps.push(C3$jscomp$53.New(C3$jscomp$53.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, e)),
                    c = 1);
                b && this._steps.push(C3$jscomp$53.New(C3$jscomp$53.Gfx.EffectChain.Step.PostDraw, this, c, 0))
            } else
                this._canUseFastPath = !0
        }
    }
    _ShouldPreDraw(a, b) {
        return b.forcePreDraw || a.MustPreDraw() || b.is3D || a.UsesDepth() && !this._useFullSurface || 0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical ? !0 : a.GetRenderer().IsWebGL() ? a.BlendsBackground() && (b.isRotatedOrNegativeSizeInstance || b.isSourceTextureRotated) || a.UsesAnySrcRectOrPixelSize() && b.isSourceTextureRotated : !1
    }
    _ShouldPostDraw(a, b) {
        return b.forcePostDraw ? !0 : a.GetRenderer().IsWebGL() ? a.BlendsBackground() || a.UsesCrossSampling() : (a.BlendsBackground() || a.UsesCrossSampling()) && this._UseRenderTargetBackgroundSampling()
    }
    _ShouldUseCopyTextureBackgroundSampling(a) {
        return a.IsWebGPU() && this._isAnyShaderBackgroundBlending && !this._isAnyShaderCrossSampling
    }
    Render(a, b, d) {
        a.IsWebGPU() && null === b && (b = a.GetBackbufferRenderTarget());
        this._destRenderTarget = b;
        this._contentObject = d.contentObject || null;
        this._contextObject = d.contextObject || null;
        this._blendMode = d.blendMode || 0;
        this._devicePixelRatio = d.devicePixelRatio || 1;
        this._layerScale = d.layerScale || 1;
        this._layerAngle = d.layerAngle || 0;
        this._time = "number" === typeof d.time ? d.time : this._manager.GetTime();
        this._didChangeTransform = !1;
        a.ResetDidChangeTransformFlag();
        this._isAnyShaderAnimated && this._Redraw();
        let c = !1;
        this._UseCopyTextureBackgroundSampling() && (this._CalculateDrawSizeAndRectangles(a, d),
        c = !0,
        this._backTex = this._manager._GetWebGPUBackTexture(a, this._drawWidth, this._drawHeight),
        tempRect.copy(this._drawSurfaceRect),
        tempRect.roundOuter(),
        a.CopyTextureToTexture(this._destRenderTarget.GetTexture(), this._backTex, tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height()));
        if (this._canUseFastPath)
            this._Render_FastPath(a, d);
        else {
            c || this._CalculateDrawSizeAndRectangles(a, d);
            a.ResetColor();
            a.SetBaseZ(0);
            a.SetCurrentZ(0);
            this._cbDrawContentHook = d.drawContentHook || null;
            this._compositOffX = d.compositOffX || 0;
            this._compositOffY = d.compositOffY || 0;
            this._updateOwnProjection = !!d.updateOwnProjection;
            this._OnBeforeStartEffectChain(a);
            this._renderTargets[0] = b;
            this._renderTargets[1] = 1 <= this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
            this._renderTargets[2] = 2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
            for (const e of this._steps)
                b = this._GetRenderTargetForId(e.GetSrcTargetId()),
                d = this._GetRenderTargetForId(e.GetDestTargetId()),
                a.IsWebGPU() ? e.Run_WebGPU(a, b, d) : e.Run_WebGL(a, b, d);
            this._renderTargets[1] && this._ReleaseRenderTarget(this._renderTargets[1]);
            this._renderTargets[2] && this._ReleaseRenderTarget(this._renderTargets[2]);
            this._renderTargets.fill(null);
            this._OnAfterEndEffectChain(a);
            this._cbDrawContentHook = this._contextObject = this._contentObject = this._backTex = this._destRenderTarget = null
        }
    }
    _CalculateDrawSizeAndRectangles(a, b) {
        const [d,c] = this._manager.GetDrawSize(a);
        this._SetDrawSize(a, d, c);
        this._CalculateRectangles(b)
    }
    _SetDrawSize(a, b, d) {
        if (0 >= b || 0 >= d)
            throw Error("invalid draw size");
        this._drawWidth === b && this._drawHeight === d || this._CalculateDeviceTransformMatrices(a, b, d, 0, 0, this._projectionMatrix, this._modelViewMatrix);
        this._drawWidth = b;
        this._drawHeight = d
    }
    _CalculateDeviceTransformMatrices(a, b, d, c, e, g, k) {
        c = b / 2 + c;
        e = d / 2 + e;
        a.CalculatePerspectiveMatrix(g, b / d);
        a = a.CalculateLookAtModelView2(c, e, a.GetDefaultCameraZ(d), c, e, 0, d);
        mat4$jscomp$8.copy(k, a)
    }
    _CalculateRectangles(a) {
        this._layoutRect.copy(a.layoutRect);
        a.drawSurfaceRect ? this._drawSurfaceRect.copy(a.drawSurfaceRect) : this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight);
        this._rcTexOriginal.copy(this._drawSurfaceRect);
        this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);
        a = this._layerScale * this._devicePixelRatio;
        this._drawSurfaceRect.inflate(this._boxExtendHorizontal * a, this._boxExtendVertical * a);
        this._rcTexDest.copy(this._drawSurfaceRect);
        this._rcTexDest.divide(this._drawWidth, this._drawHeight);
        this._drawSurfaceRect.clamp(0, 0, this._drawWidth, this._drawHeight);
        this._rcTexBounce.copy(this._drawSurfaceRect);
        this._rcTexBounce.divide(this._drawWidth, this._drawHeight)
    }
    _OnBeforeStartEffectChain(a) {
        this._depthEnabledAtStart = a.IsDepthEnabled();
        if (this._useFullSurface)
            a.SetDepthEnabled(!1),
            this._isAnyShaderDepthSampling && a.SetDepthSamplingEnabled(!0);
        else {
            tempRect.copy(this._drawSurfaceRect);
            if (a.IsWebGL()) {
                const b = this._layerScale * this._devicePixelRatio;
                tempRect.inflate(Math.max(this._boxExtendHorizontal, 1) * b, Math.max(this._boxExtendVertical, 1) * b);
                tempRect.roundOuter();
                tempRect.clamp(0, 0, this._drawWidth, this._drawHeight)
            } else
                tempRect.roundOuter();
            a.SetScissorRect(tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height(), this._drawHeight)
        }
    }
    _OnAfterEffectChainDrawContent(a) {
        a.ResetColor();
        this._useFullSurface || (a.SetDepthEnabled(!1),
        this._isAnyShaderDepthSampling && a.SetDepthSamplingEnabled(!0));
        a.IsWebGPU() && a.SetNormalizedCoordsProgramVariant(!0)
    }
    _OnAfterEndEffectChain(a) {
        a.SetDepthSamplingEnabled(!1);
        a.SetDepthEnabled(this._depthEnabledAtStart);
        this._useFullSurface || a.RemoveScissorRect();
        a.IsWebGPU() && a.SetNormalizedCoordsProgramVariant(!1);
        this._didChangeTransform = a.DidChangeTransform()
    }
    _ClampRcTexDest() {
        this._rcTexDest.clamp(0, 0, 1, 1)
    }
    _GetRenderTargetForId(a) {
        return 0 > a ? null : this._renderTargets[a]
    }
    _GetRenderTarget() {
        return this._manager.GetRenderTarget(this)
    }
    _GetDestRenderTarget() {
        return this._destRenderTarget
    }
    _ReleaseRenderTarget(a) {
        this._manager.ReleaseRenderTarget(a, this)
    }
    _GetShaderProgramAt(a) {
        return this._shaderProgramList[a]
    }
    _DrawContent(a) {
        this._cbDrawContentHook ? this._cbDrawContentHook(this, a, ()=>this._cbDrawContent(a, this)) : this._cbDrawContent(a, this);
        this._canUseFastPath || this._OnAfterEffectChainDrawContent(a)
    }
    _IsRenderTargetSameSizeAndOffset(a) {
        if (this._useFullSurface)
            return !0;
        if (0 !== this._compositOffX || 0 !== this._compositOffY)
            return !1;
        const [b,d] = a.GetRenderTargetSize(a.GetRenderTarget());
        return b !== this._drawWidth || d !== this._drawHeight ? !1 : !0
    }
    _SetDeviceTransform(a, b) {
        let d = this._projectionMatrix
          , c = this._modelViewMatrix;
        if (b && !this._IsRenderTargetSameSizeAndOffset(a)) {
            d = tempMat4a;
            c = tempMat4b$jscomp$1;
            const [e,g] = a.GetRenderTargetSize(a.GetRenderTarget());
            this._CalculateDeviceTransformMatrices(a, e, g, this._compositOffX, this._compositOffY, d, c);
            this._useFullSurface || a.RemoveScissorRect()
        }
        a.SetProjectionMatrix(d);
        a.SetModelViewMatrix(c)
    }
    _Redraw() {
        this._manager.Redraw(this)
    }
    _GetShaderParameters(a, b) {
        return this._cbGetShaderParameters(this._shaderProgramIndices[a], b)
    }
    _SetProgramParameters(a, b) {
        let d = this._rcTexDest
          , c = this._rcTexBounce
          , e = this._rcTexOriginal;
        a.IsWebGL() && (tempRect2.copy(d),
        tempRect2.flipAround(1),
        d = tempRect2,
        tempRect3.copy(c),
        tempRect3.flipAround(1),
        c = tempRect3,
        tempRect4.copy(e),
        tempRect4.flipAround(1),
        e = tempRect4);
        this._DoSetProgramParameters(a, b, c, e, d, 1 / this._drawWidth, 1 / this._drawHeight)
    }
    _SetFirstBounceProgramParameters(a, b) {
        let d = this._rcTexBounce
          , c = this._rcTexOriginal
          , e = 1 / this._drawWidth
          , g = 1 / this._drawHeight;
        if (this._cbGetSourceTextureInfo) {
            let {srcTexRect: l, srcWidth: n, srcHeight: p} = this._cbGetSourceTextureInfo(this._contentObject);
            l || (tempRect.set(0, 0, 0, 0),
            l = tempRect);
            n || (n = this._drawWidth);
            p || (p = this._drawHeight);
            c = d = l;
            e = 1 / n;
            g = 1 / p
        } else
            a.IsWebGL() && (tempRect3.copy(d),
            tempRect3.flipAround(1),
            d = tempRect3,
            tempRect4.copy(c),
            tempRect4.flipAround(1),
            c = tempRect4);
        let k = this._rcTexDest;
        a.IsWebGL() && (k = tempRect2,
        k.copy(this._rcTexDest),
        k.flipAround(1));
        this._DoSetProgramParameters(a, b, d, c, k, e, g);
        a.IsWebGPU() && this._isAnyIsSrcTexRotated && a.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated)
    }
    _GetBackTex(a) {
        return this._isAnyShaderBackgroundBlending ? a.IsWebGPU() ? this._UseCopyTextureBackgroundSampling() ? this._backTex : this._destRenderTarget.GetTexture() : this._destRenderTarget : null
    }
    _DoSetProgramParameters(a, b, d, c, e, g, k) {
        a.SetProgramParameters(this._GetBackTex(a), e, d, c, this._layoutRect, g, k, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time);
        a.SetProgramCustomParameters(this._GetShaderParameters(b, a))
    }
    _Render_FastPath(a, b) {
        var d = this._shaderProgramList[0];
        const c = a.IsDepthEnabled()
          , e = d.UsesDepth();
        e && (a.SetDepthEnabled(!1),
        a.SetDepthSamplingEnabled(!0),
        this._rcTexDest.set(0, 0, 1, 1),
        this._rcTexOriginal.set(0, 0, 1, 1));
        a.SetProgram(d);
        a.SetBlendMode(this._blendMode);
        a.SetRenderTarget(this._destRenderTarget);
        let g;
        this._rcTexOriginal.set(0, 0, 1, 1);
        if (d.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {
            const {srcTexRect: k, srcWidth: l, srcHeight: n} = this._cbGetSourceTextureInfo(this._contentObject);
            k && this._rcTexOriginal.copy(k);
            d = Number.isFinite(l) ? 1 / l : 0;
            g = Number.isFinite(n) ? 1 / n : 0
        } else {
            const [k,l] = this._manager.GetDrawSize(a);
            d = 1 / k;
            g = 1 / l
        }
        b.layoutRect ? this._layoutRect.copy(b.layoutRect) : this._layoutRect.set(0, 0, 0, 0);
        a.SetProgramParameters(this._GetBackTex(a), this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, d, g, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time);
        a.SetProgramCustomParameters(this._GetShaderParameters(0, a));
        a.IsWebGPU() && this._isAnyIsSrcTexRotated && a.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);
        a.SetBaseZ(0);
        this._DrawContent(a);
        e && (a.SetDepthSamplingEnabled(!1),
        a.SetDepthEnabled(c))
    }
    _UseCopyTextureBackgroundSampling() {
        return this._useCopyTextureBackgroundSampling
    }
    _UseRenderTargetBackgroundSampling() {
        return !this._useCopyTextureBackgroundSampling
    }
    IsAnyShaderBackgroundBlending() {
        return this._isAnyShaderBackgroundBlending
    }
    CanSkipCalculatingDrawSurfaceRect() {
        return !this._canUseFastPath || this._UseCopyTextureBackgroundSampling() ? !1 : !0
    }
    UseFullSurface() {
        return this._useFullSurface
    }
    GetContentObject() {
        return this._contentObject
    }
    GetContextObject() {
        return this._contextObject
    }
    _GetBlendMode() {
        return this._blendMode
    }
    _UpdateOwnProjection() {
        return this._updateOwnProjection
    }
    DidChangeTransform() {
        return this._didChangeTransform
    }
    _GetDrawSurfaceRect() {
        return this._drawSurfaceRect
    }
    _GetRcTexBounce() {
        return this._rcTexBounce
    }
    _ShouldInvalidateRenderTargets() {
        return this._invalidateRenderTargets
    }
    async DebugLogRenderTargetContents(a, b, d) {}
}
;
"use strict";
self.C3.Gfx.EffectChain.Step = class {
    constructor(a, b, d, c=-1) {
        this._effectChain = a;
        this._srcTargetId = b;
        this._destTargetId = d;
        this._index = c
    }
    GetEffectChain() {
        return this._effectChain
    }
    GetSrcTargetId() {
        return this._srcTargetId
    }
    GetDestTargetId() {
        return this._destTargetId
    }
    GetIndex() {
        return this._index
    }
    GetShaderProgram() {
        return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex())
    }
    Run_WebGL(a, b, d) {}
    Run_WebGPU(a, b, d) {}
}
;
"use strict";
const C3$jscomp$55 = self.C3;
C3$jscomp$55.Gfx.EffectChain.Step.PreDraw = class extends C3$jscomp$55.Gfx.EffectChain.Step {
    constructor(a, b, d, c) {
        super(a, b, d, c)
    }
    Run_WebGL(a, b, d) {
        b = this.GetEffectChain();
        a.SetAlphaBlend();
        a.SetTextureFillMode();
        a.SetRenderTarget(d, b._UpdateOwnProjection());
        a.ClearRgba(0, 0, 0, 0);
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
    Run_WebGPU(a, b, d) {
        b = this.GetEffectChain();
        a.SetAlphaBlend();
        a.SetTextureFillMode();
        a.SetRenderTarget(d, !1);
        a.ClearRgba(0, 0, 0, 0);
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
}
;
"use strict";
const C3$jscomp$56 = self.C3
  , tempRect$jscomp$1 = C3$jscomp$56.New(C3$jscomp$56.Rect)
  , tempQuad$jscomp$1 = C3$jscomp$56.New(C3$jscomp$56.Quad);
C3$jscomp$56.Gfx.EffectChain.Step.PostDraw = class extends C3$jscomp$56.Gfx.EffectChain.Step {
    constructor(a, b, d, c) {
        super(a, b, d, c)
    }
    Run_WebGL(a, b, d) {
        const c = this.GetEffectChain();
        a.SetTextureFillMode();
        a.SetRenderTarget(d);
        c._SetDeviceTransform(a, !0);
        a.SetBlendMode(c._GetBlendMode());
        a.SetTexture(b.GetTexture());
        tempQuad$jscomp$1.setFromRect(c._GetDrawSurfaceRect());
        tempRect$jscomp$1.copy(c._GetRcTexBounce());
        tempRect$jscomp$1.flipAround(1);
        a.Quad3(tempQuad$jscomp$1, tempRect$jscomp$1);
        c._ShouldInvalidateRenderTargets() && a.InvalidateRenderTarget(b)
    }
    Run_WebGPU(a, b, d) {
        const c = this.GetEffectChain();
        a.SetTextureFillMode();
        a.SetRenderTarget(d, !1);
        c._IsRenderTargetSameSizeAndOffset(a) ? tempQuad$jscomp$1.setFromRect(c._GetRcTexBounce()) : (a.SetNormalizedCoordsProgramVariant(!1),
        c._SetDeviceTransform(a, !0),
        tempQuad$jscomp$1.setFromRect(c._GetDrawSurfaceRect()));
        a.SetBackTexture(null);
        a.SetBlendMode(c._GetBlendMode());
        a.SetTexture(b.GetTexture());
        c.UseFullSurface() ? a.FullscreenQuad() : a.Quad3(tempQuad$jscomp$1, c._GetRcTexBounce())
    }
}
;
"use strict";
const C3$jscomp$57 = self.C3;
C3$jscomp$57.Gfx.EffectChain.Step.FirstBounce = class extends C3$jscomp$57.Gfx.EffectChain.Step {
    constructor(a, b, d, c) {
        super(a, b, d, c)
    }
    Run_WebGL(a, b, d) {
        b = this.GetEffectChain();
        a.SetRenderTarget(d, b._UpdateOwnProjection());
        a.ClearRgba(0, 0, 0, 0);
        a.SetCopyBlend();
        a.SetProgram(this.GetShaderProgram());
        b._SetFirstBounceProgramParameters(a, this.GetIndex());
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
    Run_WebGPU(a, b, d) {
        b = this.GetEffectChain();
        a.SetRenderTarget(d, !1);
        a.ClearRgba(0, 0, 0, 0);
        a.SetCopyBlend();
        a.SetProgram(this.GetShaderProgram());
        b._SetFirstBounceProgramParameters(a, this.GetIndex());
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
}
;
"use strict";
const C3$jscomp$58 = self.C3
  , tempRect$jscomp$2 = C3$jscomp$58.New(C3$jscomp$58.Rect)
  , tempQuad$jscomp$2 = C3$jscomp$58.New(C3$jscomp$58.Quad);
C3$jscomp$58.Gfx.EffectChain.Step.Bounce = class extends C3$jscomp$58.Gfx.EffectChain.Step {
    constructor(a, b, d, c) {
        super(a, b, d, c)
    }
    Run_WebGL(a, b, d) {
        const c = this.GetEffectChain();
        a.SetRenderTarget(d);
        (d = 0 === this.GetDestTargetId()) ? a.SetBlendMode(c._GetBlendMode()) : (a.ClearRgba(0, 0, 0, 0),
        a.SetCopyBlend());
        a.SetProgram(this.GetShaderProgram());
        c._SetProgramParameters(a, this.GetIndex());
        a.SetTexture(b.GetTexture());
        c._SetDeviceTransform(a, d);
        tempQuad$jscomp$2.setFromRect(c._GetDrawSurfaceRect());
        tempRect$jscomp$2.copy(c._GetRcTexBounce());
        tempRect$jscomp$2.flipAround(1);
        a.Quad3(tempQuad$jscomp$2, tempRect$jscomp$2);
        c._ShouldInvalidateRenderTargets() && a.InvalidateRenderTarget(b)
    }
    Run_WebGPU(a, b, d) {
        const c = this.GetEffectChain();
        a.SetRenderTarget(d, !1);
        0 === this.GetDestTargetId() ? (a.SetBlendMode(c._GetBlendMode()),
        a.SetBackTexture(null),
        c._IsRenderTargetSameSizeAndOffset(a) ? tempQuad$jscomp$2.setFromRect(c._GetRcTexBounce()) : (a.SetNormalizedCoordsProgramVariant(!1),
        c._SetDeviceTransform(a, !0),
        tempQuad$jscomp$2.setFromRect(c._GetDrawSurfaceRect()))) : (a.ClearRgba(0, 0, 0, 0),
        a.SetCopyBlend(),
        tempQuad$jscomp$2.setFromRect(c._GetRcTexBounce()));
        a.SetProgram(this.GetShaderProgram());
        c._SetProgramParameters(a, this.GetIndex());
        a.SetTexture(b.GetTexture());
        c.UseFullSurface() ? a.FullscreenQuad() : a.Quad3(tempQuad$jscomp$2, c._GetRcTexBounce())
    }
}
;
"use strict";
const C3$jscomp$59 = self.C3
  , C3X$jscomp$1 = self.C3X;
let runtime$jscomp$1 = null;
const keysDownByKey = new Set;
function SortZOrderList(a, b) {
    const d = a[0] - b[0];
    return 0 !== d ? d : a[1] - b[1]
}
const tempZOrderList = []
  , tempInstances = [];
let didWarnInAlertPolyfill = !1;
self.IRuntime = class {
    constructor(a, b) {
        runtime$jscomp$1 = a;
        Object.defineProperties(this, {
            assets: {
                value: runtime$jscomp$1.GetAssetManager().GetIAssetManager(),
                writable: !1
            },
            objects: {
                value: b,
                writable: !1
            },
            globalVars: {
                value: {},
                writable: !1
            },
            projectName: {
                value: runtime$jscomp$1.GetProjectName(),
                writable: !1
            },
            projectVersion: {
                value: runtime$jscomp$1.GetProjectVersion(),
                writable: !1
            },
            storage: {
                value: new self.IStorage(runtime$jscomp$1),
                writable: !1
            },
            isInWorker: {
                value: runtime$jscomp$1.IsInWorker(),
                writable: !1
            },
            viewportWidth: {
                value: runtime$jscomp$1.GetOriginalViewportWidth(),
                writable: !1
            },
            viewportHeight: {
                value: runtime$jscomp$1.GetOriginalViewportHeight(),
                writable: !1
            }
        });
        runtime$jscomp$1.UserScriptDispatcher().addEventListener("keydown", d=>{
            keysDownByKey.has(d.key) ? d.stopPropagation() : keysDownByKey.add(d.key)
        }
        );
        runtime$jscomp$1.UserScriptDispatcher().addEventListener("keyup", d=>keysDownByKey.delete(d.key));
        runtime$jscomp$1.Dispatcher().addEventListener("window-blur", ()=>keysDownByKey.clear());
        runtime$jscomp$1.IsInWorker() && (self.alert = d=>{
            didWarnInAlertPolyfill || (didWarnInAlertPolyfill = !0,
            console.warn("[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual."));
            return this.alert(d)
        }
        )
    }
    _InitGlobalVars(a) {
        Object.defineProperties(this.globalVars, a)
    }
    addEventListener(a, b) {
        runtime$jscomp$1.UserScriptDispatcher().addEventListener(a, b)
    }
    removeEventListener(a, b) {
        runtime$jscomp$1.UserScriptDispatcher().removeEventListener(a, b)
    }
    callFunction(a, ...b) {
        C3X$jscomp$1.RequireString(a);
        const d = runtime$jscomp$1.GetEventSheetManager()
          , c = d.GetFunctionBlockByName(a);
        if (!c)
            throw Error(`cannot find function name '${a}'`);
        if (!c.IsEnabled())
            return c.GetDefaultReturnValue();
        if (b.length < c.GetFunctionParameterCount())
            throw Error(`not enough function parameters passed for '${a}' (${b.length} passed, ${c.GetFunctionParameterCount()} expected)`);
        a = c.GetEventBlock();
        let e = a.GetSolModifiersIncludingParents();
        const g = d.GetCurrentEvent();
        if (g) {
            e = e.slice(0);
            const k = new Set(e);
            for (const l of g.GetSolModifiersIncludingParents())
                k.has(l) || (e.push(l),
                k.add(l));
            for (const l of d.GetDynamicSolModifiersSet())
                k.has(l) || (e.push(l),
                k.add(l))
        }
        return a.RunAsExpressionFunctionCall(e, c.IsCopyPicked(), c.GetReturnType(), c.GetDefaultReturnValue(), ...b)
    }
    setReturnValue(a) {
        const b = runtime$jscomp$1.GetEventStack().GetCurrentExpFuncStackFrame();
        if (!b)
            throw Error("not in a function which returns a value");
        switch (b.GetFunctionReturnType()) {
        case 1:
            "number" === typeof a && b.SetFunctionReturnValue(a);
            break;
        case 2:
            "string" === typeof a && b.SetFunctionReturnValue(a);
            break;
        case 3:
            "number" !== typeof a && "string" !== typeof a || b.SetFunctionReturnValue(a)
        }
    }
    getViewportSize() {
        return [runtime$jscomp$1.GetOriginalViewportWidth(), runtime$jscomp$1.GetOriginalViewportHeight()]
    }
    get dt() {
        return runtime$jscomp$1.GetDt()
    }
    get dtRaw() {
        return runtime$jscomp$1.GetDtRaw()
    }
    get gameTime() {
        return runtime$jscomp$1.GetGameTime()
    }
    get wallTime() {
        return runtime$jscomp$1.GetWallTime()
    }
    get timeScale() {
        return runtime$jscomp$1.GetTimeScale()
    }
    set timeScale(a) {
        C3X$jscomp$1.RequireFiniteNumber(a);
        runtime$jscomp$1.SetTimeScale(a)
    }
    get fps() {
        return runtime$jscomp$1.GetFPS()
    }
    get cpuUtilisation() {
        return runtime$jscomp$1.GetMainThreadTime()
    }
    get gpuUtilisation() {
        return runtime$jscomp$1.GetGPUUtilisation()
    }
    random() {
        return runtime$jscomp$1.Random()
    }
    get layout() {
        return runtime$jscomp$1.GetMainRunningLayout().GetILayout()
    }
    getLayout(a) {
        const b = runtime$jscomp$1.GetLayoutManager();
        if ("number" === typeof a || "string" === typeof a)
            a = b.GetLayout(a);
        else
            throw new TypeError("expected string or number");
        if (!a)
            throw Error("invalid layout");
        return a.GetILayout()
    }
    getAllLayouts() {
        return runtime$jscomp$1.GetLayoutManager().GetAllLayouts().map(a=>a.GetILayout())
    }
    goToLayout(a) {
        const b = runtime$jscomp$1.GetLayoutManager();
        if ("number" === typeof a || "string" === typeof a)
            a = b.GetLayout(a);
        else
            throw new TypeError("expected string or number");
        if (!a)
            throw Error("invalid layout");
        b.IsPendingChangeMainLayout() || b.ChangeMainLayout(a)
    }
    get keyboard() {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().keyboard;
        if (!a)
            throw Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
        return a
    }
    get mouse() {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().mouse;
        if (!a)
            throw Error("runtime.mouse used but Mouse object missing - add it to your project first");
        return a
    }
    get touch() {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().touch;
        if (!a)
            throw Error("runtime.touch used but Touch object missing - add it to your project first");
        return a
    }
    invokeDownload(a, b) {
        C3X$jscomp$1.RequireString(a);
        C3X$jscomp$1.RequireString(b);
        runtime$jscomp$1.InvokeDownload(a, b)
    }
    getInstanceByUid(a) {
        C3X$jscomp$1.RequireFiniteNumber(a);
        return (a = runtime$jscomp$1.GetInstanceByUID(a)) ? a.GetInterfaceClass() : null
    }
    sortZOrder(a, b) {
        C3X$jscomp$1.RequireFunction(b);
        const d = runtime$jscomp$1.GetCurrentLayout();
        for (var c of a) {
            a = runtime$jscomp$1._UnwrapIWorldInstance(c);
            var e = a.GetWorldInfo();
            tempZOrderList.push([e.GetLayer().GetIndex(), e.GetZIndex()]);
            tempInstances.push(a)
        }
        if (0 !== tempZOrderList.length) {
            tempZOrderList.sort(SortZOrderList);
            tempInstances.sort((g,k)=>b(g.GetInterfaceClass(), k.GetInterfaceClass()));
            c = !1;
            for (let g = 0, k = tempZOrderList.length; g < k; ++g) {
                a = tempInstances[g];
                e = d.GetLayerByIndex(tempZOrderList[g][0]);
                const l = tempZOrderList[g][1]
                  , n = e._GetInstances();
                n[l] !== a && (n[l] = a,
                a.GetWorldInfo()._SetLayer(e, !0),
                e.SetZIndicesChanged(),
                c = !0)
            }
            c && runtime$jscomp$1.UpdateRender();
            C3$jscomp$59.clearArray(tempZOrderList);
            C3$jscomp$59.clearArray(tempInstances)
        }
    }
    async createWorker(a, b) {
        var d = new MessageChannel;
        const c = d.port1;
        d = d.port2;
        await runtime$jscomp$1.PostComponentMessageToDOMAsync("runtime", "script-create-worker", {
            url: a,
            opts: b,
            port2: d
        }, [d]);
        return c
    }
    alert(a) {
        return runtime$jscomp$1.PostComponentMessageToDOMAsync("runtime", "alert", {
            message: a + (runtime$jscomp$1.IsInWorker() ? " [via Web Worker]" : "")
        })
    }
}
;
"use strict";
const C3$jscomp$60 = self.C3;
let assetManager = null;
self.IAssetManager = class {
    constructor(a) {
        assetManager = a;
        Object.defineProperties(this, {
            isWebMOpusSupported: {
                value: assetManager.IsAudioFormatSupported("audio/webm; codecs=opus"),
                writable: !1
            }
        })
    }
    fetchText(a) {
        return assetManager.FetchText(a)
    }
    fetchJson(a) {
        return assetManager.FetchJson(a)
    }
    fetchBlob(a) {
        return assetManager.FetchBlob(a)
    }
    fetchArrayBuffer(a) {
        return assetManager.FetchArrayBuffer(a)
    }
    getProjectFileUrl(a) {
        return assetManager.GetProjectFileUrl(a)
    }
    getMediaFileUrl(a) {
        "flat" === assetManager.GetFileStructure() && C3$jscomp$60.IsRelativeURL(a) && (a = a.toLowerCase());
        return assetManager.GetMediaFileUrl(a)
    }
    get mediaFolder() {
        return assetManager.GetMediaSubfolder()
    }
    async decodeWebMOpus(a, b) {
        if (this.isWebMOpusSupported)
            throw Error("decodeWebMOpus(): not supported because WebM Opus is supported by the platform");
        b = await assetManager.GetRuntime()._WasmDecodeWebMOpus(b);
        b = new Float32Array(b);
        a = a.createBuffer(1, b.length, 48E3);
        a.getChannelData(0).set(b);
        return a
    }
    loadScripts(...a) {
        return assetManager.LoadScripts(...a)
    }
    compileWebAssembly(a) {
        return assetManager.CompileWebAssembly(a)
    }
    loadStyleSheet(a) {
        return assetManager.LoadStyleSheet(a)
    }
}
;
"use strict";
const C3X$jscomp$3 = self.C3X;
self.IStorage = class {
    constructor(a) {
        this._storage = a._GetProjectStorage()
    }
    getItem(a) {
        C3X$jscomp$3.RequireString(a);
        return this._storage.getItem(a)
    }
    setItem(a, b) {
        C3X$jscomp$3.RequireString(a);
        return this._storage.setItem(a, b)
    }
    removeItem(a) {
        C3X$jscomp$3.RequireString(a);
        return this._storage.removeItem(a)
    }
    clear() {
        return this._storage.clear()
    }
    keys() {
        return this._storage.keys()
    }
}
;
"use strict";
const C3$jscomp$62 = self.C3
  , C3X$jscomp$4 = self.C3X
  , map$jscomp$2 = new WeakMap;
self.IObjectClass = class {
    constructor(a) {
        map$jscomp$2.set(this, a);
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            }
        });
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    addEventListener(a, b) {
        C3X$jscomp$4.RequireString(a);
        C3X$jscomp$4.RequireFunction(b);
        map$jscomp$2.get(this).UserScriptDispatcher().addEventListener(a, b)
    }
    removeEventListener(a, b) {
        C3X$jscomp$4.RequireString(a);
        C3X$jscomp$4.RequireFunction(b);
        map$jscomp$2.get(this).UserScriptDispatcher().removeEventListener(a, b)
    }
    getAllInstances() {
        return [...this.instances()]
    }
    getFirstInstance() {
        return C3$jscomp$62.first(this.instances())
    }
    getPickedInstances() {
        return [...this.pickedInstances()]
    }
    getFirstPickedInstance() {
        return C3$jscomp$62.first(this.pickedInstances())
    }
    *instances() {
        for (const a of map$jscomp$2.get(this).instancesIncludingPendingCreate())
            yield a.GetInterfaceClass()
    }
    *pickedInstances() {
        for (const a of map$jscomp$2.get(this).GetCurrentSol().GetInstances())
            yield a.GetInterfaceClass()
    }
    setInstanceClass(a) {
        C3X$jscomp$4.RequireFunction(a);
        if (0 < map$jscomp$2.get(this).GetInstanceCount())
            throw Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
        map$jscomp$2.get(this)._SetUserScriptInstanceClass(a)
    }
    createInstance(a, b, d, c, e) {
        C3X$jscomp$4.RequireNumber(b);
        C3X$jscomp$4.RequireNumber(d);
        if ("number" !== typeof a && "string" !== typeof a)
            throw new TypeError("invalid layer parameter");
        const g = map$jscomp$2.get(this)
          , k = g.GetRuntime();
        a = k.GetMainRunningLayout().GetLayer(a);
        if (!a)
            throw Error("invalid layer");
        b = k.CreateInstance(g, a, b, d, c, e);
        c && a.SortAndAddInstancesByZIndex(b);
        c = k.GetEventSheetManager();
        c.BlockFlushingInstances(!0);
        b._TriggerOnCreatedOnSelfAndRelated();
        c.BlockFlushingInstances(!1);
        c.IsInEventEngine() || k.GetLayoutManager().IsEndingLayout() || k.FlushPendingInstances();
        return b.GetInterfaceClass()
    }
}
;
"use strict";
const C3X$jscomp$5 = self.C3X
  , map$jscomp$3 = new WeakMap;
self.ILayout = class {
    constructor(a) {
        map$jscomp$3.set(this, a);
        const b = []
          , d = a.GetEffectList()
          , c = d.GetAllEffectTypes().length;
        for (let e = 0; e < c; ++e)
            b.push(new self.IEffectInstance(d,e));
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            },
            index: {
                value: a.GetIndex(),
                writable: !1
            },
            effects: {
                value: b,
                writable: !1
            }
        })
    }
    addEventListener(a, b) {
        C3X$jscomp$5.RequireString(a);
        C3X$jscomp$5.RequireFunction(b);
        map$jscomp$3.get(this).UserScriptDispatcher().addEventListener(a, b)
    }
    removeEventListener(a, b) {
        C3X$jscomp$5.RequireString(a);
        C3X$jscomp$5.RequireFunction(b);
        map$jscomp$3.get(this).UserScriptDispatcher().removeEventListener(a, b)
    }
    get width() {
        return map$jscomp$3.get(this).GetWidth()
    }
    set width(a) {
        C3X$jscomp$5.RequireFiniteNumber(a);
        map$jscomp$3.get(this).SetWidth(a)
    }
    get height() {
        return map$jscomp$3.get(this).GetHeight()
    }
    set height(a) {
        C3X$jscomp$5.RequireFiniteNumber(a);
        map$jscomp$3.get(this).SetHeight(a)
    }
    setSize(a, b) {
        C3X$jscomp$5.RequireFiniteNumber(a);
        C3X$jscomp$5.RequireFiniteNumber(b);
        const d = map$jscomp$3.get(this);
        d.SetWidth(a);
        d.SetHeight(b)
    }
    getSize() {
        const a = map$jscomp$3.get(this);
        return [a.GetWidth(), a.GetHeight()]
    }
    set scale(a) {
        C3X$jscomp$5.RequireFiniteNumber(a);
        map$jscomp$3.get(this).SetScale(a)
    }
    get scale() {
        return map$jscomp$3.get(this).GetScale()
    }
    set angle(a) {
        C3X$jscomp$5.RequireFiniteNumber(a);
        map$jscomp$3.get(this).SetAngle(a)
    }
    get angle() {
        return map$jscomp$3.get(this).GetAngle()
    }
    set scrollX(a) {
        C3X$jscomp$5.RequireNumber(a);
        map$jscomp$3.get(this).SetScrollX(a)
    }
    get scrollX() {
        return map$jscomp$3.get(this).GetScrollX()
    }
    set scrollY(a) {
        C3X$jscomp$5.RequireNumber(a);
        map$jscomp$3.get(this).SetScrollY(a)
    }
    get scrollY() {
        return map$jscomp$3.get(this).GetScrollY()
    }
    scrollTo(a, b) {
        C3X$jscomp$5.RequireNumber(a);
        C3X$jscomp$5.RequireNumber(b);
        const d = map$jscomp$3.get(this);
        d.SetScrollX(a);
        d.SetScrollY(b)
    }
    getScrollPosition() {
        const a = map$jscomp$3.get(this);
        return [a.GetScrollX(), a.GetScrollY()]
    }
    getLayer(a) {
        const b = map$jscomp$3.get(this);
        if ("number" === typeof a || "string" === typeof a)
            a = b.GetLayer(a);
        else
            throw new TypeError("expected string or number");
        return a ? a.GetILayer() : null
    }
    getAllLayers() {
        return map$jscomp$3.get(this).GetLayers().map(a=>a.GetILayer())
    }
    *allLayers() {
        for (const a of map$jscomp$3.get(this).allLayers())
            yield a.GetILayer()
    }
    setVanishingPoint(a, b) {
        C3X$jscomp$5.RequireFiniteNumber(a);
        C3X$jscomp$5.RequireFiniteNumber(b);
        map$jscomp$3.get(this).SetVanishingPointXY(a, b)
    }
    getVanishingPoint() {
        return map$jscomp$3.get(this)._GetVanishingPoint()
    }
    set projection(a) {
        C3X$jscomp$5.RequireString(a);
        const b = map$jscomp$3.get(this);
        if ("perspective" === a)
            b.SetPerspectiveProjection();
        else if ("orthographic" === a)
            b.SetOrthographicProjection();
        else
            throw Error("invalid projection");
    }
    get projection() {
        return map$jscomp$3.get(this).IsOrthographicProjection() ? "orthographic" : "perspective"
    }
}
;
"use strict";
const C3$jscomp$64 = self.C3
  , C3X$jscomp$6 = self.C3X
  , map$jscomp$4 = new WeakMap
  , BLEND_MODE_TO_INDEX = new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]])
  , INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map(a=>[a[1], a[0]]))
  , tempColor$jscomp$1 = C3$jscomp$64.New(C3$jscomp$64.Color);
self.ILayer = class {
    constructor(a) {
        map$jscomp$4.set(this, a);
        const b = []
          , d = a.GetEffectList()
          , c = d.GetAllEffectTypes().length;
        for (let e = 0; e < c; ++e)
            b.push(new self.IEffectInstance(d,e));
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            },
            index: {
                value: a.GetIndex(),
                writable: !1
            },
            layout: {
                value: a.GetLayout().GetILayout(),
                writable: !1
            },
            effects: {
                value: b,
                writable: !1
            }
        })
    }
    static _Unwrap(a) {
        return map$jscomp$4.get(a)
    }
    get parentLayer() {
        const a = map$jscomp$4.get(this).GetParentLayer();
        return a ? a.GetILayer() : null
    }
    *parentLayers() {
        for (const a of map$jscomp$4.get(this).parentLayers())
            yield a.GetILayer()
    }
    *subLayers() {
        for (const a of map$jscomp$4.get(this).GetSubLayers())
            yield a.GetILayer()
    }
    *allSubLayers() {
        for (const a of map$jscomp$4.get(this).GetSubLayers())
            for (const b of a.selfAndAllSubLayers())
                yield b.GetILayer()
    }
    get isVisible() {
        return map$jscomp$4.get(this)._IsVisibleFlagSet()
    }
    set isVisible(a) {
        map$jscomp$4.get(this).SetVisible(a)
    }
    get isSelfAndParentsVisible() {
        return map$jscomp$4.get(this).IsVisible()
    }
    get isInteractive() {
        return map$jscomp$4.get(this).IsInteractive()
    }
    set isInteractive(a) {
        map$jscomp$4.get(this).SetInteractive(a)
    }
    get isSelfAndParentsInteractive() {
        return map$jscomp$4.get(this).IsSelfAndParentsInteractive()
    }
    get opacity() {
        return map$jscomp$4.get(this).GetOpacity()
    }
    set opacity(a) {
        a = C3$jscomp$64.clamp(+a, 0, 1);
        isNaN(a) || map$jscomp$4.get(this).SetOpacity(a)
    }
    set scale(a) {
        C3X$jscomp$6.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetOwnScale(a)
    }
    get scale() {
        return map$jscomp$4.get(this).GetOwnScale()
    }
    set scaleRate(a) {
        C3X$jscomp$6.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetScaleRate(a)
    }
    get scaleRate() {
        return map$jscomp$4.get(this).GetScaleRate()
    }
    set angle(a) {
        C3X$jscomp$6.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetAngle(a)
    }
    get angle() {
        return map$jscomp$4.get(this).GetOwnAngle()
    }
    set parallaxX(a) {
        C3X$jscomp$6.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetParallaxX(a)
    }
    get parallaxX() {
        return map$jscomp$4.get(this).GetParallaxX()
    }
    set parallaxY(a) {
        C3X$jscomp$6.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetParallaxY(a)
    }
    get parallaxY() {
        return map$jscomp$4.get(this).GetParallaxY()
    }
    set zElevation(a) {
        C3X$jscomp$6.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetZElevation(a)
    }
    get zElevation() {
        return map$jscomp$4.get(this).GetZElevation()
    }
    set isTransparent(a) {
        map$jscomp$4.get(this).SetTransparent(a)
    }
    get isTransparent() {
        return map$jscomp$4.get(this).IsTransparent()
    }
    set isForceOwnTexture(a) {
        map$jscomp$4.get(this).SetForceOwnTexture(a)
    }
    get isForceOwnTexture() {
        return map$jscomp$4.get(this).IsForceOwnTexture()
    }
    set blendMode(a) {
        C3X$jscomp$6.RequireString(a);
        a = BLEND_MODE_TO_INDEX.get(a);
        if ("number" !== typeof a)
            throw Error("invalid blend mode");
        map$jscomp$4.get(this).SetBlendMode(a)
    }
    get blendMode() {
        return INDEX_TO_BLEND_MODE.get(map$jscomp$4.get(this).GetBlendMode())
    }
    set backgroundColor(a) {
        C3X$jscomp$6.RequireArray(a);
        if (3 > a.length)
            throw Error("expected 3 elements");
        tempColor$jscomp$1.setRgb(a[0], a[1], a[2]);
        a = map$jscomp$4.get(this);
        const b = a.GetBackgroundColor();
        b.equalsIgnoringAlpha(tempColor$jscomp$1) || (b.copyRgb(tempColor$jscomp$1),
        a.GetRuntime().UpdateRender())
    }
    get backgroundColor() {
        const a = map$jscomp$4.get(this).GetBackgroundColor();
        return [a.getR(), a.getG(), a.getB()]
    }
    set scrollX(a) {
        C3X$jscomp$6.RequireNumber(a);
        const b = map$jscomp$4.get(this);
        b.SetOwnScrollPositionEnabled(!0);
        b.SetScrollX(a)
    }
    get scrollX() {
        return map$jscomp$4.get(this).GetScrollX()
    }
    set scrollY(a) {
        C3X$jscomp$6.RequireNumber(a);
        const b = map$jscomp$4.get(this);
        b.SetOwnScrollPositionEnabled(!0);
        b.SetScrollY(a)
    }
    get scrollY() {
        return map$jscomp$4.get(this).GetScrollY()
    }
    scrollTo(a, b) {
        C3X$jscomp$6.RequireNumber(a);
        C3X$jscomp$6.RequireNumber(b);
        const d = map$jscomp$4.get(this);
        d.SetOwnScrollPositionEnabled(!0);
        d.SetScrollX(a);
        d.SetScrollY(b)
    }
    getScrollPosition() {
        const a = map$jscomp$4.get(this);
        return [a.GetScrollX(), a.GetScrollY()]
    }
    restoreScrollPosition() {
        map$jscomp$4.get(this).SetOwnScrollPositionEnabled(!1)
    }
    getViewport() {
        return map$jscomp$4.get(this).GetViewport().toDOMRect()
    }
    cssPxToLayer(a, b, d=0) {
        C3X$jscomp$6.RequireNumber(a);
        C3X$jscomp$6.RequireNumber(b);
        C3X$jscomp$6.RequireNumber(d);
        const c = map$jscomp$4.get(this)
          , e = c.GetRuntime();
        return c.CanvasCssToLayer(a - e.GetCanvasClientX(), b - e.GetCanvasClientY(), d)
    }
    layerToCssPx(a, b, d=0) {
        C3X$jscomp$6.RequireNumber(a);
        C3X$jscomp$6.RequireNumber(b);
        C3X$jscomp$6.RequireNumber(d);
        const c = map$jscomp$4.get(this)
          , e = c.GetRuntime()
          , [g,k] = c.LayerToCanvasCss(a, b, d);
        return [g + e.GetCanvasClientX(), k + e.GetCanvasClientY()]
    }
}
;
"use strict";
const C3$jscomp$65 = self.C3
  , C3X$jscomp$7 = self.C3X
  , map$jscomp$5 = new WeakMap
  , dispatchers = new WeakMap;
function GetDispatcher(a) {
    let b = dispatchers.get(a);
    if (b)
        return b;
    b = C3$jscomp$65.New(C3$jscomp$65.Event.Dispatcher);
    dispatchers.set(a, b);
    return b
}
let initInst = null;
self.IInstance = class {
    constructor() {
        map$jscomp$5.set(this, initInst);
        const a = {
            runtime: {
                value: initInst.GetRuntime().GetIRuntime(),
                writable: !1
            },
            objectType: {
                value: initInst.GetObjectClass().GetIObjectClass(),
                writable: !1
            },
            uid: {
                value: initInst.GetUID(),
                writable: !1
            }
        };
        initInst._GetInstVarsScriptDescriptor(a);
        initInst._GetBehaviorsScriptDescriptor(a);
        Object.defineProperties(this, a);
        initInst.GetRuntime()._MapScriptInterface(this, initInst)
    }
    static _Init(a) {
        initInst = a
    }
    static _GetInitInst() {
        return initInst
    }
    _Release() {
        const a = dispatchers.get(this);
        a && (a.Release(),
        dispatchers.delete(this));
        map$jscomp$5.delete(this)
    }
    addEventListener(a, b, d) {
        C3X$jscomp$7.RequireString(a);
        C3X$jscomp$7.RequireFunction(b);
        GetDispatcher(this).addEventListener(a, b, d)
    }
    removeEventListener(a, b, d) {
        C3X$jscomp$7.RequireString(a);
        C3X$jscomp$7.RequireFunction(b);
        GetDispatcher(this).removeEventListener(a, b, d)
    }
    dispatchEvent(a) {
        GetDispatcher(this).dispatchEvent(a)
    }
    destroy() {
        const a = map$jscomp$5.get(this)
          , b = a.GetRuntime();
        b.DestroyInstance(a);
        b.GetEventSheetManager().IsInEventEngine() || b.GetLayoutManager().IsEndingLayout() || b.FlushPendingInstances()
    }
    getOtherContainerInstances() {
        const a = map$jscomp$5.get(this).GetSiblings();
        return a ? a.map(b=>b.GetInterfaceClass()) : []
    }
    *otherContainerInstances() {
        const a = map$jscomp$5.get(this);
        if (a.IsInContainer())
            for (const b of a.siblings())
                yield b.GetInterfaceClass()
    }
    get templateName() {
        return map$jscomp$5.get(this).GetTemplateName()
    }
    set timeScale(a) {
        C3X$jscomp$7.RequireFiniteNumber(a);
        map$jscomp$5.get(this).SetTimeScale(a)
    }
    get timeScale() {
        return map$jscomp$5.get(this).GetActiveTimeScale()
    }
    restoreTimeScale() {
        map$jscomp$5.get(this).RestoreTimeScale()
    }
}
;
"use strict";
const C3$jscomp$66 = self.C3
  , C3X$jscomp$8 = self.C3X
  , IInstance$jscomp$1 = self.IInstance
  , ILayer$jscomp$1 = self.ILayer
  , map$jscomp$6 = new WeakMap
  , BLEND_MODE_TO_INDEX$jscomp$1 = new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]])
  , INDEX_TO_BLEND_MODE$jscomp$1 = new Map([...BLEND_MODE_TO_INDEX$jscomp$1.entries()].map(a=>[a[1], a[0]]))
  , tempColor$jscomp$2 = C3$jscomp$66.New(C3$jscomp$66.Color);
self.IWorldInstance = class a extends IInstance$jscomp$1 {
    constructor() {
        super();
        var b = IInstance$jscomp$1._GetInitInst();
        map$jscomp$6.set(this, b);
        const d = [];
        var c = b.GetWorldInfo();
        if (b = c.GetInstanceEffectList()) {
            c = c.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
            for (let e = 0; e < c; ++e)
                d.push(new self.IEffectInstance(b,e))
        }
        Object.defineProperties(this, {
            effects: {
                value: d,
                writable: !1
            }
        })
    }
    get layout() {
        return map$jscomp$6.get(this).GetWorldInfo().GetLayout().GetILayout()
    }
    get layer() {
        return map$jscomp$6.get(this).GetWorldInfo().GetLayer().GetILayer()
    }
    get x() {
        return map$jscomp$6.get(this).GetWorldInfo().GetX()
    }
    set x(b) {
        b = +b;
        const d = map$jscomp$6.get(this).GetWorldInfo();
        isNaN(b) || d.GetX() === b || (d.SetX(b),
        d.SetBboxChanged())
    }
    get y() {
        return map$jscomp$6.get(this).GetWorldInfo().GetY()
    }
    set y(b) {
        b = +b;
        const d = map$jscomp$6.get(this).GetWorldInfo();
        isNaN(b) || d.GetY() === b || (d.SetY(b),
        d.SetBboxChanged())
    }
    setPosition(b, d) {
        b = +b;
        d = +d;
        const c = map$jscomp$6.get(this).GetWorldInfo();
        isNaN(b) || isNaN(d) || c.GetX() === b && c.GetY() === d || (c.SetXY(b, d),
        c.SetBboxChanged())
    }
    getPosition() {
        const b = map$jscomp$6.get(this).GetWorldInfo();
        return [b.GetX(), b.GetY()]
    }
    offsetPosition(b, d) {
        b = +b;
        d = +d;
        if (!(isNaN(b) || isNaN(d) || 0 === b && 0 === d)) {
            var c = map$jscomp$6.get(this).GetWorldInfo();
            c.OffsetXY(b, d);
            c.SetBboxChanged()
        }
    }
    get zElevation() {
        return map$jscomp$6.get(this).GetWorldInfo().GetZElevation()
    }
    set zElevation(b) {
        b = +b;
        const d = map$jscomp$6.get(this)
          , c = d.GetWorldInfo();
        isNaN(b) || c.GetZElevation() === b || (c.SetZElevation(b),
        d.GetRuntime().UpdateRender())
    }
    get totalZElevation() {
        return map$jscomp$6.get(this).GetWorldInfo().GetTotalZElevation()
    }
    get width() {
        return map$jscomp$6.get(this).GetWorldInfo().GetWidth()
    }
    set width(b) {
        b = +b;
        const d = map$jscomp$6.get(this).GetWorldInfo();
        isNaN(b) || d.GetWidth() === b || (d.SetWidth(b),
        d.SetBboxChanged())
    }
    get height() {
        return map$jscomp$6.get(this).GetWorldInfo().GetHeight()
    }
    set height(b) {
        b = +b;
        const d = map$jscomp$6.get(this).GetWorldInfo();
        isNaN(b) || d.GetHeight() === b || (d.SetHeight(b),
        d.SetBboxChanged())
    }
    setSize(b, d) {
        b = +b;
        d = +d;
        const c = map$jscomp$6.get(this).GetWorldInfo();
        isNaN(b) || isNaN(d) || c.GetWidth() === b && c.GetHeight() === d || (c.SetSize(b, d),
        c.SetBboxChanged())
    }
    getSize() {
        const b = map$jscomp$6.get(this).GetWorldInfo();
        return [b.GetWidth(), b.GetHeight()]
    }
    get angle() {
        return map$jscomp$6.get(this).GetWorldInfo().GetAngle()
    }
    set angle(b) {
        b = C3$jscomp$66.clampAngle(+b);
        const d = map$jscomp$6.get(this).GetWorldInfo();
        isNaN(b) || d.GetAngle() === b || (d.SetAngle(b),
        d.SetBboxChanged())
    }
    get angleDegrees() {
        return C3$jscomp$66.toDegrees(this.angle)
    }
    set angleDegrees(b) {
        this.angle = C3$jscomp$66.toRadians(b)
    }
    getBoundingBox() {
        return map$jscomp$6.get(this).GetWorldInfo().GetBoundingBox().toDOMRect()
    }
    getBoundingQuad() {
        return map$jscomp$6.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad()
    }
    get isVisible() {
        return map$jscomp$6.get(this).GetWorldInfo().IsVisible()
    }
    set isVisible(b) {
        b = !!b;
        const d = map$jscomp$6.get(this)
          , c = d.GetWorldInfo();
        c.IsVisible() !== b && (c.SetVisible(b),
        d.GetRuntime().UpdateRender())
    }
    get opacity() {
        return map$jscomp$6.get(this).GetWorldInfo().GetOpacity()
    }
    set opacity(b) {
        b = C3$jscomp$66.clamp(+b, 0, 1);
        const d = map$jscomp$6.get(this)
          , c = d.GetWorldInfo();
        isNaN(b) || c.GetOpacity() === b || (c.SetOpacity(b),
        d.GetRuntime().UpdateRender())
    }
    set colorRgb(b) {
        C3X$jscomp$8.RequireArray(b);
        if (3 > b.length)
            throw Error("expected 3 elements");
        tempColor$jscomp$2.setRgb(b[0], b[1], b[2]);
        b = map$jscomp$6.get(this);
        const d = b.GetWorldInfo();
        d.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor$jscomp$2) || (d.SetUnpremultipliedColor(tempColor$jscomp$2),
        b.GetRuntime().UpdateRender())
    }
    get colorRgb() {
        const b = map$jscomp$6.get(this).GetWorldInfo().GetUnpremultipliedColor();
        return [b.getR(), b.getG(), b.getB()]
    }
    set blendMode(b) {
        C3X$jscomp$8.RequireString(b);
        b = BLEND_MODE_TO_INDEX$jscomp$1.get(b);
        if ("number" !== typeof b)
            throw Error("invalid blend mode");
        const d = map$jscomp$6.get(this);
        d.GetWorldInfo().SetBlendMode(b);
        d.GetRuntime().UpdateRender()
    }
    get blendMode() {
        return INDEX_TO_BLEND_MODE$jscomp$1.get(map$jscomp$6.get(this).GetWorldInfo().GetBlendMode())
    }
    moveToTop() {
        map$jscomp$6.get(this).GetWorldInfo().ZOrderMoveToTop()
    }
    moveToBottom() {
        map$jscomp$6.get(this).GetWorldInfo().ZOrderMoveToBottom()
    }
    moveToLayer(b) {
        C3X$jscomp$8.RequireInstanceOf(b, ILayer$jscomp$1);
        b = ILayer$jscomp$1._Unwrap(b);
        if (!b)
            throw Error("invalid layer");
        map$jscomp$6.get(this).GetWorldInfo().ZOrderMoveToLayer(b)
    }
    moveAdjacentToInstance(b, d) {
        C3X$jscomp$8.RequireInstanceOf(b, a);
        map$jscomp$6.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(map$jscomp$6.get(b), d)
    }
    get zIndex() {
        return map$jscomp$6.get(this).GetWorldInfo().GetZIndex()
    }
    get isCollisionEnabled() {
        return map$jscomp$6.get(this).GetWorldInfo().IsCollisionEnabled()
    }
    set isCollisionEnabled(b) {
        map$jscomp$6.get(this).GetWorldInfo().SetCollisionEnabled(!!b)
    }
    containsPoint(b, d) {
        C3X$jscomp$8.RequireNumber(b);
        C3X$jscomp$8.RequireNumber(d);
        return map$jscomp$6.get(this).GetWorldInfo().ContainsPoint(+b, +d)
    }
    testOverlap(b) {
        C3X$jscomp$8.RequireInstanceOf(b, a);
        const d = map$jscomp$6.get(this);
        b = map$jscomp$6.get(b);
        return d.GetRuntime().GetCollisionEngine().TestOverlap(d, b)
    }
    testOverlapSolid() {
        var b = map$jscomp$6.get(this);
        return (b = b.GetRuntime().GetCollisionEngine().TestOverlapSolid(b)) ? b.GetInterfaceClass() : null
    }
    getParent() {
        const b = map$jscomp$6.get(this).GetParent();
        return b ? b.GetInterfaceClass() : null
    }
    getTopParent() {
        const b = map$jscomp$6.get(this).GetTopParent();
        return b ? b.GetInterfaceClass() : null
    }
    *parents() {
        for (const b of map$jscomp$6.get(this).parents())
            yield b.GetInterfaceClass()
    }
    getChildCount() {
        return map$jscomp$6.get(this).GetChildCount()
    }
    getChildAt(b) {
        return (b = map$jscomp$6.get(this).GetChildAt(b)) ? b.GetInterfaceClass() : null
    }
    *children() {
        for (const b of map$jscomp$6.get(this).children())
            yield b.GetInterfaceClass()
    }
    *allChildren() {
        for (const b of map$jscomp$6.get(this).allChildren())
            yield b.GetInterfaceClass()
    }
    addChild(b, d) {
        C3X$jscomp$8.RequireInstanceOf(b, a);
        C3X$jscomp$8.RequireOptionalObject(d);
        d || (d = {});
        const c = map$jscomp$6.get(this);
        b = map$jscomp$6.get(b);
        c.AddChild(b, d)
    }
    removeChild(b) {
        C3X$jscomp$8.RequireInstanceOf(b, a);
        const d = map$jscomp$6.get(this);
        b = map$jscomp$6.get(b);
        d.RemoveChild(b)
    }
    removeFromParent() {
        const b = map$jscomp$6.get(this);
        b.HasParent() && b.GetParent().RemoveChild(b)
    }
    createMesh(b, d) {
        C3X$jscomp$8.RequireFiniteNumber(b);
        C3X$jscomp$8.RequireFiniteNumber(d);
        map$jscomp$6.get(this).GetWorldInfo().CreateMesh(b, d)
    }
    releaseMesh() {
        const b = map$jscomp$6.get(this).GetWorldInfo();
        b.ReleaseMesh();
        b.SetBboxChanged()
    }
    setMeshPoint(b, d, c) {
        C3X$jscomp$8.RequireFiniteNumber(b);
        C3X$jscomp$8.RequireFiniteNumber(d);
        C3X$jscomp$8.RequireObject(c);
        const e = map$jscomp$6.get(this).GetWorldInfo();
        e.SetMeshPoint(b, d, c) && e.SetBboxChanged()
    }
    getMeshSize() {
        var b = map$jscomp$6.get(this).GetWorldInfo();
        if (!b.HasMesh())
            return [0, 0];
        b = b.GetSourceMesh();
        return [b.GetHSize(), b.GetVSize()]
    }
}
;
"use strict";
const C3X$jscomp$9 = self.C3X
  , map$jscomp$7 = new WeakMap;
self.IDOMInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$7.set(this, self.IInstance._GetInitInst())
    }
    getElement() {
        return map$jscomp$7.get(this).GetSdkInstance()._GetElementInDOMMode()
    }
    focus() {
        map$jscomp$7.get(this).GetSdkInstance().FocusElement()
    }
    blur() {
        map$jscomp$7.get(this).GetSdkInstance().BlurElement()
    }
    setCssStyle(a, b) {
        C3X$jscomp$9.RequireString(a);
        map$jscomp$7.get(this).GetSdkInstance().SetElementCSSStyle(a, b)
    }
}
;
"use strict";
const C3$jscomp$68 = self.C3
  , C3X$jscomp$10 = self.C3X
  , map$jscomp$8 = new WeakMap
  , dispatchers$jscomp$1 = new WeakMap;
function GetDispatcher$jscomp$1(a) {
    let b = dispatchers$jscomp$1.get(a);
    if (b)
        return b;
    b = C3$jscomp$68.New(C3$jscomp$68.Event.Dispatcher);
    dispatchers$jscomp$1.set(a, b);
    return b
}
let initBehInst = null;
self.IBehaviorInstance = class {
    constructor() {
        map$jscomp$8.set(this, initBehInst);
        const a = {
            runtime: {
                value: initBehInst.GetRuntime().GetIRuntime(),
                writable: !1
            },
            behavior: {
                value: initBehInst.GetBehavior().GetIBehavior(),
                writable: !1
            }
        };
        Object.defineProperties(this, a)
    }
    static _Init(a) {
        initBehInst = a
    }
    static _GetInitInst() {
        return initBehInst
    }
    get instance() {
        return map$jscomp$8.get(this).GetObjectInstance().GetInterfaceClass()
    }
    _Release() {
        const a = dispatchers$jscomp$1.get(this);
        a && (a.Release(),
        dispatchers$jscomp$1.delete(this));
        map$jscomp$8.delete(this)
    }
    addEventListener(a, b, d) {
        C3X$jscomp$10.RequireString(a);
        C3X$jscomp$10.RequireFunction(b);
        GetDispatcher$jscomp$1(this).addEventListener(a, b, d)
    }
    removeEventListener(a, b, d) {
        C3X$jscomp$10.RequireString(a);
        C3X$jscomp$10.RequireFunction(b);
        GetDispatcher$jscomp$1(this).removeEventListener(a, b, d)
    }
    dispatchEvent(a) {
        GetDispatcher$jscomp$1(this).dispatchEvent(a)
    }
}
;
"use strict";
const map$jscomp$9 = new WeakMap;
self.IBehavior = class {
    constructor(a) {
        map$jscomp$9.set(this, a);
        a = {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            }
        };
        Object.defineProperties(this, a)
    }
    getAllInstances() {
        return map$jscomp$9.get(this).GetInstances().map(a=>a.GetInterfaceClass())
    }
}
;
"use strict";
const C3$jscomp$70 = self.C3
  , C3X$jscomp$12 = self.C3X
  , map$jscomp$10 = new WeakMap
  , tempColor$jscomp$3 = C3$jscomp$70.New(C3$jscomp$70.Color);
self.IEffectInstance = class {
    constructor(a, b) {
        map$jscomp$10.set(this, a);
        Object.defineProperties(this, {
            index: {
                value: b,
                writable: !1
            }
        })
    }
    get name() {
        return map$jscomp$10.get(this).GetAllEffectTypes()[this.index].GetName()
    }
    get isActive() {
        return map$jscomp$10.get(this).IsEffectIndexActive(this.index)
    }
    set isActive(a) {
        a = !!a;
        const b = map$jscomp$10.get(this);
        b.IsEffectIndexActive(this.index) !== a && (b.SetEffectIndexActive(this.index, a),
        b.UpdateActiveEffects(),
        b.GetRuntime().UpdateRender())
    }
    setParameter(a, b) {
        C3X$jscomp$12.RequireFiniteNumber(a);
        a = Math.floor(+a);
        const d = map$jscomp$10.get(this)
          , c = d.GetEffectParameter(this.index, a);
        if (null === c)
            throw new RangeError("invalid index");
        if (c instanceof C3$jscomp$70.Color) {
            if (!Array.isArray(b) || 3 > b.length)
                throw new TypeError("expected array with 3 elements");
            tempColor$jscomp$3.setRgb(b[0], b[1], b[2]);
            b = tempColor$jscomp$3
        } else if ("number" !== typeof b)
            throw new TypeError("expected number");
        d.SetEffectParameter(this.index, a, b) && d.IsEffectIndexActive(this.index) && d.GetRuntime().UpdateRender()
    }
    getParameter(a) {
        C3X$jscomp$12.RequireFiniteNumber(a);
        a = Math.floor(+a);
        a = map$jscomp$10.get(this).GetEffectParameter(this.index, a);
        if (null === a)
            throw new RangeError("invalid index");
        return a instanceof C3$jscomp$70.Color ? [a.getR(), a.getG(), a.getB()] : a
    }
}
;
"use strict";
const map$jscomp$11 = new WeakMap;
self.IAnimation = class {
    constructor(a) {
        map$jscomp$11.set(this, a);
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            },
            speed: {
                value: a.GetSpeed(),
                writable: !1
            },
            isLooping: {
                value: a.IsLooping(),
                writable: !1
            },
            repeatCount: {
                value: a.GetRepeatCount(),
                writable: !1
            },
            repeatTo: {
                value: a.GetRepeatTo(),
                writable: !1
            },
            isPingPong: {
                value: a.IsPingPong(),
                writable: !1
            },
            frameCount: {
                value: a.GetFrameCount(),
                writable: !1
            }
        })
    }
    getFrames() {
        return map$jscomp$11.get(this).GetFrames().map(a=>a.GetIAnimationFrame())
    }
    *frames() {
        for (const a of map$jscomp$11.get(this).GetFrames())
            yield a.GetIAnimationFrame()
    }
}
;
"use strict";
const map$jscomp$12 = new WeakMap;
self.IImageInfo = class {
    constructor(a) {
        map$jscomp$12.set(this, a)
    }
    get width() {
        return map$jscomp$12.get(this).GetWidth()
    }
    get height() {
        return map$jscomp$12.get(this).GetHeight()
    }
    getSize() {
        const a = map$jscomp$12.get(this);
        return [a.GetWidth(), a.GetHeight()]
    }
}
;
"use strict";
const map$jscomp$13 = new WeakMap;
self.IAnimationFrame = class extends self.IImageInfo {
    constructor(a) {
        super(a.GetImageInfo());
        map$jscomp$13.set(this, a);
        Object.defineProperties(this, {
            duration: {
                value: a.GetDuration(),
                writable: !1
            },
            originX: {
                value: a.GetOriginX(),
                writable: !1
            },
            originY: {
                value: a.GetOriginY(),
                writable: !1
            }
        })
    }
    getOrigin() {
        const a = map$jscomp$13.get(this);
        return [a.GetOriginX(), a.GetOriginY()]
    }
}
;
"use strict";
const C3X$jscomp$16 = self.C3X
  , map$jscomp$14 = new WeakMap;
function GetTimelineState(a) {
    a = map$jscomp$14.get(a);
    if (a.IsReleased())
        throw Error("timeline/tween was released and is no longer valid");
    return a
}
self.ITimelineState = class {
    constructor(a) {
        map$jscomp$14.set(this, a)
    }
    pause() {
        GetTimelineState(this).Stop()
    }
    resume() {
        GetTimelineState(this).Resume()
    }
    hasTags(a) {
        return GetTimelineState(this).HasTags(a)
    }
    set time(a) {
        C3X$jscomp$16.RequireFiniteNumber(a);
        GetTimelineState(this).SetTime(a)
    }
    get time() {
        return GetTimelineState(this).GetTime()
    }
    set totalTime(a) {
        C3X$jscomp$16.RequireFiniteNumber(a);
        GetTimelineState(this).SetTotalTime(a)
    }
    get totalTime() {
        return GetTimelineState(this).GetTotalTime()
    }
    set isLooping(a) {
        GetTimelineState(this).SetLoop(!!a)
    }
    get isLooping() {
        return GetTimelineState(this).GetLoop()
    }
    set isPingPong(a) {
        GetTimelineState(this).SetPingPong(!!a)
    }
    get isPingPong() {
        return GetTimelineState(this).GetPingPong()
    }
    set playbackRate(a) {
        C3X$jscomp$16.RequireFiniteNumber(a);
        GetTimelineState(this).SetPlaybackRate(a)
    }
    get playbackRate() {
        return GetTimelineState(this).GetPlaybackRate()
    }
    get progress() {
        const a = GetTimelineState(this);
        return a.GetTime() / a.GetTotalTime()
    }
    get tags() {
        return GetTimelineState(this).GetTags()
    }
    get finished() {
        return GetTimelineState(this).GetPlayPromise()
    }
    get isPlaying() {
        return GetTimelineState(this).IsPlaying()
    }
    get isPaused() {
        return GetTimelineState(this).IsPaused()
    }
    get isReleased() {
        return map$jscomp$14.get(this).IsReleased()
    }
}
;
"use strict";
const C3X$jscomp$17 = self.C3X
  , map$jscomp$15 = new WeakMap
  , behInstMap = new WeakMap;
let easeToIndexFunc = null;
function GetTweenState(a) {
    a = map$jscomp$15.get(a);
    if (a.IsReleased())
        throw Error("timeline/tween was released and is no longer valid");
    return a
}
self.ITweenState = class extends self.ITimelineState {
    constructor(a, b, d) {
        super(a);
        easeToIndexFunc || (easeToIndexFunc = d.easeToIndexFunc);
        map$jscomp$15.set(this, a);
        b && behInstMap.set(this, b)
    }
    stop() {
        const a = GetTweenState(this);
        behInstMap.get(this).ReleaseTween(a)
    }
    setEase(a) {
        C3X$jscomp$17.RequireString(a);
        a = self.Ease.GetEaseFromIndex(easeToIndexFunc(a));
        GetTweenState(this).SetEase(a)
    }
    get instance() {
        const a = GetTweenState(this).GetInstance();
        return a ? a.GetInterfaceClass() : null
    }
    get isDestroyOnComplete() {
        return GetTweenState(this).GetDestroyInstanceOnComplete()
    }
    set isDestroyOnComplete(a) {
        GetTweenState(this).SetDestroyInstanceOnComplete(!!a)
    }
    get value() {
        const a = GetTweenState(this);
        if ("value" !== a.GetId())
            throw Error("not a value tween");
        return a.GetPropertyTrack("value").GetSourceAdapterValue()
    }
}
;
"use strict";
const C3$jscomp$76 = self.C3
  , VALID_LOAD_POLICIES = new Set(["local", "remote"])
  , EXT_TO_TYPE = new Map([["mp4", "video/mp4"], ["webm", "video/webm"], ["m4a", "audio/mp4"], ["mp3", "audio/mpeg"], ["js", "application/javascript"], ["wasm", "application/wasm"], ["svg", "image/svg+xml"], ["html", "text/html"]]);
function GetTypeFromFileExtension(a) {
    if (!a)
        return "";
    a = a.split(".");
    if (2 > a.length)
        return "";
    a = a.at(-1).toLowerCase();
    return EXT_TO_TYPE.get(a) || ""
}
function AddScript(a) {
    return new Promise((b,d)=>{
        const c = document.createElement("script");
        c.onload = b;
        c.onerror = d;
        c.async = !1;
        c.type = "module";
        c.src = a;
        document.head.appendChild(c)
    }
    )
}
C3$jscomp$76.AssetManager = class extends C3$jscomp$76.DefendedBase {
    constructor(a, b) {
        super();
        var d = b.exportType;
        this._runtime = a;
        this._fileStructure = "folders";
        this._localUrlBlobs = new Map;
        this._localBlobUrlCache = new Map;
        this._localBlobSWUrls = new Map;
        this._isCordova = "cordova" === d;
        this._isiOSCordova = !!b.isiOSCordova;
        this._isFileProtocol = !!b.isFileProtocol;
        this._swClientId = b.swClientId;
        this._supportedAudioFormats = b.supportedAudioFormats || {};
        this._audioFiles = new Map;
        this._preloadSounds = !1;
        this._iconsSubfolder = this._fontsSubfolder = this._mediaSubfolder = "";
        this._defaultLoadPolicy = "html5" === d || "scirra-arcade" === d || "instant-games" === d ? "remote" : "local";
        this._allAssets = [];
        this._assetsByUrl = new Map;
        this._webFonts = [];
        this._loadPromises = [];
        this._hasFinishedInitialLoad = !1;
        this._lastLoadProgress = this._assetSizeLoaded = this._totalAssetSizeToLoad = 0;
        this._hasHadErrorLoading = !1;
        this._loadingRateLimiter = C3$jscomp$76.New(C3$jscomp$76.RateLimiter, ()=>this._FireLoadingProgressEvent(), 50);
        this._promiseThrottle = new C3$jscomp$76.PromiseThrottle(Math.max(C3$jscomp$76.hardwareConcurrency, 8));
        if (a = b.previewImageBlobs) {
            (d = b.previewProjectFileBlobs) && Object.assign(a, d);
            (d = b.projectData) && (a["data.json"] = d);
            for (const [c,e] of Object.entries(a))
                this._localUrlBlobs.set(c, e)
        }
        if (b = b.previewProjectFileSWUrls)
            for (const [c,e] of Object.entries(b))
                this._localBlobSWUrls.set(c, e);
        this._iAssetManager = new self.IAssetManager(this)
    }
    Release() {
        this._localUrlBlobs.clear();
        for (const a of this._localBlobUrlCache.values())
            a.startsWith("blob:") && URL.revokeObjectURL(a);
        this._localBlobUrlCache.clear();
        for (const a of this._allAssets)
            a.Release();
        C3$jscomp$76.clearArray(this._allAssets);
        this._assetsByUrl.clear();
        C3$jscomp$76.clearArray(this._loadPromises);
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    _SetFileStructure(a) {
        this._fileStructure = a;
        if ("flat" === a) {
            a = new Map;
            for (const [b,d] of this._localUrlBlobs.entries())
                a.set(b.toLowerCase(), d);
            this._localUrlBlobs = a
        }
    }
    GetFileStructure() {
        return this._fileStructure
    }
    _SetMediaSubfolder(a) {
        this._mediaSubfolder = a
    }
    GetMediaSubfolder() {
        return this._mediaSubfolder
    }
    _SetFontsSubfolder(a) {
        this._fontsSubfolder = a
    }
    GetFontsSubfolder() {
        return this._fontsSubfolder
    }
    _SetIconsSubfolder(a) {
        this._iconsSubfolder = a
    }
    GetIconsSubfolder() {
        return this._iconsSubfolder
    }
    IsFileProtocol() {
        return this._isFileProtocol
    }
    _HasLocalUrlBlob(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return this._localUrlBlobs.has(a)
    }
    _GetLocalUrlBlob(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return this._localUrlBlobs.get(a) || null
    }
    GetLocalUrlAsBlobUrl(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        if (!this._HasLocalUrlBlob(a))
            return a;
        var b = this._localBlobUrlCache.get(a);
        b || (b = this._GetLocalUrlBlob(a),
        b = URL.createObjectURL(b),
        this._localBlobUrlCache.set(a, b));
        return b
    }
    FetchBlob(a, b) {
        b = b || this._defaultLoadPolicy;
        const d = this._GetLocalUrlBlob(a);
        return d ? Promise.resolve(d) : C3$jscomp$76.IsRelativeURL(a) ? ("flat" === this._fileStructure && (a = a.toLowerCase()),
        this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(a) : "local" === b ? this._promiseThrottle.Add(()=>C3$jscomp$76.FetchBlob(a)) : C3$jscomp$76.FetchBlob(a)) : C3$jscomp$76.FetchBlob(a)
    }
    FetchArrayBuffer(a) {
        const b = this._GetLocalUrlBlob(a);
        return b ? C3$jscomp$76.BlobToArrayBuffer(b) : C3$jscomp$76.IsRelativeURL(a) ? ("flat" === this._fileStructure && (a = a.toLowerCase()),
        this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(a) : "local" === this._defaultLoadPolicy ? this._promiseThrottle.Add(()=>C3$jscomp$76.FetchArrayBuffer(a)) : C3$jscomp$76.FetchArrayBuffer(a)) : C3$jscomp$76.FetchArrayBuffer(a)
    }
    FetchText(a) {
        const b = this._GetLocalUrlBlob(a);
        return b ? C3$jscomp$76.BlobToString(b) : C3$jscomp$76.IsRelativeURL(a) ? ("flat" === this._fileStructure && (a = a.toLowerCase()),
        this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(a) : "local" === this._defaultLoadPolicy ? this._promiseThrottle.Add(()=>C3$jscomp$76.FetchText(a)) : C3$jscomp$76.FetchText(a)) : C3$jscomp$76.FetchText(a)
    }
    async FetchJson(a) {
        a = await this.FetchText(a);
        return JSON.parse(a)
    }
    _CordovaFetchLocalFileAs(a, b) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return this._runtime.PostComponentMessageToDOMAsync("runtime", "cordova-fetch-local-file", {
            filename: a,
            as: b
        })
    }
    CordovaFetchLocalFileAsText(a) {
        return this._CordovaFetchLocalFileAs(a, "text")
    }
    async CordovaFetchLocalFileAsBlob(a) {
        const b = await this._CordovaFetchLocalFileAs(a, "buffer");
        a = GetTypeFromFileExtension(a);
        return new Blob([b],{
            type: a
        })
    }
    async CordovaFetchLocalFileAsBlobURL(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        var b = this._localBlobUrlCache.get(a);
        if (b)
            return b;
        b = await this.CordovaFetchLocalFileAsBlob(a);
        b = URL.createObjectURL(b);
        this._localBlobUrlCache.set(a, b);
        return b
    }
    CordovaFetchLocalFileAsArrayBuffer(a) {
        return this._CordovaFetchLocalFileAs(a, "buffer")
    }
    GetMediaFileUrl(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        a = this._mediaSubfolder + a;
        return this._HasLocalUrlBlob(a) ? this.GetLocalUrlAsBlobUrl(a) : a
    }
    GetProjectFileUrl(a) {
        if (C3$jscomp$76.IsAbsoluteURL(a))
            return Promise.resolve(a);
        if (this._HasLocalUrlBlob(a))
            return Promise.resolve(this.GetLocalUrlAsBlobUrl(a));
        if (this._isCordova && this._isFileProtocol)
            return this.CordovaFetchLocalFileAsBlobURL(a);
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return Promise.resolve(a)
    }
    GetProjectFileIframeUrl(a) {
        if (C3$jscomp$76.IsAbsoluteURL(a))
            return Promise.resolve(a);
        var b = a.indexOf("?")
          , d = -1 === b ? "" : a.substr(b);
        b = -1 === b ? a : a.substr(0, b);
        if (this._HasLocalUrlBlob(b))
            return a = this._localBlobSWUrls.get(b) || this.GetLocalUrlAsBlobUrl(b),
            !a.startsWith("blob:") && this._swClientId && (a = new URL(a),
            d = new URLSearchParams(d),
            d.set("__c3_client_id", this._swClientId),
            a.search = d.toString(),
            a = a.toString()),
            Promise.resolve(a);
        if (this._isCordova && this._isFileProtocol)
            return this.CordovaFetchLocalFileAsBlobURL(b);
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return Promise.resolve(a)
    }
    LoadProjectFileUrl(a) {
        return this.GetProjectFileUrl(a)
    }
    LoadImage(a) {
        if (a.loadPolicy && !VALID_LOAD_POLICIES.has(a.loadPolicy))
            throw Error("invalid load policy");
        let b = this._assetsByUrl.get(a.url);
        if (b)
            return b;
        b = C3$jscomp$76.New(C3$jscomp$76.ImageAsset, this, {
            url: a.url,
            size: a.size || 0,
            loadPolicy: a.loadPolicy || this._defaultLoadPolicy
        });
        this._allAssets.push(b);
        this._assetsByUrl.set(b.GetURL(), b);
        this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += b.GetSize(),
        this._loadPromises.push(b.Load().then(()=>this._AddLoadedSize(b.GetSize()))));
        return b
    }
    async WaitForAllToLoad() {
        try {
            await Promise.all(this._loadPromises),
            this._lastLoadProgress = 1
        } catch (a) {
            console.error("Error loading: ", a),
            this._hasHadErrorLoading = !0,
            this._FireLoadingProgressEvent()
        }
    }
    SetInitialLoadFinished() {
        this._hasFinishedInitialLoad = !0
    }
    HasHadErrorLoading() {
        return this._hasHadErrorLoading
    }
    _AddLoadedSize(a) {
        this._assetSizeLoaded += a;
        this._loadingRateLimiter.Call()
    }
    _FireLoadingProgressEvent() {
        const a = C3$jscomp$76.New(C3$jscomp$76.Event, "loadingprogress");
        this._lastLoadProgress = C3$jscomp$76.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1);
        a.progress = this._lastLoadProgress;
        this._runtime.Dispatcher().dispatchEvent(a)
    }
    GetLoadProgress() {
        return this._lastLoadProgress
    }
    _SetWebFonts(a) {
        C3$jscomp$76.shallowAssignArray(this._webFonts, a);
        this._webFonts.length && this._loadPromises.push(this._LoadWebFonts())
    }
    async _LoadWebFonts() {
        const a = []
          , b = [];
        for (const [d,c,e] of this._webFonts)
            this._totalAssetSizeToLoad += e,
            a.push(this._LoadWebFont(d, c, b).then(()=>this._AddLoadedSize(e)));
        await Promise.all(a);
        this._runtime.IsInWorker() && 0 < b.length && await this._runtime.PostComponentMessageToDOMAsync("runtime", "load-webfonts", {
            webfonts: b
        })
    }
    async _LoadWebFont(a, b, d) {
        try {
            const c = await this.GetProjectFileUrl(b)
              , e = new FontFace(a,`url('${c}')`);
            this._runtime.IsInWorker() ? self.fonts.add(e) : document.fonts.add(e);
            await e.load();
            this._runtime.IsInWorker() && d.push({
                name: a,
                url: c
            })
        } catch (c) {
            console.warn(`[C3 runtime] Failed to load web font '${a}': `, c)
        }
    }
    IsAudioFormatSupported(a) {
        return !!this._supportedAudioFormats[a]
    }
    _SetAudioFiles(a, b) {
        this._preloadSounds = !!b;
        for (const [d,c,e] of a)
            this._audioFiles.set(d, {
                fileName: d,
                formats: c.map(g=>({
                    type: g[0],
                    fileExtension: g[1],
                    fullName: d + g[1],
                    fileSize: g[2]
                })),
                isMusic: e
            })
    }
    GetPreferredAudioFile(a) {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        a = this._audioFiles.get(a);
        if (!a)
            return null;
        let b = null;
        for (const d of a.formats)
            if (b || "audio/webm; codecs=opus" !== d.type || (b = d),
            this.IsAudioFormatSupported(d.type))
                return d;
        return b
    }
    GetProjectAudioFileUrl(a) {
        return (a = this.GetPreferredAudioFile(a)) ? {
            url: this.GetMediaFileUrl(a.fullName),
            type: a.type
        } : null
    }
    GetAudioToPreload() {
        if (this._preloadSounds) {
            const a = [];
            for (const b of this._audioFiles.values()) {
                if (b.isMusic)
                    continue;
                const d = this.GetPreferredAudioFile(b.fileName);
                d && a.push({
                    originalUrl: b.fileName,
                    url: this.GetMediaFileUrl(d.fullName),
                    type: d.type,
                    fileSize: d.fileSize
                })
            }
            return a
        }
        return []
    }
    GetIAssetManager() {
        return this._iAssetManager
    }
    async LoadScripts(...a) {
        const b = await Promise.all(a.map(d=>this.GetProjectFileUrl(d)));
        this._runtime.IsInWorker() ? 1 === a.length ? (a = a[0],
        await self.c3_import((C3$jscomp$76.IsRelativeURL(a) ? "./" : "") + a)) : (a = a.map(d=>`import "${C3$jscomp$76.IsRelativeURL(d) ? "./" : ""}${d}";`).join("\n"),
        a = URL.createObjectURL(new Blob([a],{
            type: "application/javascript"
        })),
        await self.c3_import(a)) : await Promise.all(b.map(d=>AddScript(d)))
    }
    async CompileWebAssembly(a) {
        if (WebAssembly.compileStreaming)
            return a = await this.GetProjectFileUrl(a),
            await WebAssembly.compileStreaming(fetch(a));
        a = await C3$jscomp$76.FetchArrayBuffer(a);
        return await WebAssembly.compile(a)
    }
    async LoadStyleSheet(a) {
        a = await this.GetProjectFileUrl(a);
        return await this._runtime.PostComponentMessageToDOMAsync("runtime", "add-stylesheet", {
            url: a
        })
    }
}
;
"use strict";
const C3$jscomp$77 = self.C3;
C3$jscomp$77.Asset = class extends C3$jscomp$77.DefendedBase {
    constructor(a, b) {
        super();
        this._assetManager = a;
        this._runtime = a.GetRuntime();
        this._url = b.url;
        this._size = b.size;
        this._loadPolicy = b.loadPolicy;
        this._blob = null;
        this._isLoaded = !1;
        this._loadPromise = null
    }
    Release() {
        this._blob = this._runtime = this._assetManager = this._loadPromise = null
    }
    GetURL() {
        return this._url
    }
    GetSize() {
        return this._size
    }
    Load() {
        return "local" === this._loadPolicy || this._blob ? (this._isLoaded = !0,
        Promise.resolve()) : this._loadPromise ? this._loadPromise : this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then(a=>{
            this._isLoaded = !0;
            this._loadPromise = null;
            return this._blob = a
        }
        ).catch(a=>console.error("Error loading resource: ", a))
    }
    IsLoaded() {
        return this._isLoaded
    }
    GetBlob() {
        return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy)
    }
}
;
"use strict";
const C3$jscomp$78 = self.C3
  , promiseThrottle = new C3$jscomp$78.PromiseThrottle
  , allImageAssets = new Set;
C3$jscomp$78.ImageAsset = class extends C3$jscomp$78.Asset {
    constructor(a, b) {
        super(a, b);
        this._webglTexture = this._texturePromise = null;
        this._refCount = 0;
        this._imageHeight = this._imageWidth = -1;
        allImageAssets.add(this)
    }
    Release() {
        this.ReleaseTexture();
        if (0 !== this._refCount)
            throw Error("released image asset which still has texture references");
        this._texturePromise = null;
        allImageAssets.delete(this);
        super.Release()
    }
    static OnRendererContextLost() {
        for (const a of allImageAssets)
            a._texturePromise = null,
            a._webglTexture = null,
            a._refCount = 0
    }
    LoadStaticTexture(a, b) {
        b = b || {};
        this._refCount++;
        if (this._webglTexture)
            return Promise.resolve(this._webglTexture);
        if (this._texturePromise)
            return this._texturePromise;
        b.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy();
        return this._texturePromise = this.GetBlob().then(d=>promiseThrottle.Add(()=>a.CreateStaticTextureAsync(d, b).then(c=>{
            this._texturePromise = null;
            if (0 === this._refCount)
                return a.DeleteTexture(c),
                null;
            this._webglTexture = c;
            this._imageWidth = c.GetWidth();
            this._imageHeight = c.GetHeight();
            return this._webglTexture
        }
        ))).catch(d=>{
            console.error("Failed to load texture: ", d);
            throw d;
        }
        )
    }
    ReleaseTexture() {
        if (0 >= this._refCount)
            throw Error("texture released too many times");
        this._refCount--;
        0 === this._refCount && this._webglTexture && (this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture),
        this._webglTexture = null)
    }
    GetTexture() {
        return this._webglTexture
    }
    GetWidth() {
        return this._imageWidth
    }
    GetHeight() {
        return this._imageHeight
    }
    async LoadToDrawable() {
        const a = await this.GetBlob();
        return C3$jscomp$78.Supports.ImageBitmapOptions ? await createImageBitmap(a, {
            premultiplyAlpha: "none"
        }) : C3$jscomp$78.Supports.ImageBitmap ? await createImageBitmap(a) : await C3$jscomp$78.BlobToImage(a)
    }
}
;
"use strict";
const C3$jscomp$79 = self.C3;
function SortByInstLastCachedZIndex(a, b) {
    return a.GetWorldInfo()._GetLastCachedZIndex() - b.GetWorldInfo()._GetLastCachedZIndex()
}
C3$jscomp$79.RenderCell = class extends C3$jscomp$79.DefendedBase {
    constructor(a, b, d) {
        super();
        this._grid = a;
        this._x = b;
        this._y = d;
        this._instances = [];
        this._isSorted = !0;
        this._pendingRemoval = new Set;
        this._isAnyPendingRemoval = !1
    }
    Release() {
        C3$jscomp$79.clearArray(this._instances);
        this._pendingRemoval.clear();
        this._grid = null
    }
    Reset() {
        C3$jscomp$79.clearArray(this._instances);
        this._isSorted = !0;
        this._pendingRemoval.clear();
        this._isAnyPendingRemoval = !1
    }
    SetChanged() {
        this._isSorted = !1
    }
    IsEmpty() {
        if (!this._instances.length)
            return !0;
        if (this._instances.length > this._pendingRemoval.size)
            return !1;
        this._FlushPending();
        return !0
    }
    Insert(a) {
        this._pendingRemoval.has(a) ? (this._pendingRemoval.delete(a),
        0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = !1)) : (this._instances.push(a),
        this._isSorted = 1 === this._instances.length)
    }
    Remove(a) {
        this._pendingRemoval.add(a);
        this._isAnyPendingRemoval = !0;
        50 <= this._pendingRemoval.size && this._FlushPending()
    }
    _FlushPending() {
        this._isAnyPendingRemoval && (this._instances.length === this._pendingRemoval.size ? this.Reset() : (C3$jscomp$79.arrayRemoveAllInSet(this._instances, this._pendingRemoval),
        this._pendingRemoval.clear(),
        this._isAnyPendingRemoval = !1))
    }
    _EnsureSorted() {
        this._isSorted || (this._instances.sort(SortByInstLastCachedZIndex),
        this._isSorted = !0)
    }
    Dump(a) {
        this._FlushPending();
        this._EnsureSorted();
        this._instances.length && a.push(this._instances)
    }
}
;
"use strict";
const C3$jscomp$80 = self.C3;
C3$jscomp$80.RenderGrid = class extends C3$jscomp$80.DefendedBase {
    constructor(a, b) {
        super();
        this._cellWidth = a;
        this._cellHeight = b;
        this._cells = C3$jscomp$80.New(C3$jscomp$80.PairMap)
    }
    Release() {
        this._cells.Release();
        this._cells = null
    }
    GetCell(a, b, d) {
        let c = this._cells.Get(a, b);
        return c ? c : d ? (c = C3$jscomp$80.New(C3$jscomp$80.RenderCell, this, a, b),
        this._cells.Set(a, b, c),
        c) : null
    }
    XToCell(a) {
        return Math.floor(a / this._cellWidth)
    }
    YToCell(a) {
        return Math.floor(a / this._cellHeight)
    }
    Update(a, b, d) {
        if (b)
            for (let c = b.getLeft(), e = b.getRight(); c <= e; ++c)
                for (let g = b.getTop(), k = b.getBottom(); g <= k; ++g) {
                    if (d && d.containsPoint(c, g))
                        continue;
                    const l = this.GetCell(c, g, !1);
                    l && (l.Remove(a),
                    l.IsEmpty() && this._cells.Delete(c, g))
                }
        if (d)
            for (let c = d.getLeft(), e = d.getRight(); c <= e; ++c)
                for (let g = d.getTop(), k = d.getBottom(); g <= k; ++g)
                    b && b.containsPoint(c, g) || this.GetCell(c, g, !0).Insert(a)
    }
    QueryRange(a, b) {
        let d = this.XToCell(a.getLeft());
        const c = this.YToCell(a.getTop())
          , e = this.XToCell(a.getRight());
        for (a = this.YToCell(a.getBottom()); d <= e; ++d)
            for (let g = c; g <= a; ++g) {
                const k = this.GetCell(d, g, !1);
                k && k.Dump(b)
            }
    }
    MarkRangeChanged(a) {
        let b = a.getLeft();
        const d = a.getTop()
          , c = a.getRight();
        for (a = a.getBottom(); b <= c; ++b)
            for (let e = d; e <= a; ++e) {
                const g = this.GetCell(b, e, !1);
                g && g.SetChanged()
            }
    }
}
;
"use strict";
const C3$jscomp$81 = self.C3
  , tmpRect$jscomp$2 = new C3$jscomp$81.Rect
  , tmpQuad$jscomp$2 = new C3$jscomp$81.Quad
  , renderCellArr = [];
new C3$jscomp$81.Rect;
new C3$jscomp$81.Rect;
const glMatrix$jscomp$8 = self.glMatrix
  , vec3$jscomp$6 = glMatrix$jscomp$8.vec3
  , vec4$jscomp$5 = glMatrix$jscomp$8.vec4
  , mat4$jscomp$9 = glMatrix$jscomp$8.mat4
  , tempMat4$jscomp$4 = mat4$jscomp$9.create()
  , tempVec3 = vec3$jscomp$6.create()
  , tempVec4$jscomp$1 = vec4$jscomp$5.create()
  , camVector = vec3$jscomp$6.create()
  , lookVector = vec3$jscomp$6.create()
  , upVector = vec3$jscomp$6.create()
  , tempVec2 = C3$jscomp$81.New(C3$jscomp$81.Vector2);
C3$jscomp$81.New(C3$jscomp$81.Rect);
function SortByInstLastCachedZIndex$jscomp$1(a, b) {
    return a.GetWorldInfo()._GetLastCachedZIndex() - b.GetWorldInfo()._GetLastCachedZIndex()
}
function SortByInstZElevation(a, b) {
    return a.GetWorldInfo().GetZElevation() - b.GetWorldInfo().GetZElevation()
}
const tempInstanceList1 = []
  , tempInstanceList2 = []
  , tempInstancesByCameraDist = [];
C3$jscomp$81.Layer = class extends C3$jscomp$81.DefendedBase {
    constructor(a, b, d) {
        super();
        this._layout = a;
        this._runtime = a.GetRuntime();
        this._parentLayer = b;
        this._name = d[0];
        this._index = -1;
        this._sid = d[2];
        this._isVisible = !!d[3];
        this._isInteractive = !!d[13];
        this._backgroundColor = C3$jscomp$81.New(C3$jscomp$81.Color);
        this._backgroundColor.setFromJSON(d[4].map(e=>e / 255));
        this._isTransparent = !!d[5];
        this._parallaxX = d[6];
        this._parallaxY = d[7];
        this._color = C3$jscomp$81.New(C3$jscomp$81.Color, 1, 1, 1, d[8]);
        this._premultipliedColor = C3$jscomp$81.New(C3$jscomp$81.Color);
        this._isForceOwnTexture = d[9];
        this._renderAs3d = d[17];
        this._useCameraDistanceDrawOrder = d[18];
        this._useRenderCells = d[10];
        this._scaleRate = d[11];
        this._blendMode = d[12];
        this._curRenderTarget = null;
        this._scale = 1;
        this._zElevation = d[16];
        this._scrollY = this._scrollX = this._angle = 0;
        this._hasOwnScrollPosition = !1;
        this._viewport = C3$jscomp$81.New(C3$jscomp$81.Rect);
        this._viewportZ0 = C3$jscomp$81.New(C3$jscomp$81.Rect);
        this._viewport3D = C3$jscomp$81.New(C3$jscomp$81.Rect);
        this._isViewportChanged = !0;
        this._projectionMatrix = mat4$jscomp$9.create();
        this._isProjectionMatrixChanged = !0;
        this._modelViewMatrix = mat4$jscomp$9.create();
        this._isMVMatrixChanged = !0;
        this._viewFrustum = C3$jscomp$81.New(C3$jscomp$81.Gfx.ViewFrustum);
        this._isViewFrustumChanged = !0;
        this._startupInitialInstances = [];
        this._initialInstancesData = d[14];
        this._initialInstances = [];
        this._createdGlobalUids = [];
        this._initialUIDsToInstanceData = new Map;
        this._instances = [];
        this._anyInstanceZElevated = this._zIndicesUpToDate = !1;
        const c = this._runtime.GetCanvasManager();
        this._effectList = C3$jscomp$81.New(C3$jscomp$81.EffectList, this, d[15]);
        this._effectChain = C3$jscomp$81.New(C3$jscomp$81.Gfx.EffectChain, c.GetEffectChainManager(), {
            drawContent: (e,g)=>{
                g = g.GetContentObject();
                const k = g.GetRenderTarget();
                e.SetColor(g.GetPremultipliedColor());
                e.DrawRenderTarget(k);
                e.InvalidateRenderTarget(k);
                c.ReleaseAdditionalRenderTarget(k)
            }
            ,
            getShaderParameters: e=>this.GetEffectList()._GetEffectChainShaderParametersForIndex(e)
        });
        this._wasDefaultColor = this._needsRebuildEffectChainSteps = !0;
        this._renderGrid = null;
        this._lastRenderList = [];
        this._isRenderListUpToDate = !1;
        this._lastRenderCells = C3$jscomp$81.New(C3$jscomp$81.Rect, 0, 0, -1, -1);
        this._curRenderCells = C3$jscomp$81.New(C3$jscomp$81.Rect, 0, 0, -1, -1);
        this._iLayer = null;
        this._UpdatePremultipliedColor();
        this.UsesRenderCells() && (this._renderGrid = C3$jscomp$81.New(C3$jscomp$81.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight()));
        this._subLayers = d[19].map(e=>C3$jscomp$81.New(C3$jscomp$81.Layer, this._layout, this, e))
    }
    _Init() {
        for (const a of this._initialInstancesData) {
            const b = this._runtime.GetObjectClassByIndex(a[1]);
            this._layout._AddInitialObjectClass(b);
            b.GetDefaultInstanceData() || (b.SetDefaultInstanceData(a),
            b._SetDefaultLayerIndex(this._index));
            this._initialInstances.push(a);
            this._initialUIDsToInstanceData.set(a[2], a)
        }
        C3$jscomp$81.shallowAssignArray(this._startupInitialInstances, this._initialInstances);
        this._initialInstancesData = null;
        this._iLayer = new self.ILayer(this)
    }
    Release() {
        this._runtime = this._layout = null
    }
    GetInitialInstanceData(a) {
        return this._initialUIDsToInstanceData.get(a)
    }
    CreateInitialInstances(a) {
        const b = this._layout.IsFirstVisit();
        let d = 0;
        const c = this._initialInstances;
        for (let g = 0, k = c.length; g < k; ++g) {
            var e = c[g];
            const l = this._runtime.GetObjectClassByIndex(e[1]);
            let n = !0;
            if (!l.HasPersistBehavior() || b)
                e = this._runtime.CreateInstanceFromData(e, this, !0),
                a.push(e),
                l.IsGlobal() && (n = !1,
                this._createdGlobalUids.push(e.GetUID()));
            n && (c[d] = c[g],
            ++d)
        }
        C3$jscomp$81.truncateArray(c, d);
        this._runtime.FlushPendingInstances();
        this.SetZIndicesChanged()
    }
    _AddInstance(a, b) {
        if (!a.GetPlugin().IsWorldType())
            throw Error("instance is not of world type");
        const d = a.GetWorldInfo();
        if (d.GetLayer() !== this)
            throw Error("instance added to wrong layer");
        this._instances.push(a);
        0 !== d.GetZElevation() && (this._anyInstanceZElevated = !0);
        b && this.UsesRenderCells() && a.GetWorldInfo().SetBboxChanged();
        this.SetZIndicesChanged()
    }
    _MaybeAddInstance(a) {
        this._instances.includes(a) || (this._instances.push(a),
        0 !== a.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = !0),
        this.SetZIndicesChanged())
    }
    _PrependInstance(a, b) {
        const d = a.GetWorldInfo();
        if (d.GetLayer() !== this)
            throw Error("instance added to wrong layer");
        this._instances.unshift(a);
        0 !== d.GetZElevation() && (this._anyInstanceZElevated = !0);
        this.SetZIndicesChanged();
        b && this.UsesRenderCells() && a.GetWorldInfo().SetBboxChanged()
    }
    _RemoveInstance(a, b) {
        const d = this._instances.indexOf(a);
        0 > d || (b && this.UsesRenderCells() && a.GetWorldInfo()._RemoveFromRenderCells(),
        this._instances.splice(d, 1),
        this.SetZIndicesChanged(),
        this._MaybeResetAnyInstanceZElevatedFlag())
    }
    _SetAnyInstanceZElevated() {
        this._anyInstanceZElevated = !0
    }
    _MaybeResetAnyInstanceZElevatedFlag() {
        0 === this._instances.length && (this._anyInstanceZElevated = !1)
    }
    _SortInstancesByLastCachedZIndex(a) {
        if (a) {
            a = new Set;
            for (var b of this._instances) {
                var d = b.GetWorldInfo()._GetLastCachedZIndex();
                0 <= d && a.add(d)
            }
            b = -1;
            for (const c of this._instances)
                if (d = c.GetWorldInfo(),
                !(0 <= d._GetLastCachedZIndex())) {
                    for (++b; a.has(b); )
                        ++b;
                    d._SetZIndex(b)
                }
        }
        this._instances.sort(SortByInstLastCachedZIndex$jscomp$1)
    }
    _Start() {}
    _End() {
        for (const a of this._instances)
            a.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(a);
        this._runtime.FlushPendingInstances();
        C3$jscomp$81.clearArray(this._instances);
        this._anyInstanceZElevated = !1;
        this.SetZIndicesChanged()
    }
    RecreateInitialObjects(a, b, d, c, e) {
        const g = this._runtime.GetEventSheetManager()
          , k = this._runtime.GetAllObjectClasses()
          , l = a.IsFamily()
          , n = [];
        for (const w of this._initialInstances) {
            var p = w[0];
            if (b.containsPoint(p[0], p[1])) {
                p = k[w[1]];
                if (p !== a)
                    if (l) {
                        if (!a.FamilyHasMember(p))
                            continue
                    } else
                        continue;
                p = this;
                var t = this._runtime.GetCurrentLayout();
                this.GetLayout() !== t && ((p = t.GetLayerByName(this.GetName())) || (p = t.GetLayerByIndex(this.GetIndex())));
                t = this._runtime.CreateInstanceFromData(w, p, !1, void 0, void 0, !1, e);
                p.SortAndAddInstancesByZIndex(t);
                p = t.GetWorldInfo();
                p.OffsetXY(d, c);
                p.SetBboxChanged();
                g.BlockFlushingInstances(!0);
                t._TriggerOnCreatedOnSelfAndRelated();
                g.BlockFlushingInstances(!1);
                n.push(t)
            }
        }
        return n
    }
    GetInstanceCount() {
        return this._instances.length
    }
    GetLayout() {
        return this._layout
    }
    GetName() {
        return this._name
    }
    _SetIndex(a) {
        this._index = a
    }
    GetIndex() {
        return this._index
    }
    GetSID() {
        return this._sid
    }
    GetRuntime() {
        return this._runtime
    }
    GetDevicePixelRatio() {
        return this._runtime.GetDevicePixelRatio()
    }
    GetEffectList() {
        return this._effectList
    }
    GetEffectChain() {
        this._MaybeRebuildEffectChainSteps();
        return this._effectChain
    }
    _MaybeRebuildEffectChainSteps() {
        const a = this.HasDefaultColor();
        if (this._needsRebuildEffectChainSteps || a !== this._wasDefaultColor || this._effectChain.NeedsRebuild()) {
            var b = this.GetEffectList().GetActiveEffectTypes();
            this._effectChain.BuildSteps(b.map(d=>d.GetShaderProgram()), {
                indexMap: b.map(d=>d.GetIndex()),
                forcePreDraw: !a,
                useFullSurface: !0
            });
            this._needsRebuildEffectChainSteps = !1;
            this._wasDefaultColor = a
        }
    }
    UpdateActiveEffects() {
        this.GetEffectList().UpdateActiveEffects();
        this._needsRebuildEffectChainSteps = !0
    }
    UsesRenderCells() {
        return this._useRenderCells && !this._useCameraDistanceDrawOrder
    }
    GetRenderGrid() {
        return this._renderGrid
    }
    SetRenderListStale() {
        this._isRenderListUpToDate = !1
    }
    IsVisible() {
        for (const a of this.selfAndParentLayers())
            if (!a._IsVisibleFlagSet())
                return !1;
        return !0
    }
    _IsVisibleFlagSet() {
        return this._isVisible
    }
    SetVisible(a) {
        a = !!a;
        this._isVisible !== a && (this._isVisible = a,
        this._runtime.UpdateRender())
    }
    SetInteractive(a) {
        this._isInteractive = !!a
    }
    IsInteractive() {
        return this._isInteractive
    }
    IsSelfAndParentsInteractive() {
        for (const a of this.selfAndParentLayers())
            if (!a.IsInteractive())
                return !1;
        return !0
    }
    SetOwnScrollPositionEnabled(a) {
        a = !!a;
        if (this._hasOwnScrollPosition !== a) {
            if (this._hasOwnScrollPosition = a)
                a = this.GetLayout(),
                this._scrollX = a.GetScrollX(),
                this._scrollY = a.GetScrollY();
            this._SetMVMatrixChanged();
            this._runtime.UpdateRender()
        }
    }
    IsOwnScrollPositionEnabled() {
        return this._hasOwnScrollPosition
    }
    SetScrollX(a) {
        var b = this.GetLayout();
        const d = b.GetScrollLeftBound();
        b = b.GetScrollRightBound();
        a > b && (a = b);
        a < d && (a = d);
        this._scrollX !== a && (this._scrollX = a,
        this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(),
        this._runtime.UpdateRender()))
    }
    SetScrollY(a) {
        var b = this.GetLayout();
        const d = b.GetScrollTopBound();
        b = b.GetScrollBottomBound();
        a > b && (a = b);
        a < d && (a = d);
        this._scrollY !== a && (this._scrollY = a,
        this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(),
        this._runtime.UpdateRender()))
    }
    GetScrollX() {
        return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX()
    }
    GetScrollY() {
        return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY()
    }
    GetViewport() {
        this._MaybeUpdateViewport();
        return this._viewport
    }
    _GetViewportZ0() {
        this._MaybeUpdateViewport();
        return this._viewportZ0
    }
    GetViewport3D() {
        this._MaybeUpdateViewport();
        return this._viewport3D
    }
    _GetVanishingPoint() {
        const a = this.GetLayout();
        return [a.GetVanishingPointX(), a.GetVanishingPointY()]
    }
    GetDefaultCameraZ(a) {
        return this._runtime.GetDefaultCameraZ(a)
    }
    GetViewportForZ(a, b) {
        var d = this._GetViewportZ0();
        if (0 === a)
            b.copy(d);
        else {
            let k = d.midX()
              , l = d.midY();
            var c = this.Get2DScaleFactorToZ(a);
            const n = d.width() / c;
            d = d.height() / c;
            const [p,t] = this._GetVanishingPoint();
            if (.5 !== p || .5 !== t) {
                const w = this.GetCameraZ();
                var e = this._runtime
                  , g = this.GetDefaultCameraZ() / w;
                c = (p - .5) * e.GetViewportWidth() / g;
                e = (t - .5) * e.GetViewportHeight() / g;
                g = this.GetAngle();
                0 !== g && (tempVec2.set(c, e),
                tempVec2.rotate(g),
                c = tempVec2.getX(),
                e = tempVec2.getY());
                a = C3$jscomp$81.unlerp(w, 0, a);
                k += C3$jscomp$81.lerp(c, 0, a);
                l += C3$jscomp$81.lerp(e, 0, a)
            }
            b.set(k - n / 2, l - d / 2, k + n / 2, l + d / 2)
        }
    }
    GetOpacity() {
        return this._color.getA()
    }
    SetOpacity(a) {
        a = C3$jscomp$81.clamp(a, 0, 1);
        this._color.getA() !== a && (this._color.setA(a),
        this._UpdatePremultipliedColor(),
        this._runtime.UpdateRender())
    }
    _UpdatePremultipliedColor() {
        this._premultipliedColor.copy(this._color);
        this._premultipliedColor.premultiply()
    }
    GetPremultipliedColor() {
        return this._premultipliedColor
    }
    HasDefaultColor() {
        return this._color.equalsRgba(1, 1, 1, 1)
    }
    GetScaleRate() {
        return this._scaleRate
    }
    SetScaleRate(a) {
        this._scaleRate !== a && (this._scaleRate = a,
        this._SetMVMatrixChanged(),
        this._runtime.UpdateRender())
    }
    GetParallaxX() {
        return this._parallaxX
    }
    GetParallaxY() {
        return this._parallaxY
    }
    SetParallax(a, b) {
        if (this._parallaxX !== a || this._parallaxY !== b)
            if (this._parallaxX = a,
            this._parallaxY = b,
            this._SetMVMatrixChanged(),
            this._runtime.UpdateRender(),
            1 !== this._parallaxX || 1 !== this._parallaxY)
                for (const d of this._instances)
                    d.GetObjectClass()._SetAnyInstanceParallaxed(!0)
    }
    SetParallaxX(a) {
        this.SetParallax(a, this.GetParallaxY())
    }
    SetParallaxY(a) {
        this.SetParallax(this.GetParallaxX(), a)
    }
    SetZElevation(a) {
        this._zElevation !== a && (this._zElevation = a,
        this._runtime.UpdateRender())
    }
    GetZElevation() {
        return this._zElevation
    }
    SetAngle(a) {
        a = C3$jscomp$81.clampAngle(a);
        this._angle !== a && (this._angle = a,
        this._SetMVMatrixChanged(),
        this._runtime.UpdateRender())
    }
    GetAngle() {
        return C3$jscomp$81.clampAngle(this._layout.GetAngle() + this._angle)
    }
    GetOwnAngle() {
        return this._angle
    }
    HasInstances() {
        return 0 < this._instances.length
    }
    _GetInstances() {
        return this._instances
    }
    _GetInstancesInDrawOrder() {
        return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (C3$jscomp$81.shallowAssignArray(tempInstancesByCameraDist, this._GetInstances()),
        tempInstancesByCameraDist.sort((a,b)=>this._SortInstancesByCameraDistance(a, b)),
        tempInstancesByCameraDist) : this._GetInstances()
    }
    _AppendAllInstancesIncludingSubLayersInDrawOrder(a) {
        C3$jscomp$81.appendArray(a, this._GetInstancesInDrawOrder());
        for (const b of this._subLayers)
            b.IsVisible() && 0 < b.GetOpacity() && b._AppendAllInstancesIncludingSubLayersInDrawOrder(a)
    }
    _SortInstancesByCameraDistance(a, b) {
        var d = this.GetLayout().Get3DCameraPosition()
          , c = d[0]
          , e = d[1];
        d = d[2];
        var g = a.GetWorldInfo();
        const k = b.GetWorldInfo();
        b = g.GetX() - c;
        a = g.GetY() - e;
        g = g.GetZElevation() - d;
        c = k.GetX() - c;
        e = k.GetY() - e;
        d = k.GetZElevation() - d;
        return c * c + e * e + d * d - (b * b + a * a + g * g)
    }
    GetBackgroundColor() {
        return this._backgroundColor
    }
    IsTransparent() {
        return this._isTransparent
    }
    SetTransparent(a) {
        a = !!a;
        this._isTransparent !== a && (this._isTransparent = a,
        this._runtime.UpdateRender())
    }
    IsForceOwnTexture() {
        return this._isForceOwnTexture
    }
    SetForceOwnTexture(a) {
        a = !!a;
        this._isForceOwnTexture !== a && (this._isForceOwnTexture = a,
        this._runtime.UpdateRender())
    }
    RendersIn2DMode() {
        return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d
    }
    RendersIn3DMode() {
        return !this.RendersIn2DMode()
    }
    Has3DCamera() {
        return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled()
    }
    SelfAndAllSubLayersHave3DCamera() {
        if (!this.Has3DCamera())
            return !1;
        for (const a of this._subLayers)
            if (!a.SelfAndAllSubLayersHave3DCamera())
                return !1;
        return !0
    }
    SetBlendMode(a) {
        this._blendMode !== a && (this._blendMode = a,
        this._runtime.UpdateRender())
    }
    GetBlendMode() {
        return this._blendMode
    }
    IsRootLayer() {
        return !this._parentLayer
    }
    GetParentLayer() {
        return this._parentLayer
    }
    GetSubLayers() {
        return this._subLayers
    }
    HasAnySubLayers() {
        return 0 < this._subLayers.length
    }
    HasAnyVisibleSubLayer() {
        for (const a of this._subLayers)
            if (a.ShouldDraw())
                return !0;
        return !1
    }
    *selfAndAllSubLayers() {
        for (const a of this._subLayers)
            yield*a.selfAndAllSubLayers();
        yield this
    }
    *parentLayers() {
        let a = this.GetParentLayer();
        for (; a; )
            yield a,
            a = a.GetParentLayer()
    }
    *selfAndParentLayers() {
        yield this;
        yield*this.parentLayers()
    }
    IsTransformCompatibleWith(a) {
        return this === a || this._parallaxX === a._parallaxX && this._parallaxY === a._parallaxY && this._scale === a._scale && this._scaleRate === a._scaleRate && this._angle === a._angle && this.GetScrollX() === a.GetScrollX() && this.GetScrollY() === a.GetScrollY()
    }
    SaveTransform() {
        return {
            parallaxX: this.GetParallaxX(),
            parallaxY: this.GetParallaxY(),
            scale: this.GetOwnScale(),
            scaleRate: this.GetScaleRate(),
            angle: this.GetOwnAngle(),
            hasOwnScroll: this.IsOwnScrollPositionEnabled(),
            scrollX: this.GetScrollX(),
            scrollY: this.GetScrollY()
        }
    }
    RestoreTransform(a) {
        this.SetParallax(a.parallaxX, a.parallaxY);
        this.SetOwnScale(a.scale);
        this.SetScaleRate(a.scaleRate);
        this.SetAngle(a.angle);
        this.SetOwnScrollPositionEnabled(a.hasOwnScroll);
        this.SetScrollX(a.scrollX);
        this.SetScrollY(a.scrollY);
        this._MaybeUpdateViewport()
    }
    _RemoveAllInstancesInSet(a) {
        0 !== a.size && 0 < C3$jscomp$81.arrayRemoveAllInSet(this._instances, a) && (this._MaybeResetAnyInstanceZElevatedFlag(),
        this.SetZIndicesChanged())
    }
    SetZIndicesChanged() {
        this._isRenderListUpToDate = this._zIndicesUpToDate = !1
    }
    _UpdateZIndices() {
        if (!this._zIndicesUpToDate) {
            this._instances.sort(SortByInstZElevation);
            if (this.UsesRenderCells())
                for (let a = 0, b = this._instances.length; a < b; ++a) {
                    const d = this._instances[a].GetWorldInfo();
                    d._SetZIndex(a);
                    this._renderGrid.MarkRangeChanged(d.GetRenderCellRange())
                }
            else
                for (let a = 0, b = this._instances.length; a < b; ++a)
                    this._instances[a].GetWorldInfo()._SetZIndex(a);
            this._zIndicesUpToDate = !0
        }
    }
    MoveInstanceAdjacent(a, b, d) {
        var c = a.GetWorldInfo();
        b = b.GetWorldInfo();
        if (c.GetLayer() !== this || b.GetLayer() !== this)
            throw Error("can't arrange Z order unless both objects on this layer");
        c = c.GetZIndex();
        b = b.GetZIndex();
        if (c === b + (d ? 1 : -1))
            return !1;
        C3$jscomp$81.arrayRemove(this._instances, c);
        c < b && b--;
        d && b++;
        b === this._instances.length ? this._instances.push(a) : this._instances.splice(b, 0, a);
        this.SetZIndicesChanged();
        return !0
    }
    _MergeSortedZArrays(a, b) {
        const d = [];
        let c = 0
          , e = 0
          , g = a.length
          , k = b.length;
        for (; c < g && e < k; ) {
            const l = a[c]
              , n = b[e];
            l.GetWorldInfo()._GetLastCachedZIndex() < n.GetWorldInfo()._GetLastCachedZIndex() ? (d.push(l),
            ++c) : (d.push(n),
            ++e)
        }
        for (; c < g; ++c)
            d.push(a[c]);
        for (; e < k; ++e)
            d.push(b[e]);
        return d
    }
    _MergeAllSortedZArrays_pass(a) {
        const b = []
          , d = a.length;
        for (let c = 0; c < d - 1; c += 2)
            b.push(this._MergeSortedZArrays(a[c], a[c + 1]));
        1 === d % 2 && b.push(a[d - 1]);
        return b
    }
    _MergeAllSortedZArrays(a) {
        for (; 1 < a.length; )
            a = this._MergeAllSortedZArrays_pass(a);
        return a[0]
    }
    _GetRenderCellInstancesToDraw() {
        this._UpdateZIndices();
        C3$jscomp$81.clearArray(renderCellArr);
        this._renderGrid.QueryRange(this.GetViewport(), renderCellArr);
        return renderCellArr.length ? 1 === renderCellArr.length ? renderCellArr[0] : this._MergeAllSortedZArrays(renderCellArr) : []
    }
    ShouldDraw() {
        return this.IsVisible() && 0 < this.GetOpacity() && this._DrawsAnyContentInSelfOrSubLayers()
    }
    _DrawsAnyContentInSelfOrSubLayers() {
        if (this.HasInstances() || !this.IsTransparent())
            return !0;
        for (const a of this._subLayers)
            if (a._DrawsAnyContentInSelfOrSubLayers())
                return !0;
        return !1
    }
    UsesOwnTexture() {
        return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect()
    }
    SelfOrAnySubLayerUsesOwnTexture() {
        if (this.UsesOwnTexture())
            return !0;
        for (const a of this._subLayers)
            if (a.SelfOrAnySubLayerUsesOwnTexture())
                return !0;
        return !1
    }
    GetRenderTarget() {
        return this._curRenderTarget
    }
    Get2DScaleFactorToZ(a) {
        if (this._layout.IsOrthographicProjection())
            return 1;
        const b = this.GetCameraZ();
        return b / (b - a)
    }
    GetCameraZ(a) {
        return this.GetDefaultCameraZ(a) / this.GetNormalScale()
    }
    _SetMVMatrixChanged() {
        this._isViewportChanged = this._isViewFrustumChanged = this._isMVMatrixChanged = !0
    }
    _GetModelViewMatrix(a) {
        this._isMVMatrixChanged && (this._CalculateModelViewMatrix(a, this._modelViewMatrix, 0, 0, null),
        this._isMVMatrixChanged = !1);
        return this._modelViewMatrix
    }
    GetCameraPosition() {
        if (this.Has3DCamera()) {
            const a = this.GetLayout().Get3DCameraPosition();
            return [a[0], a[1], a[2]]
        }
        return this._Get2DCameraPosition()
    }
    _Get2DCameraPosition(a=0, b=0, d=0) {
        var c = this._runtime
          , e = this.GetLayout()
          , g = c.GetParallaxXOrigin()
          , k = c.GetParallaxYOrigin();
        g = (this.GetScrollX() - g) * this._parallaxX + g;
        k = (this.GetScrollY() - k) * this._parallaxY + k;
        c.IsPixelRoundingEnabled() && (g = Math.round(g),
        k = Math.round(k));
        a = g + a;
        b = k + b;
        e = e.IsOrthographicProjection() ? this.GetDefaultCameraZ(d) : this.GetCameraZ(d);
        const [l,n] = this._GetVanishingPoint();
        if (.5 !== l || .5 !== n)
            k = this.GetDefaultCameraZ(d) / e,
            d = (l - .5) * c.GetViewportWidth() / k,
            c = (n - .5) * c.GetViewportHeight() / k,
            k = this.GetAngle(),
            0 !== k && (tempVec2.set(d, c),
            tempVec2.rotate(k),
            d = tempVec2.getX(),
            c = tempVec2.getY()),
            a += d,
            b += c;
        return [a, b, e]
    }
    _CalculateModelViewMatrix(a, b, d, c, e) {
        const g = this._runtime;
        var k = this.GetLayout();
        if (this.Has3DCamera()) {
            vec3$jscomp$6.copy(camVector, k.Get3DCameraPosition());
            vec3$jscomp$6.copy(lookVector, k.Get3DCameraLookAt());
            vec3$jscomp$6.copy(upVector, k.Get3DCameraUpVector());
            d = g.GetParallaxXOrigin();
            c = g.GetParallaxYOrigin();
            k = lookVector[0] - camVector[0];
            const l = lookVector[1] - camVector[1]
              , n = lookVector[2] - camVector[2];
            camVector[0] = (camVector[0] - d) * this._parallaxX + d;
            camVector[1] = (camVector[1] - c) * this._parallaxY + c;
            camVector[2] *= Math.max(this._parallaxX, this._parallaxY);
            lookVector[0] = camVector[0] + k;
            lookVector[1] = camVector[1] + l;
            lookVector[2] = camVector[2] + n
        } else {
            const [l,n,p] = this._Get2DCameraPosition(d, c, e);
            vec3$jscomp$6.set(camVector, l, n, p);
            vec3$jscomp$6.set(lookVector, l, n, p - 100);
            d = this.GetAngle();
            0 === d ? vec3$jscomp$6.set(upVector, 0, 1, 0) : vec3$jscomp$6.set(upVector, Math.sin(d), Math.cos(d), 0)
        }
        a.CalculateLookAtModelView(b, camVector, lookVector, upVector, e || g.GetViewportHeight())
    }
    _SetProjectionMatrixChanged() {
        this._isViewportChanged = this._isViewFrustumChanged = this._isProjectionMatrixChanged = !0
    }
    _GetProjectionMatrix(a) {
        this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(a),
        this._isProjectionMatrixChanged = !1);
        return this._projectionMatrix
    }
    _CalculateProjectionMatrix(a) {
        var b = this._runtime.GetCanvasManager();
        const [d,c] = this._GetVanishingPoint();
        if (this._layout.IsOrthographicProjection())
            a.CalculateOrthographicMatrix(this._projectionMatrix, b.GetDrawWidth(), b.GetDrawHeight());
        else if (.5 === d && .5 === c)
            mat4$jscomp$9.copy(this._projectionMatrix, b.GetDefaultProjectionMatrix());
        else {
            const e = b.GetDrawWidth();
            b = b.GetDrawHeight();
            a.CalculatePerspectiveMatrix(this._projectionMatrix, e / b, d, c)
        }
    }
    _SetTransform(a, b=!0, d=0, c=0, e=0) {
        b && a.SetProjectionMatrix(this._GetProjectionMatrix(a));
        0 === d && 0 === c && 0 === e ? b = this._GetModelViewMatrix(a) : (this._CalculateModelViewMatrix(a, tempMat4$jscomp$4, d, c, e),
        b = tempMat4$jscomp$4);
        a.SetModelViewMatrix(b)
    }
    PrepareForDraw(a) {
        this._SetTransform(a);
        a.SetBaseZ(this.GetZElevation())
    }
    Draw(a, b, d) {
        var c = this._runtime.GetCanvasManager();
        const e = this.UsesOwnTexture();
        var g = null;
        let k = null;
        if (this._runtime.IsGPUProfiling())
            if (a.IsWebGL()) {
                const l = c.GetLayerTimingsBuffer(this);
                l && (k = l.AddTimeElapsedQuery(),
                a.StartQuery(k))
            } else
                a.IsWebGPU() && a.WriteTimestamp(2 * (this.GetIndex() + 1));
        e ? (g = {
            sampling: this._runtime.GetSampling(),
            isSampled: !0,
            canReadPixels: a.IsWebGPU() ? this._runtime.UsesAnyBackgroundBlending() : !1
        },
        "low" === c.GetCurrentFullscreenScalingQuality() && (g.width = c.GetDrawWidth(),
        g.height = c.GetDrawHeight()),
        this._curRenderTarget = g = this._runtime.GetAdditionalRenderTarget(g),
        a.SetRenderTarget(g),
        this.IsTransparent() && a.ClearRgba(0, 0, 0, 0)) : (this._curRenderTarget = b,
        a.SetRenderTarget(b));
        this.IsTransparent() || a.Clear(this._backgroundColor);
        this._layout._DrawLayerList(a, this._curRenderTarget, this._subLayers, e && this.IsTransparent());
        this._SetTransform(a);
        a.SetBaseZ(this.GetZElevation());
        a.SetDepthEnabled(this.RendersIn3DMode());
        this.GetNormalScale() > Number.EPSILON && (this._UpdateZIndices(),
        c = this.UsesRenderCells() && 0 === this.GetZElevation() && !this._anyInstanceZElevated,
        this.Has3DCamera() ? this._DrawInstances_3DCamera(a) : c ? this._DrawInstances_RenderCells(a) : this._DrawInstances(a, this._GetInstancesInDrawOrder()));
        a.SetBaseZ(0);
        a.SetCurrentZ(0);
        e && (a.SetDepthEnabled(!1),
        this._DrawLayerOwnTextureToRenderTarget(a, g, b, d));
        k && a.EndQuery(k);
        this._runtime.IsGPUProfiling() && a.IsWebGPU() && a.WriteTimestamp(2 * (this.GetIndex() + 1) + 1);
        this._curRenderTarget = null
    }
    _DrawInstances(a, b) {
        const d = this.GetViewport()
          , c = this._curRenderTarget
          , e = this.GetLayout().IsOrthographicProjection()
          , g = this.GetLayout().HasVanishingPointOutsideViewport();
        let k = null;
        for (let l = 0, n = b.length; l < n; ++l) {
            const p = b[l];
            if (p === k)
                continue;
            k = p;
            const t = p.GetWorldInfo();
            t.IsVisible() && t.IsInViewport(d, g, e) && this._DrawInstanceMaybeWithEffects(p, t, a, c)
        }
    }
    _DrawInstances_3DCamera(a) {
        const b = this._curRenderTarget
          , d = this._GetViewFrustum()
          , c = this._GetInstancesInDrawOrder();
        for (let l = 0, n = c.length; l < n; ) {
            var e = c[l]
              , g = e.GetWorldInfo();
            if (!g.IsVisible() || !g.IsInViewport3D(d)) {
                ++l;
                continue
            }
            (!e.RendersToOwnZPlane() || 0 < g.GetDepth()) && tempInstanceList2.push(e);
            var k = e.GetWorldInfo().GetTotalZElevation();
            tempInstanceList1.push(e);
            let p = l + 1;
            for (; p < n; ++p) {
                const t = c[p]
                  , w = t.GetWorldInfo();
                if (w.IsVisible() && w.IsInViewport3D(d)) {
                    if (w.GetTotalZElevation() !== k)
                        break;
                    t.RendersToOwnZPlane() ? (0 < w.GetDepth() && tempInstanceList2.push(t),
                    tempInstanceList1.push(t)) : tempInstanceList2.push(t)
                }
            }
            if (1 !== tempInstanceList1.length || tempInstanceList1[0].MustMitigateZFighting()) {
                this._DrawCoplanarInstances_3DCamera(a, tempInstanceList1);
                for (let t = 0, w = tempInstanceList2.length; t < w; ++t)
                    e = tempInstanceList2[t],
                    g = e.GetWorldInfo(),
                    g._SetDrawNonBackFacesOnly(!0),
                    this._DrawInstanceMaybeWithEffects(e, g, a, b),
                    g._SetDrawNonBackFacesOnly(!1)
            } else {
                this._DrawInstanceMaybeWithEffects(e, g, a, b);
                for (let t = 0, w = tempInstanceList2.length; t < w; ++t)
                    g = tempInstanceList2[t],
                    g !== e && (k = g.GetWorldInfo(),
                    k.GetLayer()._DrawInstanceMaybeWithEffects(g, k, a, b))
            }
            l = p;
            C3$jscomp$81.clearArray(tempInstanceList1);
            C3$jscomp$81.clearArray(tempInstanceList2)
        }
    }
    _DrawCoplanarInstances_3DCamera(a, b) {
        const d = this._curRenderTarget;
        a.CoplanarStartStencilPass();
        for (let g = 0, k = b.length; g < k; ++g) {
            var c = b[g]
              , e = c.GetWorldInfo();
            e._SetDrawBackFaceOnly(!0);
            this._DrawInstance(c, e, a)
        }
        a.CoplanarStartColorPass();
        for (let g = 0, k = b.length; g < k; ++g)
            c = b[g],
            e = c.GetWorldInfo(),
            this._DrawInstanceMaybeWithEffects(c, e, a, d),
            e._SetDrawBackFaceOnly(!1);
        a.CoplanarRestoreStandardRendering()
    }
    _DrawInstances_RenderCells(a) {
        var b = this._renderGrid;
        const d = this._curRenderCells
          , c = this._lastRenderCells
          , e = this.GetViewport();
        d.set(b.XToCell(e.getLeft()), b.YToCell(e.getTop()), b.XToCell(e.getRight()), b.YToCell(e.getBottom()));
        this._isRenderListUpToDate && d.equals(c) ? b = this._lastRenderList : (b = this._GetRenderCellInstancesToDraw(),
        this._isRenderListUpToDate = !0,
        c.copy(d));
        this._DrawInstances(a, b);
        b !== this._lastRenderList && C3$jscomp$81.shallowAssignArray(this._lastRenderList, b)
    }
    _DrawInstanceMaybeWithEffects(a, b, d, c) {
        b.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(a, b, d, c) : this._DrawInstance(a, b, d)
    }
    _DrawInstance(a, b, d) {
        b = b.GetRendererStateGroup();
        d.GetCurrentStateGroup() !== b && b.Apply();
        a.Draw(d)
    }
    _DrawInstanceWithEffectsAndRestore(a, b, d, c) {
        this._DrawInstanceWithEffects(a, b, d, c, null) && this._SetTransform(d)
    }
    _DrawInstanceWithEffects(a, b, d, c, e) {
        const g = b.GetInstanceEffectList().GetEffectChain();
        g.Render(d, c, {
            contentObject: a,
            blendMode: b.GetBlendMode(),
            devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),
            time: a.GetInstanceGameTime(),
            layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(),
            layerAngle: this.GetAngle(),
            layoutRect: b.GetBoundingBox(),
            drawSurfaceRect: g.CanSkipCalculatingDrawSurfaceRect() ? null : this._InstanceBoxToDrawSurface(b),
            drawContentHook: e && e.drawContentHook,
            compositOffX: e && e.compositOffX,
            compositOffY: e && e.compositOffY,
            updateOwnProjection: e && e.updateOwnProjection
        });
        d.SetBaseZ(this.GetZElevation());
        return g.DidChangeTransform()
    }
    _DrawLayerOwnTextureToRenderTarget(a, b, d, c) {
        const e = this._effectList.GetActiveEffectTypes()
          , g = this._runtime;
        0 === e.length ? (a.SetRenderTarget(d),
        a.SetTextureFillMode(),
        c && 0 === this._blendMode && this.HasDefaultColor() ? a.CopyRenderTarget(b) : (a.SetBlendMode(this._blendMode),
        a.SetColor(this._premultipliedColor),
        a.DrawRenderTarget(b)),
        a.InvalidateRenderTarget(b),
        g.ReleaseAdditionalRenderTarget(b)) : this.GetEffectChain().Render(a, d, {
            contentObject: this,
            blendMode: this.GetBlendMode(),
            devicePixelRatio: g.GetEffectDevicePixelRatioParam(),
            layerScale: g.GetEffectLayerScaleParam() * this.GetNormalScale(),
            layerAngle: this.GetAngle(),
            layoutRect: this.GetViewport(),
            drawSurfaceRect: null,
            invalidateRenderTargets: !0
        })
    }
    GetOwnScale() {
        return this._scale
    }
    SetOwnScale(a) {
        this._scale !== a && (this._scale = a,
        this._layout.BoundScrolling(),
        this._SetMVMatrixChanged(),
        this._runtime.UpdateRender())
    }
    GetRenderScale() {
        return this.GetNormalScale() * this._runtime.GetRenderScale()
    }
    GetDisplayScale() {
        return this.GetNormalScale() * this._runtime.GetDisplayScale()
    }
    GetNormalScale() {
        return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1
    }
    _MaybeUpdateViewport() {
        if (this._isViewportChanged) {
            this._isViewportChanged = !1;
            var a = this._runtime.GetParallaxXOrigin()
              , b = this._runtime.GetParallaxYOrigin()
              , d = (this.GetScrollX() - a) * this._parallaxX + a
              , c = (this.GetScrollY() - b) * this._parallaxY + b;
            a = this.GetNormalScale();
            b = this._runtime.GetViewportWidth() / a;
            a = this._runtime.GetViewportHeight() / a;
            d -= b / 2;
            var e = c - a / 2;
            this._runtime.IsPixelRoundingEnabled() && (d = Math.round(d),
            e = Math.round(e));
            c = this._viewportZ0;
            c.set(d, e, d + b, e + a);
            b = this.GetAngle();
            0 !== b && (tmpRect$jscomp$2.copy(c),
            tmpRect$jscomp$2.offset(-c.midX(), -c.midY()),
            tmpQuad$jscomp$2.setFromRotatedRect(tmpRect$jscomp$2, b),
            tmpQuad$jscomp$2.getBoundingBox(tmpRect$jscomp$2),
            tmpRect$jscomp$2.offset(c.midX(), c.midY()),
            c.copy(tmpRect$jscomp$2));
            b = this._zElevation;
            this.GetViewportForZ(b, this._viewport);
            this.Has3DCamera() ? this.CalculateViewport3D(b, this._viewport3D) : this._viewport3D.copy(this._viewport)
        }
    }
    CalculateViewport3D(a, b) {
        var d = this._runtime.GetCanvasManager()
          , c = d.GetCssWidth();
        d = d.GetCssHeight();
        const [e,g] = this.CanvasCssToLayer(0, 0, a)
          , [k,l] = this.CanvasCssToLayer(c, 0, a)
          , [n,p] = this.CanvasCssToLayer(c, d, a)
          , [t,w] = this.CanvasCssToLayer(0, d, a);
        a = Math.min(e, k, n, t);
        c = Math.min(g, l, p, w);
        d = Math.max(e, k, n, t);
        let z = Math.max(g, l, p, w);
        isFinite(a) || (a = -Infinity);
        isFinite(c) || (c = -Infinity);
        isFinite(d) || (d = Infinity);
        isFinite(z) || (z = Infinity);
        b.set(a, c, d, z)
    }
    CanvasCssToLayer(a, b, d=0) {
        return this._CanvasToLayer(a, b, d, this.GetDisplayScale())
    }
    DrawSurfaceToLayer(a, b, d=0) {
        return this._CanvasToLayer(a, b, d, this.GetRenderScale() * this.GetDevicePixelRatio())
    }
    _CanvasToLayer(a, b, d, c) {
        var e = this._runtime
          , g = e.GetRenderer()
          , k = this.GetNormalScale()
          , l = e.GetViewportWidth() / k;
        k = e.GetViewportHeight() / k;
        e = tempVec4$jscomp$1;
        vec4$jscomp$5.set(e, 0, 0, l, k);
        a /= c;
        b = e[3] - b / c;
        c = this._GetProjectionMatrix(g);
        g = this._GetModelViewMatrix(g);
        l = tempVec3;
        return C3$jscomp$81.Gfx.UnprojectScreenToWorldZ(a, b, d, g, c, e, l) ? [l[0], l[1]] : [NaN, NaN]
    }
    CanvasCssToLayer_DefaultTransform(a, b) {
        const d = this._scale
          , c = this._scaleRate
          , e = this._parallaxX
          , g = this._parallaxY
          , k = this._angle;
        this._parallaxY = this._parallaxX = this._scaleRate = this._scale = 1;
        this._angle = 0;
        this._SetMVMatrixChanged();
        a = this.CanvasCssToLayer(a, b);
        this._scale = d;
        this._scaleRate = c;
        this._parallaxX = e;
        this._parallaxY = g;
        this._angle = k;
        this._SetMVMatrixChanged();
        return a
    }
    LayerToCanvasCss(a, b, d=0) {
        return this._LayerToCanvas(a, b, d, this.GetDisplayScale())
    }
    LayerToDrawSurface(a, b, d=0) {
        return this._LayerToCanvas(a, b, d, this.GetRenderScale() * this.GetDevicePixelRatio())
    }
    _LayerToCanvas(a, b, d, c) {
        var e = this._runtime
          , g = e.GetRenderer()
          , k = this.GetNormalScale()
          , l = e.GetViewportWidth() / k;
        k = e.GetViewportHeight() / k;
        e = tempVec4$jscomp$1;
        vec4$jscomp$5.set(e, 0, 0, l, k);
        l = this._GetProjectionMatrix(g);
        g = this._GetModelViewMatrix(g);
        k = tempVec3;
        return C3$jscomp$81.Gfx.Project(a, b, d, g, l, e, k) ? [k[0] * c, (e[3] - k[1]) * c] : [NaN, NaN]
    }
    _GetLayerToDrawSurfaceScale(a, b) {
        a *= this.GetRenderScale() * this.GetDevicePixelRatio();
        0 !== b && (a *= this.Get2DScaleFactorToZ(b));
        return a
    }
    _InstanceBoxToDrawSurface(a) {
        var b = a.GetBoundingBox()
          , d = a.GetTotalZElevation();
        a = a.GetDepth();
        const c = d + a
          , e = b.getLeft()
          , g = b.getTop()
          , k = b.getRight();
        b = b.getBottom();
        if (this.Has3DCamera()) {
            if (this._IsPointBehindNearPlane(e, g, d) || this._IsPointBehindNearPlane(k, g, d) || this._IsPointBehindNearPlane(k, b, d) || this._IsPointBehindNearPlane(e, b, d) || 0 < a && (this._IsPointBehindNearPlane(e, g, c) || this._IsPointBehindNearPlane(k, g, c) || this._IsPointBehindNearPlane(k, b, c) || this._IsPointBehindNearPlane(e, b, c)))
                return null
        } else if (c >= this.GetCameraZ())
            return null;
        let[l,n] = this.LayerToDrawSurface(e, g, d)
          , [p,t] = this.LayerToDrawSurface(k, b, d);
        if (0 !== this.GetAngle() || 0 < a || this.Has3DCamera()) {
            const [w,z] = this.LayerToDrawSurface(k, g, d)
              , [B,C] = this.LayerToDrawSurface(e, b, d);
            if (0 < a) {
                const [E,F] = this.LayerToDrawSurface(e, g, c)
                  , [J,K] = this.LayerToDrawSurface(k, g, c)
                  , [M,U] = this.LayerToDrawSurface(k, b, c)
                  , [X,R] = this.LayerToDrawSurface(e, b, c);
                d = Math.min(l, p, w, B, E, J, M, X);
                p = Math.max(l, p, w, B, E, J, M, X);
                l = d;
                d = Math.min(n, t, z, C, F, K, U, R);
                t = Math.max(n, t, z, C, F, K, U, R);
                n = d
            } else
                d = Math.min(l, p, w, B),
                p = Math.max(l, p, w, B),
                l = d,
                d = Math.min(n, t, z, C),
                t = Math.max(n, t, z, C),
                n = d
        }
        tmpRect$jscomp$2.set(l, n, p, t);
        return tmpRect$jscomp$2
    }
    _GetViewFrustum() {
        this._isViewFrustumChanged && (this._UpdateViewFrustum(),
        this._isViewFrustumChanged = !1);
        return this._viewFrustum
    }
    _UpdateViewFrustum() {
        var a = this._runtime.GetRenderer();
        const b = this._GetProjectionMatrix(a);
        a = this._GetModelViewMatrix(a);
        this._viewFrustum.CalculatePlanes(a, b)
    }
    _IsPointBehindNearPlane(a, b, d) {
        return this._GetViewFrustum().IsBehindNearPlane(a, b, d)
    }
    _SaveToJson() {
        return {
            s: this.GetOwnScale(),
            a: this.GetOwnAngle(),
            v: this._IsVisibleFlagSet(),
            i: this.IsInteractive(),
            bc: this._backgroundColor.toJSON(),
            t: this.IsTransparent(),
            sx: this._scrollX,
            sy: this._scrollY,
            hosp: this._hasOwnScrollPosition,
            px: this.GetParallaxX(),
            py: this.GetParallaxY(),
            c: this._color.toJSON(),
            sr: this.GetScaleRate(),
            fx: this._effectList.SaveToJson(),
            cg: this._createdGlobalUids
        }
    }
    _LoadFromJson(a) {
        this._scale = a.s;
        this._angle = a.a;
        this._isVisible = !!a.v;
        this._isInteractive = a.hasOwnProperty("i") ? a.i : !0;
        this._backgroundColor.setFromJSON(a.bc);
        this._isTransparent = !!a.t;
        a.hasOwnProperty("sx") && (this._scrollX = a.sx);
        a.hasOwnProperty("sy") && (this._scrollY = a.sy);
        a.hasOwnProperty("hosp") && (this._hasOwnScrollPosition = !!a.hosp);
        this._parallaxX = a.px;
        this._parallaxY = a.py;
        this._color.setFromJSON(a.c);
        this._UpdatePremultipliedColor();
        this._scaleRate = a.sr;
        C3$jscomp$81.shallowAssignArray(this._createdGlobalUids, a.cg);
        C3$jscomp$81.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
        const b = new Set(this._createdGlobalUids);
        let d = 0;
        for (let c = 0, e = this._initialInstances.length; c < e; ++c)
            b.has(this._initialInstances[c][2]) || (this._initialInstances[d] = this._initialInstances[c],
            ++d);
        C3$jscomp$81.truncateArray(this._initialInstances, d);
        this._effectList.LoadFromJson(a.fx);
        this._needsRebuildEffectChainSteps = !0;
        this._SortInstancesByLastCachedZIndex(!1);
        this.SetZIndicesChanged();
        this._SetMVMatrixChanged();
        this._SetProjectionMatrixChanged()
    }
    GetILayer() {
        return this._iLayer
    }
    SortAndAddInstancesByZIndex(a, b=!1) {
        if (this._instances.includes(a))
            b && this._instances.sort((e,g)=>{
                e = e.GetWorldInfo().GetSceneGraphZIndex();
                g = g.GetWorldInfo().GetSceneGraphZIndex();
                return e - g
            }
            );
        else if (a.HasChildren()) {
            var d = [...a.allChildren()];
            d.push(a);
            d.sort((e,g)=>{
                e = e.GetWorldInfo().GetSceneGraphZIndex();
                g = g.GetWorldInfo().GetSceneGraphZIndex();
                return e - g
            }
            );
            for (var c of d)
                if (c.IsInContainer())
                    for (const e of c.siblings())
                        d.includes(e) || (a = [...e.allChildren()],
                        a.push(e),
                        a.sort((g,k)=>{
                            g = g.GetWorldInfo().GetSceneGraphZIndex();
                            k = k.GetWorldInfo().GetSceneGraphZIndex();
                            return g - k
                        }
                        ),
                        a && a.length && d.splice(d.length, 0, ...a));
            for (const e of d)
                e.GetPlugin().IsWorldType() && this._AddInstance(e, !0)
        } else if (a.GetPlugin().IsWorldType() && this._AddInstance(a, !0),
        a.IsInContainer())
            for (d of a.siblings())
                if (c = [...d.allChildren()],
                c.push(d),
                c.sort((e,g)=>{
                    e = e.GetWorldInfo().GetSceneGraphZIndex();
                    g = g.GetWorldInfo().GetSceneGraphZIndex();
                    return e - g
                }
                ),
                c && c.length)
                    for (const e of c)
                        e.GetPlugin().IsWorldType() && this._AddInstance(e, !0)
    }
}
;
"use strict";
const C3$jscomp$82 = self.C3
  , C3Debugger = self.C3Debugger;
C3$jscomp$82.New(C3$jscomp$82.Rect);
C3$jscomp$82.New(C3$jscomp$82.Rect);
const tempLayoutRect = C3$jscomp$82.New(C3$jscomp$82.Rect)
  , tempColor$jscomp$4 = C3$jscomp$82.New(C3$jscomp$82.Color)
  , vec3$jscomp$7 = self.glMatrix.vec3
  , tempRender3dList = []
  , tempInstanceList1$jscomp$1 = []
  , tempInstanceList2$jscomp$1 = []
  , tempInstanceList3 = [];
function vec3EqualsXYZ(a, b, d, c) {
    return a[0] === Math.fround(b) && a[1] === Math.fround(d) && a[2] === Math.fround(c)
}
let lastLayerPreparedForDrawing = null;
function MaybePrepareLayerDraw(a, b) {
    lastLayerPreparedForDrawing !== a && (a.PrepareForDraw(b),
    lastLayerPreparedForDrawing = a)
}
C3$jscomp$82.Layout = class extends C3$jscomp$82.DefendedBase {
    constructor(a, b, d) {
        super();
        this._layoutManager = a;
        this._runtime = a.GetRuntime();
        this._name = d[0];
        this._originalWidth = d[1];
        this._originalHeight = d[2];
        this._width = d[1];
        this._height = d[2];
        this._isUnboundedScrolling = !!d[3];
        this._isOrthographicProjection = !!d[4];
        this._vanishingPointX = d[5];
        this._vanishingPointY = d[6];
        this._eventSheetName = d[7];
        this._eventSheet = null;
        this._sid = d[8];
        this._index = b;
        this._scrollY = this._scrollX = 0;
        this._scale = 1;
        this._angle = 0;
        this._initialObjectClasses = new Set;
        this._textureLoadedTypes = new Set;
        this._textureLoadPendingPromises = new Set;
        this._createdInstances = [];
        this._createdPersistedInstances = [];
        this._createdPersistedInstancesToDataMap = new Map;
        this._createdPersistedIndexToInstanceMap = new Map;
        this._initialNonWorld = [];
        this._is3dCameraEnabled = !1;
        this._cam3dposition = vec3$jscomp$7.create();
        this._cam3dlook = vec3$jscomp$7.create();
        this._cam3dup = vec3$jscomp$7.create();
        this._rootLayers = [];
        this._allLayersFlat = [];
        this._layersByName = new Map;
        this._layersBySid = new Map;
        const c = this._runtime.GetCanvasManager();
        this._effectList = C3$jscomp$82.New(C3$jscomp$82.EffectList, this, d[11]);
        this._effectChain = C3$jscomp$82.New(C3$jscomp$82.Gfx.EffectChain, c.GetEffectChainManager(), {
            drawContent: (e,g)=>{
                g = g.GetContentObject().GetRenderTarget();
                e.ResetColor();
                e.DrawRenderTarget(g);
                e.InvalidateRenderTarget(g);
                c.ReleaseAdditionalRenderTarget(g)
            }
            ,
            getShaderParameters: e=>this.GetEffectList()._GetEffectChainShaderParametersForIndex(e)
        });
        this._needsRebuildEffectChainSteps = !0;
        this._wasFullScreenQualityLow = !1;
        this._curRenderTarget = null;
        this._persistData = {};
        this._persistedIntances = new Map;
        this._isFirstVisit = !0;
        this._iLayout = new self.ILayout(this);
        this._userScriptDispatcher = C3$jscomp$82.New(C3$jscomp$82.Event.Dispatcher);
        for (const e of d[9])
            this._rootLayers.push(C3$jscomp$82.New(C3$jscomp$82.Layer, this, null, e));
        this._allLayersFlat = [...this.allLayers()];
        for (let e = 0, g = this._allLayersFlat.length; e < g; ++e)
            a = this._allLayersFlat[e],
            a._SetIndex(e),
            a._Init(),
            this._layersByName.set(a.GetName().toLowerCase(), a),
            this._layersBySid.set(a.GetSID(), a);
        for (const e of d[10]) {
            d = this._runtime.GetObjectClassByIndex(e[1]);
            if (!d)
                throw Error("missing nonworld object class");
            d.GetDefaultInstanceData() || d.SetDefaultInstanceData(e);
            this._initialNonWorld.push(e);
            this._AddInitialObjectClass(d)
        }
    }
    Release() {
        for (const a of this._allLayersFlat)
            a.Release();
        C3$jscomp$82.clearArray(this._allLayersFlat);
        this._textureLoadPendingPromises.clear();
        this._runtime = this._layoutManager = this._eventSheet = null
    }
    GetRuntime() {
        return this._runtime
    }
    GetName() {
        return this._name
    }
    GetSID() {
        return this._sid
    }
    GetIndex() {
        return this._index
    }
    GetEffectList() {
        return this._effectList
    }
    GetEffectChain() {
        this._MaybeRebuildEffectChainSteps();
        return this._effectChain
    }
    _MaybeRebuildEffectChainSteps() {
        const a = "low" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();
        if (this._needsRebuildEffectChainSteps || this._wasFullScreenQualityLow !== a || this._effectChain.NeedsRebuild()) {
            var b = this.GetEffectList().GetActiveEffectTypes();
            this._effectChain.BuildSteps(b.map(d=>d.GetShaderProgram()), {
                indexMap: b.map(d=>d.GetIndex()),
                forcePostDraw: a,
                useFullSurface: !0
            });
            this._needsRebuildEffectChainSteps = !1;
            this._wasFullScreenQualityLow = a
        }
    }
    UpdateActiveEffects() {
        this.GetEffectList().UpdateActiveEffects();
        this._needsRebuildEffectChainSteps = !0
    }
    GetMinLayerScale() {
        let a = this._allLayersFlat[0].GetNormalScale();
        for (let b = 1, d = this._allLayersFlat.length; b < d; ++b) {
            const c = this._allLayersFlat[b];
            if (0 !== c.GetParallaxX() || 0 !== c.GetParallaxY())
                a = Math.min(a, c.GetNormalScale())
        }
        return a
    }
    _GetScrollBoundMarginHorizontal() {
        return .5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale()
    }
    _GetScrollBoundMarginVertical() {
        return .5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale()
    }
    GetScrollLeftBound() {
        return this.IsUnboundedScrolling() ? -Infinity : this._GetScrollBoundMarginHorizontal()
    }
    GetScrollRightBound() {
        return this.IsUnboundedScrolling() ? Infinity : this.GetWidth() - this._GetScrollBoundMarginHorizontal()
    }
    GetScrollTopBound() {
        return this.IsUnboundedScrolling() ? -Infinity : this._GetScrollBoundMarginVertical()
    }
    GetScrollBottomBound() {
        return this.IsUnboundedScrolling() ? Infinity : this.GetHeight() - this._GetScrollBoundMarginVertical()
    }
    SetScrollX(a) {
        const b = this.GetScrollLeftBound()
          , d = this.GetScrollRightBound();
        a > d && (a = d);
        a < b && (a = b);
        this._scrollX !== a && (this._scrollX = a,
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    GetScrollX() {
        return this._scrollX
    }
    SetScrollY(a) {
        const b = this.GetScrollTopBound()
          , d = this.GetScrollBottomBound();
        a > d && (a = d);
        a < b && (a = b);
        this._scrollY !== a && (this._scrollY = a,
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    GetScrollY() {
        return this._scrollY
    }
    IsUnboundedScrolling() {
        return this._isUnboundedScrolling
    }
    BoundScrolling() {
        this.SetScrollX(this.GetScrollX());
        this.SetScrollY(this.GetScrollY());
        for (const a of this._allLayersFlat)
            a.IsOwnScrollPositionEnabled() && (a.SetScrollX(a.GetScrollX()),
            a.SetScrollY(a.GetScrollY()))
    }
    SetVanishingPointXY(a, b) {
        if (this._vanishingPointX !== a || this._vanishingPointY !== b)
            this._vanishingPointX = a,
            this._vanishingPointY = b,
            this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(),
            this._SetAllLayersMVChanged(),
            this._runtime.UpdateRender())
    }
    GetVanishingPointX() {
        return this.IsOrthographicProjection() ? .5 : this._vanishingPointX
    }
    GetVanishingPointY() {
        return this.IsOrthographicProjection() ? .5 : this._vanishingPointY
    }
    HasVanishingPointOutsideViewport() {
        const a = this.GetVanishingPointX()
          , b = this.GetVanishingPointY();
        return 0 > a || 1 < a || 0 > b || 1 < b
    }
    SetPerspectiveProjection() {
        this._isOrthographicProjection && (this._isOrthographicProjection = !1,
        this._SetAllLayersProjectionChanged(),
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    SetOrthographicProjection() {
        this._isOrthographicProjection || (this._isOrthographicProjection = !0,
        this._SetAllLayersProjectionChanged(),
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    IsOrthographicProjection() {
        return this._isOrthographicProjection
    }
    IsPerspectiveProjection() {
        return !this.IsOrthographicProjection()
    }
    Set3DCameraEnabled(a) {
        a = !!a;
        this._is3dCameraEnabled !== a && (this._is3dCameraEnabled = a,
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    Is3DCameraEnabled() {
        return this._is3dCameraEnabled
    }
    Set3DCameraOrientation(a, b, d, c, e, g, k, l, n) {
        vec3EqualsXYZ(this._cam3dposition, a, b, d) && vec3EqualsXYZ(this._cam3dlook, c, e, g) && vec3EqualsXYZ(this._cam3dup, k, l, n) || (vec3$jscomp$7.set(this._cam3dposition, a, b, d),
        vec3$jscomp$7.set(this._cam3dlook, c, e, g),
        vec3$jscomp$7.set(this._cam3dup, k, l, n),
        this.Set3DCameraChanged())
    }
    Set3DCameraChanged() {
        this._SetAllLayersMVChanged();
        this._runtime.UpdateRender()
    }
    Get3DCameraPosition() {
        return this._cam3dposition
    }
    Get3DCameraLookAt() {
        return this._cam3dlook
    }
    Get3DCameraUpVector() {
        return this._cam3dup
    }
    GetScale() {
        return this._scale
    }
    SetScale(a) {
        this._scale !== a && (this._scale = a,
        this._SetAllLayersMVChanged(),
        this.BoundScrolling(),
        this._runtime.UpdateRender())
    }
    SetAngle(a) {
        a = C3$jscomp$82.clampAngle(a);
        this._angle !== a && (this._angle = a,
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender())
    }
    GetAngle() {
        return this._angle
    }
    GetWidth() {
        return this._width
    }
    SetWidth(a) {
        !isFinite(a) || 1 > a || (this._width = a)
    }
    GetHeight() {
        return this._height
    }
    SetHeight(a) {
        !isFinite(a) || 1 > a || (this._height = a)
    }
    GetEventSheet() {
        return this._eventSheet
    }
    *allLayers() {
        for (const a of this._rootLayers)
            yield*a.selfAndAllSubLayers()
    }
    GetLayers() {
        return this._allLayersFlat
    }
    GetLayerCount() {
        return this._allLayersFlat.length
    }
    GetLayer(a) {
        return "number" === typeof a ? this.GetLayerByIndex(a) : this.GetLayerByName(a.toString())
    }
    GetLayerByIndex(a) {
        a = C3$jscomp$82.clamp(Math.floor(a), 0, this._allLayersFlat.length - 1);
        return this._allLayersFlat[a]
    }
    GetLayerByName(a) {
        return this._layersByName.get(a.toLowerCase()) || null
    }
    GetLayerBySID(a) {
        return this._layersBySid.get(a) || null
    }
    _SetAllLayersProjectionChanged() {
        for (const a of this._allLayersFlat)
            a._SetProjectionMatrixChanged()
    }
    _SetAllLayersMVChanged() {
        for (const a of this._allLayersFlat)
            a._SetMVMatrixChanged()
    }
    SaveTransform() {
        return {
            scrollX: this.GetScrollX(),
            scrollY: this.GetScrollY(),
            scale: this.GetScale(),
            angle: this.GetAngle(),
            vpX: this.GetVanishingPointX(),
            vpY: this.GetVanishingPointY()
        }
    }
    RestoreTransform(a) {
        this.SetScrollX(a.scrollX);
        this.SetScrollY(a.scrollY);
        this.SetScale(a.scale);
        this.SetAngle(a.angle);
        this.SetVanishingPointXY(a.vpX, a.vpY)
    }
    GetLayoutBackgroundColor() {
        let a = this._rootLayers.filter(b=>b.ShouldDraw())[0];
        for (; a; ) {
            if (!a.IsTransparent())
                return tempColor$jscomp$4.copyRgb(a.GetBackgroundColor()),
                tempColor$jscomp$4.setA(1),
                tempColor$jscomp$4;
            if (a.UsesOwnTexture())
                return tempColor$jscomp$4.setRgba(0, 0, 0, 0),
                tempColor$jscomp$4;
            a = a.GetSubLayers().filter(b=>b.ShouldDraw())[0]
        }
        tempColor$jscomp$4.setRgba(0, 0, 0, 0);
        return tempColor$jscomp$4
    }
    IsFirstVisit() {
        return this._isFirstVisit
    }
    _GetInitialObjectClasses() {
        return [...this._initialObjectClasses]
    }
    _AddInitialObjectClass(a) {
        if (a.IsInContainer())
            for (const b of a.GetContainer().GetObjectTypes())
                this._initialObjectClasses.add(b);
        else
            this._initialObjectClasses.add(a)
    }
    _GetTextureLoadedObjectTypes() {
        return [...this._textureLoadedTypes]
    }
    _Load(a, b) {
        if (a === this || !b)
            return Promise.resolve();
        a && (C3$jscomp$82.CopySet(this._textureLoadedTypes, a._textureLoadedTypes),
        a._textureLoadedTypes.clear());
        a = [];
        for (const d of this._initialObjectClasses)
            this._textureLoadedTypes.has(d) || (a.push(d.LoadTextures(b)),
            this._textureLoadedTypes.add(d));
        return Promise.all(a)
    }
    async MaybeLoadTexturesFor(a) {
        if (a.IsFamily())
            throw Error("cannot load textures for family");
        var b = this._runtime.GetRenderer();
        !b || b.IsContextLost() || this._textureLoadedTypes.has(a) || (this._textureLoadedTypes.add(a),
        b = a.LoadTextures(b),
        this._AddPendingTextureLoadPromise(b),
        await b,
        a.OnDynamicTextureLoadComplete(),
        this._runtime.UpdateRender())
    }
    _AddPendingTextureLoadPromise(a) {
        this._textureLoadPendingPromises.add(a);
        a.then(()=>this._textureLoadPendingPromises.delete(a)).catch(()=>this._textureLoadPendingPromises.delete(a))
    }
    WaitForPendingTextureLoadsToComplete() {
        return Promise.all([...this._textureLoadPendingPromises])
    }
    MaybeUnloadTexturesFor(a) {
        if (a.IsFamily() || 0 < a.GetInstanceCount())
            throw Error("cannot unload textures");
        const b = this._runtime.GetRenderer();
        b && this._textureLoadedTypes.has(a) && (this._textureLoadedTypes.delete(a),
        a.ReleaseTextures(b))
    }
    _Unload(a, b) {
        if (a !== this && b)
            for (const d of this._textureLoadedTypes)
                d.IsGlobal() || a._initialObjectClasses.has(d) || (d.ReleaseTextures(),
                this._textureLoadedTypes.delete(d))
    }
    _OnRendererContextLost() {
        this._textureLoadedTypes.clear()
    }
    async _StartRunning(a) {
        const b = this._runtime
          , d = this._layoutManager
          , c = b.GetEventSheetManager();
        this._eventSheetName && (this._eventSheet = c.GetEventSheetByName(this._eventSheetName),
        this._eventSheet._UpdateDeepIncludes());
        d._SetMainRunningLayout(this);
        this._width = this._originalWidth;
        this._height = this._originalHeight;
        this._scrollX = b.GetOriginalViewportWidth() / 2;
        this._scrollY = b.GetOriginalViewportHeight() / 2;
        this.BoundScrolling();
        this._SetAllLayersProjectionChanged();
        this._SetAllLayersMVChanged();
        this._MoveGlobalObjectsToThisLayout(a);
        this._runtime.SetUsingCreatePromises(!0);
        this._CreateInitialInstances();
        this._isFirstVisit || this._CreatePersistedInstances();
        this._CreateAndLinkContainerInstances(this._createdInstances);
        this._CreateAndLinkContainerInstances(this._createdPersistedInstances);
        this._CreateInitialNonWorldInstances();
        d.ClearPendingChangeLayout();
        b.FlushPendingInstances();
        this._runtime.SetUsingCreatePromises(!1);
        var e = this._runtime.GetCreatePromises();
        await Promise.all(e);
        C3$jscomp$82.clearArray(e);
        if (!b.IsLoadingState()) {
            for (const g of this._createdInstances)
                g.SetupInitialSceneGraphConnections();
            for (const g of this._createdPersistedInstances)
                g.SetupPersistedSceneGraphConnections(this._createdPersistedInstancesToDataMap, this._createdPersistedIndexToInstanceMap);
            for (const [g,k] of Object.entries(this._persistData))
                (e = this._runtime.GetObjectClassBySID(parseInt(g, 10))) && !e.IsFamily() && e.HasPersistBehavior() && C3$jscomp$82.clearArray(k);
            for (const g of this._createdInstances)
                g._TriggerOnCreated();
            for (const g of this._createdPersistedInstances)
                g._TriggerOnCreated()
        }
        C3$jscomp$82.clearArray(this._createdInstances);
        C3$jscomp$82.clearArray(this._createdPersistedInstances);
        this._createdPersistedInstancesToDataMap.clear();
        this._createdPersistedIndexToInstanceMap.clear();
        await Promise.all([...this._initialObjectClasses].map(g=>g.PreloadTexturesWithInstances(this._runtime.GetRenderer())));
        a && (b.Dispatcher().dispatchEvent(new C3$jscomp$82.Event("beforefirstlayoutstart")),
        await b.DispatchUserScriptEventAsyncWait(new C3$jscomp$82.Event("beforeprojectstart")));
        b.Dispatcher().dispatchEvent(new C3$jscomp$82.Event("beforelayoutstart"));
        await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$82.Event("beforelayoutstart"));
        b.IsLoadingState() || await b.TriggerAsync(C3$jscomp$82.Plugins.System.Cnds.OnLayoutStart, null, null);
        b.Dispatcher().dispatchEvent(new C3$jscomp$82.Event("afterlayoutstart"));
        await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$82.Event("afterlayoutstart"));
        a && (b.Dispatcher().dispatchEvent(new C3$jscomp$82.Event("afterfirstlayoutstart")),
        await b.DispatchUserScriptEventAsyncWait(new C3$jscomp$82.Event("afterprojectstart")));
        c._RunQueuedTriggers(d);
        await this.WaitForPendingTextureLoadsToComplete();
        this._isFirstVisit = !1
    }
    _MoveGlobalObjectsToThisLayout(a) {
        for (const d of this._runtime.GetAllObjectClasses())
            if (!d.IsFamily() && d.IsWorldType())
                for (const c of d.GetInstances()) {
                    const e = c.GetWorldInfo();
                    var b = e.GetLayer();
                    b = C3$jscomp$82.clamp(b.GetIndex(), 0, this._allLayersFlat.length - 1);
                    b = this._allLayersFlat[b];
                    e._SetLayer(b);
                    b._MaybeAddInstance(c)
                }
        if (!a)
            for (const d of this._allLayersFlat)
                d._SortInstancesByLastCachedZIndex(!1)
    }
    _CreateInitialInstances() {
        for (const a of this._allLayersFlat)
            a.CreateInitialInstances(this._createdInstances),
            a._Start()
    }
    _CreatePersistedInstances() {
        let a = !1;
        for (const [d,c] of Object.entries(this._persistData)) {
            const e = this._runtime.GetObjectClassBySID(parseInt(d, 10));
            if (e && !e.IsFamily() && e.HasPersistBehavior())
                for (const g of c) {
                    var b = null;
                    if (e.IsWorldType() && (b = g.hasOwnProperty("instJson") ? this.GetLayerBySID(g.instJson.w.l) : this.GetLayerBySID(g.w.l),
                    !b))
                        continue;
                    b = this._runtime.CreateInstanceFromData(e, b, !1, 0, 0, !0);
                    g.hasOwnProperty("instJson") ? b.LoadFromJson(g.instJson) : b.LoadFromJson(g);
                    a = !0;
                    this._createdPersistedInstances.push(b);
                    g.hasOwnProperty("instJson") && (this._createdPersistedInstancesToDataMap.set(b, g),
                    this._createdPersistedIndexToInstanceMap.set(g.index, b))
                }
        }
        for (const d of this._allLayersFlat)
            d._SortInstancesByLastCachedZIndex(!0),
            d.SetZIndicesChanged();
        a && (this._runtime.FlushPendingInstances(),
        this._runtime._RefreshUidMap())
    }
    _CreateAndLinkContainerInstances(a) {
        for (const d of a) {
            if (!d.IsInContainer())
                continue;
            const c = d.GetWorldInfo()
              , e = d.GetIID();
            for (const g of d.GetObjectClass().GetContainer().objectTypes())
                if (g !== d.GetObjectClass()) {
                    var b = g.GetInstances();
                    b.length > e ? d._AddSibling(b[e]) : (b = c ? this._runtime.CreateInstanceFromData(g, c.GetLayer(), !0, c.GetX(), c.GetY(), !0) : this._runtime.CreateInstanceFromData(g, null, !0, 0, 0, !0),
                    this._runtime.FlushPendingInstances(),
                    g._UpdateIIDs(),
                    d._AddSibling(b),
                    a.push(b))
                }
        }
    }
    _CreateInitialNonWorldInstances() {
        for (const a of this._initialNonWorld)
            this._runtime.GetObjectClassByIndex(a[1]).IsInContainer() || this._runtime.CreateInstanceFromData(a, null, !0)
    }
    _CreateGlobalNonWorlds() {
        const a = []
          , b = this._initialNonWorld;
        let d = 0;
        for (let c = 0, e = b.length; c < e; ++c) {
            const g = b[c]
              , k = this._runtime.GetObjectClassByIndex(g[1]);
            k.IsGlobal() ? k.IsInContainer() && k.GetContainer().HasAnyWorldType() || a.push(this._runtime.CreateInstanceFromData(g, null, !0)) : (b[d] = g,
            ++d)
        }
        C3$jscomp$82.truncateArray(b, d);
        this._runtime.FlushPendingInstances();
        this._CreateAndLinkContainerInstances(a)
    }
    RecreateInitialObjects(a, b, d, c, e, g) {
        if (d)
            return d.RecreateInitialObjects(a, b, c, e, g);
        d = [];
        for (const k of this._allLayersFlat)
            d.push(k.RecreateInitialObjects(a, b, c, e, g));
        return d.flat()
    }
    async _StopRunning() {
        const a = this._layoutManager;
        this._runtime.IsLoadingState() || (await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$82.Event("beforelayoutend")),
        await this._runtime.TriggerAsync(C3$jscomp$82.Plugins.System.Cnds.OnLayoutEnd, null, null),
        await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$82.Event("afterlayoutend")));
        a.SetIsEndingLayout(!0);
        this._runtime.GetEventSheetManager().ClearAllScheduledWaits();
        this._isFirstVisit || this._SavePersistData();
        for (const b of this._allLayersFlat)
            b._End();
        for (const b of this._runtime.GetAllObjectClasses())
            if (!(b.IsGlobal() || b.IsWorldType() || b.GetPlugin().IsSingleGlobal() || b.IsFamily())) {
                for (const d of b.GetInstances())
                    this._runtime.DestroyInstance(d);
                this._runtime.FlushPendingInstances()
            }
        a.SetIsEndingLayout(!1);
        a.GetMainRunningLayout() === this && a._SetMainRunningLayout(null)
    }
    _SaveInstanceToPersist(a, b) {
        var d = a.GetObjectClass().GetSID().toString();
        this._persistData.hasOwnProperty(d) || (this._persistData[d] = []);
        d = this._persistData[d];
        b = {
            index: b,
            instJson: a.SaveToJson(),
            sceneGraphJson: {
                children: []
            }
        };
        d.push(b);
        this._persistedIntances.set(a, b)
    }
    _SaveSceneGraphInfoToPersist(a) {
        const b = this._persistedIntances.get(a);
        for (const d of a.GetChildren())
            (a = this._persistedIntances.get(d)) && b.sceneGraphJson.children.push({
                index: a.index,
                flags: C3$jscomp$82.SceneGraphInfo._GetFlagsNumber(d.GetWorldInfo())
            })
    }
    _SavePersistData() {
        this._persistedIntances.clear();
        var a = 0;
        for (const b of this._allLayersFlat) {
            b._UpdateZIndices();
            for (const d of b._GetInstances()) {
                const c = d.GetObjectClass();
                !c.IsGlobal() && c.HasPersistBehavior() && (this._SaveInstanceToPersist(d, a),
                a++)
            }
        }
        for (const b of this._allLayersFlat)
            for (const d of b._GetInstances())
                a = d.GetObjectClass(),
                !a.IsGlobal() && a.HasPersistBehavior() && this._SaveSceneGraphInfoToPersist(d);
        this._persistedIntances.clear()
    }
    ResetPersistData() {
        this._persistData = {};
        this._isFirstVisit = !0
    }
    GetRenderTarget() {
        return this._curRenderTarget
    }
    UsesOwnTexture() {
        const a = this._runtime
          , b = a.GetRenderer().IsWebGL();
        return "low" === a.GetCanvasManager().GetCurrentFullscreenScalingQuality() || b && a.UsesAnyBackgroundBlending() || "low-latency" === a.GetCompositingMode() || this._effectList.HasAnyActiveEffect() || b && a.Uses3DFeatures()
    }
    Draw(a) {
        const b = this._runtime.GetCanvasManager()
          , d = this.UsesOwnTexture();
        if (d) {
            "low-latency" !== this._runtime.GetCompositingMode() && (a.SetRenderTarget(null),
            a.ClearRgba(0, 0, 0, 0));
            const c = {
                sampling: this._runtime.GetSampling(),
                isSampled: a.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect(),
                canReadPixels: a.IsWebGPU() ? this._runtime.UsesAnyBackgroundBlending() : !1
            };
            "low" === b.GetCurrentFullscreenScalingQuality() && (c.width = b.GetDrawWidth(),
            c.height = b.GetDrawHeight());
            this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(c)
        } else
            this._curRenderTarget = null;
        a.SetRenderTarget(this._curRenderTarget);
        a.Clear(this.GetLayoutBackgroundColor());
        this._runtime.Uses3DFeatures() && a.ClearDepth();
        this._DrawLayerList(a, this._curRenderTarget, this._rootLayers, !0);
        d && (a.SetDepthEnabled(!1),
        this._DrawLayoutOwnTextureToRenderTarget(a, this._curRenderTarget));
        this._curRenderTarget = null
    }
    _DrawLayerList(a, b, d, c) {
        d = d.filter(e=>e.ShouldDraw());
        for (let e = 0, g = d.length; e < g; ) {
            const k = d[e];
            if (k.SelfAndAllSubLayersHave3DCamera() && !k.SelfOrAnySubLayerUsesOwnTexture()) {
                tempRender3dList.push(k);
                for (let l = e + 1; l < g; ++l) {
                    const n = d[l];
                    if (n.SelfAndAllSubLayersHave3DCamera() && !n.SelfOrAnySubLayerUsesOwnTexture())
                        tempRender3dList.push(d[l]);
                    else
                        break
                }
                if (2 <= tempRender3dList.length || 1 === tempRender3dList.length && tempRender3dList[0].HasAnyVisibleSubLayer()) {
                    this._Draw3DLayers(a, b, tempRender3dList);
                    e += tempRender3dList.length;
                    C3$jscomp$82.clearArray(tempRender3dList);
                    continue
                }
                C3$jscomp$82.clearArray(tempRender3dList)
            }
            k.Draw(a, b, c && 0 === e);
            ++e
        }
    }
    _DrawLayoutOwnTextureToRenderTarget(a, b) {
        const d = this._effectList.GetActiveEffectTypes()
          , c = this._runtime;
        0 === d.length ? (a.SetRenderTarget(null),
        a.SetTextureFillMode(),
        a.CopyRenderTarget(b),
        a.InvalidateRenderTarget(b),
        c.ReleaseAdditionalRenderTarget(b)) : (tempLayoutRect.set(0, 0, c.GetViewportWidth(), c.GetViewportHeight()),
        this.GetEffectChain().Render(a, null, {
            contentObject: this,
            blendMode: 3,
            devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),
            layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(),
            layerAngle: this.GetAngle(),
            layoutRect: tempLayoutRect,
            drawSurfaceRect: null,
            invalidateRenderTargets: !0
        }))
    }
    _Draw3DLayers(a, b, d) {
        d[0].IsTransparent() || (tempColor$jscomp$4.copyRgb(d[0].GetBackgroundColor()),
        tempColor$jscomp$4.setA(1),
        a.Clear(tempColor$jscomp$4));
        var c = this._runtime.GetCanvasManager();
        a.SetDepthEnabled(!0);
        for (var e of d)
            e._UpdateZIndices(),
            e._AppendAllInstancesIncludingSubLayersInDrawOrder(tempInstanceList1$jscomp$1);
        d = d[0];
        e = null;
        if (this._runtime.IsGPUProfiling())
            if (a.IsWebGL()) {
                if (c = c.GetLayerTimingsBuffer(d))
                    e = c.AddTimeElapsedQuery(),
                    a.StartQuery(e)
            } else
                a.IsWebGPU() && a.WriteTimestamp(2 * (d.GetIndex() + 1));
        for (let p = 0, t = tempInstanceList1$jscomp$1.length; p < t; ) {
            var g = tempInstanceList1$jscomp$1[p]
              , k = g.GetWorldInfo()
              , l = k.GetLayer();
            if (k.IsVisible() && k.IsInViewport3D(l._GetViewFrustum())) {
                (!g.RendersToOwnZPlane() || 0 < k.GetDepth()) && tempInstanceList3.push(g);
                var n = g.GetWorldInfo().GetTotalZElevation();
                tempInstanceList2$jscomp$1.push(g);
                for (c = p + 1; c < t; ++c) {
                    const w = tempInstanceList1$jscomp$1[c]
                      , z = w.GetWorldInfo();
                    if (z.IsVisible() && z.IsInViewport3D(z.GetLayer()._GetViewFrustum())) {
                        if (z.GetTotalZElevation() !== n)
                            break;
                        w.RendersToOwnZPlane() ? (0 < z.GetDepth() && tempInstanceList3.push(w),
                        tempInstanceList2$jscomp$1.push(w)) : tempInstanceList3.push(w)
                    }
                }
                if (1 !== tempInstanceList2$jscomp$1.length || tempInstanceList2$jscomp$1[0].MustMitigateZFighting()) {
                    this._Draw3DLayersCoplanarInstances(a, b, tempInstanceList2$jscomp$1);
                    for (let w = 0, z = tempInstanceList3.length; w < z; ++w)
                        g = tempInstanceList3[w],
                        k = g.GetWorldInfo(),
                        l = k.GetLayer(),
                        k._SetDrawNonBackFacesOnly(!0),
                        MaybePrepareLayerDraw(l, a),
                        l._DrawInstanceMaybeWithEffects(g, k, a, b),
                        k._SetDrawNonBackFacesOnly(!1)
                } else {
                    MaybePrepareLayerDraw(l, a);
                    l._DrawInstanceMaybeWithEffects(g, k, a, b);
                    for (let w = 0, z = tempInstanceList3.length; w < z; ++w)
                        k = tempInstanceList3[w],
                        k !== g && (l = k.GetWorldInfo(),
                        n = l.GetLayer(),
                        MaybePrepareLayerDraw(n, a),
                        n._DrawInstanceMaybeWithEffects(k, l, a, b))
                }
                p = c;
                C3$jscomp$82.clearArray(tempInstanceList2$jscomp$1);
                C3$jscomp$82.clearArray(tempInstanceList3)
            } else
                ++p
        }
        e && a.EndQuery(e);
        this._runtime.IsGPUProfiling() && a.IsWebGPU() && a.WriteTimestamp(2 * (d.GetIndex() + 1) + 1);
        C3$jscomp$82.clearArray(tempInstanceList1$jscomp$1);
        lastLayerPreparedForDrawing = null
    }
    _Draw3DLayersCoplanarInstances(a, b, d) {
        a.CoplanarStartStencilPass();
        for (let k = 0, l = d.length; k < l; ++k) {
            var c = d[k]
              , e = c.GetWorldInfo()
              , g = e.GetLayer();
            e._SetDrawBackFaceOnly(!0);
            MaybePrepareLayerDraw(g, a);
            g._DrawInstance(c, e, a)
        }
        a.CoplanarStartColorPass();
        for (let k = 0, l = d.length; k < l; ++k)
            c = d[k],
            e = c.GetWorldInfo(),
            g = e.GetLayer(),
            MaybePrepareLayerDraw(g, a),
            g._DrawInstanceMaybeWithEffects(c, e, a, b),
            e._SetDrawBackFaceOnly(!1);
        a.CoplanarRestoreStandardRendering()
    }
    _SaveToJson() {
        const a = {
            sx: this.GetScrollX(),
            sy: this.GetScrollY(),
            s: this.GetScale(),
            a: this.GetAngle(),
            w: this.GetWidth(),
            h: this.GetHeight(),
            ortho: this.IsOrthographicProjection(),
            vpX: this.GetVanishingPointX(),
            vpY: this.GetVanishingPointY(),
            fv: this._isFirstVisit,
            persist: this._persistData,
            fx: this._effectList.SaveToJson(),
            layers: {}
        };
        for (const b of this._allLayersFlat)
            a.layers[b.GetSID().toString()] = b._SaveToJson();
        return a
    }
    _LoadFromJson(a) {
        this._scrollX = a.sx;
        this._scrollY = a.sy;
        this._scale = a.s;
        this._angle = a.a;
        this._width = a.w;
        this._height = a.h;
        this._isOrthographicProjection = !!a.ortho;
        a.hasOwnProperty("vpX") && (this._vanishingPointX = a.vpX);
        a.hasOwnProperty("vpY") && (this._vanishingPointY = a.vpY);
        this._isFirstVisit = !!a.fv;
        this._persistData = a.persist;
        this._effectList.LoadFromJson(a.fx);
        this._needsRebuildEffectChainSteps = !0;
        for (const [b,d] of Object.entries(a.layers))
            a = parseInt(b, 10),
            (a = this.GetLayerBySID(a)) && a._LoadFromJson(d);
        this._SetAllLayersProjectionChanged();
        this._SetAllLayersMVChanged()
    }
    GetILayout() {
        return this._iLayout
    }
    UserScriptDispatcher() {
        return this._userScriptDispatcher
    }
    DispatchUserScriptEvent(a) {
        a.layout = this.GetILayout();
        var b = this._runtime;
        (b = b.IsDebug() && !b.GetEventSheetManager().IsInEventEngine()) && C3Debugger.StartMeasuringScriptTime();
        this._userScriptDispatcher.dispatchEvent(a);
        b && C3Debugger.AddScriptTime()
    }
    DispatchUserScriptEventAsyncWait(a) {
        a.layout = this.GetILayout();
        return this._userScriptDispatcher.dispatchEventAndWaitAsync(a)
    }
}
;
"use strict";
const C3$jscomp$83 = self.C3;
C3$jscomp$83.LayoutManager = class extends C3$jscomp$83.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._allLayouts = [];
        this._layoutsByName = new Map;
        this._layoutsBySid = new Map;
        this._mainRunningLayout = null;
        this._runningSubLayouts = [];
        this._firstLayout = null;
        this._isEndingLayout = 0;
        this._pendingChangeLayout = null
    }
    Release() {
        this._pendingChangeLayout = this._firstLayout = this._mainRunningLayout = this._runtime = null;
        C3$jscomp$83.clearArray(this._allLayouts);
        this._layoutsByName.clear();
        this._layoutsBySid.clear();
        C3$jscomp$83.clearArray(this._runningSubLayouts)
    }
    Create(a) {
        a = C3$jscomp$83.New(C3$jscomp$83.Layout, this, this._allLayouts.length, a);
        this._allLayouts.push(a);
        this._layoutsByName.set(a.GetName().toLowerCase(), a);
        this._layoutsBySid.set(a.GetSID(), a)
    }
    GetRuntime() {
        return this._runtime
    }
    SetFirstLayout(a) {
        this._firstLayout = a
    }
    GetFirstLayout() {
        if (this._firstLayout)
            return this._firstLayout;
        if (this._allLayouts.length)
            return this._allLayouts[0];
        throw Error("no first layout");
    }
    GetLayoutByName(a) {
        return this._layoutsByName.get(a.toLowerCase()) || null
    }
    GetLayoutBySID(a) {
        return this._layoutsBySid.get(a) || null
    }
    GetLayoutByIndex(a) {
        a = C3$jscomp$83.clamp(Math.floor(a), 0, this._allLayouts.length - 1);
        return this._allLayouts[a]
    }
    GetLayout(a) {
        return "number" === typeof a ? this.GetLayoutByIndex(a) : this.GetLayoutByName(a.toString())
    }
    GetAllLayouts() {
        return this._allLayouts
    }
    _SetMainRunningLayout(a) {
        this._mainRunningLayout = a
    }
    GetMainRunningLayout() {
        return this._mainRunningLayout
    }
    _AddRunningSubLayout(a) {
        if (this._runningSubLayouts.includes(a))
            throw Error("layout already running");
        this._runningSubLayouts.push(a)
    }
    _RemoveRunningSubLayout(a) {
        a = this._runningSubLayouts.indexOf(a);
        if (-1 === a)
            throw Error("layout not running");
        this._runningSubLayouts.splice(a, 1)
    }
    *runningLayouts() {
        this._mainRunningLayout && (yield this._mainRunningLayout);
        this._runningSubLayouts.length && (yield*this._runningSubLayouts)
    }
    IsLayoutRunning(a) {
        return this._mainRunningLayout === a || this._runningSubLayouts.includes(a)
    }
    SetIsEndingLayout(a) {
        if (a)
            this._isEndingLayout++;
        else {
            if (0 >= this._isEndingLayout)
                throw Error("already unset");
            this._isEndingLayout--
        }
    }
    IsEndingLayout() {
        return 0 < this._isEndingLayout
    }
    ChangeMainLayout(a) {
        this._pendingChangeLayout = a
    }
    ClearPendingChangeLayout() {
        this._pendingChangeLayout = null
    }
    IsPendingChangeMainLayout() {
        return !!this._pendingChangeLayout
    }
    GetPendingChangeMainLayout() {
        return this._pendingChangeLayout
    }
    SetAllLayerProjectionChanged() {
        const a = this.GetMainRunningLayout();
        a && a._SetAllLayersProjectionChanged()
    }
    SetAllLayerMVChanged() {
        const a = this.GetMainRunningLayout();
        a && a._SetAllLayersMVChanged()
    }
}
;
"use strict";
const C3$jscomp$84 = self.C3
  , NAMES_REGEXP = RegExp("<(.+?)>", "g");
C3$jscomp$84.TimelineManager = class extends C3$jscomp$84.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._timelineDataManager = C3$jscomp$84.New(C3$jscomp$84.TimelineDataManager);
        this._pluginInstance = null;
        this._timelines = [];
        this._timelinesByName = new Map;
        this._objectClassToTimelineMap = new Map;
        this._timelinesCreatedByTemplate = new Map;
        this._scheduledTimelines = [];
        this._playingTimelines = [];
        this._markedForRemovalTimelines = [];
        this._isTickingTimelines = this._changingLayout = this._hasRuntimeListeners = !1;
        this._tickFunc = ()=>this._OnTick();
        this._tick2Func = ()=>this._OnTick2();
        this._beforeLayoutChange = ()=>this._OnBeforeChangeLayout();
        this._layoutChange = ()=>this._OnAfterChangeLayout();
        this._instanceDestroy = b=>this._OnInstanceDestroy(b.instance);
        this._beforeLoad = b=>this._OnBeforeLoad();
        this._afterLoad = b=>this._OnAfterLoad();
        this._afterLayoutStart = b=>this._OnAfterLayoutStart();
        this._destroyedWhileLoadingState = [];
        this._renderChange = 0
    }
    Release() {
        this.RemoveRuntimeListeners();
        this._afterLoad = this._instanceDestroy = this._layoutChange = this._beforeLayoutChange = this._tick2Func = this._tickFunc = null;
        for (const a of this._timelines)
            a.Stop(),
            a.Release();
        C3$jscomp$84.clearArray(this._timelines);
        this._timelines = null;
        this._timelineDataManager.Release();
        this._timelineDataManager = null;
        C3$jscomp$84.clearArray(this._scheduledTimelines);
        this._scheduledTimelines = null;
        C3$jscomp$84.clearArray(this._playingTimelines);
        this._playingTimelines = null;
        C3$jscomp$84.clearArray(this._markedForRemovalTimelines);
        this._markedForRemovalTimelines = null;
        this._timelinesByName.clear();
        this._timelinesByName = null;
        this._objectClassToTimelineMap.clear();
        this._objectClassToTimelineMap = null;
        this._timelinesCreatedByTemplate.clear();
        this._timelinesCreatedByTemplate = null;
        C3$jscomp$84.clearArray(this._destroyedWhileLoadingState);
        this._runtime = this._destroyedWhileLoadingState = null
    }
    AddRuntimeListeners() {
        const a = this._runtime.Dispatcher();
        a.addEventListener("pretick", this._tickFunc);
        a.addEventListener("tick2", this._tick2Func);
        a.addEventListener("beforelayoutchange", this._beforeLayoutChange);
        a.addEventListener("layoutchange", this._layoutChange);
        a.addEventListener("instancedestroy", this._instanceDestroy);
        a.addEventListener("beforeload", this._beforeLoad);
        a.addEventListener("afterload", this._afterLoad);
        a.addEventListener("afterlayoutstart", this._afterLayoutStart)
    }
    RemoveRuntimeListeners() {
        const a = this._runtime.Dispatcher();
        a.removeEventListener("pretick", this._tickFunc);
        a.removeEventListener("tick2", this._tick2Func);
        a.removeEventListener("beforelayoutchange", this._beforeLayoutChange);
        a.removeEventListener("layoutchange", this._layoutChange);
        a.removeEventListener("instancedestroy", this._instanceDestroy);
        a.removeEventListener("beforeload", this._beforeLoad);
        a.removeEventListener("afterload", this._afterLoad);
        a.removeEventListener("afterlayoutstart", this._afterLayoutStart)
    }
    Create(a) {
        this._timelineDataManager.Add(a);
        a = C3$jscomp$84.TimelineState.CreateInitial(a, this);
        this.Add(a);
        this.SetTimelineObjectClassesToMap(a);
        this._timelinesCreatedByTemplate.set(a.GetName(), 0)
    }
    CreateFromTemplate(a) {
        var b = this.GetTimelineDataManager();
        a = a.GetTemplateName();
        b = b.Get(a);
        b = C3$jscomp$84.TimelineState.CreateFromTemplate(`${a}:${this._timelinesCreatedByTemplate.get(a)}`, b, this);
        this._IncreaseTemplateTimelinesCount(a);
        this.Add(b);
        return b
    }
    _IncreaseTemplateTimelinesCount(a) {
        this._timelinesCreatedByTemplate.set(a, this._timelinesCreatedByTemplate.get(a) + 1)
    }
    _SetCreatedTemplateTimelinesCount() {
        for (const a of this._timelines) {
            if (a.IsTemplate())
                continue;
            const b = a.GetTemplateName();
            this._IncreaseTemplateTimelinesCount(b)
        }
    }
    _ClearCreatedTemplateTimelinesCount() {
        for (const a of this._timelinesCreatedByTemplate.keys())
            this._timelinesCreatedByTemplate.set(a, 0)
    }
    Add(a) {
        this._timelines.push(a);
        this._timelinesByName.set(a.GetName().toLowerCase(), a)
    }
    Remove(a) {
        a.Removed();
        a.IsTemplate() || (C3$jscomp$84.arrayFindRemove(this._timelines, a),
        C3$jscomp$84.arrayFindRemove(this._scheduledTimelines, a),
        C3$jscomp$84.arrayFindRemove(this._playingTimelines, a),
        C3$jscomp$84.arrayFindRemove(this._markedForRemovalTimelines, a),
        this._timelinesByName.delete(a.GetName().toLowerCase()),
        this.RemoveTimelineFromObjectClassMap(a),
        a.IsReleased() || a.Release())
    }
    Trigger(a) {
        this._runtime.Trigger(a, this._pluginInstance, null)
    }
    GetRuntime() {
        return this._runtime
    }
    GetTimelineDataManager() {
        return this._timelineDataManager
    }
    SetPluginInstance(a) {
        this._pluginInstance = a
    }
    GetPluginInstance() {
        return this._pluginInstance
    }
    *GetTimelines() {
        for (const a of this._timelines)
            yield a
    }
    *GetPlayingTimelines() {
        for (const a of this._playingTimelines)
            yield a
    }
    SetTimelineObjectClassToMap(a, b) {
        this._objectClassToTimelineMap.has(a) || this._objectClassToTimelineMap.set(a, new Set);
        this._objectClassToTimelineMap.get(a).add(b)
    }
    SetTimelineObjectClassesToMap(a) {
        for (const b of a.GetObjectClasses())
            this.SetTimelineObjectClassToMap(b, a)
    }
    RemoveTimelineFromObjectClassMap(a) {
        for (const [b,d] of this._objectClassToTimelineMap.entries())
            d.has(a) && (d.delete(a),
            0 === d.size && this._objectClassToTimelineMap.delete(b))
    }
    GetTimelinesForObjectClass(a) {
        if (this._objectClassToTimelineMap.has(a))
            return this._objectClassToTimelineMap.get(a)
    }
    GetTimelineOfTemplateForInstances(a, b) {
        if (b)
            for (const d of this._timelines)
                if (b.every(c=>d.HasTrackInstance(c.instance, c.trackId)) && d.GetName().includes(a.GetName()))
                    return d
    }
    GetTimelineByName(a) {
        return this._timelinesByName.get(a.toLowerCase()) || null
    }
    GetScheduledOrPlayingTimelineByName(a) {
        for (const b of this._scheduledTimelines)
            if (b.GetName() === a)
                return b;
        for (const b of this._playingTimelines)
            if (b.GetName() === a)
                return b;
        return null
    }
    *GetTimelinesByName(a) {
        if (NAMES_REGEXP.test(a)) {
            NAMES_REGEXP.lastIndex = 0;
            let d;
            var b = new Set;
            do
                if (d = NAMES_REGEXP.exec(a)) {
                    const c = d[1].split(",");
                    for (const e of c)
                        b.add(e)
                }
            while (d);
            for (const c of b.values())
                (a = this.GetTimelineByName(c)) && (yield a);
            b.clear()
        } else
            (b = this.GetTimelineByName(a)) && (yield b)
    }
    *GetTimelinesByTags(a) {
        for (const b of this._timelines)
            b.HasTags(a) && (yield b)
    }
    AddScheduledTimeline(a) {
        this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a);
        this._MaybeEnableRuntimeListeners()
    }
    RemovePlayingTimeline(a) {
        C3$jscomp$84.arrayFindRemove(this._playingTimelines, a);
        this._MaybeDisableRuntimeListeners()
    }
    ScheduleTimeline(a) {
        this._playingTimelines.includes(a) ? (a.SetPlaying(!0),
        a.SetScheduled(!1),
        a.SetMarkedForRemoval(!1)) : (a.SetPlaying(!1),
        a.SetScheduled(!0),
        a.SetMarkedForRemoval(!1),
        this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a));
        this._MaybeEnableRuntimeListeners()
    }
    DeScheduleTimeline(a) {
        a.SetPlaying(!1);
        a.SetScheduled(!1);
        a.ResolvePlayPromise();
        C3$jscomp$84.arrayFindRemove(this._scheduledTimelines, a);
        this._MaybeDisableRuntimeListeners()
    }
    CompleteTimeline(a) {
        a.SetPlaying(!1);
        a.SetScheduled(!1);
        this._playingTimelines.includes(a) && (a.SetMarkedForRemoval(!0),
        this._markedForRemovalTimelines.push(a),
        C3$jscomp$84.arrayFindRemove(this._playingTimelines, a))
    }
    CompleteTimelineBeforeChangeOfLayout(a) {
        a.SetPlaying(!1);
        a.SetScheduled(!1);
        a.SetMarkedForRemoval(!1);
        a.SetPlaybackRate(1);
        C3$jscomp$84.arrayFindRemove(this._playingTimelines, a)
    }
    CompleteTimelineAndResolve(a) {
        this.CompleteTimeline(a);
        a.ResolvePlayPromise()
    }
    _OnTick() {
        if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
            for (this._isTickingTimelines = !0; this._scheduledTimelines.length; ) {
                var a = this._scheduledTimelines.pop();
                a.SetInitialState();
                0 !== a.GetRenderChange() && (this._renderChange = 1);
                this._playingTimelines.push(a)
            }
            a = this._runtime._GetDtFast();
            var b = this._runtime.GetDt1()
              , d = this._runtime.GetTimeScale();
            for (let c = this._playingTimelines.length - 1; 0 <= c; c--) {
                const e = this._playingTimelines[c];
                e && e.Tick(a, d, b)
            }
            this._isTickingTimelines = !1;
            0 !== this._renderChange && this.GetRuntime().UpdateRender()
        }
    }
    _OnTick2() {
        if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
            var a;
            for (let b = 0, d = this._markedForRemovalTimelines.length; b < d; b++) {
                const c = this._markedForRemovalTimelines[b];
                a || (a = new Set);
                c.Removed();
                this._MaybeExecuteTimelineFinishTriggers(c);
                a.add(c)
            }
            if (a) {
                C3$jscomp$84.arrayRemoveAllInSet(this._markedForRemovalTimelines, a);
                this._renderChange = 0;
                for (let b = 0, d = this._playingTimelines.length; b < d; b++)
                    if (0 !== this._playingTimelines[b].GetRenderChange()) {
                        this._renderChange = 1;
                        break
                    }
            }
            this._MaybeDisableRuntimeListeners()
        }
    }
    _MaybeExecuteTimelineFinishTriggers(a) {
        a.IsReleased() || a.HasValidTracks() && a.IsComplete() && a.InitialStateSet() && a.FinishTriggers()
    }
    _MaybeEnableRuntimeListeners() {
        this._hasRuntimeListeners || (this._hasRuntimeListeners = !0)
    }
    _MaybeDisableRuntimeListeners() {
        this._markedForRemovalTimelines.length || this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = !1)
    }
    _OnBeforeChangeLayout() {
        for (this._changingLayout = !0; this._scheduledTimelines.length; )
            this.DeScheduleTimeline(this._scheduledTimelines.pop());
        const a = new Set;
        for (const b of this._playingTimelines)
            b._OnBeforeChangeLayout() && (b.Removed(),
            a.add(b));
        C3$jscomp$84.arrayRemoveAllInSet(this._playingTimelines, a);
        a.clear();
        for (const b of this._markedForRemovalTimelines)
            b._OnBeforeChangeLayout() && (b.Removed(),
            a.add(b));
        C3$jscomp$84.arrayRemoveAllInSet(this._markedForRemovalTimelines, a);
        this._MaybeDisableRuntimeListeners();
        for (const b of this._timelines)
            b.CleanCaches()
    }
    _OnAfterChangeLayout() {
        this._changingLayout = !1
    }
    _OnInstanceDestroy(a) {
        var b = a.GetObjectClass();
        if (b = this.GetTimelinesForObjectClass(b))
            if (this._runtime.IsLoadingState())
                this._destroyedWhileLoadingState.push(a);
            else
                for (const d of b)
                    d.IsTemplate() || (d.IsReleased() ? this.Remove(d) : d.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(d),
                    this.Remove(d)))
    }
    _OnBeforeLoad() {
        for (const a of this._scheduledTimelines.map(b=>b))
            this._MaybeExecuteTimelineFinishTriggers(a),
            this.Remove(a);
        for (const a of this._playingTimelines.map(b=>b))
            this._MaybeExecuteTimelineFinishTriggers(a),
            this.Remove(a)
    }
    _OnAfterLoad() {
        for (const a of this._destroyedWhileLoadingState)
            this._OnInstanceDestroy(a);
        C3$jscomp$84.clearArray(this._destroyedWhileLoadingState)
    }
    _OnAfterLayoutStart() {
        const a = this._runtime.GetLayoutManager().GetMainRunningLayout();
        if (a)
            for (const b of this._timelines) {
                const d = b.GetStartOnLayout();
                d && a.GetName() === d && this.ScheduleTimeline(b)
            }
    }
    _SaveToJson() {
        return {
            timelinesJson: this._SaveTimelinesToJson(),
            scheduledTimelinesJson: this._SaveScheduledTimelinesToJson(),
            playingTimelinesJson: this._SavePlayingTimelinesToJson(),
            markedForRemovalTimelinesJson: this._SaveMarkedForRemovalTimelinesToJson(),
            hasRuntimeListeners: this._hasRuntimeListeners,
            changingLayout: this._changingLayout,
            isTickingTimelines: this._isTickingTimelines
        }
    }
    _LoadFromJson(a) {
        a && (this._ClearCreatedTemplateTimelinesCount(),
        this._LoadTimelinesFromJson(a.timelinesJson),
        this._LoadScheduledTimelinesFromJson(a.scheduledTimelinesJson),
        this._LoadPlayingTimelinesFromJson(a.playingTimelinesJson),
        this._LoadMarkedForRemovalTimelinesFromJson(a.markedForRemovalTimelinesJson),
        this._hasRuntimeListeners = !a.hasRuntimeListeners,
        this._changingLayout = !!a.changingLayout,
        this._isTickingTimelines = !!a.isTickingTimelines,
        this._SetCreatedTemplateTimelinesCount(),
        this._MaybeEnableRuntimeListeners(),
        this._MaybeDisableRuntimeListeners())
    }
    _SaveTimelinesToJson() {
        return this._timelines.map(a=>a._SaveToJson())
    }
    _LoadTimelinesFromJson(a) {
        for (const b of a) {
            a = this.GetTimelineByName(b.name);
            if (!a) {
                a = this._GetTemplateNameFromJson(b);
                if (!a)
                    continue;
                a = this.GetTimelineByName(a);
                a = this.CreateFromTemplate(a)
            }
            a._LoadFromJson(b);
            a.HasTracks() || this.Remove(a)
        }
    }
    _GetTemplateNameFromJson(a) {
        return (a = a.name.split(":")) && 2 === a.length ? a[0] : null
    }
    _SaveScheduledTimelinesToJson() {
        return this._SaveTimelines(this._scheduledTimelines)
    }
    _LoadScheduledTimelinesFromJson(a) {
        this._LoadTimelines(a, this._scheduledTimelines)
    }
    _SavePlayingTimelinesToJson() {
        return this._SaveTimelines(this._playingTimelines)
    }
    _LoadPlayingTimelinesFromJson(a) {
        this._LoadTimelines(a, this._playingTimelines)
    }
    _SaveMarkedForRemovalTimelinesToJson() {
        return this._SaveTimelines(this._markedForRemovalTimelines)
    }
    _LoadMarkedForRemovalTimelinesFromJson(a) {
        this._LoadTimelines(a, this._markedForRemovalTimelines)
    }
    _IsTimelineInJson(a, b) {
        if (!b)
            return !1;
        for (const d of b)
            if (d === a.GetName())
                return !0;
        return !1
    }
    _SaveTimelines(a) {
        return a.map(b=>b.GetName())
    }
    _LoadTimelines(a, b) {
        var d = new Set;
        for (const c of b)
            this._IsTimelineInJson(c, a) || d.add(c);
        C3$jscomp$84.arrayRemoveAllInSet(b, d);
        if (a) {
            d = c=>e=>e.GetName() === c;
            for (const c of a)
                (a = this.GetTimelineByName(c)) && (b.find(d(c)) || b.push(a))
        }
    }
}
;
"use strict";
const C3$jscomp$85 = self.C3
  , TANGENT_RESULT = [0, 0]
  , MAP_RESULT = [0, 0]
  , PROJECTION_RESULT = [0, 0, 0, 0, 0];
C3$jscomp$85.TimelineInfo = class {
    constructor(a, b) {
        this._initialized = !1;
        this._timeline = a;
        this._segments = [];
        if (b = b ? this._timeline.GetTrackById(b) : C3$jscomp$85.first(this._timeline.GetTracks()))
            if (a = b.GetPropertyTrack("offsetX"),
            b = b.GetPropertyTrack("offsetY"),
            a && b) {
                this._xTrack = a;
                this._yTrack = b;
                a = a.GetPropertyKeyframeDataItemArrayIncludingDisabled();
                b = b.GetPropertyKeyframeDataItemArrayIncludingDisabled();
                for (let d = 1, c = Math.min(a.length, b.length); d < c; ++d) {
                    const e = a[d];
                    e.GetNext();
                    const g = e.GetPrevious()
                      , k = b[d];
                    k.GetNext();
                    const l = k.GetPrevious();
                    g && "cubic-bezier" === g.GetPathMode() && l && "cubic-bezier" === l.GetPathMode() ? this._segments.push(C3$jscomp$85.New(C3$jscomp$85.TimelineCubicBezierSegmentInfo, g, l, e, k, this._segments.length)) : (g && "line" === g.GetPathMode() && l && l.GetPathMode(),
                    this._segments.push(C3$jscomp$85.New(C3$jscomp$85.TimelineLineSegmentInfo, e, k, this._segments.length)))
                }
                this._initialized = !0
            }
    }
    Release() {
        for (const a of this._segments)
            a.Release();
        C3$jscomp$85.clearArray(this._segments);
        this._yTrack = this._xTrack = this._timeline = this._segments = null
    }
    WasInitialized() {
        return this._initialized
    }
    segments() {
        return this._segments
    }
    SetOrigin(a) {
        const b = "relative" === this._xTrack.GetResultMode() ? a.GetX() : 0;
        a = "relative" === this._yTrack.GetResultMode() ? a.GetY() : 0;
        for (const d of this._segments)
            d.SetOrigin(b, a)
    }
    Project(a, b, d) {
        d && d.tRange && (C3$jscomp$85.IsFiniteNumber(d.tRange[0]) || (d.tRange[0] = 0),
        C3$jscomp$85.IsFiniteNumber(d.tRange[1]) || (d.tRange[1] = 1));
        const c = [];
        for (const e of this._segments)
            if ("cubic-bezier" === e.GetType()) {
                const g = e.Project(a, b, d ? d.tRange : null);
                g[4] = e.GetIndex();
                c.push(JSON.parse(JSON.stringify(g)))
            }
        c.sort((e,g)=>e[3] - g[3]);
        return c[0]
    }
    Tangent(a, b) {
        return this._segments[b].Tangent(a)
    }
    TangentAngle(a, b, d, c) {
        return this._segments[c].TangentAngle(a, b, d)
    }
}
;
C3$jscomp$85.TimelineCubicBezierSegmentInfo = class {
    constructor(a, b, d, c, e) {
        this._index = e;
        e = a.GetAddOn("cubic-bezier");
        const g = d.GetAddOn("cubic-bezier")
          , k = b.GetAddOn("cubic-bezier")
          , l = c.GetAddOn("cubic-bezier");
        this._aX = a.GetValueWithResultMode();
        this._aY = b.GetValueWithResultMode();
        this._bX = a.GetValueWithResultMode() + e.GetStartAnchor();
        this._bY = b.GetValueWithResultMode() + k.GetStartAnchor();
        this._cX = d.GetValueWithResultMode() + g.GetEndAnchor();
        this._cY = c.GetValueWithResultMode() + l.GetEndAnchor();
        this._dX = d.GetValueWithResultMode();
        this._dY = c.GetValueWithResultMode();
        this._initialized = !1;
        this._len = 100;
        this._arcLengths = Array(this._len + 1);
        this._length = this._arcLengths[0] = 0;
        this._lut = [];
        this._CalculateLength()
    }
    Release() {
        C3$jscomp$85.clearArray(this._arcLengths);
        this._arcLengths = null;
        C3$jscomp$85.clearArray(this._lut);
        this._lut = null
    }
    GetType() {
        return "cubic-bezier"
    }
    GetIndex() {
        return this._index
    }
    GetStepCount() {
        return Math.floor(this._length / 30)
    }
    GetStepIncrement() {
        return 1 / this.GetStepCount()
    }
    SetOrigin(a, b) {
        this._originX = a;
        this._originY = b;
        this._arcLengths = Array(this._len + 1);
        this._arcLengths[0] = 0;
        this._CalculateLength()
    }
    Map(a) {
        if (!this._initialized)
            return NaN;
        a = this._Map(a);
        MAP_RESULT[0] = this._X(a);
        MAP_RESULT[1] = this._Y(a);
        return MAP_RESULT
    }
    Project(a, b, d) {
        const c = this._GenerateLUT(100);
        d = this._FindClosestFromLUT(a, b, c, d);
        a = this._RefineProjection(a, b, c, d);
        PROJECTION_RESULT[0] = a.x;
        PROJECTION_RESULT[1] = a.y;
        PROJECTION_RESULT[2] = a.t;
        PROJECTION_RESULT[3] = a.distance;
        return PROJECTION_RESULT
    }
    Tangent(a) {
        var b = 1 - a
          , d = b * b;
        b = 2 * b * a;
        const c = a * a;
        a = 3 * d * (this._bX + this._originX - (this._aX + this._originX)) + 3 * b * (this._cX + this._originX - (this._bX + this._originX)) + 3 * c * (this._dX + this._originX - (this._cX + this._originX));
        d = 3 * d * (this._bY + this._originY - (this._aY + this._originY)) + 3 * b * (this._cY + this._originY - (this._bY + this._originY)) + 3 * c * (this._dY + this._originY - (this._cY + this._originY));
        b = Math.hypot(a, d);
        TANGENT_RESULT[0] = a / b;
        TANGENT_RESULT[1] = d / b;
        return TANGENT_RESULT
    }
    TangentAngle(a, b, d) {
        d = this.Tangent(d);
        return C3$jscomp$85.angleTo(a, b, a + d[0], b + d[1])
    }
    _Map(a) {
        if (this._initialized) {
            a *= this._arcLengths[this._len];
            for (var b = 0, d = this._len, c = 0; b < d; )
                c = b + ((d - b) / 2 | 0),
                this._arcLengths[c] < a ? b = c + 1 : d = c;
            this._arcLengths[c] > a && c--;
            b = this._arcLengths[c];
            return b === a ? c / this._len : (c + (a - b) / (this._arcLengths[c + 1] - b)) / this._len
        }
    }
    _X(a) {
        return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(a, this._aX + this._originX, this._bX + this._originX, this._cX + this._originX, this._dX + this._originX) : NaN
    }
    _Y(a) {
        return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(a, this._aY + this._originY, this._bY + this._originY, this._cY + this._originY, this._dY + this._originY) : NaN
    }
    _GenerateLUT(a) {
        a = a || 100;
        if (this._lut.length === a)
            return this._lut;
        this._lut = [];
        a++;
        for (let b = 0; b < a; b++) {
            const d = b / (a - 1)
              , c = this._X(d)
              , e = this._Y(d);
            this._lut.push({
                x: c,
                y: e,
                t: d,
                distance: 0
            })
        }
        return this._lut
    }
    _FindClosestFromLUT(a, b, d, c=null, e=Number.MAX_SAFE_INTEGER) {
        let g = 0;
        d.forEach((k,l)=>{
            k.t = l / (d.length - 1);
            k.distance = C3$jscomp$85.distanceTo(a, b, k.x, k.y);
            c && C3$jscomp$85.IsArray(c) && C3$jscomp$85.IsFiniteNumber(c[0]) && C3$jscomp$85.IsFiniteNumber(c[1]) ? k.t >= c[0] && k.t <= c[1] && k.distance < e && (e = k.distance,
            g = l) : k.distance < e && (e = k.distance,
            g = l)
        }
        );
        return g
    }
    _RefineProjection(a, b, d, c, e=0, g=1) {
        let k = d[c]
          , l = 1
          , n = Number.MAX_SAFE_INTEGER;
        do {
            var p = 0 === c ? 0 : c - 1;
            let t = c === d.length - 1 ? d.length - 1 : c + 1
              , w = d[p].t
              , z = []
              , B = (d[t].t - w) / 4;
            if (.001 > B)
                break;
            z.push(d[p]);
            for (p = 1; 3 >= p; p++) {
                const C = w + p * B
                  , E = this._X(C)
                  , F = this._Y(C)
                  , J = Math.abs(C3$jscomp$85.distanceTo(E, F, a, b) - e);
                J < n && (n = J,
                k = {
                    x: E,
                    y: F,
                    t: C,
                    distance: J
                },
                c = p);
                z.push({
                    x: E,
                    y: F,
                    t: C,
                    distance: J
                })
            }
            z.push(d[t]);
            d = z
        } while (25 > l++);
        e && n > g && (k = null);
        return k
    }
    _CalculateLength() {
        this._initialized = !0;
        let a = this._X(0)
          , b = this._Y(0)
          , d = 0;
        for (let c = 1; c <= this._len; c++) {
            const e = this._X(.01 * c)
              , g = this._Y(.01 * c);
            d += Math.hypot(a - e, b - g);
            this._arcLengths[c] = d;
            a = e;
            b = g
        }
        this._length = d
    }
}
;
C3$jscomp$85.TimelineLineSegmentInfo = class {
    constructor(a, b, d) {
        this._index = d;
        this._targetX = a.GetValueWithResultMode();
        this._targetY = b.GetValueWithResultMode();
        this._originY = this._originX = 0
    }
    Release() {}
    GetType() {
        return "line"
    }
    GetIndex() {
        return this._index
    }
    SetOrigin(a, b) {
        this._originX = a;
        this._originY = b
    }
    GetX() {
        return this._targetX + this._originX
    }
    GetY() {
        return this._targetY + this._originY
    }
}
;
"use strict";
const C3$jscomp$86 = self.C3;
C3$jscomp$86.TimelineState = class extends C3$jscomp$86.DefendedBase {
    constructor(a, b, d) {
        super();
        this._runtime = d.GetRuntime();
        this._timelineManager = d;
        this._timelineDataItem = b;
        this._name = a;
        this._tracks = [];
        this._tracksLength = 0;
        this._beforeAndAfterTracks = null;
        this._beforeAndAfterTracksLength = 0;
        this.CreateTrackStates();
        this._playResolve = this._playPromise = null;
        this._playheadTime = 0;
        this._playbackRate = 1;
        this._pingPongState = 0;
        this._currentRepeatCount = 1;
        this._initialStateSet = this._isScheduled = this._isPlaying = !1;
        this._complete = !0;
        this._markedForRemoval = this._released = !1;
        this._completedTick = -1;
        this._firstTick = this._finishedTriggers = this._isTemplate = this._implicitPause = !1;
        this._lastDelta = NaN;
        this._tags = [""];
        this._stringTags = "";
        this._tagsChanged = !1;
        this._hasNestedContent = this._renderChange = 0;
        this._iTimelineState = null
    }
    static CreateInitial(a, b) {
        var d = b.GetTimelineDataManager();
        const c = d.GetNameId();
        d = d.Get(a[c]);
        a = C3$jscomp$86.New(C3$jscomp$86.TimelineState, a[c], d, b);
        a.SetIsTemplate(!0);
        return a
    }
    static CreateFromTemplate(a, b, d) {
        return C3$jscomp$86.New(C3$jscomp$86.TimelineState, a, b, d)
    }
    Release() {
        if (!this.IsReleased()) {
            var a = this._runtime.Dispatcher();
            this._timelineManager.DeScheduleTimeline(this);
            this._timelineManager.CompleteTimelineAndResolve(this);
            for (const b of this._tracks)
                b.Release();
            C3$jscomp$86.clearArray(this._tracks);
            this._timelineDataItem = this._timelineManager = this._runtime = this._tracks = null;
            this._released = !0;
            this._playResolve = this._playPromise = null;
            this.FireReleaseEvent(a)
        }
    }
    FireReleaseEvent(a) {
        const b = C3$jscomp$86.New(C3$jscomp$86.Event, "timelinestatereleased");
        b.timelineState = this;
        a.dispatchEvent(b)
    }
    GetType() {
        return 0
    }
    CreateTrackStates() {
        for (const a of this._timelineDataItem.GetTrackData().trackDataItems())
            this._tracksLength = this._tracks.push(C3$jscomp$86.TrackState.Create(this, a))
    }
    GetTimelineManager() {
        return this._timelineManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetTracks() {
        return this._tracks
    }
    GetSimilarPropertyTracks(a, b, d) {
        if (this._hasNestedContent) {
            var c;
            for (let g = 0; g < this._tracks.length; g++) {
                var e = this._tracks[g];
                a === e.GetInstance() && (e = e.GetPropertyTrack(d)) && b.constructor === e.GetSourceAdapter().constructor && (c || (c = []),
                c.push(e))
            }
            return c
        }
    }
    HasTracks() {
        return !!this._tracks.length
    }
    GetTrackById(a) {
        for (const b of this._tracks)
            if (C3$jscomp$86.equalsNoCase(b.GetId(), a))
                return b;
        return null
    }
    GetTrackByName(a) {
        for (const b of this._tracks)
            if (!b.IsInstanceTrack() && C3$jscomp$86.equalsNoCase(b.GetName(), a))
                return b;
        return null
    }
    SetName(a) {
        this._name = a
    }
    GetName() {
        return this._name
    }
    GetTimelineDataItem() {
        return this._timelineDataItem
    }
    GetTemplateName() {
        return this._timelineDataItem.GetName()
    }
    GetTotalTime() {
        return this._timelineDataItem.GetTotalTime()
    }
    SetTotalTime(a) {
        this._timelineDataItem.SetTotalTime(a)
    }
    GetStep() {
        return this._timelineDataItem.GetStep()
    }
    SetStep(a) {
        this._timelineDataItem.SetStep(a)
    }
    GetInterpolationMode() {
        return this._timelineDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(a) {
        this._timelineDataItem.SetInterpolationMode(a)
    }
    GetResultMode() {
        return this._timelineDataItem.GetResultMode()
    }
    SetResultMode(a) {
        this._timelineDataItem.GetResultMode(a)
    }
    SetEase(a) {
        for (const b of this.GetTracks())
            b.SetEase(a)
    }
    GetLoop() {
        return this._timelineDataItem.GetLoop()
    }
    SetLoop(a) {
        return this._timelineDataItem.SetLoop(a)
    }
    GetPingPong() {
        return this._timelineDataItem.GetPingPong()
    }
    SetPingPong(a) {
        return this._timelineDataItem.SetPingPong(a)
    }
    GetRepeatCount() {
        return this._timelineDataItem.GetRepeatCount()
    }
    SetRepeatCount(a) {
        return this._timelineDataItem.SetRepeatCount(a)
    }
    SetPlaybackRate(a) {
        return this._playbackRate = a
    }
    GetPlaybackRate() {
        return this._playbackRate
    }
    GetStartOnLayout() {
        return this._timelineDataItem.GetStartOnLayout()
    }
    GetTransformWithSceneGraph() {
        return this._timelineDataItem.GetTransformWithSceneGraph()
    }
    GetUseSystemTimescale() {
        return this._timelineDataItem.GetUseSystemTimescale()
    }
    IsForwardPlayBack() {
        return this.IsPlaying() ? 0 < this._playbackRate : !0
    }
    GetPlayPromise() {
        return this._playPromise ? this._playPromise : this._playPromise = new Promise(a=>{
            this._playResolve = a
        }
        )
    }
    ResolvePlayPromise() {
        this._playPromise && (this._playResolve(),
        this._playResolve = this._playPromise = null)
    }
    SetTags(a) {
        this._tags = C3$jscomp$86.TimelineState._GetTagArray(a);
        this._tagsChanged = !0
    }
    GetTags() {
        return this._tags
    }
    GetStringTags() {
        this._tagsChanged && (this._stringTags = this._tags.join(" "));
        this._tagsChanged = !1;
        return this._stringTags
    }
    HasTags(a) {
        return this._tags && this._tags.length ? (a = C3$jscomp$86.TimelineState._GetTagArray(a)) && a.length ? a.every(C3$jscomp$86.TimelineState._HasTag, this) : !1 : !1
    }
    OnStarted() {
        C3$jscomp$86.Plugins.Timeline && this.constructor === C3$jscomp$86.TimelineState && (C3$jscomp$86.Plugins.Timeline.Cnds.PushTriggerTimeline(this),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnTimelineStarted),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnTimelineStartedByName),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnTimelineStartedByTags),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnAnyTimelineStarted),
        C3$jscomp$86.Plugins.Timeline.Cnds.PopTriggerTimeline())
    }
    OnCompleted() {
        this._completedTick = this._runtime.GetTickCount()
    }
    FinishTriggers() {
        this._finishedTriggers || (this._finishedTriggers = !0,
        C3$jscomp$86.Plugins.Timeline && this.constructor === C3$jscomp$86.TimelineState && (C3$jscomp$86.Plugins.Timeline.Cnds.PushTriggerTimeline(this),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnTimelineFinished),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnTimelineFinishedByName),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnTimelineFinishedByTags),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnAnyTimelineFinished),
        C3$jscomp$86.Plugins.Timeline.Cnds.PopTriggerTimeline()))
    }
    SetPlaying(a) {
        this._isPlaying = a
    }
    IsCompletedTick() {
        return this._completedTick === this._runtime.GetTickCount()
    }
    IsPlaying(a=!1) {
        return this.IsCompletedTick() || this.IsScheduled() && !a ? !0 : this._isPlaying
    }
    _IsPlaying() {
        return this.IsPlaying(!0)
    }
    IsPaused() {
        return this._IsPaused()
    }
    _IsPaused() {
        return this.IsReleased() || this.IsScheduled() || this._IsPlaying() || this.IsComplete() ? !1 : !0
    }
    SetScheduled(a) {
        this._isScheduled = a
    }
    IsScheduled() {
        return this._isScheduled
    }
    SetComplete(a) {
        this._complete = a;
        a = this.GetTime();
        if (0 >= a || a >= this.GetTotalTime())
            this._complete = !0
    }
    IsComplete() {
        return this._complete
    }
    IsReleased() {
        return this._released
    }
    SetMarkedForRemoval(a) {
        this._markedForRemoval = a
    }
    IsMarkedForRemoval() {
        return this._markedForRemoval
    }
    SetImplicitPause(a) {
        this._implicitPause = a
    }
    IsImplicitPause() {
        return this._implicitPause
    }
    SetIsTemplate(a) {
        this._isTemplate = !!a
    }
    IsTemplate() {
        return this._isTemplate
    }
    InitialStateSet() {
        return this._initialStateSet
    }
    GetTime() {
        return this._playheadTime
    }
    SetTime(a) {
        const b = this.GetTime();
        this._SetTime(a);
        this.SetComplete(!1);
        this.IsComplete() || this.SetImplicitPause(!0);
        if (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet)
            this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this),
            this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime();
        this._SetUpdateStateBefore();
        this._Interpolate(this.GetTime(), !1, !0, !0, b);
        this._SetUpdateStateAfter();
        this._renderChange && this.GetRuntime().UpdateRender();
        this._OnSetTime()
    }
    _SetTime(a) {
        C3$jscomp$86.IsFiniteNumber(a) || (a = this.GetTotalTime());
        0 > a ? this._playheadTime = 0 : a >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = a
    }
    _SetTimeAndReset(a) {
        C3$jscomp$86.IsFiniteNumber(a) || (a = this.GetTotalTime());
        0 > a ? this._playheadTime = 0 : a >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = a;
        for (const b of this._tracks)
            b.SetResetState()
    }
    _OnSetTime() {
        C3$jscomp$86.Plugins.Timeline && this.constructor === C3$jscomp$86.TimelineState && (C3$jscomp$86.Plugins.Timeline.Cnds.PushTriggerTimeline(this),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnTimeSet),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnTimeSetByName),
        this._timelineManager.Trigger(C3$jscomp$86.Plugins.Timeline.Cnds.OnTimeSetByTags),
        C3$jscomp$86.Plugins.Timeline.Cnds.PopTriggerTimeline())
    }
    _CanResume() {
        if (!this.GetLoop())
            if (this.GetPingPong() && 1 === this._pingPongState)
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime())
                        return !1
                } else {
                    if (0 >= this.GetTime())
                        return !1
                }
            else if (!this.GetLoop() && !this.GetPingPong())
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime())
                        return !1
                } else if (0 >= this.GetTime())
                    return !1;
        return !0
    }
    Resume() {
        this.IsReleased() || this._CanResume() && this.Play(!0)
    }
    Play(a=!1) {
        return this.IsReleased() || this.IsScheduled() ? !1 : this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : this._IsPlaying() || !this.IsComplete() && !a && !this.IsImplicitPause() ? !1 : this._ScheduleStoppedTimeline()
    }
    _SchedulePlayingTimeline() {
        this.SetImplicitPause(!1);
        this._timelineManager.RemovePlayingTimeline(this);
        this._timelineManager.ScheduleTimeline(this);
        this.GetPlayPromise();
        return !0
    }
    _ScheduleStoppedTimeline() {
        this.SetImplicitPause(!1);
        this._timelineManager.ScheduleTimeline(this);
        this.GetPlayPromise();
        return !0
    }
    Stop(a=!1) {
        this.IsReleased() || (this.SetComplete(a),
        this._timelineManager.CompleteTimeline(this),
        this.IsComplete() && this.ResolvePlayPromise())
    }
    Reset(a=!0, b=!1) {
        if (!this.IsReleased()) {
            if (!this._IsPlaying() && this.IsScheduled())
                return this._timelineManager.DeScheduleTimeline(this);
            if (!this.IsComplete()) {
                this.Stop(!0);
                this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                var d = this.GetTime();
                this._SetUpdateStateBefore();
                b ? this._InterpolateBeforeChangeLayout(d) : this._Interpolate(d, !1, !1, !0);
                a && this._OnSetTime();
                this._SetUpdateStateAfter();
                this._renderChange && a && this.GetRuntime().UpdateRender()
            }
        }
    }
    ResetBeforeChangeLayout() {
        this.Reset(!1, !0)
    }
    _InterpolateBeforeChangeLayout(a) {
        this._Interpolate(a, !1, !1, !0, NaN, !1, !0)
    }
    _OnBeforeChangeLayout() {
        if (this.IsReleased())
            return !0;
        if (!this.GetRuntime().IsLoadingState() && this.HasValidGlobalTracks())
            return !1;
        this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);
        this.GetRuntime().IsLoadingState() || this.ResetBeforeChangeLayout();
        return !0
    }
    SetInitialStateFromSetTime() {
        this.SetInitialState(!0)
    }
    SetInitialState(a) {
        if (!this.IsMarkedForRemoval()) {
            if (a) {
                this._finishedTriggers = !1;
                this._firstTick = this._initialStateSet = !0;
                this._SetUpdateStateBefore();
                for (const b of this._tracks)
                    b.SetInitialState()
            } else if (this.SetPlaying(!0),
            this.SetScheduled(!1),
            this.OnStarted(),
            this.IsComplete()) {
                this._completedTick = -1;
                0 !== this._pingPongState && (this._playbackRate = Math.abs(this._playbackRate));
                this._pingPongState = 0;
                this._currentRepeatCount = 1;
                this._finishedTriggers = this._complete = !1;
                this._firstTick = this._initialStateSet = !0;
                this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                this._SetUpdateStateBefore();
                for (const b of this._tracks)
                    b.SetInitialState()
            } else {
                this._firstTick = !0;
                this._finishedTriggers = !1;
                this._SetUpdateStateBefore();
                for (const b of this._tracks)
                    b.SetResumeState()
            }
            this._SetUpdateStateAfter()
        }
    }
    GetRenderChange() {
        return this._renderChange
    }
    _SetUpdateStateBefore() {
        this._hasNestedContent = 0;
        for (const a of this._tracks)
            a.IsNested() && (this._hasNestedContent = 1)
    }
    _SetUpdateStateAfter() {
        this._renderChange = 0;
        for (const a of this._tracks)
            a._SetUpdateState(),
            0 === this._renderChange && 1 === a.GetRenderChange() && (this._renderChange = 1),
            this._beforeAndAfterTracks || 1 !== a.GetNeedsBeforeAndAfter() || (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []),
            this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(a))
    }
    Tick(a, b, d) {
        if (this.GetUseSystemTimescale()) {
            if (0 === a && 0 === this._lastDelta)
                return;
            this._lastDelta = a
        } else {
            if (0 === d && 0 === this._lastDelta)
                return;
            a = this._lastDelta = d;
            b = 1
        }
        d = this._playheadTime;
        b = d + a * b * this._playbackRate;
        a = this._timelineDataItem._totalTime;
        this._playheadTime = 0 > b ? 0 : b >= a ? a : b;
        var c = !1;
        b = !1;
        var e = this.GetLoop()
          , g = this.GetPingPong();
        e || g ? e && !g ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTimeAndReset(0),
        b = !0) : 0 >= this._playheadTime && (this._SetTimeAndReset(a),
        b = !0) : !e && g ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a),
        this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
        b = !0,
        1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
        this._pingPongState = 0) : c = !0 : 0 === this._pingPongState && (this._pingPongState = 1)) : 0 >= this._playheadTime && (this._SetTime(0),
        this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
        b = !0,
        1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
        this._pingPongState = 0) : c = !0 : 0 === this._pingPongState && (this._pingPongState = 1)) : e && g && (0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a),
        this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
        b = !0,
        this._pingPongState++,
        C3$jscomp$86.wrap(this._pingPongState, 0, 2)) : 0 >= this._playheadTime && (this._SetTime(0),
        this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
        b = !0,
        this._pingPongState++,
        C3$jscomp$86.wrap(this._pingPongState, 0, 2))) : 0 < this._playbackRate ? this._playheadTime >= a && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
        this._SetTimeAndReset(0),
        b = !0) : (this._SetTime(a),
        c = !0)) : 0 >= this._playheadTime && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
        this._SetTimeAndReset(a),
        b = !0) : (this._SetTime(0),
        c = !0));
        e = this._tracksLength;
        if (c) {
            for (c = 0; c < e; c++)
                this._tracks[c].SetEndState();
            this.Stop(!0);
            this.OnCompleted()
        } else {
            g = this._beforeAndAfterTracksLength;
            for (c = 0; c < g; c++)
                this._beforeAndAfterTracks[c].BeforeInterpolate();
            if (1 === this._hasNestedContent)
                for (c = 0; c < e; c++) {
                    const k = this._tracks[c]
                      , l = k.GetStartOffset()
                      , n = d - l;
                    0 > this._playheadTime - l && 0 < n ? (this._playheadTime = 0 > l ? 0 : l >= a ? a : l,
                    k.Interpolate(l, !0, !1, b, this._firstTick, !1)) : k.Interpolate(this._playheadTime, !0, !1, b, this._firstTick, !1)
                }
            else
                for (c = 0; c < e; c++)
                    this._tracks[c].Interpolate(this._playheadTime, !0, !1, b, this._firstTick, !1);
            for (c = 0; c < g; c++)
                this._beforeAndAfterTracks[c].AfterInterpolate();
            this._firstTick && (this._firstTick = !1)
        }
    }
    _Interpolate(a, b=!1, d=!1, c=!1, e=NaN, g=!1, k=!1) {
        for (var l of this._tracks)
            l.BeforeInterpolate();
        for (const n of this._tracks) {
            l = a;
            if ("number" === typeof e && !isNaN(e)) {
                const p = this.GetTime() - n.GetStartOffset()
                  , t = e - n.GetStartOffset();
                0 > p && 0 < t && (l = n.GetStartOffset(),
                this._SetTime(l))
            }
            n.Interpolate(l, b, d, c, this._firstTick, k)
        }
        for (const n of this._tracks)
            n.AfterInterpolate();
        this._firstTick && g && (this._firstTick = !1)
    }
    AddTrack() {
        var a = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
        a = C3$jscomp$86.TrackState.Create(this, a);
        this._tracksLength = this._tracks.push(a);
        return a
    }
    Removed() {
        if (!this.IsReleased())
            for (const a of this._tracks)
                a.TimelineRemoved()
    }
    CleanCaches() {
        for (const a of this._tracks)
            a.CleanCaches()
    }
    ClearTrackInstances() {
        for (const a of this._tracks)
            a.ClearInstance()
    }
    SetTrackInstance(a, b) {
        if (b)
            for (const d of this._tracks)
                if (d.IsInstanceTrack()) {
                    if (a) {
                        if (d.GetId() !== a)
                            continue
                    } else if (d.HasInstance())
                        continue;
                    d.SetInstance(b);
                    this._timelineManager.SetTimelineObjectClassToMap(b.GetObjectClass(), this);
                    break
                }
    }
    HasTrackInstance(a, b) {
        for (const d of this._tracks)
            if (d.IsInstanceTrack())
                if (b) {
                    if (b === d.GetId() && a === d.GetInstance())
                        return !0
                } else if (a === d.GetInstance())
                    return !0;
        return !1
    }
    HasValidTracks() {
        return this._tracks.some(a=>a.IsInstanceTrack() ? a.CanInstanceBeValid() : !0)
    }
    HasValidGlobalTracks() {
        return this._tracks.some(a=>a.IsInstanceTrack() ? a.CanInstanceBeValid() ? (a = a.GetObjectClass()) ? a.IsGlobal() : !1 : !1 : !1)
    }
    GetPropertyTrack(a) {
        for (const b of this.GetTracks())
            for (const d of b.GetPropertyTracks())
                if (d.GetPropertyName() === a)
                    return d
    }
    GetTrackFromInstance(a) {
        for (const b of this._tracks)
            if (a === b.GetInstance())
                return b;
        return null
    }
    GetKeyframeWithTags(a) {
        a = a ? a.split(" ") : [];
        a = [...(new Set(a.map(b=>b.toLowerCase().trim()))).values()];
        for (const b of this.GetTracks())
            for (const d of b.GetKeyframeDataItems())
                if (a.every(c=>d.HasTag(c)))
                    return d
    }
    GetObjectClasses() {
        const a = [];
        for (const b of this.GetTracks())
            a.push(b.GetObjectClass());
        return a.filter(b=>b)
    }
    _SaveToJson() {
        return {
            tracksJson: this._SaveTracksToJson(),
            name: this._name,
            playheadTime: this.GetTime(),
            playbackRate: this._playbackRate,
            pingPongState: this._pingPongState,
            currentRepeatCount: this._currentRepeatCount,
            isPlaying: this._isPlaying,
            isScheduled: this._isScheduled,
            initialStateSet: this._initialStateSet,
            finishedTriggers: this._finishedTriggers,
            complete: this._complete,
            released: this._released,
            markedForRemoval: this._markedForRemoval,
            completedTick: this._completedTick,
            implicitPause: this._implicitPause,
            isTemplate: this._isTemplate,
            tags: this._tags.join(" "),
            stringTags: this._stringTags,
            tagsChanged: this._tagsChanged,
            firstTick: this._firstTick
        }
    }
    _LoadFromJson(a) {
        a && (this._LoadTracksFromJson(a.tracksJson),
        this._name = a.name,
        this._playheadTime = a.playheadTime,
        this._playbackRate = a.playbackRate,
        this._pingPongState = a.pingPongState,
        this._currentRepeatCount = a.currentRepeatCount,
        this._isPlaying = !!a.isPlaying,
        this._isScheduled = !!a.isScheduled,
        this._initialStateSet = !!a.initialStateSet,
        this._finishedTriggers = a.hasOwnProperty("finishedTriggers") ? !!a.finishedTriggers : !1,
        this._complete = !!a.complete,
        this._released = !!a.released,
        this._markedForRemoval = !!a.markedForRemoval,
        this._completedTick = a.completedTick,
        this._implicitPause = !!a.implicitPause,
        this._isTemplate = !!a.isTemplate,
        this._tags = a.tags.split(" "),
        this._stringTags = a.stringTags,
        this._tagsChanged = !!a.tagsChanged,
        this._firstTick = !!a.firstTick)
    }
    _SaveTracksToJson() {
        return this._tracks.map(a=>a._SaveToJson())
    }
    _LoadTracksFromJson(a) {
        this.ClearTrackInstances();
        a.forEach((b,d)=>{
            this._tracks[d]._LoadFromJson(b)
        }
        );
        this._tracks.filter(b=>b.CanInstanceBeValid())
    }
    static _HasTag(a) {
        const b = this.GetTags();
        return "" === a ? 1 === b.length && "" === b[0] : b.map(d=>d.toLowerCase()).includes(a.toLowerCase())
    }
    static _GetTagArray(a) {
        if (C3$jscomp$86.IsArray(a))
            return a.slice(0);
        if (C3$jscomp$86.IsString(a))
            return a.split(" ");
        throw Error("invalid tags");
    }
    GetITimelineState() {
        this._iTimelineState || (this._iTimelineState = C3$jscomp$86.New(self.ITimelineState, this));
        return this._iTimelineState
    }
}
;
"use strict";
const C3$jscomp$87 = self.C3;
C3$jscomp$87.TrackState = class extends C3$jscomp$87.DefendedBase {
    constructor(a, b) {
        super();
        this._timeline = a;
        this._trackDataItem = b;
        this._trackData = b.GetTrackData();
        this._objectClassIndex = this._instanceUid = NaN;
        this._worldInfo = this._instance = null;
        this._isNested = 0 < b.GetStartOffset();
        this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
        this._lastKeyframeDataItem = null;
        this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();
        this._propertyTracks = [];
        this.CreatePropertyTrackStates();
        this._needsBeforeAndAfter = this._renderChange = this._worldInfoChange = 0
    }
    static Create(a, b) {
        return C3$jscomp$87.New(C3$jscomp$87.TrackState, a, b)
    }
    Release() {
        this._keyframeDataItems = null;
        for (const a of this._propertyTracks)
            a.Release();
        C3$jscomp$87.clearArray(this._propertyTracks);
        this._lastKeyframeDataItem = this._trackDataItem = this._worldInfo = this._instance = this._timeline = this._propertyTracks = null
    }
    CreatePropertyTrackStates() {
        for (const a of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems())
            this._propertyTracks.push(C3$jscomp$87.PropertyTrackState.Create(this, a))
    }
    TimelineRemoved() {
        for (const a of this._propertyTracks)
            a.TimelineRemoved()
    }
    CleanCaches() {
        for (const a of this._propertyTracks)
            a.CleanCaches();
        this._worldInfo = this._instance = null
    }
    GetTimeline() {
        return this._timeline
    }
    GetRuntime() {
        return this._timeline.GetRuntime()
    }
    GetKeyframeDataItems() {
        return this._keyframeDataItems ? this._keyframeDataItems : this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()
    }
    GetPropertyTracks() {
        return this._propertyTracks
    }
    GetPropertyTrack(a) {
        for (let b = 0; b < this._propertyTracks.length; b++) {
            const d = this._propertyTracks[b];
            if (d.GetPropertyName() === a)
                return d
        }
    }
    MaybeGetInstance() {
        this._instance || this.GetInstance()
    }
    IsInstanceValid() {
        return this._instance ? !this._instance.IsDestroyed() : !1
    }
    CanInstanceBeValid() {
        if (!this.IsInstanceTrack())
            return !1;
        var a = this.GetInstanceUID();
        return (a = this.GetRuntime().GetInstanceByUID(a)) ? !a.IsDestroyed() : !1
    }
    GetObjectClass() {
        if (this.IsInstanceTrack()) {
            var a = this.GetObjectClassIndex();
            if (-1 !== a)
                return this.GetRuntime().GetObjectClassByIndex(a)
        }
    }
    ClearInstance() {
        this._instance = null;
        this._instanceUid = -1;
        this._worldInfo = null;
        this._objectClassIndex = -1
    }
    HasInstance() {
        return !!this._instance
    }
    GetInstance() {
        if (this._instance && this.IsInstanceValid())
            return this._instance;
        const a = this.GetInstanceUID();
        return this._instance = this.GetRuntime().GetInstanceByUID(a)
    }
    SetInstance(a) {
        if (this._instance !== a) {
            this.CleanCaches();
            this._instance = a;
            this._objectClassIndex = a.GetObjectClass().GetIndex();
            this._instanceUid = a.GetUID();
            this._worldInfo = a.GetWorldInfo();
            for (const g of this.propertyTrackItems()) {
                const k = g.sourceAdapter;
                switch (g.propertyTrack.GetSourceAdapterId()) {
                case "instance-variable":
                    k.GetEditorIndex();
                    var b = a.GetObjectClass()
                      , d = b.GetInstanceVariableIndexByName(g.name)
                      , c = b.GetInstanceVariableName(d);
                    b = b.GetInstanceVariableType(d);
                    c === g.name && b === g.type && k.UpdateInstanceVariableIndex(d);
                    break;
                case "behavior":
                    var e = g.behaviorType;
                    d = this.GetObjectClass();
                    c = a.GetObjectClass();
                    b = k.GetBehaviorType(c);
                    e && b && (e = e.GetName(),
                    d.GetBehaviorIndexByName(e),
                    c.GetBehaviorIndexByName(e),
                    k.GetEditorIndex(),
                    k.UpdateBehaviorTypeSid(b.GetSID()))
                }
            }
        }
    }
    *propertyTrackItems() {
        for (const d of this._propertyTracks) {
            var a = d.GetSourceAdapter()
              , b = this.GetObjectClass();
            const c = {
                propertyTrack: d,
                sourceAdapter: a
            };
            switch (d.GetSourceAdapterId()) {
            case "world-instance":
                c.property = d.GetPropertyName();
                break;
            case "instance-variable":
                a = a.GetEditorIndex();
                c.name = b.GetInstanceVariableName(a);
                c.type = b.GetInstanceVariableType(a);
                break;
            case "effect":
                b = b.GetEffectList();
                a = a.GetEffectType(b);
                c.effectType = a;
                break;
            case "behavior":
                a = a.GetBehaviorType(b);
                c.behaviorType = a;
                break;
            case "plugin":
                c.plugin = b.GetPlugin()
            }
            yield c
        }
    }
    GetWorldInfo() {
        if (this._worldInfo && this.IsInstanceValid())
            return this._worldInfo;
        const a = this.GetInstance();
        a && (this._worldInfo = a.GetWorldInfo());
        return this._worldInfo
    }
    GetTrackDataItem() {
        return this._trackDataItem
    }
    GetInstanceUID() {
        return this._instanceUid ? this._instanceUid : this._trackDataItem.GetInstanceUID()
    }
    SetInstanceUID(a) {
        this._trackDataItem.SetInstanceUID(a)
    }
    GetInterpolationMode() {
        return this._trackDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(a) {
        this._trackDataItem.SetInterpolationMode(a)
    }
    GetResultMode() {
        return this._trackDataItem.GetResultMode()
    }
    GetId() {
        return this._trackDataItem.GetId()
    }
    GetStartOffset() {
        return this._trackDataItem.GetStartOffset()
    }
    GetLocalTotalTime() {
        return this._trackDataItem.GetLocalTotalTime()
    }
    SetLocalTotalTime(a) {
        this._trackDataItem.SetLocalTotalTime(a)
    }
    SetResultMode(a) {
        this._trackDataItem.SetResultMode(a)
    }
    SetEase(a) {
        for (const b of this.GetKeyframeDataItems())
            b.SetEase(a);
        for (const b of this.GetPropertyTracks())
            b.SetEase(a)
    }
    GetEnable() {
        return this._trackDataItem.GetEnable()
    }
    SetEnable(a) {
        this._trackDataItem.SetEnable(a)
    }
    GetObjectClassIndex() {
        return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex
    }
    SetObjectClassIndex(a) {
        this._trackDataItem.SetObjectClassIndex(a)
    }
    SetOriginalWidth(a) {
        this._trackDataItem.SetOriginalWidth(a)
    }
    GetOriginalWidth() {
        const a = this.GetInstance();
        return a && a.GetSdkInstance().IsOriginalSizeKnown() ? a.GetSdkInstance().GetOriginalWidth() : this._trackDataItem.GetOriginalWidth()
    }
    SetOriginalHeight(a) {
        this._trackDataItem.SetOriginalHeight(a)
    }
    GetOriginalHeight() {
        const a = this.GetInstance();
        return a && a.GetSdkInstance().IsOriginalSizeKnown() ? a.GetSdkInstance().GetOriginalHeight() : this._trackDataItem.GetOriginalHeight()
    }
    GetType() {
        return this._trackDataItem.GetType()
    }
    GetName() {
        return this._trackDataItem.GetName()
    }
    IsInstanceTrack() {
        return 0 === this.GetType()
    }
    IsValueTrack() {
        return 1 === this.GetType()
    }
    IsAudioTrack() {
        return 2 === this.GetType()
    }
    GetWorldInfoChange() {
        return this._worldInfoChange
    }
    GetRenderChange() {
        return this._renderChange
    }
    GetNeedsBeforeAndAfter() {
        return this._needsBeforeAndAfter
    }
    IsNested() {
        return this._isNested
    }
    SetResetState() {
        for (const a of this._propertyTracks)
            a.SetResetState()
    }
    SetInitialState() {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            var a = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
            for (const b of this._propertyTracks)
                b.SetInitialState(a),
                0 === this._worldInfoChange && 1 === b.GetWorldInfoChange() && (this._worldInfoChange = 1),
                0 === this._renderChange && 1 === b.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            this._propertyTracks.some(b=>b.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
            this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
            this.Interpolate(a);
            this.OnKeyframeReached(this._GetLastKeyFrameBeforeTime(a))
        }
    }
    SetResumeState() {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            this._timeline.IsForwardPlayBack();
            var a = this._timeline.GetTime() - this.GetStartOffset();
            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
            for (const b of this._propertyTracks)
                b.SetResumeState(a)
        }
    }
    SetEndState() {
        if (!(this.GetTimeline().IsComplete() || (this.MaybeGetInstance(),
        !this.IsInstanceValid() && this.IsInstanceTrack() || this._isNested))) {
            const a = this._timeline.GetTime()
              , b = this.GetStartOffset() + this.GetLocalTotalTime();
            a >= b ? this.Interpolate(this.GetLocalTotalTime(), !0, !1, !0, !1, !1, !0) : 0 >= a && this.Interpolate(0, !0, !1, !0, !1, !1, !0)
        }
    }
    _SetUpdateState() {
        for (let a = 0, b = this._propertyTracks.length; a < b; a++) {
            const d = this._propertyTracks[a];
            d._SetUpdateState();
            0 === this._worldInfoChange && 1 === d.GetWorldInfoChange() && (this._worldInfoChange = 1);
            0 === this._renderChange && 1 === d.GetRenderChange() && (this._renderChange = 1)
        }
    }
    BeforeInterpolate() {
        const a = this._propertyTracks.length;
        for (let b = 0; b < a; b++)
            this._propertyTracks[b].BeforeInterpolate()
    }
    Interpolate(a, b=!1, d=!1, c=!1, e=!1, g=!1, k=!1) {
        this._instance || this.GetInstance();
        const l = this._instance && !this._instance.IsDestroyed()
          , n = 0 === this._trackDataItem._type;
        if (!(!l && n || g && n && this.GetObjectClass().IsGlobal() || (a -= this.GetStartOffset(),
        0 > a))) {
            this.MaybeSetInitialStateOfNestedTrack(a, b);
            this.MaybeTriggerKeyframeReachedConditions(a, b, e);
            for (let p = 0, t = this._propertyTracks.length; p < t; p++)
                this._propertyTracks[p].Interpolate(a, d, c, k);
            this.MaybeSetEndStateOfNestedTrack(a, b);
            0 !== this._worldInfoChange && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()),
            this._worldInfo && this._worldInfo.SetBboxChanged())
        }
    }
    AfterInterpolate() {
        const a = this._propertyTracks.length;
        for (let b = 0; b < a; b++)
            this._propertyTracks[b].AfterInterpolate()
    }
    MaybeSetInitialStateOfNestedTrack(a, b) {
        if (b && this._isNested && !this._initialStateOfNestedSet) {
            if (this.GetTimeline().IsForwardPlayBack()) {
                if (0 > a)
                    return;
                for (const d of this._propertyTracks)
                    d.Interpolate(0, !1, !0)
            } else {
                if (a > this.GetLocalTotalTime())
                    return;
                for (const d of this._propertyTracks)
                    d.Interpolate(this.GetLocalTotalTime(), !1, !0)
            }
            for (const d of this._propertyTracks)
                d.SetInitialState();
            this._initialStateOfNestedSet = !0
        }
    }
    MaybeSetEndStateOfNestedTrack(a, b) {
        if (b && this._isNested && !this._endStateOfNestedSet)
            if (this.GetTimeline().IsForwardPlayBack()) {
                if (a >= this.GetLocalTotalTime()) {
                    for (const d of this._propertyTracks)
                        d.Interpolate(this.GetLocalTotalTime(), !1, !0);
                    this._endStateOfNestedSet = !0
                }
            } else if (0 >= a) {
                for (const d of this._propertyTracks)
                    d.Interpolate(0, !1, !0);
                this._endStateOfNestedSet = !0
            }
    }
    MaybeTriggerKeyframeReachedConditions(a, b, d) {
        if (!d && b && C3$jscomp$87.Plugins.Timeline) {
            b = this.GetTimeline();
            d = this._lastKeyframeDataItem.GetNext();
            var c = this._lastKeyframeDataItem.GetTime()
              , e = d ? d.GetTime() : b.GetTotalTime();
            if (a <= c || a >= e)
                this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(a, this._trackDataItem),
                b.IsForwardPlayBack() ? d && this.OnKeyframeReached(this._lastKeyframeDataItem) : (a = this._lastKeyframeDataItem.GetNext()) && this.OnKeyframeReached(a)
        }
    }
    _GetLastKeyFrameBeforeTime(a) {
        const b = this._trackData.GetKeyFrameDataItemAtTime(a, this._trackDataItem);
        return b ? b : this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(a, this._trackDataItem)
    }
    OnKeyframeReached(a) {
        const b = this.GetTimeline()
          , d = b.GetTimelineManager();
        C3$jscomp$87.Plugins.Timeline.Cnds.PushTriggerTimeline(b);
        C3$jscomp$87.Plugins.Timeline.Cnds.PushTriggerKeyframe(a);
        d.Trigger(C3$jscomp$87.Plugins.Timeline.Cnds.OnAnyKeyframeReached);
        d.Trigger(C3$jscomp$87.Plugins.Timeline.Cnds.OnKeyframeReached);
        C3$jscomp$87.Plugins.Timeline.Cnds.PopTriggerTimeline(b);
        C3$jscomp$87.Plugins.Timeline.Cnds.PopTriggerKeyframe(a)
    }
    AddKeyframe() {
        return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem()
    }
    AddPropertyTrack() {
        var a = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem();
        a = C3$jscomp$87.PropertyTrackState.Create(this, a);
        this._propertyTracks.push(a);
        return a
    }
    DeleteKeyframes(a) {
        this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(a)
    }
    DeletePropertyKeyframes(a) {
        for (const b of this._propertyTracks)
            b.DeletePropertyKeyframes(a)
    }
    SaveState() {
        for (const a of this._propertyTracks)
            a.SaveState()
    }
    CompareInitialStateWithCurrent() {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack())
            for (const a of this._propertyTracks)
                a.CompareInitialStateWithCurrent()
    }
    CompareSaveStateWithCurrent() {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            var a = !1;
            for (const b of this._propertyTracks) {
                const d = b.CompareSaveStateWithCurrent();
                !a && d && (a = !0)
            }
            a && (a = this.AddKeyframe(),
            a.SetTime(this.GetTimeline().GetTime()),
            a.SetEase("noease"),
            a.SetEnable(!0),
            a.SetTags(""))
        }
    }
    _SaveToJson() {
        var a = this.GetInstance();
        a = a ? a.GetUID() : this.GetInstanceUID();
        return {
            propertyTracksJson: this._SavePropertyTracksToJson(),
            lastKeyframeDataItemJson: this._SaveLastKeyframeDataItemToJson(),
            initialStateOfNestedSet: this._initialStateOfNestedSet,
            endStateOfNestedSet: this._endStateOfNestedSet,
            instanceUid: a
        }
    }
    _LoadFromJson(a) {
        if (a) {
            this._LoadPropertyTracksFromJson(a.propertyTracksJson);
            this._LoadLastKeyframeDataItemFromJson(a.lastKeyframeDataItemJson);
            this._LoadInstanceFromJson(a.instanceUid);
            this._initialStateOfNestedSet = !1;
            a.hasOwnProperty.initialStateOfNestedSet && (this._initialStateOfNestedSet = a.initialStateOfNestedSet);
            this._endStateOfNestedSet = !1;
            a.hasOwnProperty.endStateOfNestedSet && (this._endStateOfNestedSet = a.endStateOfNestedSet);
            for (const b of this._propertyTracks)
                0 === this._worldInfoChange && 1 === b.GetWorldInfoChange() && (this._worldInfoChange = 1),
                0 === this._renderChange && 1 === b.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            this._propertyTracks.some(b=>b.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1)
        }
    }
    _SaveLastKeyframeDataItemToJson() {
        return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem)
    }
    _SavePropertyTracksToJson() {
        return this._propertyTracks.map(a=>a._SaveToJson())
    }
    _LoadPropertyTracksFromJson(a) {
        a.forEach((b,d)=>{
            this._propertyTracks[d]._LoadFromJson(b)
        }
        )
    }
    _LoadInstanceFromJson(a) {
        C3$jscomp$87.IsFiniteNumber(a) && (a = this.GetRuntime().GetInstanceByUID(a)) && this.GetTimeline().SetTrackInstance(this._trackDataItem.GetId(), a)
    }
    _LoadLastKeyframeDataItemFromJson(a) {
        this._lastKeyframeDataItem = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemFromIndex(a)
    }
}
;
"use strict";
const C3$jscomp$88 = self.C3;
C3$jscomp$88.PropertyTrackState = class extends C3$jscomp$88.DefendedBase {
    constructor(a, b) {
        super();
        this._track = a;
        this._propertyTrackDataItem = b;
        this._propertyTrackData = b.GetPropertyTrackData();
        this._needsBeforeAndAfter = this._renderChange = this._worldInfoChange = 0;
        this._sourceAdapter = this.GetSourceAdapter();
        this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        this._absoluteValueObject = this._lastPropertyKeyframeDataItem = null
    }
    static Create(a, b) {
        return C3$jscomp$88.New(C3$jscomp$88.PropertyTrackState, a, b)
    }
    Release() {
        this._track = null;
        this._sourceAdapter && (this._sourceAdapter.Release(),
        this._sourceAdapter = null);
        this._propertyTrackData = this._propertyTrackDataItem = this._propertyKeyframeDataItems = null
    }
    GetWorldInfoChange() {
        return this._worldInfoChange
    }
    GetRenderChange() {
        return this._renderChange
    }
    GetNeedsBeforeAndAfter() {
        return this._needsBeforeAndAfter
    }
    HasAbsoluteValueObject() {
        return !!this._absoluteValueObject
    }
    SetAbsoluteValueObject(a) {
        this._absoluteValueObject = a
    }
    GetAbsoluteValueObject() {
        return this._absoluteValueObject
    }
    GetTrack() {
        return this._track
    }
    GetPropertyTrackDataItem() {
        return this._propertyTrackDataItem
    }
    GetPropertyTrackData() {
        return this._propertyTrackData
    }
    GetTimeline() {
        return this._track.GetTimeline()
    }
    GetRuntime() {
        return this._track.GetRuntime()
    }
    GetInstance() {
        return this._track.GetInstance()
    }
    GetSourceAdapter() {
        if (this._sourceAdapter)
            return this._sourceAdapter;
        let a;
        switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
        case "behavior":
            a = new C3$jscomp$88.PropertyTrackState.BehaviorSourceAdapter(this);
            break;
        case "effect":
            a = new C3$jscomp$88.PropertyTrackState.EffectSourceAdapter(this);
            this._renderChange = 1;
            break;
        case "instance-variable":
            a = new C3$jscomp$88.PropertyTrackState.InstanceVariableSourceAdapter(this);
            break;
        case "plugin":
            a = new C3$jscomp$88.PropertyTrackState.PluginSourceAdapter(this);
            this._renderChange = 1;
            break;
        case "world-instance":
            a = new C3$jscomp$88.PropertyTrackState.PropertySourceAdapter(this);
            this._worldInfoChange = this._renderChange = 1;
            break;
        case "value":
            a = new C3$jscomp$88.PropertyTrackState.ValueSourceAdapter(this);
            break;
        case "audio":
            a = new C3$jscomp$88.PropertyTrackState.AudioSourceAdapter(this)
        }
        return this._sourceAdapter = a
    }
    GetSourceAdapterId() {
        return this._propertyTrackDataItem.GetSourceAdapterId()
    }
    SetSourceAdapterId(a) {
        this._propertyTrackDataItem.SetSourceAdapterId(a)
    }
    GetSourceAdapterArgs() {
        return this._propertyTrackDataItem.GetSourceAdapterArguments()
    }
    SetSourceAdapterArgs(a) {
        this._propertyTrackDataItem.SetSourceAdapterArguments(a)
    }
    GetSourceAdapterValue() {
        return this.GetSourceAdapter().GetValue()
    }
    GetPropertyName() {
        return this._propertyTrackDataItem.GetProperty()
    }
    SetPropertyName(a) {
        this._propertyTrackDataItem.SetProperty(a)
    }
    GetPropertyType() {
        return this._propertyTrackDataItem.GetType()
    }
    SetPropertyType(a) {
        this._propertyTrackDataItem.SetType(a)
    }
    GetPropertyKeyframeType() {
        return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType()
    }
    GetMin() {
        return this._propertyTrackDataItem.GetMin()
    }
    SetMin(a) {
        this._propertyTrackDataItem.SetMin(a)
    }
    GetMax() {
        return this._propertyTrackDataItem.GetMax()
    }
    SetMax(a) {
        this._propertyTrackDataItem.SetMax(a)
    }
    GetEnable() {
        return this._propertyTrackDataItem.GetEnable()
    }
    SetEnable(a) {
        this._propertyTrackDataItem.SetEnable(a)
    }
    GetInterpolationMode() {
        return this._propertyTrackDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(a) {
        this._propertyTrackDataItem.SetInterpolationMode(a)
    }
    GetResultMode() {
        return this._propertyTrackDataItem.GetResultMode()
    }
    SetResultMode(a) {
        this._propertyTrackDataItem.SetResultMode(a)
    }
    SetEase(a) {
        for (const b of this.GetPropertyKeyframeDataItems())
            b.SetEase(a)
    }
    CanHavePropertyKeyframes() {
        return this._propertyTrackDataItem.CanHavePropertyKeyframes()
    }
    GetPropertyKeyframeDataItems() {
        return this._propertyKeyframeDataItems ? this._propertyKeyframeDataItems : this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
    }
    GetPropertyKeyframeDataItemArrayIncludingDisabled() {
        return this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArrayIncludingDisabled()
    }
    GetPropertyKeyFrameDataItemAtTime(a) {
        return this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(a, this._propertyTrackDataItem)
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a) {
        return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem)
    }
    GetPropertyKeyframeDataItemPairForTime(a) {
        let b = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(a, this._propertyTrackDataItem);
        b ? a = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(a, this._propertyTrackDataItem) : (b = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem),
        a = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, this._propertyTrackDataItem));
        return {
            start: b,
            end: a
        }
    }
    *GetPropertyKeyframeValues() {
        for (const a of this.GetPropertyKeyframeDataItems())
            yield a.GetValueWithResultMode()
    }
    *GetPropertyKeyframeTimes() {
        for (const a of this.GetPropertyKeyframeDataItems())
            yield a.GetTime()
    }
    TimelineRemoved() {
        this.GetSourceAdapter().TimelineRemoved()
    }
    CleanCaches() {
        this.GetSourceAdapter().CleanCaches()
    }
    GetCurrentState() {
        return this.GetSourceAdapter().GetCurrentState()
    }
    SetResetState() {
        this.GetSourceAdapter().SetResetState()
    }
    SetInitialState(a) {
        this.GetSourceAdapter().SetInitialState();
        this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(a);
        this._SetUpdateState()
    }
    SetResumeState(a) {
        this.GetSourceAdapter().SetResumeState();
        this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(a)
    }
    _SetUpdateState() {
        var a = this.GetTrack();
        this._needsBeforeAndAfter = 0;
        if (a.IsInstanceTrack()) {
            var b = this.GetTimeline();
            a = a.GetInstance();
            const d = this.GetSourceAdapter()
              , c = this.GetPropertyName();
            d.MayNeedBeforeAndAfterInterpolate() ? (b = b.GetSimilarPropertyTracks(a, d, c)) && b.length && (this._needsBeforeAndAfter = 1) : this._needsBeforeAndAfter = 0
        }
    }
    _GetLastPropertyKeyFrameBeforeTime(a) {
        const b = this.GetTimeline()
          , d = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(a, this._propertyTrackDataItem);
        return d ? d : b.IsForwardPlayBack() ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem) : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, this._propertyTrackDataItem)
    }
    BeforeInterpolate() {
        this._sourceAdapter.BeforeInterpolate()
    }
    Interpolate(a, b=!1, d=!1, c=!1) {
        let e;
        if (b)
            var g = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
        else {
            if (this._lastPropertyKeyframeDataItem) {
                var k = this.GetTimeline();
                const l = this._lastPropertyKeyframeDataItem.GetNext();
                g = this._lastPropertyKeyframeDataItem.GetTime();
                k = l ? l.GetTime() : k.GetTotalTime();
                if (a <= g || a >= k)
                    this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem)
            } else
                this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
            g = this._lastPropertyKeyframeDataItem
        }
        g && (e = g.GetNext());
        this._sourceAdapter.Interpolate(a, g, e, b, d, c)
    }
    GetInterpolatedValue(a) {
        if (this._lastPropertyKeyframeDataItem) {
            var b = this.GetTimeline();
            const c = this._lastPropertyKeyframeDataItem.GetNext();
            var d = this._lastPropertyKeyframeDataItem.GetTime();
            b = c ? c.GetTime() : b.GetTotalTime();
            if (a <= d || a >= b)
                this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem)
        } else
            this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
        d = this._lastPropertyKeyframeDataItem;
        b = d.GetNext();
        return this._sourceAdapter.GetInterpolatedValue(a, d, b)
    }
    GetInterpolatedValueFast(a, b, d) {
        return this._sourceAdapter.GetInterpolatedValue(a, b, d)
    }
    AfterInterpolate() {
        this._sourceAdapter.AfterInterpolate()
    }
    static GetStartPropertyKeyframeForTime(a, b) {
        const d = b.GetPropertyTrackDataItem();
        return b._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, d)
    }
    static GetEndPropertyKeyframeForTime(a, b) {
        const d = b.GetPropertyTrackDataItem();
        return b._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, d)
    }
    AddPropertyKeyframe() {
        const a = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
        this._lastPropertyKeyframeDataItem = null;
        return a
    }
    DeletePropertyKeyframes(a) {
        this._lastPropertyKeyframeDataItem = null;
        this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(a)
    }
    SaveState() {
        this.GetSourceAdapter().SaveState()
    }
    CompareInitialStateWithCurrent() {
        if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
            const a = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem)
              , b = this.GetSourceAdapter().GetCurrentState();
            a.SetAbsoluteValue(b)
        }
    }
    CompareSaveStateWithCurrent() {
        const a = this.GetSourceAdapter().CompareSaveStateWithCurrent();
        a && this.AddPropertyKeyframeAtCurrentTime();
        this.GetSourceAdapter().ClearSaveState();
        return a
    }
    AddPropertyKeyframeAtCurrentTime() {
        const a = this.GetTimeline().GetTime()
          , b = this.GetSourceAdapter()
          , d = C3$jscomp$88.PropertyTrackState.GetStartPropertyKeyframeForTime(a, this)
          , c = this.AddPropertyKeyframe();
        c.SetType(d.GetType());
        c.SetTime(a);
        c.SetEase(d.GetEase());
        c.SetEnable(!0);
        c.SetValue(b.GetValueAtTime());
        c.SetAbsoluteValue(b.GetCurrentState())
    }
    _SaveToJson() {
        return {
            sourceAdapterJson: this.GetSourceAdapter()._SaveToJson()
        }
    }
    _LoadFromJson(a) {
        a && this.GetSourceAdapter()._LoadFromJson(a.sourceAdapterJson)
    }
}
;
"use strict";
const NS = self.C3.PropertyTrackState;
NS.PropertySourceAdapter = class {
    constructor(a) {
        this._propertyTrack = a;
        this._propertyAdapter = null;
        this.GetPropertyAdapter()
    }
    Release() {
        this._propertyAdapter && (this._propertyAdapter.Release(),
        this._propertyAdapter = null);
        this._propertyTrack = null
    }
    MayNeedBeforeAndAfterInterpolate() {
        return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate()
    }
    GetPropertyTrack() {
        return this._propertyTrack
    }
    TimelineRemoved() {
        this._propertyAdapter && this._propertyAdapter.TimelineRemoved()
    }
    CleanCaches() {
        this._propertyAdapter && this._propertyAdapter.CleanCaches()
    }
    GetPropertyAdapter() {
        return this._propertyAdapter ? this._propertyAdapter : this._propertyAdapter = this._CreatePropertyAdapter()
    }
    GetEditorIndex() {}
    GetIndex() {
        return this.GetEditorIndex()
    }
    GetTarget() {}
    SetResetState() {
        this.GetPropertyAdapter().SetResetState()
    }
    SetInitialState() {
        this.GetPropertyAdapter().SetInitialState()
    }
    SetResumeState() {
        this.GetPropertyAdapter().SetResumeState()
    }
    BeforeInterpolate() {
        this._propertyAdapter.BeforeChangeProperty()
    }
    Interpolate(a, b, d, c, e, g) {
        let k;
        switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
            k = NS.NumericTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
            break;
        case "angle":
            k = NS.AngleTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
            break;
        case "boolean":
            k = NS.BooleanTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
            break;
        case "color":
            k = NS.ColorTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
            break;
        case "text":
            k = NS.TextTypeAdapter.Interpolate(a, b, d, this._propertyTrack)
        }
        this._propertyAdapter.ChangeProperty(a, k, b, d, c, e, g)
    }
    GetInterpolatedValue(a, b, d) {
        switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
            return NS.NumericTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
        case "angle":
            return NS.AngleTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
        case "boolean":
            return NS.BooleanTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
        case "color":
            return NS.ColorTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
        case "text":
            return NS.TextTypeAdapter.Interpolate(a, b, d, this._propertyTrack)
        }
    }
    AfterInterpolate() {
        this._propertyAdapter.AfterChangeProperty()
    }
    SaveState() {
        this.GetPropertyAdapter().SetSaveState()
    }
    ClearSaveState() {
        this.GetPropertyAdapter().ClearSaveState()
    }
    GetCurrentState() {
        return this.GetPropertyAdapter().GetCurrentState()
    }
    CompareInitialStateWithCurrent() {
        return this.GetPropertyAdapter().CompareInitialStateWithCurrent()
    }
    CompareSaveStateWithCurrent() {
        return this.GetPropertyAdapter().CompareSaveStateWithCurrent()
    }
    GetValueAtTime() {
        const a = this._propertyTrack
          , b = a.GetTrack().GetTimeline().GetTime()
          , d = NS.GetStartPropertyKeyframeForTime(b, a)
          , c = d.GetNext();
        switch (a.GetPropertyKeyframeType()) {
        case "numeric":
            return NS.NumericTypeAdapter.Interpolate(b, d, c, a);
        case "angle":
            return NS.AngleTypeAdapter.Interpolate(b, d, c, a);
        case "boolean":
            return NS.BooleanTypeAdapter.Interpolate(b, d, c, a);
        case "color":
            return NS.ColorTypeAdapter.Interpolate(b, d, c, a);
        case "text":
            return NS.TextTypeAdapter.Interpolate(b, d, c, a)
        }
    }
    _CreatePropertyAdapter() {
        const a = this._propertyTrack;
        switch (a.CanHavePropertyKeyframes() ? a.GetPropertyKeyframeType() : "") {
        case "combo":
        case "boolean":
        case "text":
        case "string":
            return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
        case "numeric":
        case "number":
        case "angle":
            return "combo" === this._propertyTrack.GetPropertyType() ? new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
        case "color":
        case "offsetColor":
            return new NS.PropertyInterpolationAdapter.ColorInterpolationAdapter(this);
        default:
            return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this)
        }
    }
    _SaveToJson() {
        return {
            propertyAdapterJson: this.GetPropertyAdapter()._SaveToJson()
        }
    }
    _LoadFromJson(a) {
        a && this.GetPropertyAdapter()._LoadFromJson(a.propertyAdapterJson)
    }
}
;
"use strict";
const C3$jscomp$90 = self.C3
  , INDEX = 0;
class InstanceVariableSourceAdapter extends C3$jscomp$90.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a);
        this._updatedIndex = NaN
    }
    GetEditorIndex() {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX]
    }
    GetIndex() {
        return this._updatedIndex ? this._updatedIndex : super.GetIndex()
    }
    GetTarget() {
        return this._propertyTrack.GetTrack().GetInstance()
    }
    UpdateInstanceVariableIndex(a) {
        this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX] !== a && (this._updatedIndex = a)
    }
    Interpolate(a, b, d, c, e) {
        this.GetPropertyAdapter().CanChange(b.GetValue()) && super.Interpolate(a, b, d, c, e)
    }
    GetInterpolatedValue(a, b, d) {
        if (this.GetPropertyAdapter().CanChange(b.GetValue()))
            return super.GetInterpolatedValue(a, b, d)
    }
    _SaveToJson() {
        return Object.assign(super._SaveToJson(), {
            index: this._updatedIndex
        })
    }
    _LoadFromJson(a) {
        a && (super._LoadFromJson(a),
        this._updatedIndex = a.index)
    }
}
C3$jscomp$90.PropertyTrackState.InstanceVariableSourceAdapter = InstanceVariableSourceAdapter;
"use strict";
const C3$jscomp$91 = self.C3;
class BehaviorSourceAdapter extends C3$jscomp$91.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a);
        this._sid = NaN
    }
    GetEditorIndex() {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
    }
    GetTarget() {
        var a = this._propertyTrack.GetPropertyTrackDataItem()
          , b = this._propertyTrack.GetTrack();
        a = this._sid ? this._sid : a.GetSourceAdapterArguments()[0];
        b = b.GetInstance();
        a = b.GetBehaviorIndexBySID(a);
        return b.GetBehaviorInstances()[a].GetSdkInstance()
    }
    GetBehaviorType(a) {
        const b = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2];
        return a.GetBehaviorTypeByName(b)
    }
    UpdateBehaviorTypeSid(a) {
        this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._sid = a)
    }
    Interpolate(a, b, d, c, e) {
        const g = this._propertyTrack.GetTrack().GetInstance();
        this.GetBehaviorType(g.GetObjectClass()) && super.Interpolate(a, b, d, c, e)
    }
    GetInterpolatedValue(a, b, d) {
        const c = this._propertyTrack.GetTrack().GetInstance();
        if (this.GetBehaviorType(c.GetObjectClass()))
            return super.GetInterpolatedValue(a, b, d)
    }
    _SaveToJson() {
        return Object.assign(super._SaveToJson(), {
            sid: this._sid
        })
    }
    _LoadFromJson(a) {
        a && (super._LoadFromJson(a),
        this._sid = a.sid)
    }
}
C3$jscomp$91.PropertyTrackState.BehaviorSourceAdapter = BehaviorSourceAdapter;
"use strict";
const C3$jscomp$92 = self.C3;
class EffectSourceAdapter extends C3$jscomp$92.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a)
    }
    GetEditorIndex() {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
    }
    GetTarget() {
        const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
        var b = a.GetEffectList();
        b = this.GetEffectType(b).GetIndex();
        return a.IsEffectIndexActive(b) ? a.GetEffectParametersForIndex(b) : null
    }
    GetEffectType(a) {
        const b = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
        return a.GetEffectTypeByName(b)
    }
    Interpolate(a, b, d, c, e) {
        this._IsEffectActive() && super.Interpolate(a, b, d, c, e)
    }
    GetInterpolatedValue(a, b, d) {
        if (this._IsEffectActive())
            return super.GetInterpolatedValue(a, b, d)
    }
    _IsEffectActive() {
        const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
        var b = a.GetEffectList();
        if (b = this.GetEffectType(b))
            return b = b.GetIndex(),
            a.IsEffectIndexActive(b)
    }
}
C3$jscomp$92.PropertyTrackState.EffectSourceAdapter = EffectSourceAdapter;
"use strict";
const C3$jscomp$93 = self.C3;
class PluginSourceAdapter extends C3$jscomp$93.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a)
    }
    GetEditorIndex() {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
    }
    GetTarget() {
        return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance()
    }
    Interpolate(a, b, d, c, e) {
        var g = this._propertyTrack.GetTrack();
        const k = g.GetObjectClass().GetPlugin();
        g = g.GetInstance().GetObjectClass().GetPlugin();
        k === g && super.Interpolate(a, b, d, c, e)
    }
    GetInterpolatedValue(a, b, d) {
        var c = this._propertyTrack.GetTrack();
        const e = c.GetObjectClass().GetPlugin();
        c = c.GetInstance().GetObjectClass().GetPlugin();
        if (e === c)
            return super.GetInterpolatedValue(a, b, d)
    }
}
C3$jscomp$93.PropertyTrackState.PluginSourceAdapter = PluginSourceAdapter;
"use strict";
const C3$jscomp$94 = self.C3;
class ValueSourceAdapter extends C3$jscomp$94.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a);
        this._value = 0;
        this._init = !1
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !1
    }
    SetInitialState() {
        const a = this._propertyTrack.GetPropertyTrackData();
        let b = this._propertyTrack.GetPropertyTrackDataItem();
        b = a.GetFirstPropertyKeyframeDataItem(b);
        this._value = b.GetValueWithResultMode()
    }
    SetResumeState() {}
    GetValue() {
        this._init || this._propertyTrack.Interpolate(0);
        return this._value
    }
    Interpolate(a, b, d, c, e) {
        this._value = C3$jscomp$94.PropertyTrackState.NumericTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
        this._init = !0
    }
    SaveState() {}
    ClearSaveState() {}
    GetCurrentState() {
        return this._value
    }
    CompareInitialStateWithCurrent() {
        return !1
    }
    CompareSaveStateWithCurrent() {
        return !1
    }
    _SaveToJson() {
        return {
            value: this._value,
            init: this._init
        }
    }
    _LoadFromJson(a) {
        a && (this._value = a.value,
        this._init = a.hasOwnProperty("init") ? a.init : !0)
    }
}
C3$jscomp$94.PropertyTrackState.ValueSourceAdapter = ValueSourceAdapter;
"use strict";
const C3$jscomp$95 = self.C3;
class AudioSourceAdapter extends C3$jscomp$95.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
        super(a);
        this._audioPlaybackStarted = !1;
        this._expressions = this._actions = this._sdkInstance = null;
        this._timeline = this._propertyTrack.GetTimeline();
        this._track = this._propertyTrack.GetTrack();
        this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs();
        this._fileArgs = this._sourceAdapterArgs[0];
        this._startOffsetTime = this._sourceAdapterArgs[1];
        this._audioTag = this._sourceAdapterArgs[3] ? this._sourceAdapterArgs[3] : Math.random().toString(36).slice(2);
        this._volume = this._pauseVolume = this._pauseTime = NaN;
        this._audioSource = null;
        this._Initialize()
    }
    Release() {
        super.Release();
        this._audioSource = this._fileArgs = this._sourceAdapterArgs = this._track = this._timeline = this._expressions = this._actions = this._sdkInstance = null
    }
    _Initialize() {
        if (self.C3.Plugins.Audio) {
            var a = this._propertyTrack.GetRuntime().GetObjectClassByName("audio");
            a && (this._sdkInstance = a.GetSingleGlobalInstance().GetSdkInstance());
            this._actions = self.C3.Plugins.Audio.Acts;
            this._expressions = self.C3.Plugins.Audio.Exps
        }
    }
    _MaybeSetAudioSource() {
        if (!this._audioSource) {
            var a = this._propertyTrack.GetTrack().GetPropertyTrack("audioSource");
            a && (this._audioSource = a.GetSourceAdapter())
        }
    }
    _GetPauseVolume() {
        const a = this._propertyTrack.GetTrack().GetPropertyTrack("volume");
        return a ? a.GetSourceAdapter()._pauseVolume : this._pauseVolume
    }
    TimelineRemoved() {
        super.TimelineRemoved();
        this._audioPlaybackStarted = !1;
        this._sdkInstance && (this._expressions && (this._pauseTime = this._expressions.PlaybackTime.call(this._sdkInstance, this._audioTag),
        this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)),
        this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag))
    }
    GetAudioTag() {
        return this._audioTag
    }
    GetVolume() {
        return this._volume
    }
    SetVolume(a) {
        this._volume = a
    }
    SetInitialState() {
        super.SetInitialState();
        this._pauseTime = NaN;
        this._audioPlaybackStarted = !1
    }
    SetResumeState() {
        super.SetResumeState();
        const a = this._propertyTrack.GetTimeline().GetTime();
        this._pauseTime = a - this._startOffsetTime;
        switch (this._propertyTrack.GetPropertyName()) {
        case "volume":
            this._pauseVolume = this._propertyTrack.GetInterpolatedValue(a)
        }
        this._audioPlaybackStarted = !1
    }
    Interpolate(a, b, d, c, e) {
        if (this._sdkInstance)
            switch (this._propertyTrack.GetPropertyName()) {
            case "audioSource":
                if (!this._timeline.IsForwardPlayBack())
                    break;
                if (c) {
                    this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag);
                    break
                }
                if (a < this._startOffsetTime) {
                    this._audioPlaybackStarted = !1;
                    break
                }
                b = this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag);
                d = this._timeline.GetPlaybackRate();
                d !== b && this._actions.SetPlaybackRate.call(this._sdkInstance, this._audioTag, d);
                if (this._audioPlaybackStarted)
                    break;
                if (!this._propertyTrack.GetTimeline().IsPlaying())
                    break;
                this._audioPlaybackStarted = !0;
                isNaN(this._pauseTime) ? (b = self.performance.now(),
                a -= this._startOffsetTime,
                "suspended" === this._sdkInstance.GetAudioContextState() ? this._audioPlaybackStarted = !1 : (b = (self.performance.now() - b) / 1E3,
                a += b,
                this._actions && (b = this.GetVolume(),
                isNaN(b) ? (this.SetVolume(0),
                b = 0) : this.SetVolume(b),
                this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, b, this._audioTag, a)))) : (a = this._pauseTime,
                this._pauseTime = NaN,
                b = this._GetPauseVolume(),
                this._pauseVolume = NaN,
                "suspended" === this._sdkInstance.GetAudioContextState() ? this._audioPlaybackStarted = !1 : this._actions && (this.SetVolume(b),
                this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, b, this._audioTag, a)));
                break;
            case "volume":
                this._MaybeSetAudioSource(),
                super.Interpolate(a, b, d, c, e)
            }
    }
    GetInterpolatedValue(a, b, d) {
        if (this._sdkInstance)
            switch (this._propertyTrack.GetPropertyName()) {
            case "volume":
                return this._MaybeSetAudioSource(),
                super.GetInterpolatedValue(a, b, d)
            }
    }
    Getter(a, b) {
        return this._audioSource ? this._audioSource.GetVolume() : 0
    }
    Setter(a, b, d, c) {
        this._audioSource && this._audioSource.SetVolume(this.Getter() + b);
        this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume())
    }
    AbsoluteSetter(a, b, d) {
        this._audioSource && this._audioSource.SetVolume(b);
        this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume())
    }
    DoesRounding() {
        return !0
    }
    _SaveToJson() {
        return {
            audioPlaybackStarted: this._audioPlaybackStarted,
            audioTag: this._audioTag,
            pauseTime: this._pauseTime,
            pauseVolume: this._pauseVolume,
            volume: this._volume
        }
    }
    _LoadFromJson(a) {
        a && (this._audioPlaybackStarted = a.audioPlaybackStarted,
        this._audioTag = a.audioTag,
        this._pauseTime = a.pauseTime,
        this._pauseVolume = a.pauseVolume,
        this._volume = a.volume,
        this._Initialize())
    }
}
C3$jscomp$95.PropertyTrackState.AudioSourceAdapter = AudioSourceAdapter;
"use strict";
self.C3.PropertyTrackState.PropertyInterpolationAdapter = class {
    constructor(a) {
        this._sourceAdapter = a;
        this._propertyTrack = a.GetPropertyTrack();
        this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo();
        this._property = this._propertyTrack.GetPropertyName();
        this._firstAbsoluteUpdate = !1;
        this._target = this._saveState = null
    }
    Release() {
        this._target = this._saveState = this._worldInfo = this._propertyTrack = this._sourceAdapter = null
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !1
    }
    TimelineRemoved() {}
    CleanCaches() {
        this._target = this._saveState = this._worldInfo = null
    }
    GetSourceAdapter() {
        return this._sourceAdapter
    }
    GetPropertyTrack() {
        return this._propertyTrack
    }
    GetWorldInfo() {
        return this._worldInfo ? this._worldInfo : this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()
    }
    SetFirstAbsoluteUpdate(a) {
        this._firstAbsoluteUpdate = !!a
    }
    GetFirstAbsoluteUpdate() {
        return this._firstAbsoluteUpdate
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    SetSaveState() {
        this._saveState = this.GetCurrentState()
    }
    ClearSaveState() {
        this._saveState = null
    }
    GetCurrentState() {}
    CompareInitialStateWithCurrent() {}
    CompareSaveStateWithCurrent() {}
    CanChange(a) {
        return typeof this._Getter() === typeof a
    }
    BeforeChangeProperty() {}
    ChangeProperty(a, b, d, c, e, g, k) {}
    AfterChangeProperty() {}
    _FirstKeyframeGetter() {
        return this._PickTimelinePlaybackMode(()=>{
            const a = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(a)
        }
        , ()=>{
            const a = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a)
        }
        ).GetAbsoluteValue()
    }
    _CurrentKeyframeGetter() {
        const a = this._propertyTrack.GetTimeline().GetTime() - this._propertyTrack.GetTrack().GetStartOffset();
        return this._PickTimelinePlaybackMode(()=>{
            const b = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, b)
        }
        , ()=>{
            const b = this._propertyTrack.GetPropertyTrackDataItem()
              , d = this._propertyTrack.GetPropertyTrackData()
              , c = d.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, b);
            return c ? c : d.GetLastPropertyKeyframeDataItem(b)
        }
        ).GetAbsoluteValue()
    }
    _PickTimelinePlaybackMode(a, b) {
        return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? a() : b()
    }
    _PickResultMode(a, b) {
        return "relative" === this._propertyTrack.GetResultMode() ? a() : b()
    }
    _PickFirstAbsoluteUpdate(a, b) {
        return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(!1),
        a()) : b()
    }
    _GetAbsoluteInitialValue(a) {}
    _GetIndex() {
        return this._sourceAdapter.GetIndex()
    }
    _GetTarget() {
        return this._target ? this._target : this._target = this._sourceAdapter.GetTarget()
    }
    _PickSource(a, b, d, c, e, g) {
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
            return a();
        case "effect":
            return b();
        case "instance-variable":
            return d();
        case "plugin":
            return c();
        case "world-instance":
            return e();
        case "audio":
            return g()
        }
    }
    _SaveToJson() {
        return {
            firstAbsoluteUpdate: this._firstAbsoluteUpdate,
            saveState: this._saveState
        }
    }
    _LoadFromJson(a) {
        a && (this._firstAbsoluteUpdate = a.firstAbsoluteUpdate,
        this._saveState = a.saveState)
    }
    _GetPropertyKeyframeStubs(a, b=!1) {
        const d = [];
        for (const c of a) {
            a = c.GetTrack().GetStartOffset();
            for (const e of c.GetPropertyKeyframeDataItems())
                b && 0 === e.GetTime() ? d.push({
                    time: a + e.GetTime(),
                    value: e.GetAbsoluteValue()
                }) : b || d.push({
                    time: a + e.GetTime(),
                    value: e.GetAbsoluteValue()
                })
        }
        return d.sort((c,e)=>c.time - e.time)
    }
    _GetLastPropertyKeyframeStub(a, b, d) {
        return this._GetPropertyKeyframeStubLowerThanPlayhead(b, d)
    }
    _GetPropertyKeyframeStubLowerThanPlayhead(a, b) {
        for (let d = b.length - 1; 0 <= d; d--)
            if (b[d].time <= a)
                return b[d];
        return null
    }
}
;
"use strict";
const C3$jscomp$97 = self.C3
  , TMP_COLORS_MAP = new Map
  , TMP_COLOR = [0, 0, 0];
class ColorInterpolationAdapter extends C3$jscomp$97.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(a) {
        super(a)
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    GetCurrentState() {
        const a = this._propertyTrack.GetSourceAdapterId()
          , b = this._GetTarget()
          , d = this._GetIndex();
        switch (a) {
        case "behavior":
            return this._ToColorArray(b.GetPropertyValueByIndex(d));
        case "effect":
            return this._ToColorArray(b[d]);
        case "plugin":
            return this._ToColorArray(b.GetPropertyValueByIndex(d));
        case "world-instance":
            return this._ToColorArray(this._Getter())
        }
    }
    CompareInitialStateWithCurrent() {
        const a = this._FirstKeyframeGetter();
        return !this._CompareColors(a, this._Getter())
    }
    CompareSaveStateWithCurrent() {
        return C3$jscomp$97.IsNullOrUndefined(this._saveState) ? !1 : !this._CompareColors(this._saveState, this._Getter())
    }
    _CompareColors(a, b) {
        a = this._GetColorFromArray(a);
        b = this._GetColorFromArray(b);
        return a.equalsIgnoringAlpha(b)
    }
    _FirstKeyframeGetter() {
        const a = super._FirstKeyframeGetter();
        return this._GetColorFromArray(a)
    }
    _CurrentKeyframeGetter() {
        const a = super._CurrentKeyframeGetter();
        return this._GetColorFromArray(a)
    }
    _GetAbsoluteInitialValue(a) {}
    _ToColorArray(a) {
        return C3$jscomp$97.IsInstanceOf(a, C3$jscomp$97.Color) ? a.toArray().slice(0, 3) : a.slice(0, 3)
    }
    _GetColorFromArray(a) {
        return C3$jscomp$97.IsInstanceOf(a, C3$jscomp$97.Color) ? a : new C3$jscomp$97.Color(a[0],a[1],a[2],1)
    }
    CanChange(a) {
        return !0
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !0
    }
    BeforeChangeProperty() {
        var a = this._propertyTrack.GetTimeline()
          , b = this._propertyTrack.GetInstance();
        const d = this._propertyTrack.GetSourceAdapter();
        (a = a.GetSimilarPropertyTracks(b, d, this._property)) && 1 < a.length && (TMP_COLORS_MAP.has(b) || TMP_COLORS_MAP.set(b, new Map),
        b = TMP_COLORS_MAP.get(b),
        a = this._propertyTrack.GetSourceAdapterId(),
        b.has(a) || b.set(a, new Map),
        b = b.get(a),
        b.has(this._property) || b.set(this._property, {
            used: !1,
            color: new C3$jscomp$97.Color(0,0,0,1)
        }))
    }
    _GetTmpColor(a, b, d) {
        a = TMP_COLORS_MAP.get(a).get(b).get(d);
        a.used = !0;
        return a.color
    }
    ChangeProperty(a, b, d, c, e) {
        e = this._propertyTrack.GetTimeline();
        c = this._propertyTrack.GetTrack();
        a = this._propertyTrack.GetInstance();
        var g = this._propertyTrack.GetSourceAdapter();
        d = this._propertyTrack.GetSourceAdapterId();
        if ((g = e.GetSimilarPropertyTracks(a, g, this._property)) && 1 < g.length) {
            if (g = this._GetPropertyKeyframeStubs(g, !0),
            e = this._GetLastPropertyKeyframeStub(e, e.GetTime(), g))
                c = c.GetStartOffset(),
                g = e.time - c,
                0 === g ? this._GetTmpColor(a, d, this._property).addRgb(b[0], b[1], b[2]) : 0 > g || (e = b[0],
                c = b[1],
                b = b[2],
                g = this._propertyTrack.Interpolate(g, !1, !0),
                e = C3$jscomp$97.Color.DiffChannel(e, g[0]),
                c = C3$jscomp$97.Color.DiffChannel(c, g[1]),
                b = C3$jscomp$97.Color.DiffChannel(b, g[2]),
                this._GetTmpColor(a, d, this._property).addRgb(e, c, b))
        } else
            this._Setter(b[0], b[1], b[2])
    }
    AfterChangeProperty() {
        const a = this._propertyTrack.GetInstance();
        if (TMP_COLORS_MAP.has(a)) {
            var b = TMP_COLORS_MAP.get(a)
              , d = this._propertyTrack.GetSourceAdapterId();
            if (b.has(d)) {
                var c = b.get(d);
                if (c.has(this._property)) {
                    var e = c.get(this._property)
                      , g = e.color;
                    e.used && this._Setter(g.getR(), g.getG(), g.getB());
                    0 === c.size && b.delete(d);
                    0 === b.size && TMP_COLORS_MAP.delete(a)
                }
            }
        }
    }
    _Getter() {
        const a = this._propertyTrack.GetSourceAdapterId()
          , b = this._GetTarget()
          , d = this._GetIndex();
        switch (a) {
        case "behavior":
            return this._GetColorFromArray(b.GetPropertyValueByIndex(d));
        case "effect":
            return b[d].clone();
        case "plugin":
            return this._GetColorFromArray(b.GetPropertyValueByIndex(d));
        case "world-instance":
            return this.GetWorldInfo().GetUnpremultipliedColor().clone()
        }
    }
    _Setter(a, b, d) {
        const c = this._propertyTrack.GetSourceAdapterId()
          , e = this._GetTarget()
          , g = this._GetIndex();
        switch (c) {
        case "behavior":
            TMP_COLOR[0] = a;
            TMP_COLOR[1] = b;
            TMP_COLOR[2] = d;
            e.SetPropertyValueByIndex(g, TMP_COLOR);
            break;
        case "effect":
            e[g].setRgb(a, b, d);
            break;
        case "plugin":
            TMP_COLOR[0] = a;
            TMP_COLOR[1] = b;
            TMP_COLOR[2] = d;
            e.SetPropertyValueByIndex(g, TMP_COLOR);
            break;
        case "world-instance":
            this.GetWorldInfo().SetUnpremultipliedColorRGB(a, b, d)
        }
    }
    _SaveToJson() {}
    _LoadFromJson(a) {}
}
C3$jscomp$97.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = ColorInterpolationAdapter;
"use strict";
const C3$jscomp$98 = self.C3
  , NS$jscomp$1 = C3$jscomp$98.PropertyTrackState;
class NoInterpolationAdapter extends C3$jscomp$98.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(a) {
        super(a)
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    GetCurrentState() {
        return this._Getter()
    }
    CompareInitialStateWithCurrent() {
        return this._FirstKeyframeGetter() !== this.GetCurrentState()
    }
    CompareSaveStateWithCurrent() {
        return C3$jscomp$98.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !1
    }
    ChangeProperty(a, b, d, c, e) {
        d = this._propertyTrack;
        const g = d.GetTrack();
        c = d.GetSourceAdapterId();
        e = d.GetTimeline();
        var k = g.GetInstance();
        const l = d.GetSourceAdapter();
        (k = e.GetSimilarPropertyTracks(k, l, this._property)) && 1 < k.length && (k = this._GetPropertyKeyframeStubs(k),
        a += g.GetStartOffset(),
        a = this._GetLastPropertyKeyframeStub(e, a, k)) && (b = a.value);
        switch (d.GetPropertyKeyframeType()) {
        case "numeric":
            if (!NS$jscomp$1.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, c))
                return;
            break;
        case "angle":
            if (!NS$jscomp$1.AngleTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, c))
                return;
            break;
        case "boolean":
            if (!NS$jscomp$1.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, c))
                return;
            break;
        case "color":
            if (!NS$jscomp$1.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, c))
                return;
            break;
        case "text":
            if (!NS$jscomp$1.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, c))
                return
        }
        this._Setter(b)
    }
    _Getter() {
        const a = this._propertyTrack.GetSourceAdapterId()
          , b = this._GetTarget()
          , d = this._GetIndex();
        switch (a) {
        case "behavior":
            return b.GetPropertyValueByIndex(d);
        case "effect":
            return b[d];
        case "instance-variable":
            return b.GetInstanceVariableValue(d);
        case "plugin":
            return b.GetPropertyValueByIndex(d)
        }
    }
    _Setter(a) {
        const b = this._propertyTrack.GetSourceAdapterId()
          , d = this._GetTarget()
          , c = this._GetIndex();
        switch (b) {
        case "behavior":
            d.SetPropertyValueByIndex(c, a);
            break;
        case "effect":
            d[c] = a;
            break;
        case "instance-variable":
            d.SetInstanceVariableValue(c, a);
            break;
        case "plugin":
            d.SetPropertyValueByIndex(c, a)
        }
    }
}
C3$jscomp$98.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = NoInterpolationAdapter;
"use strict";
const C3$jscomp$99 = self.C3
  , INSTANCE_FUNC_MAP = new Map
  , add$jscomp$1 = (a,b,d,c,e,g=!1,k=null,l=null)=>{
    INSTANCE_FUNC_MAP.set(a, {
        setter: b,
        absolute_setter: d,
        getter: c,
        round: e,
        fRound: g,
        init: k,
        reset: l
    })
}
;
add$jscomp$1("offsetX", (a,b,d,c)=>{
    "relative" === c._propertyTrack.GetResultMode() ? a.OffsetX(b, d.GetTimeline().GetTransformWithSceneGraph()) : a.OffsetX(b)
}
, (a,b)=>a.SetX(b), a=>a.GetX(), !0);
add$jscomp$1("offsetY", (a,b,d,c)=>{
    "relative" === c._propertyTrack.GetResultMode() ? a.OffsetY(b, d.GetTimeline().GetTransformWithSceneGraph()) : a.OffsetY(b)
}
, (a,b)=>a.SetY(b), a=>a.GetY(), !0);
add$jscomp$1("offsetWidth", (a,b,d,c,e)=>{
    if (0 !== b) {
        var g = "relative" === c._propertyTrack.GetResultMode()
          , k = 1 === c._typeAdapter.GetType();
        if ((g || k) && a.HasParent() && a.GetTransformWithParentWidth()) {
            if (isNaN(c._absoluteToFactor)) {
                g = [];
                for (k = a.GetParent(); k; )
                    g.push(k),
                    k = k.GetParent();
                g.reverse();
                k = (w,z)=>{
                    if (z = z.GetTimeline().GetTrackFromInstance(w.GetInstance()))
                        return z.GetOriginalWidth();
                    z = w.GetInstance().GetSdkInstance();
                    return z.IsOriginalSizeKnown() ? z.GetOriginalWidth() : w._GetSceneGraphInfo()._GetStartWidth()
                }
                ;
                const p = (w,z,B)=>{
                    w = z.GetTimeline().GetTrackFromInstance(w.GetInstance());
                    if (!w)
                        return 0;
                    B = w.GetPropertyTrack(B);
                    if (!B)
                        return 0;
                    B = B.GetPropertyTrackDataItem().GetPropertyKeyframeData();
                    return B ? (B = B.GetLastPropertyKeyframeDataItem()) ? B.GetValue() : 0 : 0
                }
                ;
                let t = g[0];
                var l = t._GetSceneGraphInfo()._GetStartWidth()
                  , n = t._GetSceneGraphInfo().GetStartScaleX();
                l *= n;
                l += p(t, d, "offsetWidth");
                l += k(t, d) * p(t, d, "offsetScaleX");
                for (n = 1; n < g.length; n++)
                    t = g[n],
                    l *= t._GetSceneGraphInfo().GetStartScaleX(),
                    l += p(t, d, "offsetWidth"),
                    l += k(t, d) * p(t, d, "offsetScaleX");
                c._absoluteToFactor = 0 === l ? Number.EPSILON : l
            }
            e || a.OffsetWidth(b / c._absoluteToFactor, !0)
        } else
            a.OffsetWidth(b)
    }
}
, (a,b)=>a.SetWidth(b), a=>a.GetWidth(), !0);
add$jscomp$1("offsetHeight", (a,b,d,c,e)=>{
    if (0 !== b) {
        var g = "relative" === c._propertyTrack.GetResultMode()
          , k = 1 === c._typeAdapter.GetType();
        if ((g || k) && a.HasParent() && a.GetTransformWithParentHeight()) {
            if (isNaN(c._absoluteToFactor)) {
                g = [];
                for (k = a.GetParent(); k; )
                    g.push(k),
                    k = k.GetParent();
                g.reverse();
                k = (w,z)=>{
                    if (z = z.GetTimeline().GetTrackFromInstance(w.GetInstance()))
                        return z.GetOriginalHeight();
                    z = w.GetInstance().GetSdkInstance();
                    return z.IsOriginalSizeKnown() ? z.GetOriginalHeight() : w._GetSceneGraphInfo()._GetStartHeight()
                }
                ;
                const p = (w,z,B)=>{
                    w = z.GetTimeline().GetTrackFromInstance(w.GetInstance());
                    if (!w)
                        return 0;
                    B = w.GetPropertyTrack(B);
                    if (!B)
                        return 0;
                    B = B.GetPropertyTrackDataItem().GetPropertyKeyframeData();
                    return B ? (B = B.GetLastPropertyKeyframeDataItem()) ? B.GetValue() : 0 : 0
                }
                ;
                let t = g[0];
                var l = t._GetSceneGraphInfo()._GetStartHeight()
                  , n = t._GetSceneGraphInfo().GetStartScaleY();
                l *= n;
                l += p(t, d, "offsetHeight");
                l += k(t, d) * p(t, d, "offsetScaleY");
                for (n = 1; n < g.length; n++)
                    t = g[n],
                    l *= t._GetSceneGraphInfo().GetStartScaleY(),
                    l += p(t, d),
                    l += k(t, d) * p(t, d, "offsetScaleY");
                c._absoluteToFactor = 0 === l ? Number.EPSILON : l
            }
            e || a.OffsetHeight(b / c._absoluteToFactor, !0)
        } else
            a.OffsetHeight(b)
    }
}
, (a,b)=>a.SetHeight(b), a=>a.GetHeight(), !0);
add$jscomp$1("offsetAngle", (a,b)=>a.OffsetAngle(b), (a,b)=>a.SetAngle(b), a=>a.GetAngle(), !1);
add$jscomp$1("offsetOpacity", (a,b,d,c,e)=>{
    b /= c._opacityFactor ? c._opacityFactor : 1;
    d = a.GetOpacity() + b;
    0 === c._clampAccumulator ? (1 < d ? c._clampAccumulator += d - 1 : 0 > d && (c._clampAccumulator += d),
    a.OffsetOpacity(b)) : (a = a.GetOpacity() + b,
    0 < b && 0 < c._clampAccumulator ? 1 < a && (c._clampAccumulator += a - 1) : 0 < b && 0 > c._clampAccumulator ? (c._clampAccumulator += b,
    0 < c._clampAccumulator && (c._clampAccumulator = 0)) : 0 > b && 0 < c._clampAccumulator ? (c._clampAccumulator += b,
    0 > c._clampAccumulator && (c._clampAccumulator = 0)) : 0 > b && 0 > c._clampAccumulator && 0 > a && (c._clampAccumulator += a))
}
, (a,b)=>{
    a.SetOpacity(b)
}
, a=>a.GetOpacity(), !1, !0, (a,b,d)=>{
    a._clampAccumulator = 0;
    switch (a._propertyTrack.GetResultMode()) {
    case "relative":
        a._propertyTrack.GetPropertyTrackData();
        var c = a._propertyTrack.GetPropertyTrackDataItem().GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
          , e = a.GetWorldInfo().GetOpacity()
          , g = e;
        for (var k of c)
            g = k.GetTime(),
            g = a._propertyTrack.GetInterpolatedValue(g),
            g = e + g,
            g = C3$jscomp$99.clamp(g, 0, 1);
        a._totalForewardOpacityDelta = e - g;
        a._totalForewardOpacityDelta = Math.round(100 * (a._totalForewardOpacityDelta + Number.EPSILON)) / 100;
        g = e;
        for (e = c.length - 1; 0 <= e; e--)
            k = c[e].GetTime(),
            k = a._propertyTrack.GetInterpolatedValue(k),
            g -= k,
            g = C3$jscomp$99.clamp(g, 0, 1);
        a._totalBackwardOpacityDelta = g;
        a._totalBackwardOpacityDelta = Math.round(100 * (a._totalBackwardOpacityDelta + Number.EPSILON)) / 100
    }
    c = "relative" === a._propertyTrack.GetResultMode();
    g = 1 === a._typeAdapter.GetType();
    if ((c || g) && b.HasParent() && b.GetTransformWithParentOpacity()) {
        c = [];
        for (b = b.GetParent(); b; )
            c.push(b),
            b = b.GetParent();
        c.reverse();
        b = (l,n,p)=>{
            l = n.GetTimeline().GetTrackFromInstance(l.GetInstance());
            if (!l)
                return 0;
            p = l.GetPropertyTrack(p);
            if (!p)
                return 0;
            p = p.GetPropertyTrackDataItem().GetPropertyKeyframeData();
            return p ? (p = p.GetLastPropertyKeyframeDataItem()) ? p.GetValue() : 0 : 0
        }
        ;
        g = c[0]._GetSceneGraphInfo().GetStartOpacity();
        g += b(c[0], d, "offsetOpacity");
        for (e = 1; e < c.length; e++)
            g += b(c[e], d, "offsetOpacity");
        a._opacityFactor = 0 === g ? 1 : g
    }
}
, a=>{
    switch (a._propertyTrack.GetResultMode()) {
    case "relative":
        a._clampAccumulator = 0;
        const b = a.GetWorldInfo();
        let d = b.GetOpacity();
        d = Math.round(100 * (d + Number.EPSILON)) / 100;
        a._propertyTrack.GetTimeline().IsForwardPlayBack() ? (b.SetOpacity(d + a._totalForewardOpacityDelta),
        a._lastValue = 0) : (b.SetOpacity(d - a._totalBackwardOpacityDelta),
        a._lastValue = a.GetSourceAdapter().GetValueAtTime())
    }
}
);
add$jscomp$1("offsetOriginX", (a,b)=>a.OffsetOriginX(b), (a,b)=>a.SetOriginX(b), a=>a.GetOriginX(), !1);
add$jscomp$1("offsetOriginY", (a,b)=>a.OffsetOriginY(b), (a,b)=>a.SetOriginY(b), a=>a.GetOriginY(), !1);
add$jscomp$1("offsetZElevation", (a,b)=>a.OffsetZElevation(b), (a,b)=>a.SetZElevation(b), a=>a.GetZElevation(), !0);
add$jscomp$1("offsetScaleX", (a,b,d,c)=>{
    if (0 !== b) {
        var e = 0 > a.GetWidth() ? -1 : 1;
        "relative" === c._propertyTrack.GetResultMode() && a.HasParent() && a.GetTransformWithParentWidth() ? (b *= d.GetOriginalWidth() * e,
        isNaN(c._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetWidth").setter(a, 1, d, c, !0),
        a.OffsetWidth(b / c._absoluteToFactor, !0)) : a.OffsetWidth(d.GetOriginalWidth() * e * b)
    }
}
, (a,b,d)=>{
    a.SetWidth(d.GetOriginalWidth() * b)
}
, (a,b)=>{
    const d = 0 > a.GetWidth() ? -1 : 1;
    if (a.GetTransformWithParentWidth()) {
        var c = a.GetParent()
          , e = b.GetTimeline().GetTrackFromInstance(c.GetInstance());
        e ? c = c.GetWidth() / e.GetOriginalWidth() : (e = c.GetInstance().GetSdkInstance(),
        c = e.IsOriginalSizeKnown() ? c.GetWidth() / e.GetOriginalWidth() : 1);
        return a.GetWidth() * d / (b.GetOriginalWidth() * c)
    }
    return a.GetWidth() * d / b.GetOriginalWidth()
}
, !1);
add$jscomp$1("offsetScaleY", (a,b,d,c)=>{
    if (0 !== b) {
        var e = 0 > a.GetHeight() ? -1 : 1;
        "relative" === c._propertyTrack.GetResultMode() && a.HasParent() && a.GetTransformWithParentHeight() ? (b *= d.GetOriginalHeight() * e,
        isNaN(c._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetHeight").setter(a, 1, d, c, !0),
        a.OffsetHeight(b / c._absoluteToFactor, !0)) : a.OffsetHeight(d.GetOriginalHeight() * e * b)
    }
}
, (a,b,d)=>{
    a.SetHeight(d.GetOriginalHeight() * b)
}
, (a,b)=>{
    const d = 0 > a.GetHeight() ? -1 : 1;
    if (a.GetTransformWithParentHeight()) {
        var c = a.GetParent()
          , e = b.GetTimeline().GetTrackFromInstance(c.GetInstance());
        e ? c = c.GetHeight() / e.GetOriginalHeight() : (e = c.GetInstance().GetSdkInstance(),
        c = e.IsOriginalSizeKnown() ? c.GetHeight() / e.GetOriginalHeight() : 1);
        return a.GetHeight() * d / (b.GetOriginalHeight() * c)
    }
    return a.GetHeight() * d / b.GetOriginalHeight()
}
, !1);
class NumericInterpolationAdapter extends C3$jscomp$99.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(a) {
        super(a);
        this._totalBackwardOpacityDelta = this._totalForewardOpacityDelta = this._clampAccumulator = this._lastValue = 0;
        this._absoluteToFactor = this._opacityFactor = NaN;
        this._source_adapter_absolute_setter = this._source_adapter_setter = this._source_adapter_getter = this._init_action = this._reset_action = this._instance_absolute_setter = this._instance_setter = this._instance_getter = null;
        this._fRound = this._round = !1;
        C3$jscomp$99.IsInstanceOf(this._propertyTrack.GetTimeline(), C3$jscomp$99.TweenState) ? this._typeAdapter = new C3$jscomp$99.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new C3$jscomp$99.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
        const b = this._propertyTrack.GetPropertyName();
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "world-instance":
            a = INSTANCE_FUNC_MAP.get(b);
            this._instance_getter = a.getter;
            this._instance_setter = a.setter;
            this._instance_absolute_setter = a.absolute_setter;
            this._round = a.round;
            this._fRound = a.fRound;
            this._init_action = a.init;
            this._reset_action = a.reset;
            break;
        case "audio":
            this._source_adapter_getter = a.Getter,
            this._source_adapter_setter = a.Setter,
            this._source_adapter_absolute_setter = a.AbsoluteSetter,
            this._round = !!a.DoesRounding(),
            this._fRound = !1
        }
    }
    Release() {
        this._instance_absolute_setter = this._instance_setter = this._instance_getter = this._typeAdapter = null;
        this._absoluteToFactor = NaN;
        super.Release()
    }
    MayNeedBeforeAndAfterInterpolate() {
        return this._typeAdapter.MayNeedBeforeAndAfterInterpolate()
    }
    GetLastValue() {
        return this._lastValue
    }
    SetLastValue(a) {
        this._lastValue = a
    }
    SetResetState() {
        this._reset_action && this._reset_action(this)
    }
    SetInitialState() {
        var a = this._typeAdapter.SetInitialState();
        "number" === typeof a && (this._lastValue = a);
        if (this._init_action) {
            a = this.GetWorldInfo();
            const b = this._propertyTrack.GetTrack();
            this._init_action(this, a, b)
        }
    }
    SetResumeState() {
        const a = this._typeAdapter.SetResumeState();
        "number" === typeof a && (this._lastValue = a)
    }
    GetCurrentState() {
        return this._Getter()
    }
    CompareInitialStateWithCurrent() {
        return this._FirstKeyframeGetter() !== this.GetCurrentState()
    }
    CompareSaveStateWithCurrent() {
        return C3$jscomp$99.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
    }
    BeforeChangeProperty() {
        this._typeAdapter.BeforeChangeProperty()
    }
    ChangeProperty(a, b, d, c, e, g, k) {
        return this._typeAdapter.ChangeProperty(a, b, d, c, e, g, k)
    }
    AfterChangeProperty() {
        this._typeAdapter.AfterChangeProperty()
    }
    _Getter() {
        const a = this._GetTarget()
          , b = this._GetIndex()
          , d = this.GetWorldInfo()
          , c = this._propertyTrack.GetTrack();
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
            return a.GetPropertyValueByIndex(b);
        case "effect":
            return a[b];
        case "instance-variable":
            return a.GetInstanceVariableValue(b);
        case "plugin":
            return a.GetPropertyValueByIndex(b);
        case "world-instance":
            return this._instance_getter(d, c);
        case "audio":
            return this._source_adapter_getter.call(this.GetSourceAdapter(), d, c)
        }
    }
    _Setter(a, b, d) {
        b = this._GetTarget();
        d = this._GetIndex();
        const c = this.GetWorldInfo()
          , e = this._propertyTrack.GetTrack();
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
            b.OffsetPropertyValueByIndex(d, a);
            break;
        case "effect":
            b[d] += a;
            break;
        case "instance-variable":
            b.SetInstanceVariableOffset(d, a);
            break;
        case "plugin":
            b.OffsetPropertyValueByIndex(d, a);
            break;
        case "world-instance":
            this._instance_setter(c, a, e, this);
            break;
        case "audio":
            this._source_adapter_setter.call(this.GetSourceAdapter(), c, a, e, this)
        }
    }
    _SetterAbsolute(a, b, d) {
        b = this._GetTarget();
        d = this._GetIndex();
        const c = this.GetWorldInfo()
          , e = this._propertyTrack.GetTrack();
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
            b.SetPropertyValueByIndex(d, a);
            break;
        case "effect":
            b[d] = a;
            break;
        case "instance-variable":
            b.SetInstanceVariableValue(d, a);
            break;
        case "plugin":
            b.SetPropertyValueByIndex(d, a);
            break;
        case "world-instance":
            this._instance_absolute_setter(c, a, e);
            break;
        case "audio":
            this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), c, a, e)
        }
    }
    _MaybeEnsureValue(a, b, d, c, e, g, k, l) {
        this._typeAdapter._MaybeEnsureValue(a, b, d, c, e, g, k, l)
    }
    _AddDelta(a, b, d, c, e) {
        const g = (a.toString().split(".")[1] || "").length;
        a = this._Getter();
        c = 0 === g ? this._round ? Math.round(a) : this._fRound ? Math.round(100 * (a + Number.EPSILON)) / 100 : c ? this._GetForceValue(b, d, e) : a : this._round ? Number(C3$jscomp$99.toFixed(a, g)) : c ? this._GetForceValue(b, d, e) : a;
        this._Setter(c - a, b, d)
    }
    _GetForceValue(a, b, d) {
        var c = this.GetPropertyTrack().GetTimeline();
        const e = c.IsForwardPlayBack()
          , g = c.GetLoop();
        c = c.GetPingPong();
        return g || c ? e ? a.GetAbsoluteValue() : b.GetAbsoluteValue() : d ? e ? b.GetAbsoluteValue() : a.GetAbsoluteValue() : e ? a.GetAbsoluteValue() : b.GetAbsoluteValue()
    }
    _SaveToJson() {
        return Object.assign(super._SaveToJson(), {
            v: this._lastValue,
            a: this._clampAccumulator,
            fod: this._totalForewardOpacityDelta,
            bod: this._totalBackwardOpacityDelta
        })
    }
    _LoadFromJson(a) {
        a && (super._LoadFromJson(a),
        this._lastValue = a.v,
        this._clampAccumulator = a.a,
        this._totalForewardOpacityDelta = C3$jscomp$99.IsFiniteNumber(a.fod) ? a.fod : 0,
        this._totalBackwardOpacityDelta = C3$jscomp$99.IsFiniteNumber(a.bod) ? a.bod : 0)
    }
}
C3$jscomp$99.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = NumericInterpolationAdapter;
"use strict";
class AbsoluteValueObject {
    constructor(a) {
        this._used = !1;
        this._value = 0;
        this._propertyTracks = a;
        for (let b = 0, d = this._propertyTracks.length; b < d; b++)
            this._propertyTracks[b].SetAbsoluteValueObject(this)
    }
    GetPropertyTracks() {
        return this._propertyTracks
    }
    SetUsed() {
        this._used = !0
    }
    GetUsed() {
        return this._used
    }
    SetValue(a) {
        this._value = a
    }
    GetValue() {
        return this._value
    }
    Reset() {
        this._used = !1;
        this._value = 0
    }
}
class NumericInterpolationAdapterForTimeline {
    constructor(a) {
        this._numericInterpolationAdapter = a
    }
    Release() {
        this._numericInterpolationAdapter = null
    }
    GetType() {
        return 0
    }
    SetInitialState() {
        const a = this._numericInterpolationAdapter;
        this._numericInterpolationAdapter.GetPropertyTrack();
        return a._PickResultMode(()=>a._PickTimelinePlaybackMode(()=>0, ()=>a.GetSourceAdapter().GetValueAtTime()), ()=>{}
        )
    }
    SetResumeState() {}
    MayNeedBeforeAndAfterInterpolate() {
        switch (this._numericInterpolationAdapter.GetPropertyTrack().GetResultMode()) {
        case "relative":
            return !1;
        case "absolute":
            return !0
        }
    }
    BeforeChangeProperty() {
        var a = this._numericInterpolationAdapter.GetPropertyTrack()
          , b = a.GetPropertyName();
        switch (a.GetResultMode()) {
        case "absolute":
            if (a.HasAbsoluteValueObject())
                a.GetAbsoluteValueObject().Reset();
            else {
                const d = a.GetTimeline()
                  , c = a.GetInstance();
                a = a.GetSourceAdapter();
                (b = d.GetSimilarPropertyTracks(c, a, b)) && 1 < b.length && new AbsoluteValueObject(b)
            }
        }
    }
    ChangeProperty(a, b, d, c, e, g, k) {
        var l = this._numericInterpolationAdapter;
        k = this._numericInterpolationAdapter.GetPropertyTrack();
        switch (k.GetResultMode()) {
        case "relative":
            k = l.GetLastValue();
            l._Setter(b - k, d, c);
            g && this._MaybeEnsureValue(a, d, c, e, k, b);
            l.SetLastValue(b);
            break;
        case "absolute":
            if (c = k.GetTimeline(),
            d = k.GetTrack(),
            k.GetInstance(),
            k.GetSourceAdapter(),
            k.HasAbsoluteValueObject()) {
                if (a = k.GetAbsoluteValueObject(),
                e = a.GetPropertyTracks(),
                e = l._GetPropertyKeyframeStubs(e, !0),
                l = l._GetLastPropertyKeyframeStub(c, c.GetTime(), e))
                    d = d.GetStartOffset(),
                    l = l.time - d,
                    0 === l ? (a.SetUsed(),
                    a.SetValue(a.GetValue() + b)) : 0 > l || (k = k.GetInterpolatedValue(l),
                    a.SetUsed(),
                    a.SetValue(a.GetValue() + (b - k)))
            } else
                l._SetterAbsolute(b)
        }
    }
    AfterChangeProperty() {
        const a = this._numericInterpolationAdapter;
        var b = this._numericInterpolationAdapter.GetPropertyTrack();
        switch (b.GetResultMode()) {
        case "absolute":
            b.HasAbsoluteValueObject() && (b = b.GetAbsoluteValueObject(),
            b.GetUsed() && a._SetterAbsolute(b.GetValue()))
        }
    }
    _MaybeEnsureValue(a, b, d, c, e, g) {
        const k = this._numericInterpolationAdapter;
        c || (b && a === b.GetTime() ? k._AddDelta(b.GetValueWithResultMode(), b, d) : d && a === d.GetTime() ? k._AddDelta(d.GetValueWithResultMode(), b, d) : 0 === g - e && k._AddDelta(b.GetValueWithResultMode(), b, d))
    }
}
self.C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = NumericInterpolationAdapterForTimeline;
"use strict";
class NumericInterpolationAdapterForTween {
    constructor(a) {
        this._numericInterpolationAdapter = a
    }
    Release() {
        this._numericInterpolationAdapter = null
    }
    GetType() {
        return 1
    }
    SetInitialState() {
        const a = this._numericInterpolationAdapter;
        a.SetFirstAbsoluteUpdate(!0);
        return this._GetAbsoluteInitialValue(a._FirstKeyframeGetter())
    }
    SetResumeState() {
        const a = this._numericInterpolationAdapter;
        if (a._FirstKeyframeGetter() !== a._CurrentKeyframeGetter())
            return a.SetFirstAbsoluteUpdate(!0),
            this._GetAbsoluteInitialValue(a._CurrentKeyframeGetter())
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !1
    }
    BeforeChangeProperty() {}
    ChangeProperty(a, b, d, c, e, g, k) {
        const l = this._numericInterpolationAdapter
          , n = l.GetLastValue();
        switch (l.GetPropertyTrack().GetResultMode()) {
        case "relative":
            l._Setter(b - n, d, c);
            g && this._MaybeEnsureValue(a, d, c, e, n, b, !1, k);
            break;
        case "absolute":
            l.GetFirstAbsoluteUpdate() ? (l.SetFirstAbsoluteUpdate(!1),
            l._Setter(n, d, c)) : (l._Setter(b - n, d, c),
            g && this._MaybeEnsureValue(a, d, c, e, n, b, this._ForceEndValue(), k))
        }
        l.SetLastValue(b)
    }
    AfterChangeProperty() {}
    _GetAbsoluteInitialValue(a) {
        return a - this._numericInterpolationAdapter.GetCurrentState()
    }
    _ForceEndValue() {
        var a = this._numericInterpolationAdapter;
        const b = a.GetWorldInfo().GetInstance();
        a = a.GetPropertyTrack().GetRuntime().GetTimelineManager();
        let d = 0;
        for (const c of a.GetPlayingTimelines())
            0 === c.GetType() ? c.HasTrackInstance(b) && d++ : 1 === c.GetType() && c.GetInstance() === b && d++;
        return 1 >= d
    }
    _MaybeEnsureValue(a, b, d, c, e, g, k, l) {
        const n = this._numericInterpolationAdapter;
        c ? b && a === b.GetTime() ? n._AddDelta(b.GetValueWithResultMode(), b, d, k, l) : d && a === d.GetTime() ? n._AddDelta(d.GetValueWithResultMode(), b, d, k, l) : d || n._AddDelta(b.GetValueWithResultMode(), b, d, k, l) : b && a === b.GetTime() ? n._AddDelta(b.GetValueWithResultMode(), b, d, k, l) : d && a === d.GetTime() ? n._AddDelta(d.GetValueWithResultMode(), b, d, k, l) : 0 === g - e && n._AddDelta(b.GetValueWithResultMode(), b, d, k, l)
    }
}
self.C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = NumericInterpolationAdapterForTween;
"use strict";
const C3$jscomp$102 = self.C3
  , Ease$jscomp$1 = self.Ease;
C3$jscomp$102.PropertyTrackState.NumericTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, d, c) {
        let e;
        switch (c) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return e === d ? !1 : !0
    }
    static Interpolate(a, b, d, c) {
        if (!d)
            return b = c.GetPropertyTrackDataItem(),
            b = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(b),
            b.GetValueWithResultMode();
        var e = c.GetInterpolationMode();
        "default" === e && (e = "continuous");
        "combo" === c.GetPropertyType() && (e = "discrete");
        if ("discrete" === e)
            return b.GetValueWithResultMode();
        if ("continuous" === e || "step" === e) {
            "step" === e && (e = c.GetTimeline().GetStep(),
            0 !== e && (e = 1 / e,
            a = Math.floor(a * e) / e));
            e = b.GetValueWithResultMode();
            const g = d.GetValueWithResultMode()
              , k = b.GetAddOn("cubic-bezier")
              , l = d.GetAddOn("cubic-bezier")
              , n = k && k.GetStartEnable() && l && l.GetEndEnable();
            if (!n && e === g)
                return e;
            const p = b.GetTime();
            d = d.GetTime();
            a = C3$jscomp$102.normalize(a, p, d);
            b = b.GetEase();
            n ? (d -= p,
            b = Ease$jscomp$1.GetRuntimeEase(b)(d * a, 0, 1, d),
            b = Ease$jscomp$1.GetRuntimeEase("cubicbezier")(b, e, e + k.GetStartAnchor(), g + l.GetEndAnchor(), g)) : b = Ease$jscomp$1.GetRuntimeEase(b)((d - p) * a, e, g - e, d - p);
            return "integer" === c.GetPropertyType() ? Math.floor(b) : b
        }
    }
}
;
"use strict";
const C3$jscomp$103 = self.C3;
C3$jscomp$103.PropertyTrackState.AngleTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, d, c) {
        let e;
        switch (c) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return e === d ? !1 : !0
    }
    static Interpolate(a, b, d, c) {
        if (!d)
            return b = c.GetPropertyTrackDataItem(),
            b = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(b),
            b.GetValueWithResultMode();
        var e = c.GetInterpolationMode();
        "default" === e && (e = "continuous");
        "combo" === c.GetPropertyType() && (e = "discrete");
        if ("discrete" === e)
            return b.GetValueWithResultMode();
        if ("continuous" === e || "step" === e) {
            "step" === e && (c = c.GetTimeline().GetStep(),
            0 !== c && (c = 1 / c,
            a = Math.floor(a * c) / c));
            const g = b.GetTime()
              , k = d.GetTime();
            c = b.GetValueWithResultMode();
            d = d.GetValueWithResultMode();
            if (e = b.GetAddOn("angle")) {
                const l = e.GetRevolutions();
                if (c === d && 0 === l)
                    return c;
                a = C3$jscomp$103.normalize(a, g, k);
                b = self.Ease.GetRuntimeEase(b.GetEase())(a, 0, 1, 1);
                switch (e.GetDirection()) {
                case "closest":
                    return C3$jscomp$103.angleLerp(c, d, b, l);
                case "clockwise":
                    return C3$jscomp$103.angleLerpClockwise(c, d, b, l);
                case "anti-clockwise":
                    return C3$jscomp$103.angleLerpAntiClockwise(c, d, b, l)
                }
            } else {
                if (c === d)
                    return c;
                a = C3$jscomp$103.normalize(a, g, k);
                b = self.Ease.GetRuntimeEase(b.GetEase());
                return C3$jscomp$103.angleLerp(c, d, b(a, 0, 1, 1))
            }
        }
    }
}
;
"use strict";
self.C3.PropertyTrackState.BooleanTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, d, c) {
        let e;
        switch (c) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return !!e === !!d ? !1 : !0
    }
    static Interpolate(a, b, d, c) {
        return d ? b.GetValueWithResultMode() ? 1 : 0 : (a = c.GetPropertyTrackDataItem(),
        a = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a),
        a.GetValueWithResultMode() ? 1 : 0)
    }
}
;
"use strict";
const C3$jscomp$105 = self.C3
  , TEMP_COLOR_ARRAY = [0, 0, 0]
  , TEMP_COLOR_ARRAY_2 = [0, 0, 0]
  , TEMP_COLOR_ARRAY_3 = [0, 0, 0];
C3$jscomp$105.PropertyTrackState.ColorTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, d, c) {
        let e;
        switch (c) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        Array.isArray(d) ? (TEMP_COLOR_ARRAY[0] = d[0],
        TEMP_COLOR_ARRAY[1] = d[1],
        TEMP_COLOR_ARRAY[2] = d[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(d),
        TEMP_COLOR_ARRAY[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()),
        TEMP_COLOR_ARRAY[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()),
        TEMP_COLOR_ARRAY[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB()));
        Array.isArray(e) ? (TEMP_COLOR_ARRAY_2[0] = e[0],
        TEMP_COLOR_ARRAY_2[1] = e[1],
        TEMP_COLOR_ARRAY_2[2] = e[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(e),
        TEMP_COLOR_ARRAY_2[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()),
        TEMP_COLOR_ARRAY_2[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()),
        TEMP_COLOR_ARRAY_2[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB()));
        return TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0] || TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1] || TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2] ? !0 : !1
    }
    static Interpolate(a, b, d, c) {
        if (!d) {
            var e = c.GetPropertyTrackDataItem();
            e = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e);
            c = e.GetValueWithResultMode();
            TEMP_COLOR_ARRAY[0] = c[0];
            TEMP_COLOR_ARRAY[1] = c[1];
            TEMP_COLOR_ARRAY[2] = c[2];
            return TEMP_COLOR_ARRAY
        }
        e = c.GetInterpolationMode();
        "default" === e && (e = "continuous");
        if ("discrete" === e)
            return c = b.GetValueWithResultMode(),
            TEMP_COLOR_ARRAY[0] = c[0],
            TEMP_COLOR_ARRAY[1] = c[1],
            TEMP_COLOR_ARRAY[2] = c[2],
            TEMP_COLOR_ARRAY;
        if ("continuous" === e || "step" === e) {
            "step" === e && (c = c.GetTimeline().GetStep(),
            0 !== c && (c = 1 / c,
            a = Math.floor(a * c) / c));
            c = b.GetTime();
            e = d.GetTime();
            var g = b.GetValueWithResultMode()
              , k = d.GetValueWithResultMode();
            a = C3$jscomp$105.normalize(a, c, e);
            var l = b.GetEase();
            b = g[0];
            d = g[1];
            g = g[2];
            const n = k[0]
              , p = k[1];
            k = k[2];
            l = self.Ease.GetRuntimeEase(l);
            c = e - c;
            e = c * a;
            TEMP_COLOR_ARRAY[0] = b === n ? b : l(e, b, n - b, c);
            TEMP_COLOR_ARRAY[1] = d === p ? d : l(e, d, p - d, c);
            TEMP_COLOR_ARRAY[2] = g === k ? g : l(e, g, k - g, c);
            return TEMP_COLOR_ARRAY
        }
    }
}
;
"use strict";
self.C3.PropertyTrackState.TextTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, d, c) {
        let e;
        switch (c) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return e === d ? !1 : !0
    }
    static Interpolate(a, b, d, c) {
        return d ? b.GetValueWithResultMode() : (a = c.GetPropertyTrackDataItem(),
        a = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a),
        a.GetValueWithResultMode())
    }
}
;
"use strict";
const C3$jscomp$107 = self.C3;
C3$jscomp$107.TimelineDataManager = class {
    constructor() {
        this._timelineDataItems = new Map
    }
    Release() {
        for (const a of this._timelineDataItems.values())
            a.Release();
        this._timelineDataItems.clear();
        this._timelineDataItems = null
    }
    Add(a) {
        a = new C3$jscomp$107.TimelineDataItem(a);
        const b = a.GetName();
        this._timelineDataItems.set(b, a)
    }
    Get(a) {
        return this._timelineDataItems.get(a)
    }
    GetNameId() {
        return 0
    }
    static _CreateDataItems(a, b, d, c) {
        if (b)
            for (const e of b)
                C3$jscomp$107.TimelineDataManager._CreateDataItem("create", e, a, d, c)
    }
    static _CreateDataItemsIncludingDisabled(a, b, d, c) {
        if (b)
            for (const e of b)
                C3$jscomp$107.TimelineDataManager._CreateDataItem("create-including-disabled", e, a, d, c)
    }
    static _LoadDataItemsFromJson(a, b, d, c) {
        a.length ? b.forEach((e,g)=>{
            a[g]._LoadFromJson(e)
        }
        ) : b.forEach(e=>{
            C3$jscomp$107.TimelineDataManager._CreateDataItem("load", e, a, d, c)
        }
        )
    }
    static _CreateDataItem(a, b, d, c, e) {
        let g;
        if ("function" === typeof c)
            switch (a) {
            case "load":
                g = new c(null,e);
                break;
            case "create":
                g = new c(b,e);
                break;
            case "create-including-disabled":
                g = new c(b,e)
            }
        else if ("object" === typeof c)
            switch (c = c.map.get(b[c.prop]),
            a) {
            case "load":
                g = new c(null,e);
                break;
            case "create":
                g = new c(b,e);
                break;
            case "create-including-disabled":
                g = new c(b,e)
            }
        switch (a) {
        case "load":
            g._LoadFromJson(b);
            d.push(g);
            break;
        case "create":
            if ("function" === typeof g.GetEnable && !g.GetEnable())
                return g.Release();
            d.push(g);
            break;
        case "create-including-disabled":
            d.push(g)
        }
    }
}
;
"use strict";
const C3$jscomp$108 = self.C3;
C3$jscomp$108.TimelineDataItem = class {
    constructor(a) {
        this._name = "";
        this._totalTime = NaN;
        this._step = 0;
        this._resultMode = this._interpolationMode = "default";
        this._pingPong = this._loop = !1;
        this._repeatCount = 1;
        this._trackData = null;
        this._startOnLayout = "";
        this._transformWithSceneGraph = !1;
        this._useSystemTimescale = !0;
        a && (this._name = a[0],
        this._totalTime = a[1],
        this._step = a[2],
        this._interpolationMode = a[3],
        this._resultMode = a[4],
        this._loop = !!a[6],
        this._pingPong = !!a[7],
        this._repeatCount = a[8],
        this._startOnLayout = a[9],
        this._transformWithSceneGraph = !!a[10],
        this._useSystemTimescale = !!a[11],
        this._trackData = new C3$jscomp$108.TrackData(a[5],this))
    }
    Release() {
        this._trackData.Release();
        this._trackData = null
    }
    GetTrackData() {
        this._trackData || (this._trackData = new C3$jscomp$108.TrackData(null,this));
        return this._trackData
    }
    GetName() {
        return this._name
    }
    SetName(a) {
        this._name = a
    }
    GetTotalTime() {
        return this._totalTime
    }
    SetTotalTime(a) {
        this._totalTime = a
    }
    GetStep() {
        return this._step
    }
    SetStep(a) {
        this._step = a
    }
    GetInterpolationMode() {
        return this._interpolationMode
    }
    SetInterpolationMode(a) {
        this._interpolationMode = a
    }
    GetResultMode() {
        return this._resultMode
    }
    SetResultMode(a) {
        this._resultMode = a
    }
    GetLoop() {
        return this._loop
    }
    SetLoop(a) {
        this._loop = a
    }
    GetPingPong() {
        return this._pingPong
    }
    SetPingPong(a) {
        this._pingPong = a
    }
    GetRepeatCount() {
        return this._repeatCount
    }
    SetRepeatCount(a) {
        this._repeatCount = a
    }
    GetStartOnLayout() {
        return this._startOnLayout
    }
    GetTransformWithSceneGraph() {
        return this._transformWithSceneGraph
    }
    GetUseSystemTimescale() {
        return this._useSystemTimescale
    }
    _SaveToJson() {
        return {
            trackDataJson: this._trackData._SaveToJson(),
            name: this._name,
            totalTime: this._totalTime,
            step: this._step,
            interpolationMode: this._interpolationMode,
            resultMode: this._resultMode,
            loop: this._loop,
            pingPong: this._pingPong,
            repeatCount: this._repeatCount,
            startOnLayout: this._startOnLayout,
            transformWithSceneGraph: !!this._transformWithSceneGraph,
            useSystemTimescale: this._useSystemTimescale
        }
    }
    _LoadFromJson(a) {
        a && (this.GetTrackData()._LoadFromJson(a.trackDataJson),
        this._name = a.name,
        this._totalTime = a.totalTime,
        this._step = a.step,
        this._interpolationMode = a.interpolationMode,
        this._resultMode = a.resultMode,
        this._loop = a.loop,
        this._pingPong = a.pingPong,
        this._repeatCount = a.repeatCount,
        this._startOnLayout = a.startOnLayout,
        this._transformWithSceneGraph = !!a.transformWithSceneGraph,
        this._useSystemTimescale = !!a.useSystemTimescale)
    }
}
;
"use strict";
const C3$jscomp$109 = self.C3;
class TrackDataItem {
    constructor(a, b) {
        this._trackData = b;
        this._additionalInstanceData = this._instanceData = null;
        this._objectClassIndex = this._instanceUid = NaN;
        this._resultMode = this._interpolationMode = "default";
        this._enabled = !1;
        this._propertyTrackData = this._keyframeData = null;
        this._id = "";
        this._nestedData = null;
        this._startOffset = 0;
        this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime();
        this._type = 0;
        this._name = "";
        a && (a[0] && (this._instanceData = a[0],
        this._instanceUid = a[0][2],
        this._objectClassIndex = a[0][1]),
        this._interpolationMode = a[1],
        this._resultMode = a[2],
        this._enabled = !!a[3],
        a[6] && (this._id = a[6]),
        a[7] && (this._nestedData = a[7],
        this._startOffset = a[7][0],
        this._localTotalTime = a[7][1]),
        a[8] && (this._additionalInstanceData = a[8]),
        a[8] && (this._additionalInstanceData = a[8]),
        a[9] && (this._type = a[9]),
        a[10] && (this._name = a[10]),
        this._keyframeData = new C3$jscomp$109.KeyframeData(a[4],this),
        this._propertyTrackData = new C3$jscomp$109.PropertyTrackData(a[5],this))
    }
    Release() {
        this._trackData = this._instanceData = null;
        this._keyframeData && (this._keyframeData.Release(),
        this._keyframeData = null);
        this._propertyTrackData && (this._propertyTrackData.Release(),
        this._propertyTrackData = null);
        this._nestedData = null
    }
    GetTrackData() {
        return this._trackData
    }
    GetKeyframeData() {
        this._keyframeData || (this._keyframeData = new C3$jscomp$109.KeyframeData(null,this));
        return this._keyframeData
    }
    GetPropertyTrackData() {
        this._propertyTrackData || (this._propertyTrackData = new C3$jscomp$109.PropertyTrackData(null,this));
        return this._propertyTrackData
    }
    GetInstanceData() {
        return this._instanceData
    }
    GetObjectClassIndex() {
        return this._objectClassIndex
    }
    SetObjectClassIndex(a) {
        this._objectClassIndex = a
    }
    GetInstanceUID() {
        return this._instanceUid
    }
    SetInstanceUID(a) {
        this._instanceUid = a
    }
    GetInterpolationMode() {
        return this._interpolationMode
    }
    SetInterpolationMode(a) {
        this._interpolationMode = a
    }
    GetResultMode() {
        return this._resultMode
    }
    SetResultMode(a) {
        this._resultMode = a
    }
    GetEnable() {
        return this._enabled
    }
    SetEnable(a) {
        this._enabled = !!a
    }
    GetId() {
        return this._id
    }
    GetStartOffset() {
        return this._startOffset
    }
    GetLocalTotalTime() {
        return this._localTotalTime
    }
    SetLocalTotalTime(a) {
        this._localTotalTime = a
    }
    GetOriginalWidth() {
        return this._additionalInstanceData[0]
    }
    SetOriginalWidth(a) {
        this._additionalInstanceData || (this._additionalInstanceData = []);
        this._additionalInstanceData[0] = a
    }
    GetOriginalHeight() {
        this._additionalInstanceData || (this._additionalInstanceData = []);
        return this._additionalInstanceData[1]
    }
    SetOriginalHeight(a) {
        this._additionalInstanceData || (this._additionalInstanceData = []);
        this._additionalInstanceData[1] = a
    }
    GetType() {
        return this._type
    }
    GetName() {
        return this._name
    }
    _SaveToJson() {
        return {
            keyframeDataJson: this._keyframeData._SaveToJson(),
            propertyTrackDataJson: this._propertyTrackData._SaveToJson(),
            instanceData: this._instanceData,
            additionalInstanceData: this._additionalInstanceData,
            instanceUid: this._instanceUid,
            objectClassIndex: this._objectClassIndex,
            interpolationMode: this._interpolationMode,
            resultMode: this._resultMode,
            enabled: this._enabled,
            id: this._id,
            nestedData: this._nestedData,
            type: this._type,
            name: this._name
        }
    }
    _LoadFromJson(a) {
        a && (this._instanceData = a.instanceData,
        this._instanceUid = a.instanceUid,
        this._objectClassIndex = a.objectClassIndex,
        this._interpolationMode = a.interpolationMode,
        this._resultMode = a.resultMode,
        this._enabled = a.enabled,
        this._id = a.id,
        this._type = a.type ? a.type : 0,
        this._name = a.name ? a.name : "",
        this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(),
        a.nestedData && (this._nestedData = a.nestedData,
        this._startOffset = this._nestedData[0],
        this._localTotalTime = this._nestedData[1]),
        a.additionalInstanceData && (this._additionalInstanceData = a.additionalInstanceData),
        this.GetKeyframeData()._LoadFromJson(a.keyframeDataJson),
        this.GetPropertyTrackData()._LoadFromJson(a.propertyTrackDataJson))
    }
}
C3$jscomp$109.TrackData = class {
    constructor(a, b) {
        this._timelineDataItem = b;
        this._trackDataItems = [];
        C3$jscomp$109.TimelineDataManager._CreateDataItems(this._trackDataItems, a, TrackDataItem, this)
    }
    Release() {
        this._timelineDataItem = null;
        for (const a of this._trackDataItems)
            a.Release();
        C3$jscomp$109.clearArray(this._trackDataItems);
        this._trackDataItems = null
    }
    GetTimelineDataItem() {
        return this._timelineDataItem
    }
    AddEmptyTrackDataItem() {
        const a = new TrackDataItem(null,this);
        this._trackDataItems.push(a);
        return a
    }
    GetFirstKeyframeDataItem(a) {
        return a.GetKeyframeData().GetKeyframeDataItemArray()[0]
    }
    GetLastKeyframeDataItem(a) {
        return a.GetKeyframeData().GetKeyframeDataItemArray().at(-1)
    }
    GetKeyFrameDataItemAtTime(a, b) {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        const d = b.length;
        for (let c = 0; c < d; c++) {
            const e = b[c];
            if (e.GetTime() === a)
                return e
        }
    }
    GetFirstKeyFrameDataItemHigherThan(a, b) {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        const d = b.length;
        for (let c = 0; c < d; c++) {
            const e = b[c];
            if (e.GetTime() > a)
                return e
        }
    }
    GetFirstKeyFrameDataItemHigherOrEqualThan(a, b) {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        const d = b.length;
        for (let c = 0; c < d; c++) {
            const e = b[c];
            if (e.GetTime() >= a)
                return e
        }
    }
    GetFirstKeyFrameDataItemLowerOrEqualThan(a, b) {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        for (let d = b.length - 1; 0 <= d; d--) {
            const c = b[d];
            if (c.GetTime() <= a)
                return c
        }
    }
    *trackDataItems() {
        for (const a of this._trackDataItems)
            yield a
    }
    _SaveToJson() {
        return {
            trackDataItemsJson: this._trackDataItems.map(a=>a._SaveToJson())
        }
    }
    _LoadFromJson(a) {
        a && C3$jscomp$109.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, a.trackDataItemsJson, TrackDataItem, this)
    }
}
;
"use strict";
const C3$jscomp$110 = self.C3;
class PropertyTrackDataItem {
    constructor(a, b) {
        this._propertyTrackData = b;
        this._sourceAdapterId = "";
        this._type = this._property = this._sourceAdapterArguments = null;
        this._max = this._min = NaN;
        this._resultMode = this._interpolationMode = "default";
        this._enabled = !1;
        this._propertyKeyframeData = null;
        this._canHavePropertyKeyframes = !0;
        a && (this._sourceAdapterId = a[0][0],
        this._sourceAdapterArguments = a[0].slice(1),
        this._property = a[1],
        this._type = a[2],
        this._min = a[3],
        this._max = a[4],
        this._interpolationMode = a[5],
        this._resultMode = a[6],
        this._enabled = !!a[7],
        this._propertyKeyframeData = new C3$jscomp$110.PropertyKeyframeData(a[8],this),
        this._canHavePropertyKeyframes = a[9])
    }
    Release() {
        this._propertyKeyframeData.Release();
        this._sourceAdapterArguments = this._propertyTrackData = this._propertyKeyframeData = null
    }
    GetPropertyTrackData() {
        return this._propertyTrackData
    }
    GetPropertyKeyframeData() {
        this._propertyKeyframeData || (this._propertyKeyframeData = new C3$jscomp$110.PropertyKeyframeData(null,this));
        return this._propertyKeyframeData
    }
    GetSourceAdapterId() {
        return this._sourceAdapterId
    }
    SetSourceAdapterId(a) {
        this._sourceAdapterId = a
    }
    GetSourceAdapterArguments() {
        return this._sourceAdapterArguments
    }
    SetSourceAdapterArguments(a) {
        this._sourceAdapterArguments = a
    }
    GetProperty() {
        return this._property
    }
    SetProperty(a) {
        this._property = a
    }
    GetType() {
        return this._type
    }
    SetType(a) {
        this._type = a
    }
    GetMin() {
        return this._min
    }
    SetMin(a) {
        this._min = a
    }
    GetMax() {
        return this._max
    }
    SetMax(a) {
        this._max = a
    }
    GetInterpolationMode() {
        return this._interpolationMode
    }
    SetInterpolationMode(a) {
        this._interpolationMode = a
    }
    GetResultMode() {
        return this._resultMode
    }
    SetResultMode(a) {
        this._resultMode = a
    }
    GetEnable() {
        return this._enabled
    }
    SetEnable(a) {
        this._enabled = !!a
    }
    CanHavePropertyKeyframes() {
        return !!this._canHavePropertyKeyframes
    }
    _SaveToJson() {
        return {
            propertyKeyframeDataJson: this._propertyKeyframeData._SaveToJson(),
            sourceAdapterId: this._sourceAdapterId,
            sourceAdapterArguments: this._sourceAdapterArguments,
            property: this._property,
            type: this._type,
            min: this._min,
            max: this._max,
            interpolationMode: this._interpolationMode,
            resultMode: this._resultMode,
            enabled: this._enabled,
            canHavePropertyKeyframes: this._canHavePropertyKeyframes
        }
    }
    _LoadFromJson(a) {
        a && (this._sourceAdapterId = a.sourceAdapterId,
        this._sourceAdapterArguments = a.sourceAdapterArguments,
        this._property = a.property,
        this._type = a.type,
        this._min = a.min,
        this._max = a.max,
        this._interpolationMode = a.interpolationMode,
        this._resultMode = a.resultMode,
        this._enabled = a.enabled,
        this._canHavePropertyKeyframes = a.canHavePropertyKeyframes,
        this.GetPropertyKeyframeData()._LoadFromJson(a.propertyKeyframeDataJson))
    }
}
C3$jscomp$110.PropertyTrackData = class {
    constructor(a, b) {
        this._trackDataItem = b;
        this._propertyTrackDataItems = [];
        C3$jscomp$110.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, a, PropertyTrackDataItem, this)
    }
    Release() {
        this._trackDataItem = null;
        for (const a of this._propertyTrackDataItems)
            a.Release();
        C3$jscomp$110.clearArray(this._propertyTrackDataItems);
        this._propertyTrackDataItems = null
    }
    GetTrackDataItem() {
        return this._trackDataItem
    }
    AddEmptyPropertyTrackDataItem() {
        const a = new PropertyTrackDataItem(null,this);
        this._propertyTrackDataItems.push(a);
        return a
    }
    GetFirstPropertyKeyframeDataItem(a) {
        return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0]
    }
    GetLastPropertyKeyframeDataItem(a) {
        return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray().at(-1)
    }
    GetPropertyKeyFrameDataItemAtTime(a, b) {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        const d = b.length;
        for (let c = 0; c < d; c++) {
            const e = b[c];
            if (e.GetTime() === a)
                return e
        }
    }
    GetFirstPropertyKeyFrameDataItemHigherThan(a, b) {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        const d = b.length;
        for (let c = 0; c < d; c++) {
            const e = b[c];
            if (e.GetTime() > a)
                return e
        }
    }
    GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, b) {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        const d = b.length;
        for (let c = 0; c < d; c++) {
            const e = b[c];
            if (e.GetTime() >= a)
                return e
        }
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, b) {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        for (let d = b.length - 1; 0 <= d; d--) {
            const c = b[d];
            if (c.GetTime() <= a)
                return c
        }
    }
    *propertyTrackDataItems() {
        for (const a of this._propertyTrackDataItems)
            yield a
    }
    _SaveToJson() {
        return {
            propertyTrackDataItemsJson: this._propertyTrackDataItems.map(a=>a._SaveToJson())
        }
    }
    _LoadFromJson(a) {
        a && C3$jscomp$110.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, a.propertyTrackDataItemsJson, PropertyTrackDataItem, this)
    }
}
;
"use strict";
const C3$jscomp$111 = self.C3;
class KeyframeDataItem {
    constructor(a, b) {
        this._keyframeData = b;
        this._time = -1;
        this._ease = "noease";
        this._enable = !1;
        this._lowerTags = this._tags = null;
        a && (this._time = a[0],
        this._ease = a[1],
        this._enable = !!a[2],
        this._tags = (a = a[3]) ? a.split(" ") : [],
        this._lowerTags = new Set(this._tags.map(d=>d.toLowerCase())),
        this._next = null)
    }
    Release() {
        this._keyframeData = null;
        C3$jscomp$111.clearArray(this._tags);
        this._tags = null;
        this._lowerTags.clear();
        this._next = this._lowerTags = null
    }
    GetKeyframeData() {
        return this._keyframeData
    }
    GetNext() {
        return this._next
    }
    SetNext(a) {
        this._next = a
    }
    GetTime() {
        return this._time
    }
    SetTime(a) {
        this._time = a;
        this._keyframeData._LinkKeyframeDataItems()
    }
    GetEase() {
        return this._ease
    }
    SetEase(a) {
        this._ease = a
    }
    GetEnable() {
        return this._enable
    }
    SetEnable(a) {
        this._enable = !!a
    }
    GetTags() {
        return this._tags
    }
    SetTags(a) {
        this._tags = a ? a.split(" ") : [];
        this._lowerTags = new Set(this._tags.map(b=>b.toLowerCase()))
    }
    GetLowerTags() {
        return this._lowerTags
    }
    HasTag(a) {
        return this._lowerTags.has(a.toLowerCase())
    }
    _SaveToJson() {
        return {
            time: this._time,
            ease: this._ease,
            enable: this._enable,
            tags: this._tags
        }
    }
    _LoadFromJson(a) {
        a && (this._time = a.time,
        this._ease = a.ease,
        this._enable = a.enable,
        this._tags = a.tags,
        this._lowerTags = new Set(this._tags.map(b=>b.toLowerCase())))
    }
}
C3$jscomp$111.KeyframeData = class {
    constructor(a, b) {
        this._trackDataItem = b;
        this._keyframeDataItems = [];
        C3$jscomp$111.TimelineDataManager._CreateDataItems(this._keyframeDataItems, a, KeyframeDataItem, this);
        this._LinkKeyframeDataItems()
    }
    Release() {
        this._trackDataItem = null;
        for (const a of this._keyframeDataItems)
            a.Release();
        C3$jscomp$111.clearArray(this._keyframeDataItems);
        this._keyframeDataItems = null
    }
    _LinkKeyframeDataItems() {
        this._keyframeDataItems.sort((a,b)=>a.GetTime() - b.GetTime());
        for (let a = 0; a < this._keyframeDataItems.length; a++)
            this._keyframeDataItems[a].SetNext(this._keyframeDataItems[a + 1])
    }
    GetTrackDataItem() {
        return this._trackDataItem
    }
    GetKeyframeDataItemCount() {
        return this._keyframeDataItems.length
    }
    GetKeyframeDataItemArray() {
        return this._keyframeDataItems
    }
    AddEmptyKeyframeDataItem() {
        const a = new KeyframeDataItem(null,this);
        this._keyframeDataItems.push(a);
        this._LinkKeyframeDataItems();
        return a
    }
    DeleteKeyframeDataItems(a) {
        for (const b of this._keyframeDataItems) {
            if (!a(b))
                continue;
            const d = this._keyframeDataItems.indexOf(b);
            -1 !== d && (b.Release(),
            this._keyframeDataItems.splice(d, 1))
        }
        this.SortKeyframeDataItems();
        this._LinkKeyframeDataItems()
    }
    SortKeyframeDataItems() {
        this._keyframeDataItems.sort((a,b)=>a.GetTime() - b.GetTime())
    }
    GetKeyframeDataItemIndex(a) {
        return this._keyframeDataItems.indexOf(a)
    }
    GetKeyframeDataItemFromIndex(a) {
        return this._keyframeDataItems[a]
    }
    *keyframeDataItems() {
        for (const a of this._keyframeDataItems)
            yield a
    }
    *keyframeDataItemsReverse() {
        for (let a = this._keyframeDataItems.length - 1; 0 <= a; a--)
            yield this._keyframeDataItems[a]
    }
    _SaveToJson() {
        return {
            keyframeDataItemsJson: this._keyframeDataItems.map(a=>a._SaveToJson())
        }
    }
    _LoadFromJson(a) {
        a && (C3$jscomp$111.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, a.keyframeDataItemsJson, KeyframeDataItem, this),
        this._LinkKeyframeDataItems())
    }
}
;
"use strict";
const C3$jscomp$112 = self.C3;
class PropertyKeyframeDataItem {
    constructor(a, b) {
        this._propertyKeyframeData = b;
        this._aValue = this._value = null;
        this._type = "";
        this._time = NaN;
        this._ease = "noease";
        this._enable = !1;
        this._addonData = null;
        this._addonInstance = void 0;
        this._pathMode = "line";
        a && (this._value = a[0][0],
        this._aValue = a[0][1],
        this._type = a[0][2],
        this._time = a[1],
        this._ease = a[2],
        this._enable = !!a[3],
        this._pathMode = a[5],
        this._addonData = null,
        a[4] && (this._addonData = new C3$jscomp$112.AddonData(a[4],this)),
        this._prev = this._next = null)
    }
    Release() {
        this._propertyKeyframeData = null;
        this._addonData && (this._addonData.Release(),
        this._addonData = null);
        this._prev = this._next = null
    }
    GetAddonData() {
        return this._addonData
    }
    SetNext(a) {
        this._next = a
    }
    GetNext() {
        return this._next
    }
    SetPrevious(a) {
        this._prev = a
    }
    GetPrevious() {
        return this._prev
    }
    GetValue() {
        return this._value
    }
    SetValue(a) {
        "color" === this._type && C3$jscomp$112.IsFiniteNumber(a) ? (this._value[0] = C3$jscomp$112.GetRValue(a),
        this._value[1] = C3$jscomp$112.GetGValue(a),
        this._value[2] = C3$jscomp$112.GetBValue(a)) : this._value = a
    }
    GetAbsoluteValue() {
        return this._aValue
    }
    SetAbsoluteValue(a) {
        "color" === this._type && C3$jscomp$112.IsFiniteNumber(a) ? (this._aValue[0] = C3$jscomp$112.GetRValue(a),
        this._aValue[1] = C3$jscomp$112.GetGValue(a),
        this._aValue[2] = C3$jscomp$112.GetBValue(a)) : this._aValue = a
    }
    GetValueWithResultMode() {
        const a = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
        if ("relative" === a)
            return this.GetValue();
        if ("absolute" === a)
            return this.GetAbsoluteValue()
    }
    GetType() {
        return this._type
    }
    SetType(a) {
        this._type = a
    }
    GetTime() {
        return this._time
    }
    SetTime(a) {
        this._time = a;
        this._propertyKeyframeData._LinkPropertyKeyframeDataItems()
    }
    GetEase() {
        return this._ease
    }
    SetEase(a) {
        this._ease = a
    }
    GetEnable() {
        return this._enable
    }
    SetEnable(a) {
        this._enable = !!a
    }
    GetPathMode() {
        return this._pathMode
    }
    GetAddOn(a) {
        if (this._addonData) {
            if (this._addonInstance || null === this._addonInstance)
                return this._addonInstance;
            var b = this._addonData.GetAddDataItemArray();
            if (!b)
                return this._addonInstance = null;
            var d = b.length;
            for (let c = 0; c < d; c++) {
                const e = b[c];
                if (e.GetId() === a)
                    return this._addonInstance = e
            }
            return this._addonInstance = null
        }
    }
    _SaveToJson() {
        const a = this._addonData;
        return {
            addonDataJson: a ? a._SaveToJson() : a,
            value: this._value,
            aValue: this._aValue,
            type: this._type,
            time: this._time,
            ease: this._ease,
            enable: this._enable
        }
    }
    _LoadFromJson(a) {
        a && (a.addonDataJson && this._addonData._SetFromJson(a.addonDataJson),
        this._value = a.value,
        this._aValue = a.aValue,
        this._type = a.type,
        this._time = a.time,
        this._ease = a.ease,
        this._enable = a.enable)
    }
}
C3$jscomp$112.PropertyKeyframeData = class {
    constructor(a, b) {
        this._propertyTrackDataItem = b;
        this._propertyKeyframeDataItems = [];
        this._propertyKeyframeDataItemsIncludingDisabled = [];
        C3$jscomp$112.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, a, PropertyKeyframeDataItem, this);
        C3$jscomp$112.TimelineDataManager._CreateDataItemsIncludingDisabled(this._propertyKeyframeDataItemsIncludingDisabled, a, PropertyKeyframeDataItem, this);
        this._LinkPropertyKeyframeDataItems()
    }
    Release() {
        this._propertyTrackDataItem = null;
        for (const a of this._propertyKeyframeDataItems)
            a.Release();
        C3$jscomp$112.clearArray(this._propertyKeyframeDataItems);
        this._propertyKeyframeDataItems = null;
        for (const a of this._propertyKeyframeDataItemsIncludingDisabled)
            a.Release();
        C3$jscomp$112.clearArray(this._propertyKeyframeDataItemsIncludingDisabled);
        this._propertyKeyframeDataItemsIncludingDisabled = null
    }
    _LinkPropertyKeyframeDataItems() {
        let a = this._propertyKeyframeDataItems;
        a.sort((c,e)=>c.GetTime() - e.GetTime());
        for (var b = 0; b < a.length; b++) {
            var d = a[b];
            b + 1 < a.length && d.SetNext(a[b + 1]);
            0 <= b - 1 && d.SetPrevious(a[b - 1])
        }
        a = this._propertyKeyframeDataItemsIncludingDisabled;
        a.sort((c,e)=>c.GetTime() - e.GetTime());
        for (b = 0; b < a.length; b++)
            d = a[b],
            b + 1 < a.length && d.SetNext(a[b + 1]),
            0 <= b - 1 && d.SetPrevious(a[b - 1])
    }
    AddEmptyPropertyKeyframeDataItem() {
        const a = new PropertyKeyframeDataItem(null,this);
        this._propertyKeyframeDataItems.push(a);
        this._LinkPropertyKeyframeDataItems();
        return a
    }
    DeletePropertyKeyframeDataItems(a) {
        for (const b of this._propertyKeyframeDataItems) {
            if (!a(b))
                continue;
            const d = this._propertyKeyframeDataItems.indexOf(b);
            -1 !== d && (b.Release(),
            this._propertyKeyframeDataItems.splice(d, 1))
        }
        this.SortPropertyKeyFrameDataItems();
        this._LinkPropertyKeyframeDataItems()
    }
    SortPropertyKeyFrameDataItems() {
        this._propertyKeyframeDataItems.sort((a,b)=>a.GetTime() - b.GetTime())
    }
    GetPropertyTrackDataItem() {
        return this._propertyTrackDataItem
    }
    GetPropertyKeyframeDataItemCount() {
        return this._propertyKeyframeDataItems.length
    }
    GetLastPropertyKeyframeDataItem() {
        return this._propertyKeyframeDataItems[this._propertyKeyframeDataItems.length - 1]
    }
    GetPropertyKeyframeDataItemArray() {
        return this._propertyKeyframeDataItems
    }
    GetPropertyKeyframeDataItemArrayIncludingDisabled() {
        return this._propertyKeyframeDataItemsIncludingDisabled
    }
    *propertyKeyframeDataItems() {
        for (const a of this._propertyKeyframeDataItems)
            yield a
    }
    *propertyKeyframeDataItemsReverse() {
        for (let a = this._propertyKeyframeDataItems.length - 1; 0 <= a; a--)
            yield this._propertyKeyframeDataItems[a]
    }
    _SaveToJson() {
        const a = this._propertyKeyframeDataItemsIncludingDisabled;
        return {
            propertyKeyframeDataItemsJson: this._propertyKeyframeDataItems.map(b=>b._SaveToJson()),
            propertyKeyframeDataItemsIncludingDisabledJson: a.map(b=>b._SaveToJson())
        }
    }
    _LoadFromJson(a) {
        a && (C3$jscomp$112.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, a.propertyKeyframeDataItemsJson, PropertyKeyframeDataItem, this),
        C3$jscomp$112.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItemsIncludingDisabled, a.propertyKeyframeDataItemsIncludingDisabledJson, PropertyKeyframeDataItem, this),
        this._LinkPropertyKeyframeDataItems())
    }
}
;
"use strict";
const C3$jscomp$113 = self.C3;
class AddonDataItem {
    constructor(a, b) {
        this._addonData = b;
        this._id = a[0];
        this._data = a[1]
    }
    Release() {
        this._data = this._addonData = null
    }
    GetAddonData() {
        return this._addonData
    }
    GetId() {
        return this._id
    }
    _SaveToJson() {
        return {
            id: this._id,
            data: this._data
        }
    }
    _LoadFromJson(a) {
        a && (this._id = a.id,
        this._data = a.data)
    }
}
class AddonDataCubicBezierItem extends AddonDataItem {
    constructor(a, b) {
        super(a, b);
        this._startAnchor = this._data[0];
        this._startEnable = !!this._data[1];
        this._endAnchor = this._data[2];
        this._endEnable = !!this._data[3]
    }
    Release() {
        super.Release()
    }
    GetStartAnchor() {
        return this._startAnchor
    }
    GetStartEnable() {
        return this._startEnable
    }
    GetEndAnchor() {
        return this._endAnchor
    }
    GetEndEnable() {
        return this._endEnable
    }
    _SaveToJson() {
        return Object.assign(super._SaveToJson(), {
            startAnchor: this._startAnchor,
            startEnable: !!this._startEnable,
            endAnchor: this._endAnchor,
            endEnable: !!this._endEnable
        })
    }
    _LoadFromJson(a) {
        a && (super._LoadFromJson(a),
        this._startAnchor = a.startAnchor,
        this._startEnable = !!a.startEnable,
        this._endAnchor = a.endAnchor,
        this._endEnable = !!a.endEnable)
    }
}
class AddonDataAngleItem extends AddonDataItem {
    constructor(a, b) {
        super(a, b);
        this._direction = this._data[0];
        this._revolutions = this._data[1]
    }
    Release() {
        super.Release()
    }
    GetDirection() {
        return this._direction
    }
    GetRevolutions() {
        return this._revolutions
    }
    _SaveToJson() {
        return Object.assign(super._SaveToJson(), {
            direction: this._direction,
            revolutions: this._revolutions
        })
    }
    _LoadFromJson(a) {
        a && (super._LoadFromJson(a),
        this._direction = a.direction,
        this._revolutions = a.revolutions)
    }
}
C3$jscomp$113.AddonData = class {
    constructor(a, b) {
        this._propertyKeyframeDataItem = b;
        this._addonDataItems = [];
        C3$jscomp$113.TimelineDataManager._CreateDataItems(this._addonDataItems, a, {
            prop: 0,
            map: new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]])
        }, this)
    }
    Release() {
        this._propertyKeyframeDataItem = null;
        for (const a of this._addonDataItems)
            a.Release();
        C3$jscomp$113.clearArray(this._addonDataItems);
        this._addonDataItems = null
    }
    GetPropertyKeyframeDataItem() {
        return this._propertyKeyframeDataItem
    }
    GetAddDataItemArray() {
        return this._addonDataItems
    }
    *addonDataItems() {
        for (const a of this._addonDataItems)
            yield a
    }
    _SaveToJson() {
        return {
            addonDataItemsJson: this._addonDataItems.map(a=>a._SaveToJson())
        }
    }
    _LoadFromJson(a) {
        a && C3$jscomp$113.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, a.addonDataItemsJson, {
            prop: "id",
            map: new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]])
        }, this)
    }
}
;
"use strict";
const C3$jscomp$114 = self.C3;
let createdTweens = 0;
C3$jscomp$114.TweenState = class extends C3$jscomp$114.TimelineState {
    constructor(a, b) {
        super(`tween-${createdTweens++}`, a, b);
        this._id = "";
        this._destroyInstanceOnComplete = !1;
        this._initialValueMode = "start-value";
        this._iTweenState = this._track = this._on_started_callbacks = this._on_completed_callbacks = this._instance = null
    }
    FireReleaseEvent(a) {
        const b = C3$jscomp$114.New(C3$jscomp$114.Event, "tweenstatereleased");
        b.tweenState = this;
        a.dispatchEvent(b)
    }
    GetType() {
        return 1
    }
    CreateTrackStates() {
        for (const a of this._timelineDataItem.GetTrackData().trackDataItems())
            this._tracks.push(C3$jscomp$114.TweenTrackState.Create(this, a));
        this._track = this._tracks[0]
    }
    AddTrack() {
        var a = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
        a = C3$jscomp$114.TweenTrackState.Create(this, a);
        this._tracks.push(a);
        this._track = this._tracks[0];
        return a
    }
    GetPropertyTrack(a) {
        return this._track.GetPropertyTracks()[0]
    }
    SetPropertyType(a) {
        this._propertyType = a
    }
    GetInstance() {
        var a = this.GetTracks();
        if (a && a.length && (this._track = a = a[0])) {
            var b = a.GetInstance();
            return a.IsInstanceValid() ? b : void 0
        }
    }
    AddStartedCallback(a) {
        this._on_started_callbacks || (this._on_started_callbacks = []);
        this._on_started_callbacks.push(a)
    }
    AddCompletedCallback(a) {
        this._on_completed_callbacks || (this._on_completed_callbacks = []);
        this._on_completed_callbacks.push(a)
    }
    RemoveStartedCallback(a) {
        this._on_started_callbacks && (a = this._on_started_callbacks.indexOf(a),
        -1 !== a && this._on_started_callbacks.splice(a, 1))
    }
    RemoveCompletedCallback(a) {
        this._on_completed_callbacks && (a = this._on_completed_callbacks.indexOf(a),
        -1 !== a && this._on_completed_callbacks.splice(a, 1))
    }
    SetStartValue(a, b) {
        for (const c of this._tracks)
            for (const e of c._propertyTracks) {
                if (e.GetPropertyName() !== b)
                    continue;
                var d = e.GetPropertyTrackData();
                const g = e.GetPropertyTrackDataItem();
                d = d.GetFirstPropertyKeyframeDataItem(g);
                d.SetValue(a);
                d.SetAbsoluteValue(a)
            }
    }
    _GetPropertyTrackState(a) {
        for (const b of this._tracks)
            for (const d of b._propertyTracks)
                if (d.GetPropertyName() === a)
                    return d
    }
    BeforeSetEndValues(a) {
        for (const c of a)
            a = this._GetPropertyTrackState(c),
            this.SetStartValue(a.GetCurrentState(), c);
        if (this.IsForwardPlayBack()) {
            var b = this.GetTotalTime() - this.GetTime();
            this.SetTotalTime(b);
            for (var d of this._tracks)
                d.SetLocalTotalTime(b);
            this._SetTime(0)
        } else {
            d = this.GetTime();
            this.SetTotalTime(d);
            for (b of this._tracks)
                b.SetLocalTotalTime(d);
            this._SetTime(d)
        }
        this.SetInitialStateFromSetTime()
    }
    SetEndValue(a, b) {
        var d = this._GetPropertyTrackState(b);
        b = d.GetPropertyTrackData();
        d = d.GetPropertyTrackDataItem();
        b = b.GetLastPropertyKeyframeDataItem(d);
        b.SetTime(this.GetTotalTime());
        b.SetValue(a);
        b.SetAbsoluteValue(a)
    }
    SetId(a) {
        this._id = a
    }
    GetId() {
        return this._id
    }
    SetInitialValueMode(a) {
        this._initialValueMode = a
    }
    GetInitialValueMode() {
        return this._initialValueMode
    }
    SetDestroyInstanceOnComplete(a) {
        this._destroyInstanceOnComplete = a
    }
    GetDestroyInstanceOnComplete() {
        return this._destroyInstanceOnComplete
    }
    OnStarted() {
        if (this._on_started_callbacks)
            for (const a of this._on_started_callbacks)
                a(this);
        if (!this.IsComplete())
            for (const a of this._tracks)
                a.CompareSaveStateWithCurrent()
    }
    OnCompleted() {
        this._completedTick = this._runtime.GetTickCount()
    }
    FinishTriggers() {
        if (!this._finishedTriggers && (this._finishedTriggers = !0,
        this._on_completed_callbacks))
            for (const a of this._on_completed_callbacks)
                a(this)
    }
    SetTime(a) {
        this._DeleteIntermediateKeyframes();
        super.SetTime(a)
    }
    _SetTimeAndReset(a) {
        C3$jscomp$114.IsFiniteNumber(a) || (a = this.GetTotalTime());
        0 > a ? this._playheadTime = 0 : a >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = a;
        this._track.SetResetState()
    }
    SetInitialState(a) {
        if (!this.InitialStateSet() && "current-state" === this.GetInitialValueMode())
            for (const b of this._tracks)
                b.CompareInitialStateWithCurrent();
        super.SetInitialState(a)
    }
    Stop(a=!1) {
        super.Stop(a);
        if (!this.IsComplete())
            for (const b of this._tracks)
                b.SaveState()
    }
    Reset(a=!0, b=!1) {
        this._DeleteIntermediateKeyframes();
        super.Reset(a, b)
    }
    _DeleteIntermediateKeyframes() {
        for (const a of this._tracks) {
            const b = d=>{
                d = d.GetTime();
                const c = this.GetTotalTime();
                return 0 !== d && d !== c
            }
            ;
            a.DeleteKeyframes(b);
            a.DeletePropertyKeyframes(b)
        }
    }
    _OnBeforeChangeLayout() {
        if (this.IsReleased())
            return !0;
        const a = this.GetInstance();
        if (a && a.GetObjectClass().IsGlobal())
            return !1;
        this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);
        this.ResetBeforeChangeLayout();
        return !0
    }
    Tick(a, b, d) {
        this._instance || (this._instance = this.GetInstance());
        if (!this._instance || this._instance.IsDestroyed())
            this.Stop(!0),
            this.OnCompleted();
        else if (b = this._instance.GetTimeScale(),
        -1 !== b && (a = d * b),
        0 !== a || 0 !== this._lastDelta) {
            this._lastDelta = a;
            d = this._playheadTime + a * this._playbackRate;
            a = this._timelineDataItem._totalTime;
            this._playheadTime = 0 > d ? 0 : d >= a ? a : d;
            b = d = !1;
            var c = this.GetLoop()
              , e = this.GetPingPong();
            c || e ? c && !e ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTimeAndReset(0),
            b = !0) : 0 >= this._playheadTime && (this._SetTimeAndReset(a),
            b = !0) : !c && e ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a),
            this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
            b = !0,
            1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
            this._pingPongState = 0) : d = !0 : 0 === this._pingPongState && (this._pingPongState = 1)) : 0 >= this._playheadTime && (this._SetTime(0),
            this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
            b = !0,
            1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
            this._pingPongState = 0) : d = !0 : 0 === this._pingPongState && (this._pingPongState = 1)) : c && e && (0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a),
            this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
            b = !0,
            this._pingPongState++,
            C3$jscomp$114.wrap(this._pingPongState, 0, 2)) : 0 >= this._playheadTime && (this._SetTime(0),
            this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
            b = !0,
            this._pingPongState++,
            C3$jscomp$114.wrap(this._pingPongState, 0, 2))) : 0 < this._playbackRate ? this._playheadTime >= a && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
            this._SetTimeAndReset(0),
            b = !0) : (this._SetTime(a),
            d = !0)) : 0 >= this._playheadTime && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++,
            this._SetTimeAndReset(a),
            b = !0) : (this._SetTime(0),
            d = !0));
            d ? (this._track.SetEndState(),
            this.Stop(!0),
            this.OnCompleted()) : (this._track.Interpolate(this._playheadTime, !0, !1, b, this._firstTick, !1),
            this._firstTick && (this._firstTick = !1))
        }
    }
    _SaveToJson() {
        const a = super._SaveToJson()
          , b = this.GetTimelineDataItem();
        return Object.assign(a, {
            tweenDataItemJson: b._SaveToJson(),
            id: this._id,
            destroyInstanceOnComplete: this._destroyInstanceOnComplete,
            initialValueMode: this._initialValueMode
        })
    }
    _LoadFromJson(a) {
        a && (this.GetTimelineDataItem()._LoadFromJson(a.tweenDataItemJson),
        super._LoadFromJson(a),
        this._id = a.id,
        this._destroyInstanceOnComplete = a.destroyInstanceOnComplete,
        this._initialValueMode = a.initialValueMode)
    }
    static IsPlaying(a) {
        return a.IsPlaying()
    }
    static IsPaused(a) {
        return a.IsPaused()
    }
    static Build(a) {
        var b = a.runtime.GetTimelineManager()
          , d = new C3$jscomp$114.TimelineDataItem;
        if (a.json) {
            d._LoadFromJson(a.json.tweenDataItemJson);
            var c = new C3$jscomp$114.TweenState(d,b);
            c._LoadFromJson(a.json);
            return c
        }
        b = new C3$jscomp$114.TweenState(d,b);
        C3$jscomp$114.IsArray(a.propertyTracksConfig) || (a.propertyTracksConfig = [a.propertyTracksConfig]);
        b.SetId(a.id);
        b.SetTags(a.tags);
        b.SetInitialValueMode(a.initialValueMode);
        b.SetDestroyInstanceOnComplete(a.releaseOnComplete);
        b.SetLoop(a.loop);
        b.SetPingPong(a.pingPong);
        b.SetTotalTime(a.time);
        b.SetStep(0);
        b.SetInterpolationMode("default");
        b.SetResultMode(a.propertyTracksConfig[0].resultMode);
        b.SetRepeatCount(a.repeatCount);
        d = b.AddTrack();
        d.SetInstanceUID(a.instance.GetUID());
        d.SetInterpolationMode("default");
        d.SetResultMode(a.propertyTracksConfig[0].resultMode);
        d.SetEnable(!0);
        d.SetObjectClassIndex(a.instance.GetObjectClass().GetIndex());
        var e = a.instance.GetSdkInstance()
          , g = e.IsOriginalSizeKnown() ? e.GetOriginalWidth() : a.instance.GetWorldInfo().GetWidth();
        e = e.IsOriginalSizeKnown() ? e.GetOriginalHeight() : a.instance.GetWorldInfo().GetHeight();
        d.SetOriginalWidth(g);
        d.SetOriginalHeight(e);
        g = d.AddKeyframe();
        g.SetTime(0);
        g.SetEase("noease");
        g.SetEnable(!0);
        g.SetTags("");
        g = d.AddKeyframe();
        g.SetTime(a.time);
        g.SetEase("noease");
        g.SetEnable(!0);
        g.SetTags("");
        for (c of a.propertyTracksConfig)
            g = d.AddPropertyTrack(),
            g.SetSourceAdapterId(c.sourceId),
            g.SetSourceAdapterArgs(c.sourceArgs),
            g.SetPropertyName(c.property),
            g.SetPropertyType(c.type),
            g.SetMin(NaN),
            g.SetMax(NaN),
            g.SetInterpolationMode("default"),
            g.SetResultMode(c.resultMode),
            g.SetEnable(!0),
            e = g.AddPropertyKeyframe(),
            e.SetType(c.valueType),
            e.SetTime(0),
            e.SetEase(c.ease),
            e.SetEnable(!0),
            e.SetValue(c.startValue),
            e.SetAbsoluteValue(c.startValue),
            e = g.AddPropertyKeyframe(),
            e.SetType(c.valueType),
            e.SetTime(a.time),
            e.SetEase(c.ease),
            e.SetEnable(!0),
            e.SetValue(c.endValue),
            e.SetAbsoluteValue(c.endValue),
            g.GetSourceAdapter();
        return b
    }
    GetITweenState(a, b) {
        this._iTweenState || (this._iTweenState = C3$jscomp$114.New(self.ITweenState, this, a, b));
        return this._iTweenState
    }
}
;
"use strict";
const C3$jscomp$115 = self.C3;
C3$jscomp$115.TweenTrackState = class extends C3$jscomp$115.TrackState {
    constructor(a, b) {
        super(a, b);
        this._secondPropertyTrack = this._firstPropertyTrack = null
    }
    static Create(a, b) {
        return C3$jscomp$115.New(C3$jscomp$115.TweenTrackState, a, b)
    }
    _CachePropertyTracks() {
        1 === this._propertyTracks.length ? this._firstPropertyTrack = this._propertyTracks[0] : (this._firstPropertyTrack = this._propertyTracks[0],
        this._secondPropertyTrack = this._propertyTracks[1])
    }
    CreatePropertyTrackStates() {
        for (const a of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems())
            this._propertyTracks.push(C3$jscomp$115.TweenPropertyTrackState.Create(this, a));
        this._CachePropertyTracks()
    }
    AddPropertyTrack() {
        var a = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem();
        a = C3$jscomp$115.TweenPropertyTrackState.Create(this, a);
        this._propertyTracks.push(a);
        this._CachePropertyTracks();
        return a
    }
    SetInitialState() {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            var a = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
            for (const b of this._propertyTracks)
                b.SetInitialState(a),
                0 === this._worldInfoChange && 1 === b.GetWorldInfoChange() && (this._worldInfoChange = 1),
                0 === this._renderChange && 1 === b.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            this._propertyTracks.some(b=>b.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
            this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
            this.Interpolate(a)
        }
    }
    BeforeInterpolate() {}
    Interpolate(a, b, d=!1, c=!1, e, g=!1, k=!1) {
        this._instance || this.GetInstance();
        if (this._instance) {
            if (this._instance.IsDestroyed() || g && this.GetObjectClass().IsGlobal())
                return !1;
            this._secondPropertyTrack ? (this._firstPropertyTrack.Interpolate(a, d, c, k),
            this._secondPropertyTrack.Interpolate(a, d, c, k)) : this._firstPropertyTrack.Interpolate(a, d, c, k);
            0 !== this._firstPropertyTrack.GetWorldInfoChange() && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()),
            this._worldInfo && this._worldInfo.SetBboxChanged())
        }
    }
    AfterInterpolate() {}
    _LoadFromJson(a) {
        super._LoadFromJson(a);
        this._CachePropertyTracks()
    }
}
;
"use strict";
const C3$jscomp$116 = self.C3;
C3$jscomp$116.TweenPropertyTrackState = class extends C3$jscomp$116.PropertyTrackState {
    constructor(a, b) {
        super(a, b);
        this._basic = !1
    }
    static Create(a, b) {
        return C3$jscomp$116.New(C3$jscomp$116.TweenPropertyTrackState, a, b)
    }
    Interpolate(a, b=!1, d=!1, c=!1) {
        if (this._basic) {
            var e = this._propertyKeyframeDataItems[0];
            var g = this._propertyKeyframeDataItems[1]
        } else {
            if (b)
                e = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
            else {
                if (this._lastPropertyKeyframeDataItem) {
                    g = this.GetTimeline();
                    const k = this._lastPropertyKeyframeDataItem.GetNext();
                    e = this._lastPropertyKeyframeDataItem.GetTime();
                    g = k ? k.GetTime() : g.GetTotalTime();
                    if (a <= e || a >= g)
                        this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem)
                } else
                    this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
                e = this._lastPropertyKeyframeDataItem
            }
            g = e.GetNext()
        }
        this._sourceAdapter.Interpolate(a, e, g, b, d, c)
    }
    AddPropertyKeyframe() {
        const a = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
        this._lastPropertyKeyframeDataItem = null;
        this._basic = 2 >= this.GetPropertyKeyframeDataItems().length;
        return a
    }
    DeletePropertyKeyframes(a) {
        this._lastPropertyKeyframeDataItem = null;
        this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(a);
        this._basic = 2 >= this.GetPropertyKeyframeDataItems().length
    }
    _SaveToJson() {
        return {
            sourceAdapterJson: this.GetSourceAdapter()._SaveToJson(),
            basic: this._basic
        }
    }
    _LoadFromJson(a) {
        a && (this.GetSourceAdapter()._LoadFromJson(a.sourceAdapterJson),
        this._basic = a.basic)
    }
}
;
"use strict";
const C3$jscomp$117 = self.C3
  , Ease$jscomp$2 = self.Ease;
C3$jscomp$117.Transition = class extends C3$jscomp$117.DefendedBase {
    constructor(a, b=!0) {
        super();
        this._name = a[0];
        this._linear = !1;
        this._transitionKeyframes = [];
        for (var d of a[1])
            a = C3$jscomp$117.TransitionKeyframe.Create(this, d),
            this._transitionKeyframes.push(a);
        for (d = 0; d < this._transitionKeyframes.length; d++)
            this._transitionKeyframes[d].SetNext(this._transitionKeyframes[d + 1]);
        this._precalculatedSamples = new Map;
        this._transitionKeyframeCache = new Map;
        this._PreCalcSamples();
        b && Ease$jscomp$2.AddCustomEase(this._name, (c,e,g,k)=>this.Interpolate(c, e, g, k))
    }
    static Create(a) {
        return C3$jscomp$117.New(C3$jscomp$117.Transition, a)
    }
    Release() {
        for (const a of this._transitionKeyframes)
            a.Release();
        C3$jscomp$117.clearArray(this._transitionKeyframes);
        this._transitionKeyframes = null;
        this._precalculatedSamples.clear();
        this._precalculatedSamples = null;
        this._transitionKeyframeCache.clear();
        this._transitionKeyframeCache = null
    }
    MakeLinear(a) {
        this._linear = !!a
    }
    GetTransitionKeyFrameAt(a) {
        const b = this._transitionKeyframeCache.get(a);
        if (b)
            return b;
        for (const d of this._transitionKeyframes)
            if (d.GetValueX() === a)
                return this._transitionKeyframeCache.set(a, d),
                d
    }
    GetFirstTransitionKeyFrameHigherThan(a) {
        for (const b of this._transitionKeyframes)
            if (b.GetValueX() > a)
                return b
    }
    GetFirstTransitionKeyFrameHigherOrEqualThan(a) {
        for (const b of this._transitionKeyframes)
            if (b.GetValueX() >= a)
                return b
    }
    GetFirstTransitionKeyFrameLowerThan(a) {
        for (let b = this._transitionKeyframes.length - 1; 0 <= b; b--) {
            const d = this._transitionKeyframes[b];
            if (d.GetValueX() < a)
                return d
        }
    }
    GetFirstTransitionKeyFrameLowerOrEqualThan(a) {
        for (let b = this._transitionKeyframes.length - 1; 0 <= b; b--) {
            const d = this._transitionKeyframes[b];
            if (d.GetValueX() <= a)
                return d
        }
    }
    Interpolate(a, b, d, c) {
        if (this._linear)
            return Ease$jscomp$2.NoEase(a, b, d, c);
        var e = a / c;
        a = this.GetFirstTransitionKeyFrameLowerOrEqualThan(e);
        c = a.GetNext();
        c || (a = this.GetFirstTransitionKeyFrameLowerThan(e),
        c = a.GetNext());
        var g = c.GetValueX() - a.GetValueX();
        e = C3$jscomp$117.mapToRange(e, a.GetValueX(), c.GetValueX(), 0, g);
        g = a.GetValueX();
        const k = a.GetValueY()
          , l = a.GetValueX() + a.GetStartAnchorX()
          , n = a.GetValueY() + a.GetStartAnchorY()
          , p = c.GetValueX() + c.GetEndAnchorX()
          , t = c.GetValueY() + c.GetEndAnchorY()
          , w = c.GetValueX();
        c = c.GetValueY();
        c = Ease$jscomp$2.GetRuntimeEase("spline")(e, g, k, l, n, p, t, w, c, this._precalculatedSamples.get(a));
        c += a.GetValueY();
        return (1 - c) * b + c * (b + d)
    }
    _PreCalcSamples() {
        this._precalculatedSamples.clear();
        for (let d = 0; d < this._transitionKeyframes.length - 1; d++) {
            var a = this._transitionKeyframes[d];
            if (!a.GetStartEnable())
                continue;
            var b = this._transitionKeyframes[d + 1];
            const c = a.GetValueX()
              , e = a.GetValueX() + a.GetStartAnchorX()
              , g = b.GetValueX() + b.GetEndAnchorX();
            b = b.GetValueX();
            this._precalculatedSamples.set(a, Ease$jscomp$2.GetBezierSamples(c, e, g, b))
        }
    }
}
;
"use strict";
const C3$jscomp$118 = self.C3;
C3$jscomp$118.TransitionKeyframe = class extends C3$jscomp$118.DefendedBase {
    constructor(a, b) {
        super();
        this._transition = a;
        this._valueX = b[0];
        this._valueY = b[1];
        this._startAnchorX = b[2];
        this._startAnchorY = b[3];
        this._endAnchorX = b[4];
        this._endAnchorY = b[5];
        this._startEnable = b[6];
        this._endEnable = b[7];
        this._next = null
    }
    Release() {
        this._transition = null
    }
    static Create(a, b) {
        return C3$jscomp$118.New(C3$jscomp$118.TransitionKeyframe, a, b)
    }
    SetNext(a) {
        this._next = a
    }
    GetNext() {
        return this._next
    }
    GetValueX() {
        return this._valueX
    }
    GetValueY() {
        return this._valueY
    }
    GetStartAnchorX() {
        return this._startAnchorX
    }
    GetStartAnchorY() {
        return this._startAnchorY
    }
    GetEndAnchorX() {
        return this._endAnchorX
    }
    GetEndAnchorY() {
        return this._endAnchorY
    }
    GetStartEnable() {
        return this._startEnable
    }
    GetEndEnable() {
        return this._endEnable
    }
}
;
"use strict";
const C3$jscomp$119 = self.C3;
C3$jscomp$119.TransitionManager = class extends C3$jscomp$119.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._transitions = []
    }
    Release() {
        for (const a of this._transitions)
            a.Release();
        C3$jscomp$119.clearArray(this._transitions);
        this._transitions = null
    }
    Create(a) {
        this._transitions.push(C3$jscomp$119.Transition.Create(a))
    }
}
;
"use strict";
const C3$jscomp$120 = self.C3;
C3$jscomp$120.TemplateManager = class extends C3$jscomp$120.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._instanceToTemplateNameMap = this._templateDataMap = null;
        this._instanceDestroy = b=>this._OnInstanceDestroy(b.instance)
    }
    Release() {
        this.RemoveRuntimeListeners();
        if (this._templateDataMap) {
            for (const a of this._templateDataMap.values())
                a.clear();
            this._templateDataMap.clear()
        }
        this._runtime = this._templateDataMap = null
    }
    Create(a) {
        this._templateDataMap || (this._templateDataMap = new Map);
        if (a) {
            var b = a[0][16][0]
              , d = a[1];
            this._templateDataMap.has(d) || this._templateDataMap.set(d, new Map);
            this._templateDataMap.get(d).set(b, a)
        }
    }
    AddRuntimeListeners() {
        const a = this._runtime.Dispatcher();
        a && a.addEventListener("instancedestroy", this._instanceDestroy)
    }
    RemoveRuntimeListeners() {
        const a = this._runtime.Dispatcher();
        a && a.removeEventListener("instancedestroy", this._instanceDestroy)
    }
    HasTemplates() {
        return this._templateDataMap ? 0 !== this._templateDataMap.size : !1
    }
    GetTemplateData(a, b) {
        a = a instanceof C3$jscomp$120.ObjectClass ? a.GetIndex() : a;
        if (this._templateDataMap.has(a) && (b = this._templateDataMap.get(a).get(b)))
            return JSON.parse(JSON.stringify(b))
    }
    MapInstanceToTemplateName(a, b) {
        this._instanceToTemplateNameMap || (this._instanceToTemplateNameMap = new WeakMap);
        this._instanceToTemplateNameMap.has(a) || this._instanceToTemplateNameMap.set(a, b)
    }
    GetInstanceTemplateName(a) {
        return this._instanceToTemplateNameMap ? (a = this._instanceToTemplateNameMap.get(a)) ? a : "" : ""
    }
    _OnInstanceDestroy(a) {
        this._instanceToTemplateNameMap && this._instanceToTemplateNameMap.has(a) && this._instanceToTemplateNameMap.delete(a)
    }
}
;
"use strict";
const C3$jscomp$121 = self.C3;
C3$jscomp$121.SolStack = class extends C3$jscomp$121.DefendedBase {
    constructor(a) {
        super();
        this._objectClass = a;
        this._stack = [];
        this._stack.push(C3$jscomp$121.New(C3$jscomp$121.Sol, this));
        this._index = 0;
        this._current = this._stack[0]
    }
    Release() {
        for (const a of this._stack)
            a.Release();
        C3$jscomp$121.clearArray(this._stack);
        this._objectClass = this._current = null
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetCurrentSol() {
        return this._current
    }
    GetOneBelowCurrentSol() {
        return this._stack[this._index - 1]
    }
    Clear() {
        this.GetCurrentSol().Clear()
    }
    PushClean() {
        var a = this._stack
          , b = ++this._index;
        b === a.length ? (b = C3$jscomp$121.New(C3$jscomp$121.Sol, this),
        a.push(b),
        this._current = b) : (a = a[b],
        a.Reset(),
        this._current = a)
    }
    PushCopy() {
        const a = this._stack
          , b = ++this._index;
        b === a.length && a.push(C3$jscomp$121.New(C3$jscomp$121.Sol, this));
        const d = a[b];
        d.Copy(a[b - 1]);
        this._current = d
    }
    Pop() {
        this._current = this._stack[--this._index]
    }
    RemoveInstances(a) {
        const b = this._stack;
        for (let d = 0, c = b.length; d < c; ++d)
            b[d].RemoveInstances(a)
    }
}
;
"use strict";
const C3$jscomp$122 = self.C3;
C3$jscomp$122.Sol = class extends C3$jscomp$122.DefendedBase {
    constructor(a) {
        super();
        this._stack = a;
        this._objectClass = this._stack.GetObjectClass();
        this._eventStack = this._objectClass.GetRuntime().GetEventStack();
        this._selectAll = !0;
        this._instances = [];
        this._elseInstances = []
    }
    Release() {
        this.ClearArrays();
        this._eventStack = this._objectClass = this._stack = null
    }
    ClearArrays() {
        C3$jscomp$122.clearArray(this._instances);
        C3$jscomp$122.clearArray(this._elseInstances)
    }
    GetObjectClass() {
        return this._objectClass
    }
    IsSelectAll() {
        return this._selectAll
    }
    HasAnyInstances() {
        return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length
    }
    GetInstances() {
        return this._selectAll ? this._objectClass.GetInstances() : this._instances
    }
    HasAnyElseInstances() {
        return !!this._elseInstances.length
    }
    GetElseInstances() {
        return this._elseInstances
    }
    GetExpressionInstances() {
        const a = this.GetInstances();
        return a.length ? a : this._elseInstances
    }
    Reset() {
        this._selectAll = !0;
        C3$jscomp$122.clearArray(this._elseInstances)
    }
    Clear() {
        this._selectAll = !0
    }
    Copy(a) {
        a.IsSelectAll() ? this.Reset() : (this._selectAll = !1,
        C3$jscomp$122.shallowAssignArray(this._instances, a._instances),
        C3$jscomp$122.clearArray(this._elseInstances))
    }
    _PushInstance(a) {
        this._instances.push(a)
    }
    _PushElseInstance(a) {
        this._elseInstances.push(a)
    }
    _SetSelectAll(a) {
        this._selectAll = !!a
    }
    _GetOwnInstances() {
        return this._instances
    }
    _GetOwnElseInstances() {
        return this._elseInstances
    }
    SetSinglePicked(a) {
        this._selectAll = !1;
        C3$jscomp$122.clearArray(this._instances);
        this._instances.push(a)
    }
    SetArrayPicked(a) {
        this._selectAll = !1;
        C3$jscomp$122.shallowAssignArray(this._instances, a)
    }
    SetSetPicked(a) {
        this._selectAll = !1;
        C3$jscomp$122.clearArray(this._instances);
        for (const b of a)
            this._instances.push(b)
    }
    AddElseInstances(a, b) {
        for (const d of b)
            a.has(d) || this._elseInstances.push(d)
    }
    TransferElseInstancesToOwn(a) {
        for (const b of a)
            this._instances.push(b);
        C3$jscomp$122.arrayRemoveAllInSet(this._elseInstances, a)
    }
    ClearElseInstances() {
        C3$jscomp$122.clearArray(this._elseInstances)
    }
    PickOne(a) {
        a && (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock() ? (this.IsSelectAll() && (C3$jscomp$122.clearArray(this._instances),
        C3$jscomp$122.shallowAssignArray(this._elseInstances, a.GetObjectClass().GetInstances()),
        this._selectAll = !1),
        a = this._elseInstances.indexOf(a),
        -1 !== a && (this._instances.push(this._elseInstances[a]),
        this._elseInstances.splice(a, 1))) : this.SetSinglePicked(a))
    }
    RemoveInstances(a) {
        C3$jscomp$122.arrayRemoveAllInSet(this._instances, a);
        C3$jscomp$122.arrayRemoveAllInSet(this._elseInstances, a)
    }
}
;
"use strict";
const C3$jscomp$123 = self.C3;
C3$jscomp$123.EventStack = class extends C3$jscomp$123.DefendedBase {
    constructor(a) {
        super();
        this._eventSheetManager = a;
        this._runtime = this._eventSheetManager.GetRuntime();
        this._stack = [];
        this._stack.push(C3$jscomp$123.New(C3$jscomp$123.EventStackFrame, this, null));
        this._index = 0;
        this._expFuncStack = []
    }
    Release() {
        for (const a of this._stack)
            a.Release();
        C3$jscomp$123.clearArray(this._stack);
        C3$jscomp$123.clearArray(this._expFuncStack);
        this._runtime = this._eventSheetManager = null
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetCurrentStackFrame() {
        return this._stack[this._index]
    }
    GetAllStackFrames() {
        return this._stack
    }
    GetCurrentStackFrameIndex() {
        return this._index
    }
    Push(a) {
        var b = this._stack;
        const d = ++this._index;
        if (d === b.length)
            return a = C3$jscomp$123.New(C3$jscomp$123.EventStackFrame, this, a),
            b.push(a),
            a;
        b = b[d];
        b.Reset(a);
        return b
    }
    Pop() {
        --this._index
    }
    PushExpFunc(a) {
        this._expFuncStack.push(a)
    }
    PopExpFunc() {
        this._expFuncStack.pop()
    }
    GetCurrentExpFuncStackFrame() {
        const a = this._expFuncStack;
        return 0 === a.length ? null : a.at(-1)
    }
}
;
"use strict";
const C3$jscomp$124 = self.C3;
C3$jscomp$124.EventStackFrame = class extends C3$jscomp$124.DefendedBase {
    constructor(a, b) {
        super();
        this._stack = a;
        this._runtime = this._stack.GetRuntime();
        this._currentEvent = b;
        this._actIndex = this._cndIndex = 0;
        this._elseBranchRan = this._lastEventTrue = !1;
        this._expressionObjectClass = null;
        this._functionReturnValue = this._functionReturnType = 0;
        this._dynamicSolModifiers = null
    }
    Release() {
        this.Reset(null);
        this._runtime = this._stack = null
    }
    Reset(a) {
        this._currentEvent = a;
        this._actIndex = this._cndIndex = 0;
        this._elseBranchRan = this._lastEventTrue = !1;
        this._dynamicSolModifiers = null
    }
    _Restore(a, b) {
        this._currentEvent = a;
        this._cndIndex = 0;
        this._actIndex = b
    }
    ResetQuick() {
        this._actIndex = this._cndIndex = 0
    }
    GetCurrentEvent() {
        return this._currentEvent
    }
    SetCurrentEvent(a) {
        this._currentEvent = a
    }
    GetConditionIndex() {
        return this._cndIndex
    }
    SetConditionIndex(a) {
        this._cndIndex = a
    }
    GetActionIndex() {
        return this._actIndex
    }
    SetActionIndex(a) {
        this._actIndex = a
    }
    SetLastEventTrue(a) {
        this._lastEventTrue = !!a
    }
    GetLastEventTrue() {
        return this._lastEventTrue
    }
    SetElseBranchRan(a) {
        this._elseBranchRan = !!a
    }
    GetElseBranchRan() {
        return this._elseBranchRan
    }
    SetExpressionObjectClass(a) {
        this._expressionObjectClass = a
    }
    GetExpressionObjectClass() {
        return this._expressionObjectClass
    }
    InitCallFunctionExpression(a, b) {
        this._functionReturnType = a;
        this._functionReturnValue = b
    }
    GetFunctionReturnType() {
        return this._functionReturnType
    }
    SetFunctionReturnValue(a) {
        this._functionReturnValue = a
    }
    GetFunctionReturnValue() {
        return this._functionReturnValue
    }
    IsSolModifierAfterCnds() {
        const a = this._currentEvent;
        return a.IsSolWriterAfterCnds() ? !0 : this._cndIndex < a.GetConditionCount() - 1 ? !!a.GetSolModifiers().length : !1
    }
    SetDynamicSolModifiers(a) {
        this._dynamicSolModifiers = a
    }
    GetDynamicSolModifiers() {
        return this._dynamicSolModifiers
    }
}
;
"use strict";
const C3$jscomp$125 = self.C3;
C3$jscomp$125.LocalVarStack = class extends C3$jscomp$125.DefendedBase {
    constructor(a) {
        super();
        this._eventSheetManager = a;
        this._runtime = this._eventSheetManager.GetRuntime();
        this._stack = [];
        this._index = -1;
        this._current = null;
        this._initialValues = []
    }
    Release() {
        C3$jscomp$125.clearArray(this._stack);
        this._runtime = this._eventSheetManager = null
    }
    _SetInitialValues(a) {
        this._initialValues = a;
        a = this._initialValues.slice(0);
        this._stack.push(a);
        this._index = 0;
        this._current = a
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetCurrent() {
        return this._current
    }
    Push() {
        const a = ++this._index
          , b = this._stack;
        a === b.length ? b.push(this._initialValues.slice(0)) : C3$jscomp$125.shallowAssignArray(b[a], this._initialValues);
        this._current = b[a]
    }
    Pop() {
        this._current = this._stack[--this._index]
    }
}
;
"use strict";
const C3$jscomp$126 = self.C3;
C3$jscomp$126.LoopStack = class extends C3$jscomp$126.DefendedBase {
    constructor(a) {
        super();
        this._eventSheetManager = a;
        this._runtime = this._eventSheetManager.GetRuntime();
        this._stack = [];
        this._index = -1
    }
    Release() {
        C3$jscomp$126.clearArray(this._stack);
        this._runtime = this._eventSheetManager = null
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    IsInLoop() {
        return 0 <= this._index
    }
    GetCurrent() {
        return this._stack[this._index]
    }
    Push() {
        ++this._index;
        if (this._index === this._stack.length) {
            var a = C3$jscomp$126.New(C3$jscomp$126.Loop, this);
            this._stack.push(a);
            return a
        }
        a = this._stack[this._index];
        a.Reset();
        return a
    }
    Pop() {
        --this._index
    }
    FindByName(a) {
        const b = this._stack;
        for (let d = this._index; 0 <= d; --d) {
            const c = b[d];
            if (c.GetName() === a)
                return c
        }
        return null
    }
    _GetStack() {
        return this._stack.slice(0, this._index + 1)
    }
}
;
"use strict";
const C3$jscomp$127 = self.C3;
C3$jscomp$127.Loop = class extends C3$jscomp$127.DefendedBase {
    constructor(a) {
        super();
        this._loopStack = a;
        this._name = "";
        this._index = 0;
        this._isStopped = !1;
        this._end = NaN
    }
    Reset() {
        this._name = "";
        this._index = 0;
        this._isStopped = !1;
        this._end = NaN
    }
    SetName(a) {
        this._name = a
    }
    GetName() {
        return this._name
    }
    SetIndex(a) {
        this._index = a
    }
    GetIndex() {
        return this._index
    }
    Stop() {
        this._isStopped = !0
    }
    IsStopped() {
        return this._isStopped
    }
    SetEnd(a) {
        this._end = a
    }
    GetEnd() {
        return this._end
    }
}
;
"use strict";
const C3$jscomp$128 = self.C3;
C3$jscomp$128.ArrayStack = class extends C3$jscomp$128.DefendedBase {
    constructor() {
        super();
        this._stack = [];
        this._index = -1
    }
    Release() {
        C3$jscomp$128.clearArray(this._stack)
    }
    GetCurrent() {
        return this._stack[this._index]
    }
    Push() {
        ++this._index;
        if (this._index === this._stack.length) {
            const a = [];
            this._stack.push(a);
            return a
        }
        return this._stack[this._index]
    }
    Pop() {
        --this._index
    }
}
;
"use strict";
const C3$jscomp$129 = self.C3;
function SortSolArray(a, b) {
    return a.GetIndex() - b.GetIndex()
}
function IsSolArrayIdentical(a, b) {
    for (let d = 0, c = a.length; d < c; ++d)
        if (a[d] !== b[d])
            return !1;
    return !0
}
C3$jscomp$129.EventSheetManager = class extends C3$jscomp$129.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._allSheets = [];
        this._sheetsByName = new Map;
        this._allGroups = [];
        this._groupsByName = new Map;
        this._blocksBySid = new Map;
        this._cndsBySid = new Map;
        this._actsBySid = new Map;
        this._allUniqueSolModifiers = new Map;
        this._eventVarsBySid = new Map;
        this._nextLocalVarIndex = 0;
        this._allGlobalVars = [];
        this._allLocalVars = [];
        this._localVarInitialValues = [];
        this._functionBlocksByName = new Map;
        this._customActionBlocksMap = new Map;
        this._eventStack = C3$jscomp$129.New(C3$jscomp$129.EventStack, this);
        this._localVarStack = C3$jscomp$129.New(C3$jscomp$129.LocalVarStack, this);
        this._loopStack = C3$jscomp$129.New(C3$jscomp$129.LoopStack, this);
        this._triggersToPostInit = [];
        this._queuedTriggers = [];
        this._queuedDebugTriggers = [];
        this._blockFlushingDepth = this._executingTriggerDepth = this._runningEventsDepth = 0;
        this._scheduledWaits = [];
        this._asyncActionPromises = [];
        self.c3_callFunction = (b,d)=>this._InvokeFunctionFromJS(b, d)
    }
    Release() {
        this.ClearAllScheduledWaits();
        this._eventStack.Release();
        this._eventStack = null;
        this._localVarStack.Release();
        this._localVarStack = null;
        C3$jscomp$129.clearArray(this._queuedTriggers);
        C3$jscomp$129.clearArray(this._queuedDebugTriggers);
        this._runtime = null;
        C3$jscomp$129.clearArray(this._allSheets);
        this._sheetsByName.clear()
    }
    Create(a) {
        a = C3$jscomp$129.New(C3$jscomp$129.EventSheet, this, a);
        this._allSheets.push(a);
        this._sheetsByName.set(a.GetName().toLowerCase(), a)
    }
    _AddTriggerToPostInit(a) {
        this._triggersToPostInit.push(a)
    }
    _PostInit() {
        for (const a of this._customActionBlocksMap.values())
            a._CheckOverrideState();
        for (const a of this._functionBlocksByName.values())
            a._PostInit();
        for (const a of this._customActionBlocksMap.values())
            a._PostInit();
        for (const a of this._allSheets)
            a._PostInit();
        for (const a of this._allSheets)
            a._UpdateDeepIncludes();
        for (const a of this._triggersToPostInit)
            a._PostInit(!1);
        C3$jscomp$129.clearArray(this._triggersToPostInit);
        this._localVarStack._SetInitialValues(this._localVarInitialValues)
    }
    GetRuntime() {
        return this._runtime
    }
    GetEventSheetByName(a) {
        return this._sheetsByName.get(a.toLowerCase()) || null
    }
    _RegisterGroup(a) {
        this._allGroups.push(a);
        this._groupsByName.set(a.GetGroupName(), a)
    }
    _RegisterEventBlock(a) {
        this._blocksBySid.set(a.GetSID(), a)
    }
    _RegisterCondition(a) {
        this._cndsBySid.set(a.GetSID(), a)
    }
    _RegisterAction(a) {
        this._actsBySid.set(a.GetSID(), a)
    }
    _RegisterFunctionBlock(a) {
        switch (a.GetFunctionType()) {
        case 0:
            this._functionBlocksByName.set(a.GetFunctionName().toLowerCase(), a);
            break;
        case 1:
            this._customActionBlocksMap.set(a.GetFunctionName().toLowerCase(), a)
        }
    }
    _RegisterEventVariable(a) {
        this._eventVarsBySid.set(a.GetSID(), a);
        a.IsGlobal() ? this._allGlobalVars.push(a) : this._allLocalVars.push(a)
    }
    _DeduplicateSolModifierList(a) {
        2 <= a.length && a.sort(SortSolArray);
        let b = this._allUniqueSolModifiers.get(a.length);
        b || (b = [],
        this._allUniqueSolModifiers.set(a.length, b));
        for (let d = 0, c = b.length; d < c; ++d) {
            const e = b[d];
            if (IsSolArrayIdentical(a, e))
                return e
        }
        b.push(a);
        return a
    }
    _GetNextLocalVarIndex(a) {
        this._localVarInitialValues.push(a.GetInitialValue());
        return this._nextLocalVarIndex++
    }
    GetEventStack() {
        return this._eventStack
    }
    GetCurrentEventStackFrame() {
        return this.GetEventStack().GetCurrentStackFrame()
    }
    GetCurrentEvent() {
        return this.GetCurrentEventStackFrame().GetCurrentEvent()
    }
    GetCurrentCondition() {
        const a = this.GetCurrentEventStackFrame();
        return a.GetCurrentEvent().GetConditionAt(a.GetConditionIndex())
    }
    GetCurrentAction() {
        const a = this.GetCurrentEventStackFrame();
        return a.GetCurrentEvent().GetActionAt(a.GetActionIndex())
    }
    GetLocalVarStack() {
        return this._localVarStack
    }
    GetLoopStack() {
        return this._loopStack
    }
    GetAllLocalVariablesInScope(a) {
        const b = [];
        for (a = a.GetScopeParent(); a; )
            C3$jscomp$129.appendArray(b, a._GetAllLocalVariablesInScope()),
            a = a.GetScopeParent();
        return b
    }
    _GetLocalVariablesScriptInterface(a) {
        const b = {};
        for (const d of this.GetAllLocalVariablesInScope(a))
            b[d.GetJsPropName()] = d._GetScriptInterfaceDescriptor();
        return Object.create(Object.prototype, b)
    }
    GetEventVariableBySID(a) {
        return this._eventVarsBySid.get(a) || null
    }
    GetEventBlockBySID(a) {
        return this._blocksBySid.get(a) || null
    }
    GetConditionBySID(a) {
        return this._cndsBySid.get(a) || null
    }
    GetActionBySID(a) {
        return this._actsBySid.get(a) || null
    }
    GetFunctionBlockByName(a) {
        return this._functionBlocksByName.get(a.toLowerCase()) || null
    }
    GetCustomActionBlockByName(a, b) {
        let d = this._customActionBlocksMap.get((a.GetName() + "." + b).toLowerCase());
        if (d)
            return d;
        if (!a.IsFamily())
            for (const c of a.GetFamilies())
                if (d = this._customActionBlocksMap.get((c.GetName() + "." + b).toLowerCase()))
                    return d;
        return null
    }
    GetAllGlobalVariables() {
        return this._allGlobalVars
    }
    GetAllLocalVariables() {
        return this._allLocalVars
    }
    ResetAllGlobalsToInitialValue() {
        for (const a of this._allGlobalVars)
            a.ResetToInitialValue()
    }
    GetEventGroupByName(a) {
        return this._groupsByName.get(a.toLowerCase()) || null
    }
    GetEventGroupBySID(a) {
        return (a = this._blocksBySid.get(a)) && a.IsGroup() ? a : null
    }
    GetAllGroups() {
        return this._allGroups
    }
    ResetAllGroupsInitialActivation() {
        for (const a of this._allGroups)
            a.ResetInitialActivation()
    }
    _ResetAllHasRunFlags() {
        for (const a of this._allSheets)
            a._ResetHasRunFlag()
    }
    RunEvents(a) {
        this._ResetAllHasRunFlags();
        this._runningEventsDepth++;
        for (const b of a.runningLayouts())
            if (a = b.GetEventSheet())
                this._runtime.PushCurrentLayout(b),
                a.Run(),
                this._runtime.PopCurrentLayout();
        this._runningEventsDepth--
    }
    async DebugRunEvents(a) {
        this._ResetAllHasRunFlags();
        this._runningEventsDepth++;
        for (const b of this._DebugRunEventsGen(a))
            await this._runtime.DebugBreak(b);
        this._runningEventsDepth--
    }
    *_DebugRunEventsGen(a) {
        for (const b of a.runningLayouts())
            if (a = b.GetEventSheet())
                this._runtime.PushCurrentLayout(b),
                yield*a.DebugRun(),
                this._runtime.PopCurrentLayout()
    }
    _Trigger(a, b, d, c) {
        let e = !1;
        if (!a.GetMainRunningLayout())
            return this.QueueTrigger(b, d, c);
        this._executingTriggerDepth++;
        for (const g of a.runningLayouts())
            if (a = g.GetEventSheet()) {
                this._runtime.PushCurrentLayout(g);
                for (const k of a.deepIncludes()) {
                    const l = k._Trigger(b, d, c);
                    e = e || l
                }
                a = a._Trigger(b, d, c);
                e = e || a;
                this._runtime.PopCurrentLayout()
            }
        this._executingTriggerDepth--;
        return e
    }
    *_DebugTrigger(a, b, d, c) {
        let e = !1;
        if (!a.GetMainRunningLayout())
            return this.QueueTrigger(b, d, c);
        this._executingTriggerDepth++;
        for (const g of a.runningLayouts())
            if (a = g.GetEventSheet()) {
                this._runtime.PushCurrentLayout(g);
                for (const k of a.deepIncludes()) {
                    const l = yield*k._DebugTrigger(b, d, c);
                    e = e || l
                }
                a = yield*a._DebugTrigger(b, d, c);
                e = e || a;
                this._runtime.PopCurrentLayout()
            }
        this._executingTriggerDepth--;
        return e
    }
    QueueTrigger(a, b, d) {
        this._queuedTriggers.push([a, b, d]);
        return !1
    }
    QueueDebugTrigger(a, b, d) {
        let c = null;
        const e = new Promise(g=>c = g);
        this._queuedDebugTriggers.push([a, b, d, c]);
        return e
    }
    *_RunQueuedDebugTriggersGen() {
        if (this._runtime.HitBreakpoint())
            throw Error("should not be in breakpoint");
        const a = this._runtime.GetLayoutManager();
        for (; this._queuedDebugTriggers.length; ) {
            const [b,d,c,e] = this._queuedDebugTriggers.shift()
              , g = yield*this._DebugTrigger(a, b, d, c);
            e(g)
        }
    }
    async RunQueuedDebugTriggersAsync() {
        for (const a of this._RunQueuedDebugTriggersGen())
            await this._runtime.DebugBreak(a)
    }
    _FastTrigger(a, b, d, c) {
        let e = !1;
        var g = a.GetMainRunningLayout();
        if (a = g.GetEventSheet()) {
            this._executingTriggerDepth++;
            this._runtime.PushCurrentLayout(g);
            g = a.deepIncludes();
            for (let k = 0, l = g.length; k < l; ++k) {
                const n = g[k]._FastTrigger(b, d, c);
                e = e || n
            }
            b = a._FastTrigger(b, d, c);
            e = e || b;
            this._runtime.PopCurrentLayout();
            this._executingTriggerDepth--;
            return e
        }
    }
    *_DebugFastTrigger(a, b, d, c) {
        let e = !1;
        var g = a.GetMainRunningLayout();
        if (a = g.GetEventSheet()) {
            this._executingTriggerDepth++;
            this._runtime.PushCurrentLayout(g);
            g = a.deepIncludes();
            for (let k = 0, l = g.length; k < l; ++k) {
                const n = yield*g[k]._DebugFastTrigger(b, d, c);
                e = e || n
            }
            b = yield*a._DebugFastTrigger(b, d, c);
            e = e || b;
            this._runtime.PopCurrentLayout();
            this._executingTriggerDepth--;
            return e
        }
    }
    GetTriggerDepth() {
        return this._executingTriggerDepth
    }
    IsInTrigger() {
        return 0 < this.GetTriggerDepth()
    }
    _IncTriggerDepth() {
        return ++this._executingTriggerDepth
    }
    _DecTriggerDepth() {
        --this._executingTriggerDepth
    }
    IsRunningEvents() {
        return 0 < this._runningEventsDepth
    }
    IsInEventEngine() {
        return this.IsRunningEvents() || this.IsInTrigger()
    }
    _RunQueuedTriggers(a) {
        for (const [b,d,c] of this._queuedTriggers)
            this._Trigger(a, b, d, c);
        C3$jscomp$129.clearArray(this._queuedTriggers)
    }
    BlockFlushingInstances(a) {
        a ? this._blockFlushingDepth++ : this._blockFlushingDepth--
    }
    IsFlushingBlocked() {
        return 0 < this._blockFlushingDepth
    }
    ClearSol(a) {
        for (let b = 0, d = a.length; b < d; ++b)
            a[b].GetSolStack().Clear()
    }
    PushCleanSol(a) {
        for (let b = 0, d = a.length; b < d; ++b)
            a[b].GetSolStack().PushClean()
    }
    PushCopySol(a) {
        for (let b = 0, d = a.length; b < d; ++b)
            a[b].GetSolStack().PushCopy()
    }
    PopSol(a) {
        for (let b = 0, d = a.length; b < d; ++b)
            a[b].GetSolStack().Pop()
    }
    GetDynamicSolModifiersSet(a) {
        const b = new Set
          , d = this._eventStack.GetAllStackFrames()
          , c = this._eventStack.GetCurrentStackFrameIndex();
        for (let e = 0; e <= c; ++e) {
            const g = d[e].GetDynamicSolModifiers();
            if (g)
                for (const k of g)
                    a && a.has(k) || b.add(k)
        }
        return b
    }
    PushCleanSolDynamic(a) {
        a = new Set([...a]);
        a = this.GetDynamicSolModifiersSet(a);
        if (0 < a.size) {
            for (const b of a)
                b.GetSolStack().PushClean();
            return [...a]
        }
        return null
    }
    AddScheduledWait() {
        const a = C3$jscomp$129.New(C3$jscomp$129.ScheduledWait, this);
        this._scheduledWaits.push(a);
        return a
    }
    scheduledWaits() {
        return this._scheduledWaits
    }
    RunScheduledWaits() {
        if (this._scheduledWaits.length) {
            var a = this.GetCurrentEventStackFrame()
              , b = !1;
            this._runningEventsDepth++;
            for (let d = 0, c = this._scheduledWaits.length; d < c; ++d) {
                const e = this._scheduledWaits[d];
                e._ShouldRun() && e._Run(a);
                e.ShouldRelease() && (b = !0)
            }
            b && (this._FilterScheduledWaitsToRelease(),
            a.Reset(null));
            this._runningEventsDepth--
        }
    }
    async DebugRunScheduledWaits() {
        if (this._scheduledWaits.length) {
            var a = this.GetCurrentEventStackFrame()
              , b = !1;
            this._runningEventsDepth++;
            for (let d = 0, c = this._scheduledWaits.length; d < c; ++d) {
                const e = this._scheduledWaits[d];
                e._ShouldRun() && await e._DebugRun(a);
                e.ShouldRelease() && (b = !0)
            }
            b && (this._FilterScheduledWaitsToRelease(),
            a.Reset(null));
            this._runningEventsDepth--
        }
    }
    _FilterScheduledWaitsToRelease() {
        const a = C3$jscomp$129.arrayFilterOut(this._scheduledWaits, b=>b.ShouldRelease());
        for (const b of a)
            b.Release()
    }
    ClearAllScheduledWaits() {
        for (const a of this._scheduledWaits)
            a.Release();
        C3$jscomp$129.clearArray(this._scheduledWaits)
    }
    RemoveInstancesFromScheduledWaits(a) {
        for (const b of this._scheduledWaits)
            b.RemoveInstances(a)
    }
    AddAsyncActionPromise(a) {
        this._asyncActionPromises.push(a)
    }
    ClearAsyncActionPromises() {
        C3$jscomp$129.clearArray(this._asyncActionPromises)
    }
    GetPromiseForAllAsyncActions() {
        const a = Promise.all(this._asyncActionPromises);
        this._asyncActionPromises = [];
        return a
    }
    _SaveToJson() {
        return {
            groups: this._SaveGroupsToJson(),
            cnds: this._SaveCndsToJson(),
            acts: this._SaveActsToJson(),
            vars: this._SaveVarsToJson(),
            waits: this._SaveScheduledWaitsToJson()
        }
    }
    _LoadFromJson(a) {
        this._LoadGroupsFromJson(a.groups);
        this._LoadCndsFromJson(a.cnds);
        this._LoadActsFromJson(a.acts);
        this._LoadVarsFromJson(a.vars);
        this._LoadScheduledWaitsFromJson(a.waits)
    }
    _SaveGroupsToJson() {
        const a = {};
        for (const b of this.GetAllGroups())
            a[b.GetSID().toString()] = b.IsGroupActive();
        return a
    }
    _LoadGroupsFromJson(a) {
        for (const [b,d] of Object.entries(a))
            a = parseInt(b, 10),
            (a = this.GetEventGroupBySID(a)) && a.SetGroupActive(d)
    }
    _SaveCndsToJson() {
        const a = {};
        for (const [b,d] of this._cndsBySid) {
            const c = d._SaveToJson();
            c && (a[b.toString()] = c)
        }
        return a
    }
    _LoadCndsFromJson(a) {
        const b = new Map;
        for (const [d,c] of Object.entries(a))
            b.set(parseInt(d, 10), c);
        for (const [d,c] of this._cndsBySid)
            c._LoadFromJson(b.get(d) || null)
    }
    _SaveActsToJson() {
        const a = {};
        for (const [b,d] of this._actsBySid) {
            const c = d._SaveToJson();
            c && (a[b.toString()] = c)
        }
        return a
    }
    _LoadActsFromJson(a) {
        const b = new Map;
        for (const [d,c] of Object.entries(a))
            b.set(parseInt(d, 10), c);
        for (const [d,c] of this._actsBySid)
            c._LoadFromJson(b.get(d) || null)
    }
    _SaveVarsToJson() {
        const a = {};
        for (const [b,d] of this._eventVarsBySid)
            d.IsConstant() || !d.IsGlobal() && !d.IsStatic() || (a[b.toString()] = d.GetValue());
        return a
    }
    _LoadVarsFromJson(a) {
        for (const [b,d] of Object.entries(a))
            a = parseInt(b, 10),
            (a = this.GetEventVariableBySID(a)) && a.SetValue(d)
    }
    _SaveScheduledWaitsToJson() {
        return this._scheduledWaits.filter(a=>!a.IsPromise()).map(a=>a._SaveToJson())
    }
    _LoadScheduledWaitsFromJson(a) {
        this.ClearAllScheduledWaits();
        for (const b of a)
            (a = C3$jscomp$129.ScheduledWait._CreateFromJson(this, b)) && this._scheduledWaits.push(a)
    }
    _GetPerfRecords() {
        return [...this._runtime.GetLayoutManager().runningLayouts()].map(a=>a.GetEventSheet()).filter(a=>a).map(a=>a._GetPerfRecord())
    }
    FindFirstFunctionBlockParent(a) {
        for (; a; )
            if (a = a.GetScopeParent(),
            a instanceof C3$jscomp$129.FunctionBlock)
                return a;
        return null
    }
    _InvokeFunctionFromJS(a, b) {
        Array.isArray(b) || (b = []);
        a = this.GetFunctionBlockByName(a.toLowerCase());
        if (!a)
            return null;
        if (!a.IsEnabled())
            return a.GetDefaultReturnValue();
        var d = a.GetFunctionParameters();
        if (b.length < d.length) {
            b = b.slice(0);
            do
                b.push(d[b.length].GetInitialValue());
            while (b.length < d.length)
        }
        d = a.GetEventBlock();
        return d.RunAsExpressionFunctionCall(d.GetSolModifiersIncludingParents(), !1, a.GetReturnType(), a.GetDefaultReturnValue(), ...b)
    }
}
;
"use strict";
const C3$jscomp$130 = self.C3;
C3$jscomp$130.EventSheet = class extends C3$jscomp$130.DefendedBase {
    constructor(a, b) {
        super();
        this._eventSheetManager = a;
        this._runtime = a.GetRuntime();
        this._name = b[0];
        this._events = [];
        this._triggers = new Map;
        this._fastTriggers = new Map;
        this._eventsByDisplayNumber = new Map;
        this._hasRun = !1;
        this._shallowIncludes = [];
        this._deepIncludes = [];
        this._alreadyIncludedSheets = new Set;
        for (const d of b[1])
            this._CreateEvent(d, null, this._events);
        this._perfRecord = this._runtime.IsDebug() ? {
            type: "sheet",
            name: this._name,
            totalTimeCounter: 0,
            children: []
        } : null
    }
    Release() {
        this._runtime = this._eventSheetManager = null
    }
    _CreateEvent(a, b, d) {
        switch (a[0]) {
        case 0:
        case 3:
            this._CreateEventBlock(a, b, d);
            break;
        case 1:
            this._CreateEventVariable(a, b, d);
            break;
        case 2:
            this._CreateInclude(a, b, d);
            break;
        case 4:
            this._CreateFunctionBlock(a, b);
            break;
        case 5:
            this._CreateScriptBlock(a, b, d);
            break;
        case 6:
            this._CreateCustomACEBlock(a, b);
            break;
        default:
            throw Error("invalid event type");
        }
    }
    _CreateEventBlock(a, b, d) {
        a = C3$jscomp$130.EventBlock.Create(this, b, a);
        if (a.IsOrBlock()) {
            d.push(a);
            d = a.GetConditions();
            for (let c = 0, e = d.length; c < e; ++c)
                d[c].IsTrigger() && this._InitTrigger(a, c)
        } else
            a.IsTrigger() ? this._InitTrigger(a, 0) : d.push(a)
    }
    _CreateFunctionBlock(a, b) {
        a = C3$jscomp$130.FunctionBlock.CreateFunctionBlock(this, b, a);
        this._eventSheetManager._RegisterFunctionBlock(a)
    }
    _CreateCustomACEBlock(a, b) {
        a = C3$jscomp$130.FunctionBlock.CreateCustomACEBlock(this, b, a);
        this._eventSheetManager._RegisterFunctionBlock(a)
    }
    _CreateEventVariable(a, b, d) {
        a = C3$jscomp$130.EventVariable.Create(this, b, a);
        d.push(a)
    }
    _CreateInclude(a, b, d) {
        a = C3$jscomp$130.EventInclude.Create(this, b, a);
        d.push(a)
    }
    _CreateScriptBlock(a, b, d) {
        a = C3$jscomp$130.EventScript.Create(this, b, a);
        d.push(a)
    }
    _InitTrigger(a, b) {
        a.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(a);
        var d = a.GetConditionAt(b)
          , c = d._GetFunc()
          , e = d.GetObjectClass();
        if (d.IsFastTrigger()) {
            var g = this._fastTriggers.get(e);
            g || (g = new Map,
            this._fastTriggers.set(e, g));
            d = d.GetFastTriggerValue().toLowerCase();
            e = g.get(c);
            e || (e = new Map,
            g.set(c, e));
            c = e.get(d);
            c || (c = [],
            e.set(d, c));
            c.push([a, b])
        } else
            g = this._triggers.get(e),
            g || (g = {
                methodMap: new Map,
                behaviors: new Map
            },
            this._triggers.set(e, g)),
            (e = d.GetBehaviorType()) ? (d = g.behaviors.get(e),
            d || (d = new Map,
            g.behaviors.set(e, d))) : d = g.methodMap,
            g = d.get(c),
            g || (g = [],
            d.set(c, g)),
            g.push([a, b])
    }
    _PostInit() {
        const a = this._events;
        for (let b = 0, d = a.length; b < d; ++b) {
            const c = b < d - 1 && a[b + 1]instanceof C3$jscomp$130.EventBlock && a[b + 1].IsElseBlock();
            a[b]._PostInit(c)
        }
    }
    _AddShallowInclude(a) {
        this._shallowIncludes.push(a)
    }
    _UpdateDeepIncludes() {
        C3$jscomp$130.clearArray(this._deepIncludes);
        this._AddDeepIncludes(this);
        this._alreadyIncludedSheets.clear()
    }
    _AddDeepIncludes(a) {
        const b = a._deepIncludes
          , d = a._alreadyIncludedSheets;
        for (const c of this._shallowIncludes) {
            const e = c.GetIncludeSheet();
            c.IsActive() && a !== e && !d.has(e) && (d.add(e),
            e._AddDeepIncludes(a),
            b.push(e))
        }
    }
    deepIncludes() {
        return this._deepIncludes
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetName() {
        return this._name
    }
    _RegisterEventByDisplayNumber(a, b) {
        this._eventsByDisplayNumber.set(b, a)
    }
    _GetEventByDisplayNumber(a) {
        return this._eventsByDisplayNumber.get(a) || null
    }
    _ResetHasRunFlag() {
        this._hasRun = !1
    }
    Run() {
        if (!this._hasRun) {
            var a = this._runtime
              , b = a.IsCPUProfiling()
              , d = b ? performance.now() : 0;
            this._hasRun = !0;
            var c = this.GetEventSheetManager()
              , e = c.GetCurrentEventStackFrame();
            for (const g of this._events)
                g.Run(e),
                c.ClearSol(g.GetSolModifiers()),
                c.ClearAsyncActionPromises(),
                a.FlushPendingInstances();
            e.Reset(null);
            b && (this._perfRecord.totalTimeCounter += performance.now() - d)
        }
    }
    *DebugRun() {
        if (!this._hasRun) {
            this._hasRun = !0;
            var a = this._runtime
              , b = this.GetEventSheetManager()
              , d = b.GetCurrentEventStackFrame();
            for (const c of this._events)
                yield*c.DebugRun(d),
                b.ClearSol(c.GetSolModifiers()),
                b.ClearAsyncActionPromises(),
                a.FlushPendingInstances();
            d.Reset(null)
        }
    }
    _Trigger(a, b, d) {
        if (b) {
            const c = b.GetObjectClass();
            this._TriggerForClass(a, b, c, d);
            for (const e of c.GetFamilies())
                this._TriggerForClass(a, b, e, d)
        } else
            return this._TriggerForClass(a, b, null, null)
    }
    _TriggerForClass(a, b, d, c) {
        d = this._triggers.get(d);
        if (!d)
            return !1;
        c = c ? d.behaviors.get(c) : d.methodMap;
        if (!c)
            return !1;
        c = c.get(a);
        if (!c)
            return !1;
        a = !1;
        for (const [e,g] of c)
            c = this._ExecuteTrigger(b, e, g),
            a = a || c;
        return a
    }
    *_DebugTrigger(a, b, d) {
        if (b) {
            const c = b.GetObjectClass();
            yield*this._DebugTriggerForClass(a, b, c, d);
            for (const e of c.GetFamilies())
                yield*this._DebugTriggerForClass(a, b, e, d)
        } else
            return yield*this._DebugTriggerForClass(a, b, null, null)
    }
    *_DebugTriggerForClass(a, b, d, c) {
        d = this._triggers.get(d);
        if (!d)
            return !1;
        c = c ? d.behaviors.get(c) : d.methodMap;
        if (!c)
            return !1;
        c = c.get(a);
        if (!c)
            return !1;
        a = !1;
        for (const [e,g] of c)
            c = e.DebugCanRunFast() ? this._ExecuteTrigger(b, e, g) : yield*this._DebugExecuteTrigger(b, e, g),
            a = a || c;
        return a
    }
    _FastTrigger(a, b, d) {
        b = b.GetObjectClass();
        b = this._fastTriggers.get(b);
        if (!b)
            return !1;
        a = b.get(a);
        if (!a)
            return !1;
        d = a.get(d);
        if (!d)
            return !1;
        a = !1;
        for (let c = 0, e = d.length; c < e; ++c)
            b = d[c],
            b = this._ExecuteTrigger(null, b[0], b[1]),
            a = a || b;
        return a
    }
    *_DebugFastTrigger(a, b, d) {
        b = b.GetObjectClass();
        b = this._fastTriggers.get(b);
        if (!b)
            return !1;
        a = b.get(a);
        if (!a)
            return !1;
        d = a.get(d);
        if (!d)
            return !1;
        a = !1;
        for (let e = 0, g = d.length; e < g; ++e) {
            var c = d[e];
            b = c[0];
            c = c[1];
            b = b.DebugCanRunFast() ? this._ExecuteTrigger(null, b, c) : yield*this._DebugExecuteTrigger(null, b, c);
            a = a || b
        }
        return a
    }
    _ExecuteTrigger(a, b, d) {
        const c = this._runtime
          , e = this._eventSheetManager
          , g = e.GetCurrentEvent()
          , k = e.GetEventStack()
          , l = e.GetTriggerDepth();
        let n = !1;
        g && e.PushCleanSol(g.GetSolModifiersIncludingParents());
        e.PushCleanSol(b.GetSolModifiersIncludingParents());
        const p = 1 < l;
        p && e.GetLocalVarStack().Push();
        const t = k.Push(b);
        a && (b.GetConditions()[d].GetObjectClass().GetCurrentSol().SetSinglePicked(a),
        a.IsInContainer() && a.SetSiblingsSinglePicked());
        a = !0;
        if (b.GetParent()) {
            const w = b.GetTriggerParents();
            for (let z = 0, B = w.length; z < B; ++z)
                if (!w[z].RunPreTrigger(t)) {
                    a = !1;
                    break
                }
        }
        a && (b.IsOrBlock() ? b.RunOrBlockTrigger(t, d) : b.Run(t),
        n = t.GetLastEventTrue());
        k.Pop();
        p && e.GetLocalVarStack().Pop();
        e.PopSol(b.GetSolModifiersIncludingParents());
        g && e.PopSol(g.GetSolModifiersIncludingParents());
        g || 1 !== l || (e.ClearAsyncActionPromises(),
        e.IsFlushingBlocked() || c.FlushPendingInstances());
        return n
    }
    *_DebugExecuteTrigger(a, b, d) {
        const c = this._runtime
          , e = this._eventSheetManager
          , g = e.GetCurrentEvent()
          , k = e.GetEventStack()
          , l = e.GetTriggerDepth();
        let n = !1;
        g && e.PushCleanSol(g.GetSolModifiersIncludingParents());
        e.PushCleanSol(b.GetSolModifiersIncludingParents());
        const p = 1 < l;
        p && e.GetLocalVarStack().Push();
        const t = k.Push(b);
        a && (b.GetConditions()[d].GetObjectClass().GetCurrentSol().SetSinglePicked(a),
        a.IsInContainer() && a.SetSiblingsSinglePicked());
        a = !0;
        if (b.GetParent()) {
            const w = b.GetTriggerParents();
            for (let z = 0, B = w.length; z < B; ++z)
                if (!(yield*w[z].DebugRunPreTrigger(t))) {
                    a = !1;
                    break
                }
        }
        a && (b.IsOrBlock() ? yield*b.DebugRunOrBlockTrigger(t, d) : yield*b.DebugRun(t),
        n = t.GetLastEventTrue());
        k.Pop();
        p && e.GetLocalVarStack().Pop();
        e.PopSol(b.GetSolModifiersIncludingParents());
        g && e.PopSol(g.GetSolModifiersIncludingParents());
        g || 1 !== l || (e.ClearAsyncActionPromises(),
        e.IsFlushingBlocked() || c.FlushPendingInstances());
        return n
    }
    _GetPerfRecord() {
        return this._perfRecord
    }
}
;
"use strict";
const C3$jscomp$131 = self.C3
  , EMPTY_ARRAY = [];
function NoActions(a, b) {
    return !0
}
function *DebugNoActions(a, b) {
    return !0
}
C3$jscomp$131.EventBlock = class extends C3$jscomp$131.DefendedBase {
    constructor(a, b, d) {
        super();
        this._eventSheet = a;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._scopeParent = null;
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._solModifiers = [];
        this._solModifiersIncludingParents = [];
        this._hasElseBlock = this._isTopLevelGroup = this._isSolWriterAfterCnds = this._hasGotSolModifiersIncludingParents = !1;
        this._isOrBlock = !!d[2];
        this._isElseBlock = !1;
        this._triggerParents = null;
        this._conditions = [];
        this._actions = [];
        this._subEvents = [];
        this._RunActions = NoActions;
        this._DebugRunActions = DebugNoActions;
        this._isInitiallyActive = this._isGroup = !1;
        this._groupName = "";
        this._isGroupActive = !1;
        this._perfRecord = this._containedIncludes = null;
        this._sid = d[4];
        this._displayNumber = d[5];
        this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
        this._debugData = this._runtime.IsDebug() ? {
            isBreakpoint: d[3][0],
            isBreakable: d[3][1],
            canRunAllConditionsFast: !1,
            canRunAllActionsFast: !1,
            canRunAllSubEventsFast: !1,
            canRunSelfFast: !1
        } : null;
        this.GetEventSheetManager()._RegisterEventBlock(this);
        3 === d[0] && this._InitGroup(d[1]);
        a = 0;
        for (var c of d[6])
            b = C3$jscomp$131.Condition.Create(this, c, a++),
            this._conditions.push(b),
            this._AddSolModifier(b.GetObjectClass());
        a = 0;
        for (const e of d[7])
            c = C3$jscomp$131.Action.Create(this, e, a++),
            this._actions.push(c);
        if (9 === d.length) {
            d = d[8];
            for (const e of d)
                this._eventSheet._CreateEvent(e, this, this._subEvents)
        }
        this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() && this._conditions[0]._GetFunc() === C3$jscomp$131.Plugins.System.Cnds.Else);
        0 === this._conditions.length && (this._conditions = EMPTY_ARRAY);
        0 === this._actions.length && (this._actions = EMPTY_ARRAY);
        0 === this._subEvents.length && (this._subEvents = EMPTY_ARRAY)
    }
    static Create(a, b, d) {
        return C3$jscomp$131.New(C3$jscomp$131.EventBlock, a, b, d)
    }
    _InitGroup(a) {
        this._isGroup = !0;
        this._isGroupActive = this._isInitiallyActive = !!a[0];
        this._groupName = a[1].toLowerCase();
        this._containedIncludes = [];
        this.GetEventSheetManager()._RegisterGroup(this);
        this._runtime.IsDebug() && (this._perfRecord = {
            type: "group",
            name: a[1],
            totalTimeCounter: 0,
            children: []
        })
    }
    _AddContainedInclude(a) {
        this._containedIncludes.push(a)
    }
    _AddContainerSolModifierToList(a, b) {
        for (const d of a.GetContainer().objectTypes())
            b.includes(d) || b.push(d)
    }
    _AddSolModifierToList(a, b) {
        if (a)
            if (b.includes(a) || b.push(a),
            a.IsFamily())
                for (const d of a.GetFamilyMembers())
                    d.IsInContainer() && this._AddContainerSolModifierToList(d, b);
            else
                a.IsInContainer() && this._AddContainerSolModifierToList(a, b)
    }
    _AddSolModifier(a) {
        this._AddSolModifierToList(a, this._solModifiers)
    }
    _AddParentSolModifier(a) {
        this._AddSolModifierToList(a, this._solModifiersIncludingParents)
    }
    SetAllSolModifiers() {
        this._solModifiers = this._runtime.GetAllObjectClasses()
    }
    _PostInit(a) {
        this._hasElseBlock = !!a;
        this._IdentifyTopLevelGroup();
        this._IdentifyTriggerParents();
        for (const d of this._conditions)
            d._PostInit();
        if (0 < this._actions.length) {
            a = !1;
            for (var b of this._actions)
                b._PostInit(),
                b.HasReturnType() && (a = !0);
            a ? (this._RunActions = this._RunActions_ReturnValue,
            this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast,
            this._DebugRunActions = this._DebugRunActions_Fast)
        }
        b = this._subEvents;
        for (let d = 0, c = b.length; d < c; ++d)
            a = d < c - 1 && b[d + 1]instanceof C3$jscomp$131.EventBlock && b[d + 1].IsElseBlock(),
            b[d]._PostInit(a);
        this._debugData && this._UpdateCanRunFast();
        this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord)
    }
    _GetPerfRecord() {
        return this._perfRecord
    }
    _GetPerfRecordParent() {
        let a = this.GetParent();
        for (; a; ) {
            if (a.IsGroup())
                return a;
            a = a.GetParent()
        }
        return this._eventSheet
    }
    _UpdateCanRunFast() {
        const a = this._debugData;
        a.canRunAllConditionsFast = this._conditions.every(b=>b.DebugCanRunFast());
        a.canRunAllActionsFast = this._actions.every(b=>b.DebugCanRunFast());
        a.canRunAllSubEventsFast = this._subEvents.every(b=>b.DebugCanRunFast());
        a.canRunSelfFast = a.canRunAllConditionsFast && a.canRunAllActionsFast && a.canRunAllSubEventsFast
    }
    _UpdateCanRunFastRecursive() {
        let a = this;
        do
            a._UpdateCanRunFast(),
            a = a.GetParent();
        while (a)
    }
    _IdentifyTopLevelGroup() {
        if (this.IsGroup()) {
            var a = this.GetParent();
            for (this._isTopLevelGroup = !0; a; ) {
                if (!a.IsGroup()) {
                    this._isTopLevelGroup = !1;
                    break
                }
                a = a.GetParent()
            }
        }
    }
    _IdentifySolModifiersIncludingParents() {
        var a = this._runtime.GetAllObjectClasses();
        if (this._solModifiers === a)
            this._solModifiersIncludingParents = a;
        else {
            this._solModifiersIncludingParents = C3$jscomp$131.cloneArray(this._solModifiers);
            for (a = this.GetParent(); a; ) {
                for (var b of a._solModifiers)
                    this._AddParentSolModifier(b);
                a = a.GetParent()
            }
            b = this.GetEventSheetManager();
            this._solModifiers = b._DeduplicateSolModifierList(this._solModifiers);
            this._solModifiersIncludingParents = b._DeduplicateSolModifierList(this._solModifiersIncludingParents)
        }
    }
    _IdentifyTriggerParents() {
        if (this.HasAnyTriggeredCondition()) {
            this._triggerParents = [];
            for (var a = this.GetParent(); a; )
                this._triggerParents.push(a),
                a = a.GetParent();
            this._triggerParents.reverse()
        }
    }
    SetSolWriterAfterCnds() {
        this._isSolWriterAfterCnds = !0;
        this._parent && this._parent.SetSolWriterAfterCnds()
    }
    IsSolWriterAfterCnds() {
        return this._isSolWriterAfterCnds
    }
    GetSolModifiers() {
        return this._solModifiers
    }
    GetSolModifiersIncludingParents() {
        this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = !0,
        this._IdentifySolModifiersIncludingParents());
        return this._solModifiersIncludingParents
    }
    HasSolModifier(a) {
        return this._solModifiers.includes(a)
    }
    GetTriggerParents() {
        return this._triggerParents
    }
    GetEventSheet() {
        return this._eventSheet
    }
    GetEventSheetManager() {
        return this._eventSheet.GetEventSheetManager()
    }
    GetRuntime() {
        return this._runtime
    }
    GetParent() {
        return this._parent
    }
    _SetScopeParent(a) {
        this._scopeParent = a
    }
    GetScopeParent() {
        return this._scopeParent || this._parent
    }
    GetDisplayNumber() {
        return this._displayNumber
    }
    IsDebugBreakable() {
        return this._debugData && this._debugData.isBreakable
    }
    IsDebugBreakpoint() {
        return this.IsDebugBreakable() && this._debugData.isBreakpoint
    }
    _SetDebugBreakpoint(a) {
        this._debugData.isBreakpoint = !!a;
        this._UpdateCanRunFastRecursive()
    }
    IsGroup() {
        return this._isGroup
    }
    IsTopLevelGroup() {
        return this._isTopLevelGroup
    }
    IsElseBlock() {
        return this._isElseBlock
    }
    HasElseBlock() {
        return this._hasElseBlock
    }
    GetGroupName() {
        return this._groupName
    }
    IsGroupActive() {
        return this._isGroupActive
    }
    ResetInitialActivation() {
        this.SetGroupActive(this._isInitiallyActive)
    }
    SetGroupActive(a) {
        a = !!a;
        if (!this._isGroup)
            throw Error("not a group");
        if (this._isGroupActive !== a) {
            this._isGroupActive = a;
            for (const b of this._containedIncludes)
                b.UpdateActive();
            this._containedIncludes.length && (a = this._runtime.GetCurrentLayout().GetEventSheet()) && a._UpdateDeepIncludes()
        }
    }
    GetSID() {
        return this._sid
    }
    IsOrBlock() {
        return this._isOrBlock
    }
    IsTrigger() {
        return this._conditions.length && this._conditions[0].IsTrigger()
    }
    IsForFunctionBlock() {
        return this._scopeParent && this._scopeParent instanceof C3$jscomp$131.FunctionBlock
    }
    HasAnyTriggeredCondition() {
        return this.IsForFunctionBlock() || this._conditions.some(a=>a.IsTrigger())
    }
    GetConditions() {
        return this._conditions
    }
    GetConditionCount() {
        return this._conditions.length
    }
    GetConditionAt(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._conditions.length)
            throw new RangeError("invalid condition index");
        return this._conditions[a]
    }
    GetConditionByDebugIndex(a) {
        return this.GetConditionAt(a)
    }
    IsFirstConditionOfType(a) {
        let b = a.GetIndex();
        if (0 === b)
            return !0;
        for (--b; 0 <= b; --b)
            if (this._conditions[b].GetObjectClass() === a.GetObjectClass())
                return !1;
        return !0
    }
    GetActions() {
        return this._actions
    }
    GetActionCount() {
        return this._actions.length
    }
    GetActionAt(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._actions.length)
            throw new RangeError("invalid action index");
        return this._actions[a]
    }
    GetActionByDebugIndex(a) {
        a = Math.floor(a);
        const b = this._actions.find(d=>d.GetDebugIndex() === a);
        if (!b)
            throw new RangeError("invalid action debug index");
        return b
    }
    _HasActionIndex(a) {
        a = Math.floor(a);
        return 0 <= a && a < this._actions.length
    }
    GetSubEvents() {
        return this._subEvents
    }
    _GetAllLocalVariablesInScope() {
        return this._subEvents.filter(a=>a instanceof C3$jscomp$131.EventVariable)
    }
    RunPreTrigger(a) {
        a.SetCurrentEvent(this);
        const b = this._conditions;
        let d = 0 === b.length;
        for (let c = 0, e = b.length; c < e; ++c) {
            const g = b[c];
            a.SetConditionIndex(c);
            if (g.IsLooping())
                throw Error("trigger cannot be used as sub-event to a loop");
            if (g.Run())
                d = !0;
            else if (!this._isOrBlock)
                return !1
        }
        return this._isOrBlock ? d : !0
    }
    RunOrBlockTrigger(a, b) {
        a.SetCurrentEvent(this);
        this._conditions[b].Run() && (this._RunActions(a, 0) && this._RunSubEvents(a),
        a.SetLastEventTrue(!0))
    }
    *DebugRunPreTrigger(a) {
        a.SetCurrentEvent(this);
        const b = this._conditions;
        let d = 0 === b.length;
        for (let c = 0, e = b.length; c < e; ++c) {
            const g = b[c];
            a.SetConditionIndex(c);
            if (g.IsLooping())
                throw Error("trigger cannot be used as sub-event to a loop");
            if (g.DebugCanRunFast() ? g.Run() : yield*g.DebugRun())
                d = !0;
            else if (!this._isOrBlock)
                return !1
        }
        return this._isOrBlock ? d : !0
    }
    *DebugRunOrBlockTrigger(a, b) {
        a.SetCurrentEvent(this);
        b = this._conditions[b];
        if (b.DebugCanRunFast() ? b.Run() : yield*b.DebugRun())
            (this.DebugCanRunActionsFast() ? this._RunActions(a, 0) : yield*this._DebugRunActions(a, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents()),
            a.SetLastEventTrue(!0)
    }
    Run(a) {
        a.SetCurrentEvent(this);
        this._isElseBlock || a.SetElseBranchRan(!1);
        this._isOrBlock ? this._RunOrBlock(a) : this._RunAndBlock(a)
    }
    *DebugRun(a) {
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        a.SetCurrentEvent(this);
        this._isElseBlock || a.SetElseBranchRan(!1);
        this._isOrBlock ? yield*this._DebugRunOrBlock(a) : yield*this._DebugRunAndBlock(a)
    }
    _RunOrBlock(a) {
        const b = this._conditions;
        let d = 0 === b.length;
        for (let e = 0, g = b.length; e < g; ++e) {
            var c = b[e];
            c.IsTrigger() || (a.SetConditionIndex(e),
            c = c.Run(),
            d = d || c)
        }
        a.SetLastEventTrue(d);
        d && (this._RunActions(a, 0) && this._RunSubEvents(a),
        this._hasElseBlock && a.SetElseBranchRan(!0))
    }
    *_DebugRunOrBlock(a) {
        const b = this._conditions;
        let d = 0 === b.length;
        for (let e = 0, g = b.length; e < g; ++e) {
            var c = b[e];
            c.IsTrigger() || (a.SetConditionIndex(e),
            c = c.DebugCanRunFast() ? c.Run() : yield*c.DebugRun(),
            d = d || c)
        }
        a.SetLastEventTrue(d);
        d && ((this.DebugCanRunActionsFast() ? this._RunActions(a, 0) : yield*this._DebugRunActions(a, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents()),
        this._hasElseBlock && a.SetElseBranchRan(!0))
    }
    _RunAndBlock(a) {
        const b = this._conditions;
        for (let d = 0, c = b.length; d < c; ++d) {
            const e = b[d];
            a.SetConditionIndex(d);
            if (!e.Run()) {
                a.SetLastEventTrue(!1);
                return
            }
        }
        a.SetLastEventTrue(!0);
        this._RunActions(a, 0) && this._RunSubEvents(a);
        a.GetLastEventTrue() && this._hasElseBlock && a.SetElseBranchRan(!0)
    }
    *_DebugRunAndBlock(a) {
        const b = this._conditions;
        for (let d = 0, c = b.length; d < c; ++d) {
            const e = b[d];
            a.SetConditionIndex(d);
            if (e.DebugCanRunFast() ? !e.Run() : !(yield*e.DebugRun())) {
                a.SetLastEventTrue(!1);
                return
            }
        }
        a.SetLastEventTrue(!0);
        (this.DebugCanRunActionsFast() ? this._RunActions(a, 0) : yield*this._DebugRunActions(a, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents());
        a.GetLastEventTrue() && this._hasElseBlock && a.SetElseBranchRan(!0)
    }
    _RunActions_Fast(a, b) {
        const d = this._actions;
        for (let c = b, e = d.length; c < e; ++c)
            b = d[c],
            a.SetActionIndex(c),
            b.Run();
        return !0
    }
    *_DebugRunActions_Fast(a, b) {
        const d = this._actions;
        for (let c = b, e = d.length; c < e; ++c)
            b = d[c],
            a.SetActionIndex(c),
            b.DebugCanRunFast() ? b.Run() : yield*b.DebugRun();
        return !0
    }
    _RunActions_ReturnValue(a, b) {
        const d = this.GetEventSheetManager()
          , c = this._actions;
        for (let e = b, g = c.length; e < g; ++e) {
            b = c[e];
            a.SetActionIndex(e);
            const k = b.Run();
            if (b.CanBailOut() && !0 === k)
                return !1;
            b.IsAsync() && k instanceof Promise && d.AddAsyncActionPromise(k)
        }
        return !0
    }
    *_DebugRunActions_ReturnValue(a, b) {
        const d = this.GetEventSheetManager()
          , c = this._actions;
        for (let e = b, g = c.length; e < g; ++e) {
            b = c[e];
            a.SetActionIndex(e);
            let k;
            k = b.DebugCanRunFast() ? b.Run() : yield*b.DebugRun();
            if (b.CanBailOut() && !0 === k)
                return !1;
            b.IsAsync() && k instanceof Promise && d.AddAsyncActionPromise(k)
        }
        return !0
    }
    _ResumeActionsAndSubEvents(a) {
        this._RunActions(a, a.GetActionIndex()) && this._RunSubEvents()
    }
    *_DebugResumeActionsAndSubEvents(a) {
        if (yield*this._DebugRunActions(a, a.GetActionIndex()))
            yield*this._DebugRunSubEvents()
    }
    _RunSubEvents() {
        if (this._subEvents.length) {
            var a = this.IsGroup() && this._runtime.IsCPUProfiling()
              , b = a ? performance.now() : 0
              , d = this._eventStack
              , c = d.Push(this);
            this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(c) : this._RunSubEvents_Fast(c);
            d.Pop();
            a && (this._perfRecord.totalTimeCounter += performance.now() - b)
        }
    }
    _RunSubEvents_SolWriterAfterCnds(a) {
        const b = this._isGroup
          , d = this._isTopLevelGroup
          , c = this.GetEventSheetManager()
          , e = this._subEvents;
        for (let g = 0, k = e.length, l = k - 1; g < k; ++g) {
            const n = e[g]
              , p = n.GetSolModifiers()
              , t = !d || !b && g < l;
            t && c.PushCopySol(p);
            n.Run(a);
            t ? c.PopSol(p) : c.ClearSol(p)
        }
    }
    _RunSubEvents_Fast(a) {
        const b = this._subEvents;
        for (let d = 0, c = b.length; d < c; ++d)
            b[d].Run(a)
    }
    *_DebugRunSubEvents() {
        if (this._subEvents.length) {
            var a = this._eventStack
              , b = a.Push(this);
            this._isSolWriterAfterCnds ? yield*this._DebugRunSubEvents_SolWriterAfterCnds(b) : yield*this._DebugRunSubEvents_Fast(b);
            a.Pop()
        }
    }
    *_DebugRunSubEvents_SolWriterAfterCnds(a) {
        const b = this._isGroup
          , d = this._isTopLevelGroup
          , c = this.GetEventSheetManager()
          , e = this._subEvents;
        for (let g = 0, k = e.length, l = k - 1; g < k; ++g) {
            const n = e[g]
              , p = n.GetSolModifiers()
              , t = !d || !b && g < l;
            t && c.PushCopySol(p);
            yield*n.DebugRun(a);
            t ? c.PopSol(p) : c.ClearSol(p)
        }
    }
    *_DebugRunSubEvents_Fast(a) {
        const b = this._subEvents;
        for (let d = 0, c = b.length; d < c; ++d)
            yield*b[d].DebugRun(a)
    }
    Retrigger(a, b) {
        b.ResetQuick();
        const d = this._conditions;
        if (!this.IsOrBlock())
            for (let c = a.GetConditionIndex() + 1, e = d.length; c < e; ++c)
                if (a = d[c],
                b.SetConditionIndex(c),
                !a.Run())
                    return !1;
        this._RunActions(b, 0) && this._RunSubEvents(b);
        return !0
    }
    *DebugRetrigger(a, b) {
        b.ResetQuick();
        const d = this._conditions;
        if (!this.IsOrBlock())
            for (let c = a.GetConditionIndex() + 1, e = d.length; c < e; ++c)
                if (a = d[c],
                b.SetConditionIndex(c),
                a.DebugCanRunFast() ? !a.Run() : !(yield*a.DebugRun()))
                    return !1;
        (this.DebugCanRunActionsFast() ? this._RunActions(b, 0) : yield*this._DebugRunActions(b, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents());
        return !0
    }
    DebugCanRunFast() {
        return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast
    }
    DebugCanRunActionsFast() {
        return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast
    }
    DebugCanRunSubEventsFast() {
        return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast
    }
    _CheckParentsOKToRun(a) {
        if (this.GetParent()) {
            const b = this.GetTriggerParents();
            for (let d = 0, c = b.length; d < c; ++d)
                if (!b[d].RunPreTrigger(a))
                    return !1
        }
        return !0
    }
    *_DebugCheckParentsOKToRun(a) {
        if (this.GetParent()) {
            const b = this.GetTriggerParents();
            for (let d = 0, c = b.length; d < c; ++d)
                if (!(yield*b[d].DebugRunPreTrigger(a)))
                    return !1
        }
        return !0
    }
    _EvaluateFunctionCallParameters(a, b, d) {
        0 < b.length ? d ? (b = b.map(c=>c.Get(0)),
        a.GetLocalVarStack().Push(),
        this._scopeParent.SetFunctionParameters(b)) : this._scopeParent.EvaluateFunctionParameters(b) : d && a.GetLocalVarStack().Push()
    }
    RunAsFunctionCall(a, b, d, c) {
        let e, g;
        const k = 0 < a.length;
        let l = null;
        const n = this._eventStack
          , p = this._runtime.GetEventSheetManager()
          , t = 1 < p._IncTriggerDepth();
        this._EvaluateFunctionCallParameters(p, b, t);
        k && (d ? p.PushCopySol(a) : p.PushCleanSol(a));
        if (null !== c) {
            if (c.copyFromObjectClass) {
                b = d ? c.copyFromObjectClass.GetCurrentSol() : c.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol();
                const w = c.copyToObjectClass.GetCurrentSol();
                w.SetArrayPicked(b.GetInstances());
                w.ClearElseInstances();
                d || c.copyToObjectClass.ApplySolToContainer()
            } else
                c.pickObjectClass && (b = c.pickObjectClass.GetCurrentSol(),
                b.SetArrayPicked(c.pickInstances),
                b.ClearElseInstances());
            c.pushCleanSolDynamic && (l = p.PushCleanSolDynamic(a))
        }
        c = n.Push(this);
        d && c.SetDynamicSolModifiers(a);
        this._CheckParentsOKToRun(c) && (c.SetCurrentEvent(this),
        (d = this._scopeParent.IsAsync()) && ([g,e] = this._scopeParent.StartAsyncFunctionCall()),
        this._RunAndBlock(c),
        d && this._scopeParent.MaybeFinishAsyncFunctionCall(g));
        n.Pop();
        t && p.GetLocalVarStack().Pop();
        null !== l && p.PopSol(l);
        k && p.PopSol(a);
        p._DecTriggerDepth();
        return e
    }
    *DebugRunAsFunctionCall(a, b, d, c) {
        let e, g;
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        const k = 0 < a.length;
        let l = null;
        const n = this._eventStack
          , p = this._runtime.GetEventSheetManager()
          , t = 1 < p._IncTriggerDepth();
        this._EvaluateFunctionCallParameters(p, b, t);
        k && (d ? p.PushCopySol(a) : p.PushCleanSol(a));
        if (null !== c) {
            if (c.copyFromObjectClass) {
                b = d ? c.copyFromObjectClass.GetCurrentSol() : c.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol();
                const w = c.copyToObjectClass.GetCurrentSol();
                w.SetArrayPicked(b.GetInstances());
                w.ClearElseInstances();
                d || c.copyToObjectClass.ApplySolToContainer()
            } else
                c.pickObjectClass && (b = c.pickObjectClass.GetCurrentSol(),
                b.SetArrayPicked(c.pickInstances),
                b.ClearElseInstances());
            c.pushCleanSolDynamic && (l = p.PushCleanSolDynamic(a))
        }
        c = n.Push(this);
        d && c.SetDynamicSolModifiers(a);
        if (yield*this._DebugCheckParentsOKToRun(c))
            c.SetCurrentEvent(this),
            (d = this._scopeParent.IsAsync()) && ([g,e] = this._scopeParent.StartAsyncFunctionCall()),
            yield*this._DebugRunAndBlock(c),
            d && this._scopeParent.MaybeFinishAsyncFunctionCall(g);
        n.Pop();
        t && p.GetLocalVarStack().Pop();
        null !== l && p.PopSol(l);
        k && p.PopSol(a);
        p._DecTriggerDepth();
        return e
    }
    RunAsMappedFunctionCall(a, b) {
        const d = this.GetSolModifiersIncludingParents()
          , c = 0 < d.length
          , e = this._eventStack
          , g = this._runtime.GetEventSheetManager()
          , k = 1 < g._IncTriggerDepth();
        k && g.GetLocalVarStack().Push();
        this._scopeParent.SetFunctionParameters(a);
        c && (b ? g.PushCopySol(d) : g.PushCleanSol(d));
        a = e.Push(this);
        this._CheckParentsOKToRun(a) && (a.SetCurrentEvent(this),
        this._RunAndBlock(a));
        e.Pop();
        k && g.GetLocalVarStack().Pop();
        c && g.PopSol(d);
        g._DecTriggerDepth()
    }
    *DebugRunAsMappedFunctionCall(a, b) {
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        const d = this.GetSolModifiersIncludingParents()
          , c = 0 < d.length
          , e = this._eventStack
          , g = this._runtime.GetEventSheetManager()
          , k = 1 < g._IncTriggerDepth();
        k && g.GetLocalVarStack().Push();
        this._scopeParent.SetFunctionParameters(a);
        c && (b ? g.PushCopySol(d) : g.PushCleanSol(d));
        a = e.Push(this);
        if (yield*this._DebugCheckParentsOKToRun(a))
            a.SetCurrentEvent(this),
            yield*this._DebugRunAndBlock(a);
        e.Pop();
        k && g.GetLocalVarStack().Pop();
        c && g.PopSol(d);
        g._DecTriggerDepth()
    }
    RunAsExpressionFunctionCall(a, b, d, c, ...e) {
        let g, k;
        const l = 0 < a.length
          , n = this._runtime
          , p = this._eventStack
          , t = n.GetEventSheetManager()
          , w = 1 < t._IncTriggerDepth();
        w && t.GetLocalVarStack().Push();
        0 < e.length && this._scopeParent.SetFunctionParameters(e);
        l && (b ? t.PushCopySol(a) : t.PushCleanSol(a));
        b = p.Push(this);
        b.InitCallFunctionExpression(d, c);
        p.PushExpFunc(b);
        n.SetDebuggingEnabled(!1);
        this._CheckParentsOKToRun(b) && (b.SetCurrentEvent(this),
        (d = this._scopeParent.IsAsync()) && ([k,g] = this._scopeParent.StartAsyncFunctionCall()),
        this._RunAndBlock(b),
        d && this._scopeParent.MaybeFinishAsyncFunctionCall(k));
        n.SetDebuggingEnabled(!0);
        p.Pop();
        p.PopExpFunc();
        w && t.GetLocalVarStack().Pop();
        l && t.PopSol(a);
        t._DecTriggerDepth();
        return g || b.GetFunctionReturnValue()
    }
}
;
"use strict";
const C3$jscomp$132 = self.C3
  , EMPTY_SOL_MODIFIERS = [];
let hadUserScriptException = !1;
C3$jscomp$132.EventScript = class extends C3$jscomp$132.DefendedBase {
    constructor(a, b, d) {
        super();
        const c = a.GetRuntime()
          , e = a.GetEventSheetManager();
        this._eventSheet = a;
        this._eventSheetManager = e;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._func = c.GetObjectReference(d[1]);
        this._displayNumber = d[2];
        this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
        this._debugData = c.IsDebug() ? {
            isBreakpoint: d[3][0],
            isBreakable: d[3][1]
        } : null
    }
    static Create(a, b, d) {
        return C3$jscomp$132.New(C3$jscomp$132.EventScript, a, b, d)
    }
    _PostInit() {
        const a = this._func
          , b = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
        this._func = a.bind(null, this._runtime.GetIRuntime(), b)
    }
    GetParent() {
        return this._parent
    }
    GetScopeParent() {
        return this._parent
    }
    GetEventSheet() {
        return this._eventSheet
    }
    GetDisplayNumber() {
        return this._displayNumber
    }
    IsDebugBreakable() {
        return this._debugData && this._debugData.isBreakable
    }
    IsDebugBreakpoint() {
        return this.IsDebugBreakable() && this._debugData.isBreakpoint
    }
    _SetDebugBreakpoint(a) {
        this._debugData.isBreakpoint = !!a
    }
    IsElseBlock() {
        return !1
    }
    GetSolModifiers() {
        return EMPTY_SOL_MODIFIERS
    }
    GetSolModifiersIncludingParents() {
        return this._parent ? this._parent.GetSolModifiersIncludingParents() : EMPTY_SOL_MODIFIERS
    }
    Run(a) {
        a.SetCurrentEvent(this);
        this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript())
    }
    async _RunUserScript() {
        try {
            await this._func()
        } catch (a) {
            console.error(`Unhandled exception running script %c ${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", a),
            self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
            hadUserScriptException || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"),
            hadUserScriptException = !0)
        }
    }
    *DebugRun(a) {
        a.SetCurrentEvent(this);
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        this.Run(a)
    }
    DebugCanRunFast() {
        return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext()
    }
    static HadUserScriptException() {
        return hadUserScriptException
    }
    static SetHadUserScriptException() {
        hadUserScriptException = !0
    }
}
;
"use strict";
const C3$jscomp$133 = self.C3;
C3$jscomp$133.FunctionBlock = class extends C3$jscomp$133.DefendedBase {
    constructor(a, b, d) {
        super();
        this._eventSheet = a;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._functionType = 0;
        this._functionName = "";
        this._returnType = 0;
        this._functionParameters = [];
        this._isEnabled = !0;
        this._aceName = "";
        this._objectClass = null;
        this._hasOverrides = !1;
        this._innerLocalVariables = [];
        this._isAsync = this._isCopyPicked = !1;
        this._nextAsyncId = 0;
        this._currentAsyncId = -1;
        this._asyncMap = new Map;
        this._eventBlock = C3$jscomp$133.EventBlock.Create(a, b, d);
        this._eventBlock._SetScopeParent(this)
    }
    InitFunctionBlock(a) {
        this._functionType = 0;
        this._functionName = a[0];
        this._returnType = a[1];
        this._functionParameters = a[2].map(b=>C3$jscomp$133.EventVariable.Create(this._eventSheet, this, b));
        this._isEnabled = a[3];
        this._isAsync = a[4];
        this._isCopyPicked = a[5]
    }
    InitCustomACEBlock(a) {
        this._functionType = 1;
        this._aceName = a[1];
        this._objectClass = this._runtime.GetObjectClassByIndex(a[2]);
        this._eventBlock._AddSolModifier(this._objectClass);
        this._functionName = this._objectClass.GetName() + "." + this._aceName;
        this._returnType = a[3];
        this._functionParameters = a[4].map(b=>C3$jscomp$133.EventVariable.Create(this._eventSheet, this, b));
        this._isEnabled = a[5];
        this._isAsync = a[6];
        this._isCopyPicked = a[7];
        this._objectClass.AddCustomAction(this)
    }
    static CreateFunctionBlock(a, b, d) {
        a = C3$jscomp$133.New(C3$jscomp$133.FunctionBlock, a, b, d);
        a.InitFunctionBlock(d[1]);
        return a
    }
    static CreateCustomACEBlock(a, b, d) {
        a = C3$jscomp$133.New(C3$jscomp$133.FunctionBlock, a, b, d);
        a.InitCustomACEBlock(d[1]);
        return a
    }
    _CheckOverrideState() {
        if (this._objectClass && this._objectClass.IsFamily())
            for (const a of this._objectClass.GetFamilyMembers())
                if (a.HasOwnCustomActionByName(this._aceName)) {
                    this._hasOverrides = !0;
                    break
                }
    }
    _PostInit() {
        for (const a of this._functionParameters)
            a._PostInit();
        this._eventBlock._PostInit(!1)
    }
    GetFunctionType() {
        return this._functionType
    }
    _GetAllLocalVariablesInScope() {
        return this._functionParameters
    }
    GetFunctionParameters() {
        return this._functionParameters
    }
    GetFunctionParameterCount() {
        return this._functionParameters.length
    }
    _RegisterLocalVariable(a) {
        this._innerLocalVariables.push(a)
    }
    _GetAllInnerLocalVariables() {
        return this._innerLocalVariables
    }
    EvaluateFunctionParameters(a) {
        const b = this._functionParameters;
        for (let d = 0, c = b.length; d < c; ++d)
            b[d].SetValue(a[d].Get(0))
    }
    SetFunctionParameters(a) {
        const b = this._functionParameters;
        for (let d = 0, c = b.length; d < c; ++d)
            b[d].SetValue(a[d])
    }
    CaptureFunctionParameters() {
        return this._functionParameters.map(a=>a.GetValue())
    }
    GetParent() {
        return this._parent
    }
    GetScopeParent() {
        return this._parent
    }
    GetFunctionName() {
        return this._functionName
    }
    GetACEName() {
        return this._aceName
    }
    HasCustomACEOverrides() {
        return this._hasOverrides
    }
    GetReturnType() {
        return this._returnType
    }
    GetObjectClass() {
        return this._objectClass
    }
    IsEnabled() {
        return this._isEnabled
    }
    GetDefaultReturnValue() {
        switch (this._returnType) {
        case 0:
            return null;
        case 2:
            return "";
        default:
            return 0
        }
    }
    GetEventBlock() {
        return this._eventBlock
    }
    IsCopyPicked() {
        return this._isCopyPicked
    }
    IsAsync() {
        return this._isAsync
    }
    StartAsyncFunctionCall() {
        const a = this._nextAsyncId++;
        this._currentAsyncId = a;
        let b;
        const d = new Promise(c=>b = c);
        this._asyncMap.set(a, {
            resolve: b,
            pauseCount: 0
        });
        return [a, d]
    }
    MaybeFinishAsyncFunctionCall(a) {
        const b = this._asyncMap.get(a);
        0 === b.pauseCount && (b.resolve(),
        this._asyncMap.delete(a));
        this._currentAsyncId = -1
    }
    PauseCurrentAsyncFunction() {
        this._asyncMap.get(this._currentAsyncId).pauseCount++;
        return this._currentAsyncId
    }
    ResumeAsyncFunction(a) {
        this._currentAsyncId = a;
        this._asyncMap.get(a).pauseCount--
    }
    RunAsFamilyCustomActionWithOverrides(a, b) {
        var d = new Map
          , c = [];
        for (const e of this._objectClass.GetCurrentSol().GetInstances()) {
            const g = e.GetObjectClass();
            if (g.HasOwnCustomActionByName(this._aceName)) {
                const k = d.get(g);
                Array.isArray(k) ? k.push(e) : d.set(g, [e])
            } else
                c.push(e)
        }
        0 < c.length && this._eventBlock.RunAsFunctionCall(a, b, this._isCopyPicked, {
            pickObjectClass: this._objectClass,
            pickInstances: c
        });
        if (0 < d.size)
            for (const [e,g] of d)
                d = e.GetOwnCustomActionByName(this._aceName).GetEventBlock(),
                c = [...(new Set([...a, ...d.GetSolModifiers()]))],
                d.RunAsFunctionCall(c, b, this._isCopyPicked, {
                    pickObjectClass: e,
                    pickInstances: g
                })
    }
    *DebugRunAsFamilyCustomActionWithOverrides(a, b) {
        var d = new Map
          , c = [];
        for (const e of this._objectClass.GetCurrentSol().GetInstances()) {
            const g = e.GetObjectClass();
            if (g.HasOwnCustomActionByName(this._aceName)) {
                const k = d.get(g);
                Array.isArray(k) ? k.push(e) : d.set(g, [e])
            } else
                c.push(e)
        }
        0 < c.length && (yield*this._eventBlock.DebugRunAsFunctionCall(a, b, this._isCopyPicked, {
            pickObjectClass: this._objectClass,
            pickInstances: c
        }));
        if (0 < d.size)
            for (const [e,g] of d)
                d = e.GetOwnCustomActionByName(this._aceName).GetEventBlock(),
                c = [...(new Set([...a, ...d.GetSolModifiers()]))],
                yield*d.DebugRunAsFunctionCall(c, b, this._isCopyPicked, {
                    pickObjectClass: e,
                    pickInstances: g
                })
    }
}
;
"use strict";
const C3$jscomp$134 = self.C3
  , EMPTY_SOL_MODIFIERS$jscomp$1 = [];
C3$jscomp$134.EventVariable = class extends C3$jscomp$134.DefendedBase {
    constructor(a, b, d) {
        super();
        const c = a.GetEventSheetManager();
        this._eventSheet = a;
        this._eventSheetManager = c;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._localVarStack = c.GetLocalVarStack();
        this._name = d[1];
        this._type = d[2];
        this._initialValue = d[3];
        this._isStatic = !!d[4];
        this._isConstant = !!d[5];
        this._isFunctionParameter = b instanceof C3$jscomp$134.FunctionBlock;
        this._sid = d[6];
        this._jsPropName = this._runtime.GetJsPropName(d[8]);
        this._scriptSetter = e=>this.SetValue(e);
        this._scriptGetter = ()=>this.GetValue();
        this._hasSingleValue = !this._parent || this._isStatic || this._isConstant;
        this._value = this._initialValue;
        this._localIndex = -1;
        this.IsBoolean() && (this._value = this._value ? 1 : 0);
        !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = c._GetNextLocalVarIndex(this));
        c._RegisterEventVariable(this)
    }
    static Create(a, b, d) {
        return C3$jscomp$134.New(C3$jscomp$134.EventVariable, a, b, d)
    }
    _PostInit() {
        if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {
            const a = this._eventSheetManager.FindFirstFunctionBlockParent(this);
            a && a._RegisterLocalVariable(this)
        }
    }
    GetName() {
        return this._name
    }
    GetJsPropName() {
        return this._jsPropName
    }
    GetParent() {
        return this._parent
    }
    GetScopeParent() {
        return this.GetParent()
    }
    IsGlobal() {
        return !this.GetParent()
    }
    IsLocal() {
        return !this.IsGlobal()
    }
    IsFunctionParameter() {
        return this._isFunctionParameter
    }
    IsStatic() {
        return this._isStatic
    }
    IsConstant() {
        return this._isConstant
    }
    IsNumber() {
        return 0 === this._type
    }
    IsString() {
        return 1 === this._type
    }
    IsBoolean() {
        return 2 === this._type
    }
    IsElseBlock() {
        return !1
    }
    GetSID() {
        return this._sid
    }
    GetInitialValue() {
        return this._initialValue
    }
    GetSolModifiers() {
        return EMPTY_SOL_MODIFIERS$jscomp$1
    }
    Run(a) {
        !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue())
    }
    DebugCanRunFast() {
        return !0
    }
    *DebugRun(a) {
        this.Run(a)
    }
    SetValue(a) {
        this.IsNumber() ? "number" !== typeof a && (a = parseFloat(a)) : this.IsString() ? "string" !== typeof a && (a = a.toString()) : this.IsBoolean() && (a = a ? 1 : 0);
        this._hasSingleValue ? this._value = a : this._localVarStack.GetCurrent()[this._localIndex] = a
    }
    GetValue() {
        return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex]
    }
    GetTypedValue() {
        let a = this.GetValue();
        this.IsBoolean() && (a = !!a);
        return a
    }
    ResetToInitialValue() {
        this._value = this._initialValue
    }
    _GetScriptInterfaceDescriptor() {
        return {
            configurable: !1,
            enumerable: !0,
            get: this._scriptGetter,
            set: this._scriptSetter
        }
    }
}
;
"use strict";
const C3$jscomp$135 = self.C3
  , EMPTY_SOL_MODIFIERS$jscomp$2 = [];
C3$jscomp$135.EventInclude = class extends C3$jscomp$135.DefendedBase {
    constructor(a, b, d) {
        super();
        const c = a.GetEventSheetManager();
        this._eventSheet = a;
        this._eventSheetManager = c;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._includeSheet = null;
        this._includeSheetName = d[1];
        this._isActive = !0
    }
    static Create(a, b, d) {
        return C3$jscomp$135.New(C3$jscomp$135.EventInclude, a, b, d)
    }
    _PostInit() {
        this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName);
        this._eventSheet._AddShallowInclude(this);
        let a = this.GetParent();
        for (; a; )
            a instanceof C3$jscomp$135.EventBlock && a.IsGroup() && a._AddContainedInclude(this),
            a = a.GetParent();
        this.UpdateActive();
        this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord())
    }
    GetParent() {
        return this._parent
    }
    GetSolModifiers() {
        return EMPTY_SOL_MODIFIERS$jscomp$2
    }
    GetIncludeSheet() {
        return this._includeSheet
    }
    Run(a) {
        a = !!this.GetParent();
        const b = this._runtime.GetAllObjectClasses();
        a && this._eventSheetManager.PushCleanSol(b);
        this._includeSheet.Run();
        a && this._eventSheetManager.PopSol(b)
    }
    *DebugRun(a) {
        a = !!this.GetParent();
        const b = this._runtime.GetAllObjectClasses();
        a && this._eventSheetManager.PushCleanSol(b);
        yield*this._includeSheet.DebugRun();
        a && this._eventSheetManager.PopSol(b)
    }
    DebugCanRunFast() {
        return !1
    }
    IsActive() {
        return this._isActive
    }
    UpdateActive() {
        let a = this.GetParent();
        for (; a; ) {
            if (a instanceof C3$jscomp$135.EventBlock && a.IsGroup() && !a.IsGroupActive()) {
                this._isActive = !1;
                return
            }
            a = a.GetParent()
        }
        this._isActive = !0
    }
}
;
"use strict";
const C3$jscomp$136 = self.C3;
C3$jscomp$136.ExpNode = class extends C3$jscomp$136.DefendedBase {
    constructor(a) {
        super();
        this._owner = a;
        this._runtime = a.GetRuntime()
    }
    _PostInit() {}
    static CreateNode(a, b) {
        return C3$jscomp$136.New([BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode][b[0]], a, b)
    }
}
;
class SystemExpressionExpNode extends C3$jscomp$136.ExpNode {
    constructor(a, b) {
        super(a);
        this._systemPlugin = this._runtime.GetSystemPlugin();
        this._func = this._runtime.GetObjectReference(b[1]);
        this._func !== C3$jscomp$136.Plugins.System.Exps.random && this._func !== C3$jscomp$136.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance()
    }
    GetBoundMethod() {
        return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin)
    }
}
class CallFunctionExpressionExpNode extends C3$jscomp$136.ExpNode {
    constructor(a, b) {
        super(a);
        this._functionBlock = null;
        this._functionName = b[1];
        this._owner.SetVariesPerInstance()
    }
    _PostInit() {
        const a = this._runtime.GetEventSheetManager();
        this._functionBlock = a.GetFunctionBlockByName(this._functionName);
        this._functionName = null;
        const b = this._owner.GetEventBlock()
          , d = this._functionBlock.GetEventBlock();
        this._combinedSolModifiers = [...(new Set([...b.GetSolModifiersIncludingParents(), ...d.GetSolModifiersIncludingParents()]))];
        this._combinedSolModifiers = a._DeduplicateSolModifierList(this._combinedSolModifiers)
    }
    GetBoundMethod() {
        const a = this._functionBlock;
        if (a.IsEnabled()) {
            const d = a.GetEventBlock();
            return C3$jscomp$136.EventBlock.prototype.RunAsExpressionFunctionCall.bind(d, this._combinedSolModifiers, a.IsCopyPicked(), a.GetReturnType(), a.GetDefaultReturnValue())
        }
        const b = a.GetDefaultReturnValue();
        return ()=>b
    }
}
function WrapIndex(a, b) {
    if (a >= b)
        return a % b;
    0 > a && (a <= -b && (a %= b),
    0 > a && (a += b));
    return a
}
class ObjectExpressionNode extends C3$jscomp$136.ExpNode {
    constructor(a, b) {
        super(a);
        this._objectClass = this._runtime.GetObjectClassByIndex(b[1]);
        this._func = this._runtime.GetObjectReference(b[2]);
        this._returnsString = !!b[3];
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._owner._MaybeVaryFor(this._objectClass)
    }
    GetBoundMethod() {
        return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance())
    }
    ExpObject(...a) {
        const b = this._objectClass
          , d = b.GetCurrentSol().GetExpressionInstances();
        var c = d.length;
        if (0 === c)
            return this._returnsString ? "" : 0;
        c = WrapIndex(this._owner.GetSolIndex(), c);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(b);
        return this._func.apply(d[c].GetSdkInstance(), a)
    }
    ExpObject_InstExpr(a, ...b) {
        const d = this._objectClass
          , c = d.GetInstances()
          , e = c.length;
        if (0 === e)
            return this._returnsString ? "" : 0;
        a = WrapIndex(a, e);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(d);
        return this._func.apply(c[a].GetSdkInstance(), b)
    }
}
class InstVarExpressionNode extends C3$jscomp$136.ExpNode {
    constructor(a, b) {
        super(a);
        this._objectClass = this._runtime.GetObjectClassByIndex(b[1]);
        this._varIndex = b[3];
        this._returnsString = !!b[2];
        this._owner._MaybeVaryFor(this._objectClass)
    }
    ExpInstVar() {
        const a = this._objectClass.GetCurrentSol().GetExpressionInstances();
        var b = a.length;
        if (0 === b)
            return this._returnsString ? "" : 0;
        b = WrapIndex(this._owner.GetSolIndex(), b);
        return a[b]._GetInstanceVariableValueUnchecked(this._varIndex)
    }
    ExpInstVar_Family() {
        var a = this._objectClass
          , b = a.GetCurrentSol().GetExpressionInstances()
          , d = b.length;
        if (0 === d)
            return this._returnsString ? "" : 0;
        d = WrapIndex(this._owner.GetSolIndex(), d);
        b = b[d];
        a = b.GetObjectClass().GetFamilyInstanceVariableOffset(a.GetFamilyIndex());
        return b._GetInstanceVariableValueUnchecked(this._varIndex + a)
    }
    ExpInstVar_InstExpr(a) {
        const b = this._objectClass;
        var d = b.GetInstances();
        const c = d.length;
        if (0 === c)
            return this._returnsString ? "" : 0;
        a = WrapIndex(a, c);
        d = d[a];
        a = 0;
        b.IsFamily() && (a = d.GetObjectClass().GetFamilyInstanceVariableOffset(b.GetFamilyIndex()));
        return d._GetInstanceVariableValueUnchecked(this._varIndex + a)
    }
}
class BehaviorExpressionNode extends C3$jscomp$136.ExpNode {
    constructor(a, b) {
        super(a);
        this._objectClass = this._runtime.GetObjectClassByIndex(b[1]);
        this._behaviorType = this._objectClass.GetBehaviorTypeByName(b[2]);
        this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(b[2]);
        this._func = this._runtime.GetObjectReference(b[3]);
        this._returnsString = !!b[4];
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._owner._MaybeVaryFor(this._objectClass)
    }
    ExpBehavior(...a) {
        const b = this._objectClass;
        var d = b.GetCurrentSol().GetExpressionInstances()
          , c = d.length;
        if (0 === c)
            return this._returnsString ? "" : 0;
        c = WrapIndex(this._owner.GetSolIndex(), c);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(b);
        d = d[c];
        c = 0;
        b.IsFamily() && (c = d.GetObjectClass().GetFamilyBehaviorOffset(b.GetFamilyIndex()));
        return this._func.apply(d.GetBehaviorInstances()[this._behaviorIndex + c].GetSdkInstance(), a)
    }
    ExpBehavior_InstExpr(a, ...b) {
        const d = this._objectClass;
        var c = d.GetInstances();
        const e = c.length;
        if (0 === e)
            return this._returnsString ? "" : 0;
        a = WrapIndex(a, e);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(d);
        c = c[a];
        a = 0;
        d.IsFamily() && (a = c.GetObjectClass().GetFamilyBehaviorOffset(d.GetFamilyIndex()));
        return this._func.apply(c.GetBehaviorInstances()[this._behaviorIndex + a].GetSdkInstance(), b)
    }
}
class EventVarExpNode extends C3$jscomp$136.ExpNode {
    constructor(a, b) {
        super(a);
        this._eventVar = null;
        this._eventVarSid = b[1]
    }
    _PostInit() {
        this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
    }
    GetVar() {
        return this._eventVar
    }
}
"use strict";
const C3$jscomp$137 = self.C3;
C3$jscomp$137.Parameter = class extends C3$jscomp$137.DefendedBase {
    constructor(a, b, d) {
        super();
        this._owner = a;
        this._index = d;
        this._type = b;
        this.Get = null;
        this._isConstant = this._variesPerInstance = !1
    }
    static Create(a, b, d) {
        const c = b[0];
        return C3$jscomp$137.New([ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter, TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter][c], a, c, d, b)
    }
    _PostInit() {}
    SetVariesPerInstance() {
        this._variesPerInstance = !0
    }
    _MaybeVaryFor(a) {
        this._variesPerInstance || !a || a.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = !0)
    }
    VariesPerInstance() {
        return this._variesPerInstance
    }
    GetIndex() {
        return this._index
    }
    GetRuntime() {
        return this._owner.GetRuntime()
    }
    GetEventBlock() {
        return this._owner.GetEventBlock()
    }
    IsConstant() {
        return this._isConstant
    }
}
;
function GetExpressionFunc(a) {
    a = self.C3_ExpressionFuncs[a];
    if (!a)
        throw Error("invalid expression number");
    return a
}
class ExpressionParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._solIndex = 0;
        a = c[1];
        this._expressionNumber = a[0];
        this._numberedNodes = [];
        this._expressionFunc = null;
        for (let e = 1, g = a.length; e < g; ++e)
            this._numberedNodes.push(C3$jscomp$137.ExpNode.CreateNode(this, a[e]));
        this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = GetExpressionFunc(this._expressionNumber),
        this._isConstant = !0)
    }
    _GetNode(a) {
        if (0 > a || a >= this._numberedNodes.length)
            throw new RangeError("invalid numbered node");
        return this._numberedNodes[a]
    }
    _PostInit() {
        for (var a of this._numberedNodes)
            a._PostInit();
        a = GetExpressionFunc(this._expressionNumber);
        this._expressionFunc = this._numberedNodes.length ? a(this) : a
    }
    GetSolIndex() {
        return this._solIndex
    }
    GetExpression(a) {
        this._solIndex = a;
        return this._expressionFunc()
    }
}
class StringExpressionParameter extends ExpressionParameter {
    constructor(a, b, d, c) {
        super(a, b, d, c);
        this.Get = this.GetStringExpression;
        14 === b && (this.GetEventBlock().SetAllSolModifiers(),
        this._owner instanceof C3$jscomp$137.Action && this.GetEventBlock().SetSolWriterAfterCnds())
    }
    GetStringExpression(a) {
        this._solIndex = a;
        a = this._expressionFunc();
        return "string" === typeof a ? a : ""
    }
    _GetFastTriggerValue() {
        return GetExpressionFunc(this._expressionNumber)()
    }
}
class LayerExpressionParameter extends ExpressionParameter {
    constructor(a, b, d, c) {
        super(a, b, d, c);
        this.Get = this.GetLayer;
        this._isConstant = !1
    }
    GetLayer(a) {
        this._solIndex = a;
        a = this._expressionFunc();
        return this.GetRuntime().GetCurrentLayout().GetLayer(a)
    }
}
class ComboParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._combo = c[1];
        this.Get = this.GetCombo;
        this._isConstant = !0
    }
    GetCombo() {
        return this._combo
    }
}
class BooleanParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._bool = c[1];
        this.Get = this.GetBoolean;
        this._isConstant = !0
    }
    GetBoolean() {
        return this._bool
    }
}
class ObjectParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._objectClass = this.GetRuntime().GetObjectClassByIndex(c[1]);
        this.Get = this.GetObjectClass;
        a = this.GetEventBlock();
        a._AddSolModifier(this._objectClass);
        this._owner instanceof C3$jscomp$137.Action ? a.SetSolWriterAfterCnds() : a.GetParent() && a.GetParent().SetSolWriterAfterCnds();
        this._isConstant = !0
    }
    GetObjectClass() {
        return this._objectClass
    }
}
class LayoutParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(c[1]);
        this.Get = this.GetLayout;
        this._isConstant = !0
    }
    GetLayout() {
        return this._layout
    }
}
class TimelineParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(c[1]);
        this.Get = this.GetTimeline;
        this._isConstant = !0
    }
    GetTimeline() {
        return this._timeline
    }
}
class FileParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._fileInfo = c[1];
        this.Get = this.GetFile;
        this._isConstant = !0
    }
    GetFile() {
        return this._fileInfo
    }
}
class InstVarParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._instVarIndex = c[1];
        a = this._owner.GetObjectClass();
        this._owner instanceof C3$jscomp$137.Condition && this._owner.IsStatic() ? (this.Get = this.GetInstanceVariable,
        this._isConstant = !0) : a && a.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable,
        this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable,
        this._isConstant = !0)
    }
    GetInstanceVariable() {
        return this._instVarIndex
    }
    GetFamilyInstanceVariable(a) {
        a = a || 0;
        const b = this._owner.GetObjectClass();
        var d = b.GetCurrentSol();
        const c = d.GetInstances();
        if (c.length)
            a = c[a % c.length].GetObjectClass();
        else if (d.HasAnyElseInstances())
            d = d.GetElseInstances(),
            a = d[a % d.length].GetObjectClass();
        else if (0 < b.GetInstanceCount())
            d = b.GetInstances(),
            a = d[a % d.length].GetObjectClass();
        else
            return 0;
        return this._instVarIndex + a.GetFamilyInstanceVariableOffset(b.GetFamilyIndex())
    }
}
class EventVarParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._eventVarSid = c[1];
        this._eventVar = null;
        this.Get = this.GetEventVariable;
        this._isConstant = !0
    }
    _PostInit() {
        this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
    }
    GetEventVariable() {
        return this._eventVar
    }
}
class FunctionParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._functionBlockName = c[1];
        this._functionBlock = null;
        this.Get = this.GetFunction;
        this._isConstant = !0
    }
    _PostInit() {
        this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName);
        this._functionBlockName = null
    }
    GetFunction() {
        return this._functionBlock
    }
}
class VariadicParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._subParams = [];
        this._variadicRet = [];
        this._isConstant = !0;
        for (let e = 1, g = c.length; e < g; ++e)
            a = C3$jscomp$137.Parameter.Create(this._owner, c[e], 0),
            this._subParams.push(a),
            this._variadicRet.push(0),
            a.IsConstant() || (this._isConstant = !1);
        this.Get = this.GetVariadic
    }
    _PostInit() {
        for (const a of this._subParams)
            a._PostInit()
    }
    GetVariadic() {
        const a = this._subParams
          , b = this._variadicRet;
        for (let d = 0, c = a.length; d < c; ++d)
            b[d] = a[d].Get(0);
        return b
    }
}
class EaseParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._easeIndex = c[1];
        this.Get = this.GetEase;
        this._isConstant = !0
    }
    GetEase() {
        return this._easeIndex
    }
}
class TilemapBrushParameter extends C3$jscomp$137.Parameter {
    constructor(a, b, d, c) {
        super(a, b, d);
        this._brushIndex = c[1];
        this.Get = this.GetTilemapBrush;
        this._isConstant = !0
    }
    GetTilemapBrush() {
        return this._brushIndex
    }
}
class TemplateExpressionParameter extends ExpressionParameter {
    constructor(a, b, d, c) {
        super(a, b, d, c);
        this.Get = this.GetTemplateName;
        this._isConstant = !1
    }
    GetTemplateName() {
        return this._expressionFunc()
    }
}
"use strict";
const C3$jscomp$138 = self.C3;
function EvalParams(a, b) {
    for (let d = 0, c = a.length; d < c; ++d)
        b[d] = a[d].Get(0)
}
const EMPTY_PARAMS_ARRAY = []
  , noop$jscomp$1 = function() {};
C3$jscomp$138.Condition = class extends C3$jscomp$138.DefendedBase {
    constructor(a, b, d) {
        super();
        this._eventBlock = a;
        this._runtime = a.GetRuntime();
        this._index = d;
        this._func = this._runtime.GetObjectReference(b[1]);
        this._isTrigger = 0 < b[3];
        this._isFastTrigger = 2 === b[3];
        this._isLooping = !!b[4];
        this._isInverted = !!b[5];
        this._isStatic = !!b[6];
        this._sid = b[7];
        this._isInOrBlock = this._eventBlock.IsOrBlock();
        this._behaviorType = this._objectClass = null;
        this._behaviorIndex = -1;
        this._systemPlugin = null;
        this.DebugRun = this.Run = noop$jscomp$1;
        this._parameters = [];
        this._results = [];
        this._anyParamVariesPerInstance = !1;
        this._unsavedData = this._savedData = null;
        this._debugData = this._runtime.IsDebug() ? {
            isBreakpoint: b[8][0],
            canDebug: b[8][1]
        } : null;
        -1 === b[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(b[0]),
        b[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(b[2]),
        this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(b[2])),
        this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds());
        if (10 === b.length) {
            a = b[9];
            for (let c of a)
                this._parameters.push(C3$jscomp$138.Parameter.Create(this, c, this._parameters.length)),
                this._results.push(0)
        }
        0 === this._parameters.length && (this._results = this._parameters = EMPTY_PARAMS_ARRAY);
        this._eventBlock.GetEventSheetManager()._RegisterCondition(this)
    }
    static Create(a, b, d) {
        return C3$jscomp$138.New(C3$jscomp$138.Condition, a, b, d)
    }
    _PostInit() {
        for (const a of this._parameters)
            a._PostInit(),
            a.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
        this._isFastTrigger ? (this.Run = this._RunFastTrigger,
        this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(),
        this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(),
        this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic,
        this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject,
        this.DebugRun = this._DebugRunObject)
    }
    _SetSystemRunMethod() {
        this._SetRunMethodForBoundFunc(this._systemPlugin, this._systemPlugin, this._RunSystem)
    }
    _SetSingleGlobalRunMethod() {
        const a = this._objectClass.GetPlugin()
          , b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        this._SetRunMethodForBoundFunc(a, b, this._RunSingleGlobal)
    }
    _SetRunMethodForBoundFunc(a, b, d) {
        const c = this._func
          , e = this._isInverted
          , g = this._parameters;
        if (0 === g.length) {
            const k = a._GetBoundACEMethod(c, b);
            this.Run = e ? function() {
                return C3$jscomp$138.xor(k(), e)
            }
            : k
        } else if (1 === g.length) {
            const k = g[0];
            if (!e && k.IsConstant())
                this.Run = a._GetBoundACEMethod_1param(c, b, k.Get(0));
            else {
                const l = a._GetBoundACEMethod(c, b);
                this.Run = function() {
                    return C3$jscomp$138.xor(l(k.Get(0)), e)
                }
            }
        } else if (2 === g.length) {
            const k = g[0]
              , l = g[1];
            if (!e && k.IsConstant() && l.IsConstant())
                this.Run = a._GetBoundACEMethod_2params(c, b, k.Get(0), l.Get(0));
            else {
                const n = a._GetBoundACEMethod(c, b);
                this.Run = function() {
                    return C3$jscomp$138.xor(n(k.Get(0), l.Get(0)), e)
                }
            }
        } else if (3 === g.length) {
            const k = g[0]
              , l = g[1]
              , n = g[2];
            if (!e && k.IsConstant() && l.IsConstant() && n.IsConstant())
                this.Run = a._GetBoundACEMethod_3params(c, b, k.Get(0), l.Get(0), n.Get(0));
            else {
                const p = a._GetBoundACEMethod(c, b);
                this.Run = function() {
                    return C3$jscomp$138.xor(p(k.Get(0), l.Get(0), n.Get(0)), e)
                }
            }
        } else
            this.Run = d
    }
    GetSID() {
        return this._sid
    }
    _GetFunc() {
        return this._func
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetBehaviorType() {
        return this._behaviorType
    }
    GetEventBlock() {
        return this._eventBlock
    }
    GetRuntime() {
        return this._runtime
    }
    GetIndex() {
        return this._index
    }
    GetDebugIndex() {
        return this.GetIndex()
    }
    IsTrigger() {
        return this._isTrigger
    }
    IsFastTrigger() {
        return this._isFastTrigger
    }
    IsInverted() {
        return this._isInverted
    }
    IsLooping() {
        return this._isLooping
    }
    IsStatic() {
        return this._isStatic
    }
    IsBreakpoint() {
        return this._debugData.isBreakpoint
    }
    _SetBreakpoint(a) {
        this._debugData.isBreakpoint = !!a;
        this._eventBlock._UpdateCanRunFastRecursive()
    }
    _DebugReturnsGenerator() {
        return this._debugData.canDebug
    }
    DebugCanRunFast() {
        return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
    }
    GetSavedDataMap() {
        this._savedData || (this._savedData = new Map);
        return this._savedData
    }
    GetUnsavedDataMap() {
        this._unsavedData || (this._unsavedData = new Map);
        return this._unsavedData
    }
    _RunSystem() {
        const a = this._results;
        EvalParams(this._parameters, a);
        return C3$jscomp$138.xor(this._func.apply(this._systemPlugin, a), this._isInverted)
    }
    *_DebugRunSystem() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams(this._parameters, a);
            a = this._func.apply(this._systemPlugin, a);
            C3$jscomp$138.IsIterator(a) && (a = yield*a);
            return C3$jscomp$138.xor(a, this._isInverted)
        }
        return this.Run()
    }
    _RunSingleGlobal() {
        const a = this._results;
        EvalParams(this._parameters, a);
        const b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        return C3$jscomp$138.xor(this._func.apply(b, a), this._isInverted)
    }
    *_DebugRunSingleGlobal() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams(this._parameters, a);
            const b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            a = this._func.apply(b, a);
            C3$jscomp$138.IsIterator(a) && (a = yield*a);
            return C3$jscomp$138.xor(a, this._isInverted)
        }
        return this.Run()
    }
    _RunFastTrigger() {
        return !0
    }
    *_DebugRunFastTrigger() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        return !0
    }
    _RunStatic() {
        var a = this._results;
        EvalParams(this._parameters, a);
        a = this._func.apply(this._behaviorType || this._objectClass, a);
        this._objectClass.ApplySolToContainer();
        return a
    }
    *_DebugRunStatic() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams(this._parameters, a);
            a = this._func.apply(this._behaviorType || this._objectClass, a);
            C3$jscomp$138.IsIterator(a) && (a = yield*a);
            this._objectClass.ApplySolToContainer();
            return a
        }
        return this.Run()
    }
    _RunObject() {
        const a = this._parameters
          , b = this._results
          , d = this._objectClass.GetCurrentSol();
        for (let c = 0, e = a.length; c < e; ++c) {
            const g = a[c];
            g.VariesPerInstance() || (b[c] = g.Get(0))
        }
        return d.IsSelectAll() ? this._RunObject_FirstFilter(d) : this._RunObject_NextFilter(d)
    }
    *_DebugRunObject() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        return this._RunObject()
    }
    _EvaluateVaryingParameters(a) {
        const b = this._parameters
          , d = this._results;
        for (let c = 0, e = b.length; c < e; ++c) {
            const g = b[c];
            g.VariesPerInstance() && (d[c] = g.Get(a))
        }
    }
    _RunObject_FirstFilter(a) {
        const b = this._objectClass
          , d = b.IsFamily()
          , c = b.GetFamilyIndex()
          , e = this._behaviorIndex
          , g = 0 <= e
          , k = b.GetInstances()
          , l = this._anyParamVariesPerInstance
          , n = this._results
          , p = this._func
          , t = this._isInverted
          , w = this._isInOrBlock && !this._isTrigger;
        a.ClearArrays();
        for (let B = 0, C = k.length; B < C; ++B) {
            const E = k[B];
            l && this._EvaluateVaryingParameters(B);
            var z = void 0;
            g ? (z = d ? E.GetObjectClass().GetFamilyBehaviorOffset(c) : 0,
            z = p.apply(E.GetBehaviorInstances()[e + z].GetSdkInstance(), n)) : z = p.apply(E.GetSdkInstance(), n);
            C3$jscomp$138.xor(z, t) ? a._PushInstance(E) : w && a._PushElseInstance(E)
        }
        b.FinishCondition(!0);
        a._SetSelectAll(!1);
        b.ApplySolToContainer();
        return a.HasAnyInstances()
    }
    _RunObject_NextFilter(a) {
        const b = this._objectClass;
        var d = b.IsFamily();
        const c = b.GetFamilyIndex()
          , e = b.IsInContainer()
          , g = this._behaviorIndex
          , k = 0 <= g
          , l = this._anyParamVariesPerInstance
          , n = this._results
          , p = this._func
          , t = this._isInverted
          , w = this._isInOrBlock && !this._isTrigger
          , z = a._GetOwnInstances()
          , B = a._GetOwnElseInstances()
          , C = w && !this._eventBlock.IsFirstConditionOfType(this)
          , E = C ? B : z;
        let F = 0
          , J = !1;
        for (let M = 0, U = E.length; M < U; ++M) {
            const X = E[M];
            l && this._EvaluateVaryingParameters(M);
            var K = void 0;
            k ? (K = d ? X.GetObjectClass().GetFamilyBehaviorOffset(c) : 0,
            K = p.apply(X.GetBehaviorInstances()[g + K].GetSdkInstance(), n)) : K = p.apply(X.GetSdkInstance(), n);
            C3$jscomp$138.xor(K, t) ? (J = !0,
            C ? (z.push(X),
            e && X._PushSiblingsToSolInstances()) : (E[F] = X,
            e && X._SetSiblingsToSolInstancesIndex(F),
            ++F)) : C ? (E[F] = X,
            e && X._SetSiblingsToSolElseInstancesIndex(F),
            ++F) : w && (B.push(X),
            e && X._PushSiblingsToSolElseInstances())
        }
        C3$jscomp$138.truncateArray(E, F);
        e && b._TruncateContainerSols(C, F);
        d = J;
        C && !J && (J = this._OrBlockCheckInstances(z));
        b.FinishCondition(d || w);
        return w ? J : a.HasAnyInstances()
    }
    _OrBlockCheckInstances(a) {
        var b = this._objectClass;
        const d = b.IsFamily();
        b = b.GetFamilyIndex();
        const c = this._anyParamVariesPerInstance
          , e = this._behaviorIndex
          , g = 0 <= e
          , k = this._results
          , l = this._func
          , n = this._isInverted;
        for (let t = 0, w = a.length; t < w; ++t) {
            var p = a[t];
            c && this._EvaluateVaryingParameters(t);
            if (g) {
                const z = d ? p.GetObjectClass().GetFamilyBehaviorOffset(b) : 0;
                p = l.apply(p.GetBehaviorInstances()[e + z].GetSdkInstance(), k)
            } else
                p = l.apply(p.GetSdkInstance(), k);
            if (C3$jscomp$138.xor(p, n))
                return !0
        }
        return !1
    }
    ReevaluateParameter(a, b) {
        return this._parameters[a].Get(b)
    }
    GetFastTriggerValue() {
        const a = this._parameters;
        if (!a.length)
            throw Error("no parameters");
        return a[0]._GetFastTriggerValue()
    }
    _SaveToJson() {
        if (!this._savedData || !this._savedData.size)
            return null;
        const a = {};
        for (const [b,d] of this._savedData.entries()) {
            let c = d;
            "collmemory" === b && (c = [...d.entries()].map(e=>[e[0].GetUID(), e[1].GetUID(), e[2]]));
            a[b] = c
        }
        return {
            ex: a
        }
    }
    _LoadFromJson(a) {
        this._savedData && (this._savedData.clear(),
        this._savedData = null);
        if (a) {
            var b = this._runtime
              , d = a.ex;
            if (d) {
                a = this.GetSavedDataMap();
                a.clear();
                for (const [c,e] of Object.entries(d))
                    d = e,
                    "collmemory" === c && (d = C3$jscomp$138.New(C3$jscomp$138.PairMap, e.map(g=>[b.GetInstanceByUID(g[0]), b.GetInstanceByUID(g[1]), g[2]]).filter(g=>g[0] && g[1]))),
                    a.set(c, d)
            }
        }
    }
}
;
"use strict";
const C3$jscomp$139 = self.C3;
function EvalParams$jscomp$1(a, b) {
    for (let d = 0, c = a.length; d < c; ++d)
        b[d] = a[d].Get(0)
}
const EMPTY_PARAMS_ARRAY$jscomp$1 = []
  , noop$jscomp$2 = function() {}
  , noopGenerator = function*() {};
C3$jscomp$139.Action = class extends C3$jscomp$139.DefendedBase {
    constructor(a, b, d) {
        super();
        this._eventBlock = a;
        this._runtime = a = a.GetRuntime();
        this._index = d;
        this._sid = 4 <= b.length ? b[3] : -1;
        this._actionType = 5 <= b.length ? b[4] & 255 : 0;
        this._flags = 5 <= b.length ? b[4] >> 8 : 0;
        this._behaviorType = this._objectClass = this._func = null;
        this._behaviorIndex = -1;
        this._systemPlugin = null;
        this._callFunctionName = "";
        this._callEventBlock = this._callCustomAceObjectClass = null;
        this.DebugRun = this.Run = noop$jscomp$2;
        this._parameters = [];
        this._results = [];
        this._anyParamVariesPerInstance = !1;
        this._unsavedData = this._savedData = null;
        const c = (d = -3 === b[0]) ? b[2] : b[5];
        this._debugData = a.IsDebug() || d ? {
            isBreakpoint: c[0],
            canDebug: c[1],
            index: c[2]
        } : null;
        -1 === b[0] ? (this._systemPlugin = a.GetSystemPlugin(),
        this._func = a.GetObjectReference(b[1])) : -2 === b[0] ? this._callFunctionName = b[1] : d ? (this._func = a.GetObjectReference(b[1]),
        this.Run = this.RunUserScript,
        this.DebugRun = this.DebugRunUserScript,
        this._actionType = 1) : (this._objectClass = a.GetObjectClassByIndex(b[0]),
        this._flags & 4 ? (this._callFunctionName = b[1],
        this._callCustomAceObjectClass = a.GetObjectClassByIndex(b[2])) : (b[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(b[2]),
        this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(b[2])),
        this._func = a.GetObjectReference(b[1])));
        if (7 === b.length) {
            b = b[6];
            for (const e of b)
                this._parameters.push(C3$jscomp$139.Parameter.Create(this, e, this._parameters.length)),
                this._results.push(0)
        }
        0 === this._parameters.length && (this._results = this._parameters = EMPTY_PARAMS_ARRAY$jscomp$1);
        this.CanPickAnyObjectClass() && (this._eventBlock.SetAllSolModifiers(),
        this._eventBlock.SetSolWriterAfterCnds());
        this._eventBlock.GetEventSheetManager()._RegisterAction(this)
    }
    static Create(a, b, d) {
        return C3$jscomp$139.New(C3$jscomp$139.Action, a, b, d)
    }
    _PostInit() {
        for (var a of this._parameters)
            a._PostInit(),
            a.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
        if (this._systemPlugin)
            this._SetSystemRunMethod(),
            this.DebugRun = this._DebugRunSystem;
        else if (this._callFunctionName)
            this._flags & 4 ? this._SetCallCustomActionRunMethod() : this._SetCallFunctionRunMethod(),
            this._callFunctionName = "",
            this._callCustomAceObjectClass = null;
        else if (this.Run === this.RunUserScript) {
            a = this._func;
            const b = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
            this._func = a.bind(null, this._runtime.GetIRuntime(), b)
        } else
            this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async,
            this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior,
            this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(),
            this.DebugRun = this._DebugRunSingleGlobal) : this.IsAsync() ? (this.Run = this._RunObject_Async,
            this.DebugRun = this._DebugRunObject_Async) : this.CallBeforeAfterHooks() ? (this.Run = this._RunObject_BeforeAfterHooks,
            this.DebugRun = this._DebugRunObject_BeforeAfterHooks) : this._parameters.length ? this._parameters.every(b=>b.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary,
            this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary,
            this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every(b=>b.IsConstant()) ? (EvalParams$jscomp$1(this._parameters, this._results),
            this.Run = this._RunObject_ParamsConst,
            this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary,
            this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst,
            this.DebugRun = this._DebugRunObject_ParamsConst)
    }
    _SetSystemRunMethod() {
        this._SetRunMethodForBoundFunc(this._systemPlugin, this._systemPlugin, this._RunSystem)
    }
    _SetSingleGlobalRunMethod() {
        const a = this._objectClass.GetPlugin()
          , b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        this._SetRunMethodForBoundFunc(a, b, this._RunSingleGlobal)
    }
    _SetCallFunctionRunMethod() {
        const a = this._eventBlock.GetEventSheetManager()
          , b = a.GetFunctionBlockByName(this._callFunctionName);
        if (b.IsEnabled()) {
            const d = 0 !== (this._flags & 2);
            this._callEventBlock = b.GetEventBlock();
            let c = [...(new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()]))];
            c = a._DeduplicateSolModifierList(c);
            const e = !b.IsCopyPicked() && this._HasCopyPickedParent() ? {
                pushCleanSolDynamic: !0
            } : null;
            this.Run = C3$jscomp$139.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, c, this._parameters, d, e);
            if (this._runtime.IsDebug()) {
                const g = this;
                this.DebugRun = function*() {
                    if (g.IsBreakpoint() || g._runtime.DebugBreakNext())
                        yield g;
                    return yield*g._callEventBlock.DebugRunAsFunctionCall(c, g._parameters, d, e)
                }
            } else
                this.DebugRun = noopGenerator
        } else
            this.Run = noop$jscomp$2,
            this.DebugRun = noopGenerator
    }
    _SetCallCustomActionRunMethod() {
        var a = this._eventBlock.GetEventSheetManager();
        const b = a.GetCustomActionBlockByName(this._callCustomAceObjectClass, this._callFunctionName);
        if (b.IsEnabled()) {
            const d = 0 !== (this._flags & 2);
            this._callEventBlock = b.GetEventBlock();
            let c = [...(new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents(), this._objectClass, b.GetObjectClass()]))];
            c = a._DeduplicateSolModifierList(c);
            a = !this._objectClass.IsFamily() && !b.GetObjectClass().IsFamily();
            const e = !this._objectClass.IsFamily() && b.GetObjectClass().IsFamily()
              , g = this._objectClass.IsFamily();
            let k = null;
            !b.IsCopyPicked() && this._HasCopyPickedParent() && (k = k || {},
            k.pushCleanSolDynamic = !0);
            if (e || !d)
                k = k || {},
                k.copyFromObjectClass = this._objectClass,
                k.copyToObjectClass = b.GetObjectClass();
            a || e || g && !b.HasCustomACEOverrides() ? this.Run = C3$jscomp$139.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, c, this._parameters, d, k) : g && (this.Run = C3$jscomp$139.FunctionBlock.prototype.RunAsFamilyCustomActionWithOverrides.bind(b, c, this._parameters));
            if (this._runtime.IsDebug()) {
                const l = this;
                a || e || g && !b.HasCustomACEOverrides() ? this.DebugRun = function*() {
                    if (l.IsBreakpoint() || l._runtime.DebugBreakNext())
                        yield l;
                    return yield*l._callEventBlock.DebugRunAsFunctionCall(c, l._parameters, d, k)
                }
                : g && (this.DebugRun = function*() {
                    if (l.IsBreakpoint() || l._runtime.DebugBreakNext())
                        yield l;
                    return yield*b.DebugRunAsFamilyCustomActionWithOverrides(c, l._parameters)
                }
                )
            } else
                this.DebugRun = noopGenerator
        } else
            this.Run = noop$jscomp$2,
            this.DebugRun = noopGenerator
    }
    _SetRunMethodForBoundFunc(a, b, d) {
        const c = this._func
          , e = this._parameters;
        if (0 === e.length)
            this.Run = a._GetBoundACEMethod(c, b);
        else if (1 === e.length) {
            const g = e[0];
            if (g.IsConstant())
                this.Run = a._GetBoundACEMethod_1param(c, b, g.Get(0));
            else {
                const k = a._GetBoundACEMethod(c, b);
                this.Run = function() {
                    return k(g.Get(0))
                }
            }
        } else if (2 === e.length) {
            const g = e[0]
              , k = e[1];
            if (g.IsConstant() && k.IsConstant())
                this.Run = a._GetBoundACEMethod_2params(c, b, g.Get(0), k.Get(0));
            else {
                const l = a._GetBoundACEMethod(c, b);
                this.Run = function() {
                    return l(g.Get(0), k.Get(0))
                }
            }
        } else if (3 === e.length) {
            const g = e[0]
              , k = e[1]
              , l = e[2];
            if (g.IsConstant() && k.IsConstant() && l.IsConstant())
                this.Run = a._GetBoundACEMethod_3params(c, b, g.Get(0), k.Get(0), l.Get(0));
            else {
                const n = a._GetBoundACEMethod(c, b);
                this.Run = function() {
                    return n(g.Get(0), k.Get(0), l.Get(0))
                }
            }
        } else
            this.Run = d
    }
    GetSID() {
        return this._sid
    }
    IsAsync() {
        return 1 === this._actionType
    }
    CanBailOut() {
        return 2 === this._actionType
    }
    CallBeforeAfterHooks() {
        return 3 === this._actionType
    }
    CanPickAnyObjectClass() {
        return 0 !== (this._flags & 1)
    }
    HasReturnType() {
        return this.IsAsync() || this.CanBailOut()
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetEventBlock() {
        return this._eventBlock
    }
    _HasCopyPickedParent() {
        let a = this._eventBlock;
        do {
            if (a instanceof C3$jscomp$139.FunctionBlock && a.IsCopyPicked())
                return !0;
            a = a.GetScopeParent()
        } while (a);
        return !1
    }
    GetRuntime() {
        return this._runtime
    }
    GetIndex() {
        return this._index
    }
    GetDebugIndex() {
        return this._debugData.index
    }
    IsBreakpoint() {
        return this._debugData.isBreakpoint
    }
    _SetBreakpoint(a) {
        this._debugData.isBreakpoint = !!a;
        this._eventBlock._UpdateCanRunFastRecursive()
    }
    _DebugReturnsGenerator() {
        return this._debugData.canDebug
    }
    DebugCanRunFast() {
        return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
    }
    GetSavedDataMap() {
        this._savedData || (this._savedData = new Map);
        return this._savedData
    }
    GetUnsavedDataMap() {
        this._unsavedData || (this._unsavedData = new Map);
        return this._unsavedData
    }
    _RunSystem() {
        const a = this._results;
        EvalParams$jscomp$1(this._parameters, a);
        return this._func.apply(this._systemPlugin, a)
    }
    *_DebugRunSystem() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results;
            EvalParams$jscomp$1(this._parameters, a);
            return yield*this._func.apply(this._systemPlugin, a)
        }
        return this.Run()
    }
    _RunSingleGlobal() {
        const a = this._results;
        EvalParams$jscomp$1(this._parameters, a);
        return this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), a)
    }
    *_DebugRunSingleGlobal() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results;
            EvalParams$jscomp$1(this._parameters, a);
            return yield*this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), a)
        }
        return this.Run()
    }
    _RunObject_ParamsConst() {
        const a = this._results
          , b = this._objectClass.GetCurrentSol().GetInstances();
        for (let d = 0, c = b.length; d < c; ++d)
            this._func.apply(b[d].GetSdkInstance(), a)
    }
    *_DebugRunObject_ParamsConst() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results
              , b = this._objectClass.GetCurrentSol().GetInstances();
            for (let d = 0, c = b.length; d < c; ++d)
                yield*this._func.apply(b[d].GetSdkInstance(), a)
        } else
            this._RunObject_ParamsConst()
    }
    _RunObject_ParamsDontVary() {
        const a = this._results;
        EvalParams$jscomp$1(this._parameters, a);
        const b = this._objectClass.GetCurrentSol().GetInstances();
        for (let d = 0, c = b.length; d < c; ++d)
            this._func.apply(b[d].GetSdkInstance(), a)
    }
    *_DebugRunObject_ParamsDontVary() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results;
            EvalParams$jscomp$1(this._parameters, a);
            const b = this._objectClass.GetCurrentSol().GetInstances();
            for (let d = 0, c = b.length; d < c; ++d)
                yield*this._func.apply(b[d].GetSdkInstance(), a)
        } else
            this._RunObject_ParamsDontVary()
    }
    _RunObject_AllParamsVary() {
        const a = this._parameters
          , b = this._results
          , d = this._func
          , c = this._objectClass.GetCurrentSol().GetInstances();
        for (let e = 0, g = c.length; e < g; ++e) {
            const k = c[e];
            for (let l = 0, n = a.length; l < n; ++l)
                b[l] = a[l].Get(e);
            d.apply(k.GetSdkInstance(), b)
        }
    }
    *_DebugRunObject_AllParamsVary() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._parameters
              , b = this._results
              , d = this._func
              , c = this._objectClass.GetCurrentSol().GetInstances();
            for (let e = 0, g = c.length; e < g; ++e) {
                const k = c[e];
                for (let l = 0, n = a.length; l < n; ++l)
                    b[l] = a[l].Get(e);
                yield*d.apply(k.GetSdkInstance(), b)
            }
        } else
            this._RunObject_AllParamsVary()
    }
    _RunObject_SomeParamsVary() {
        const a = this._parameters
          , b = this._results
          , d = this._func
          , c = this._objectClass.GetCurrentSol().GetInstances();
        for (let g = 0, k = a.length; g < k; ++g) {
            var e = a[g];
            e.VariesPerInstance() || (b[g] = e.Get(0))
        }
        for (let g = 0, k = c.length; g < k; ++g) {
            e = c[g];
            for (let l = 0, n = a.length; l < n; ++l) {
                const p = a[l];
                p.VariesPerInstance() && (b[l] = p.Get(g))
            }
            d.apply(e.GetSdkInstance(), b)
        }
    }
    *_DebugRunObject_SomeParamsVary() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const b = this._parameters
              , d = this._results
              , c = this._func
              , e = this._objectClass.GetCurrentSol().GetInstances();
            for (let g = 0, k = b.length; g < k; ++g) {
                var a = b[g];
                a.VariesPerInstance() || (d[g] = a.Get(0))
            }
            for (let g = 0, k = e.length; g < k; ++g) {
                a = e[g];
                for (let l = 0, n = b.length; l < n; ++l) {
                    const p = b[l];
                    p.VariesPerInstance() && (d[l] = p.Get(g))
                }
                yield*c.apply(a.GetSdkInstance(), d)
            }
        } else
            this._RunObject_SomeParamsVary()
    }
    _RunObject_BeforeAfterHooks() {
        const a = this._parameters
          , b = this._results
          , d = this._func;
        var c = this._objectClass;
        const e = c.GetSdkType();
        c = c.GetCurrentSol().GetInstances();
        e.BeforeRunAction(d);
        for (let g = 0, k = c.length; g < k; ++g) {
            const l = c[g];
            for (let n = 0, p = a.length; n < p; ++n)
                b[n] = a[n].Get(g);
            d.apply(l.GetSdkInstance(), b)
        }
        e.AfterRunAction(d)
    }
    *_DebugRunObject_BeforeAfterHooks() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const b = this._parameters
              , d = this._results
              , c = this._func;
            var a = this._objectClass;
            const e = a.GetSdkType();
            a = a.GetCurrentSol().GetInstances();
            e.BeforeRunAction(c);
            for (let g = 0, k = a.length; g < k; ++g) {
                const l = a[g];
                for (let n = 0, p = b.length; n < p; ++n)
                    d[n] = b[n].Get(g);
                yield*c.apply(l.GetSdkInstance(), d)
            }
            e.AfterRunAction(c)
        } else
            this._RunObject_BeforeAfterHooks()
    }
    _RunBehavior() {
        var a = this._objectClass;
        const b = a.IsFamily()
          , d = a.GetFamilyIndex()
          , c = this._parameters
          , e = this._anyParamVariesPerInstance
          , g = this._results
          , k = this._func
          , l = this._behaviorIndex;
        a = a.GetCurrentSol().GetInstances();
        for (let t = 0, w = c.length; t < w; ++t) {
            var n = c[t];
            n.VariesPerInstance() || (g[t] = n.Get(0))
        }
        for (let t = 0, w = a.length; t < w; ++t) {
            n = a[t];
            if (e)
                for (let z = 0, B = c.length; z < B; ++z) {
                    var p = c[z];
                    p.VariesPerInstance() && (g[z] = p.Get(t))
                }
            p = b ? n.GetObjectClass().GetFamilyBehaviorOffset(d) : 0;
            k.apply(n.GetBehaviorInstances()[l + p].GetSdkInstance(), g)
        }
    }
    *_DebugRunBehavior() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._objectClass;
            const c = a.IsFamily()
              , e = a.GetFamilyIndex()
              , g = this._parameters
              , k = this._anyParamVariesPerInstance
              , l = this._results
              , n = this._func
              , p = this._behaviorIndex;
            a = a.GetCurrentSol().GetInstances();
            for (let t = 0, w = g.length; t < w; ++t) {
                var b = g[t];
                b.VariesPerInstance() || (l[t] = b.Get(0))
            }
            for (let t = 0, w = a.length; t < w; ++t) {
                b = a[t];
                if (k)
                    for (let z = 0, B = g.length; z < B; ++z) {
                        var d = g[z];
                        d.VariesPerInstance() && (l[z] = d.Get(t))
                    }
                d = c ? b.GetObjectClass().GetFamilyBehaviorOffset(e) : 0;
                yield*n.apply(b.GetBehaviorInstances()[p + d].GetSdkInstance(), l)
            }
        } else
            this._RunBehavior()
    }
    _RunObject_Async() {
        const a = this._parameters
          , b = this._results
          , d = this._func
          , c = this._objectClass.GetCurrentSol().GetInstances()
          , e = [];
        for (let g = 0, k = c.length; g < k; ++g) {
            const l = c[g];
            for (let n = 0, p = a.length; n < p; ++n)
                b[n] = a[n].Get(g);
            e.push(d.apply(l.GetSdkInstance(), b))
        }
        return Promise.all(e)
    }
    *_DebugRunObject_Async() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._parameters
              , b = this._results
              , d = this._func
              , c = this._objectClass.GetCurrentSol().GetInstances()
              , e = [];
            for (let g = 0, k = c.length; g < k; ++g) {
                const l = c[g];
                for (let n = 0, p = a.length; n < p; ++n)
                    b[n] = a[n].Get(g);
                e.push(yield*d.apply(l.GetSdkInstance(), b))
            }
            return Promise.all(e)
        }
        return this._RunObject_Async()
    }
    _RunBehavior_Async() {
        var a = this._objectClass;
        const b = a.IsFamily()
          , d = a.GetFamilyIndex()
          , c = this._parameters
          , e = this._results
          , g = this._func
          , k = this._behaviorIndex;
        a = a.GetCurrentSol().GetInstances();
        const l = [];
        for (let n = 0, p = a.length; n < p; ++n) {
            const t = a[n];
            for (let z = 0, B = c.length; z < B; ++z)
                e[z] = c[z].Get(n);
            const w = b ? t.GetObjectClass().GetFamilyBehaviorOffset(d) : 0;
            l.push(g.apply(t.GetBehaviorInstances()[k + w].GetSdkInstance(), e))
        }
        return Promise.all(l)
    }
    *_DebugRunBehavior_Async() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._objectClass;
            const b = a.IsFamily()
              , d = a.GetFamilyIndex()
              , c = this._parameters
              , e = this._results
              , g = this._func
              , k = this._behaviorIndex;
            a = a.GetCurrentSol().GetInstances();
            const l = [];
            for (let n = 0, p = a.length; n < p; ++n) {
                const t = a[n];
                for (let z = 0, B = c.length; z < B; ++z)
                    e[z] = c[z].Get(n);
                const w = b ? t.GetObjectClass().GetFamilyBehaviorOffset(d) : 0;
                l.push(yield*g.apply(t.GetBehaviorInstances()[k + w].GetSdkInstance(), e))
            }
            return Promise.all(l)
        }
        return this._RunBehavior_Async()
    }
    async RunUserScript() {
        try {
            await this._func()
        } catch (a) {
            console.error(`Unhandled exception running script %c ${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, "font-size: 1.2em; font-weight: bold;", a),
            self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
            C3$jscomp$139.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"),
            C3$jscomp$139.EventScript.SetHadUserScriptException())
        }
    }
    *DebugRunUserScript() {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        return this.RunUserScript()
    }
    _SaveToJson() {
        return this._savedData && this._savedData.size ? {
            ex: C3$jscomp$139.ToSuperJSON(this._savedData)
        } : null
    }
    _LoadFromJson(a) {
        this._savedData && (this._savedData.clear(),
        this._savedData = null);
        a && (a = a.ex) && (this._savedData = C3$jscomp$139.FromSuperJSON(a))
    }
}
;
"use strict";
const C3$jscomp$140 = self.C3
  , tempColor$jscomp$5 = new C3$jscomp$140.Color;
function CompareX(a, b) {
    return C3$jscomp$140.compare(this.GetWorldInfo().GetX(), a, b)
}
function CompareY(a, b) {
    return C3$jscomp$140.compare(this.GetWorldInfo().GetY(), a, b)
}
function IsOnScreen() {
    return this.GetWorldInfo().IsInViewport2()
}
function IsOutsideLayout() {
    var a = this.GetWorldInfo();
    const b = a.GetLayout();
    a = a.GetBoundingBox();
    return 0 > a.getRight() || 0 > a.getBottom() || a.getLeft() > b.GetWidth() || a.getTop() > b.GetHeight()
}
function PickDistance(a, b, d) {
    const c = this.GetCurrentSol()
      , e = c.GetInstances();
    if (!e.length)
        return !1;
    let g = e[0];
    var k = g.GetWorldInfo();
    let l = g
      , n = C3$jscomp$140.distanceSquared(k.GetX(), k.GetY(), b, d);
    for (let p = 1, t = e.length; p < t; ++p)
        if (g = e[p],
        k = g.GetWorldInfo(),
        k = C3$jscomp$140.distanceSquared(k.GetX(), k.GetY(), b, d),
        0 === a && k < n || 1 === a && k > n)
            n = k,
            l = g;
    c.PickOne(l);
    return !0
}
function SetX(a) {
    const b = this.GetWorldInfo();
    b.GetX() !== a && (b.SetX(a),
    b.SetBboxChanged())
}
function SetY(a) {
    const b = this.GetWorldInfo();
    b.GetY() !== a && (b.SetY(a),
    b.SetBboxChanged())
}
function SetPos(a, b) {
    const d = this.GetWorldInfo();
    d.EqualsXY(a, b) || (d.SetXY(a, b),
    d.SetBboxChanged())
}
function SetPosToObject(a, b) {
    if (a && (a = a.GetPairedInstance(this._inst))) {
        var [d,c] = a.GetImagePoint(b);
        b = this.GetWorldInfo();
        if (b.GetX() !== d || b.GetY() !== c)
            b.SetXY(d, c),
            b.SetBboxChanged()
    }
}
function MoveForward(a) {
    if (0 !== a) {
        var b = this.GetWorldInfo();
        b.OffsetXY(b.GetCosAngle() * a, b.GetSinAngle() * a);
        b.SetBboxChanged()
    }
}
function MoveAtAngle(a, b) {
    if (0 !== b) {
        var d = this.GetWorldInfo();
        a = C3$jscomp$140.toRadians(a);
        d.OffsetXY(Math.cos(a) * b, Math.sin(a) * b);
        d.SetBboxChanged()
    }
}
function GetX() {
    return this.GetWorldInfo().GetX()
}
function GetY() {
    return this.GetWorldInfo().GetY()
}
function GetDt() {
    return this._runtime.GetDt(this._inst)
}
function CompareWidth(a, b) {
    return C3$jscomp$140.compare(this.GetWorldInfo().GetWidth(), a, b)
}
function CompareHeight(a, b) {
    return C3$jscomp$140.compare(this.GetWorldInfo().GetHeight(), a, b)
}
function SetWidth(a) {
    const b = this.GetWorldInfo();
    b.GetWidth() !== a && (b.SetWidth(a),
    b.SetBboxChanged())
}
function SetHeight(a) {
    const b = this.GetWorldInfo();
    b.GetHeight() !== a && (b.SetHeight(a),
    b.SetBboxChanged())
}
function SetSize(a, b) {
    const d = this.GetWorldInfo();
    if (d.GetWidth() !== a || d.GetHeight() !== b)
        d.SetSize(a, b),
        d.SetBboxChanged()
}
function GetWidth() {
    return this.GetWorldInfo().GetWidth()
}
function GetHeight() {
    return this.GetWorldInfo().GetHeight()
}
function GetBboxLeft() {
    return this.GetWorldInfo().GetBoundingBox().getLeft()
}
function GetBboxTop() {
    return this.GetWorldInfo().GetBoundingBox().getTop()
}
function GetBboxRight() {
    return this.GetWorldInfo().GetBoundingBox().getRight()
}
function GetBboxBottom() {
    return this.GetWorldInfo().GetBoundingBox().getBottom()
}
function GetBboxMidX() {
    const a = this.GetWorldInfo().GetBoundingBox();
    return (a.getLeft() + a.getRight()) / 2
}
function GetBboxMidY() {
    const a = this.GetWorldInfo().GetBoundingBox();
    return (a.getTop() + a.getBottom()) / 2
}
function IsAngleWithin(a, b) {
    return C3$jscomp$140.angleDiff(this.GetWorldInfo().GetAngle(), C3$jscomp$140.toRadians(b)) <= C3$jscomp$140.toRadians(a)
}
function IsAngleClockwiseFrom(a) {
    return C3$jscomp$140.angleClockwise(this.GetWorldInfo().GetAngle(), C3$jscomp$140.toRadians(a))
}
function IsBetweenAngles(a, b) {
    a = C3$jscomp$140.toRadians(a);
    b = C3$jscomp$140.toRadians(b);
    const d = this.GetWorldInfo().GetAngle();
    return C3$jscomp$140.angleClockwise(b, a) ? C3$jscomp$140.angleClockwise(d, a) && !C3$jscomp$140.angleClockwise(d, b) : !(!C3$jscomp$140.angleClockwise(d, a) && C3$jscomp$140.angleClockwise(d, b))
}
function SetAngle(a) {
    const b = this.GetWorldInfo();
    a = C3$jscomp$140.clampAngle(C3$jscomp$140.toRadians(a));
    isNaN(a) || b.GetAngle() === a || (b.SetAngle(a),
    b.SetBboxChanged())
}
function RotateClockwise(a) {
    if (!isNaN(a) && 0 !== a) {
        var b = this.GetWorldInfo();
        b.SetAngle(b.GetAngle() + C3$jscomp$140.toRadians(a));
        b.SetBboxChanged()
    }
}
function RotateCounterclockwise(a) {
    if (!isNaN(a) && 0 !== a) {
        var b = this.GetWorldInfo();
        b.SetAngle(b.GetAngle() - C3$jscomp$140.toRadians(a));
        b.SetBboxChanged()
    }
}
function RotateTowardAngle(a, b) {
    const d = this.GetWorldInfo()
      , c = d.GetAngle();
    a = C3$jscomp$140.angleRotate(c, C3$jscomp$140.toRadians(b), C3$jscomp$140.toRadians(a));
    isNaN(a) || c === a || (d.SetAngle(a),
    d.SetBboxChanged())
}
function RotateTowardPosition(a, b, d) {
    const c = this.GetWorldInfo()
      , e = c.GetAngle();
    b -= c.GetX();
    d -= c.GetY();
    a = C3$jscomp$140.angleRotate(e, Math.atan2(d, b), C3$jscomp$140.toRadians(a));
    isNaN(a) || e === a || (c.SetAngle(a),
    c.SetBboxChanged())
}
function SetTowardPosition(a, b) {
    const d = this.GetWorldInfo()
      , c = d.GetAngle();
    a -= d.GetX();
    b -= d.GetY();
    b = Math.atan2(b, a);
    isNaN(b) || c === b || (d.SetAngle(b),
    d.SetBboxChanged())
}
function GetAngle() {
    return C3$jscomp$140.toDegrees(this.GetWorldInfo().GetAngle())
}
function CompareOpacity(a, b) {
    return C3$jscomp$140.compare(C3$jscomp$140.roundToDp(100 * this.GetWorldInfo().GetOpacity(), 6), a, b)
}
function IsVisible() {
    return this.GetWorldInfo().IsVisible()
}
function SetVisible(a) {
    const b = this.GetWorldInfo();
    a = 2 === a ? !b.IsVisible() : 0 !== a;
    b.IsVisible() !== a && (b.SetVisible(a),
    this._runtime.UpdateRender())
}
function SetOpacity(a) {
    a = C3$jscomp$140.clamp(a / 100, 0, 1);
    const b = this.GetWorldInfo();
    if (b.GetTransformWithParentOpacity()) {
        if (b._GetSceneGraphInfo().GetOwnOpacity() === a)
            return
    } else if (b.GetOpacity() === a)
        return;
    b.SetOpacity(a);
    this._runtime.UpdateRender()
}
function SetDefaultColor(a) {
    tempColor$jscomp$5.setFromRgbValue(a);
    a = this.GetWorldInfo();
    a.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor$jscomp$5) || (a.SetUnpremultipliedColor(tempColor$jscomp$5),
    this._runtime.UpdateRender())
}
function GetColor() {
    const a = this.GetWorldInfo().GetUnpremultipliedColor();
    return C3$jscomp$140.PackRGBAEx(a.getR(), a.getG(), a.getB(), a.getA())
}
function GetOpacity() {
    return C3$jscomp$140.roundToDp(100 * this.GetWorldInfo().GetOpacity(), 6)
}
function IsOnLayer(a) {
    return a ? this.GetWorldInfo().GetLayer() === a : !1
}
function PickTopBottom(a) {
    const b = this.GetCurrentSol()
      , d = b.GetInstances();
    if (!d.length)
        return !1;
    let c = d[0];
    for (let e = 1, g = d.length; e < g; ++e) {
        const k = d[e]
          , l = k.GetWorldInfo()
          , n = c.GetWorldInfo()
          , p = l.GetLayer().GetIndex()
          , t = n.GetLayer().GetIndex();
        if (0 === a) {
            if (p > t || p === t && l.GetZIndex() > n.GetZIndex())
                c = k
        } else if (p < t || p === t && l.GetZIndex() < n.GetZIndex())
            c = k
    }
    b.PickOne(c);
    return !0
}
function CompareZElevation(a, b, d) {
    const c = this.GetWorldInfo();
    a = 0 === a ? c.GetZElevation() : c.GetTotalZElevation();
    return C3$jscomp$140.compare(a, b, d)
}
function MoveToTop() {
    this.GetWorldInfo().ZOrderMoveToTop()
}
function MoveToBottom() {
    this.GetWorldInfo().ZOrderMoveToBottom()
}
function MoveToLayer(a) {
    a && this.GetWorldInfo().ZOrderMoveToLayer(a)
}
function ZMoveToObject(a, b) {
    a = 0 === a;
    b && (b = b.GetFirstPicked(this.GetInstance())) && this.GetWorldInfo().ZOrderMoveAdjacentToInstance(b, a)
}
function SetZElevation(a) {
    const b = this.GetWorldInfo();
    b.GetZElevation() !== a && (b.SetZElevation(a),
    this._runtime.UpdateRender())
}
function LayerNumber() {
    return this.GetWorldInfo().GetLayer().GetIndex()
}
function LayerName() {
    return this.GetWorldInfo().GetLayer().GetName()
}
function ZIndex() {
    return this.GetWorldInfo().GetZIndex()
}
function ZElevation() {
    return this.GetWorldInfo().GetZElevation()
}
function TotalZElevation() {
    return this.GetWorldInfo().GetTotalZElevation()
}
function IsEffectEnabled(a) {
    if (a = this.GetObjectClass().GetEffectList().GetEffectTypeByName(a))
        return a = a.GetIndex(),
        this.GetWorldInfo().GetInstanceEffectList().IsEffectIndexActive(a)
}
function SetEffectEnabled(a, b) {
    if (b = this.GetObjectClass().GetEffectList().GetEffectTypeByName(b)) {
        b = b.GetIndex();
        a = 1 === a;
        var d = this.GetWorldInfo().GetInstanceEffectList();
        d.IsEffectIndexActive(b) !== a && (d.SetEffectIndexActive(b, a),
        d.UpdateActiveEffects(),
        this._runtime.UpdateRender())
    }
}
function SetEffectParam(a, b, d) {
    if (a = this.GetObjectClass().GetEffectList().GetEffectTypeByName(a)) {
        b = Math.floor(b);
        var c = a.GetShaderProgram().GetParameterType(b);
        c && ("color" === c ? (tempColor$jscomp$5.setFromRgbValue(d),
        d = tempColor$jscomp$5) : "percent" === c && (d /= 100),
        a = a.GetIndex(),
        c = this.GetWorldInfo().GetInstanceEffectList(),
        c.SetEffectParameter(a, b, d) && c.IsEffectIndexActive(a) && this._runtime.UpdateRender())
    }
}
const tempRect$jscomp$4 = C3$jscomp$140.New(C3$jscomp$140.Rect)
  , tempCandidates1 = []
  , tempCandidates2 = [];
let needsCollisionFinish = !1
  , rPickType = null
  , rPickFromElseInstances = !1;
const rToPick = new Set;
function CollMemory_Add(a, b, d, c) {
    const e = b.GetUID()
      , g = d.GetUID();
    e < g ? a.Set(b, d, c) : a.Set(d, b, c)
}
function CollMemory_Remove(a, b, d) {
    const c = b.GetUID()
      , e = d.GetUID();
    c < e ? a.Delete(b, d) : a.Delete(d, b)
}
function CollMemory_RemoveInstance(a, b) {
    a.DeleteEither(b)
}
function CollMemory_Get(a, b, d) {
    const c = b.GetUID()
      , e = d.GetUID();
    return c < e ? a.Get(b, d) : a.Get(d, b)
}
function DoOverlapCondition(a, b, d, c) {
    if (!b)
        return !1;
    a = a.GetInstance();
    const e = 0 !== d || 0 !== c
      , g = a.GetWorldInfo()
      , k = a.GetRuntime()
      , l = k.GetCollisionEngine();
    var n = k.GetCurrentCondition();
    const p = n.GetEventBlock().IsOrBlock();
    var t = n.GetObjectClass();
    n = n.IsInverted();
    const w = b.GetCurrentSol();
    t = t !== b;
    rPickType = b;
    needsCollisionFinish = t && !n;
    rPickFromElseInstances = !1;
    let z = 0
      , B = 0
      , C = !1;
    w.IsSelectAll() ? (tempRect$jscomp$4.copy(g.GetBoundingBox()),
    tempRect$jscomp$4.offset(d, c),
    l.GetCollisionCandidates(g.GetLayer(), b, tempRect$jscomp$4, tempCandidates2),
    b = tempCandidates2) : p ? k.IsCurrentConditionFirst() && !w._GetOwnElseInstances().length && w._GetOwnInstances().length ? b = w._GetOwnInstances() : (b = w._GetOwnElseInstances(),
    rPickFromElseInstances = !0) : b = w._GetOwnInstances();
    e && (z = g.GetX(),
    B = g.GetY(),
    g.OffsetXY(d, c),
    g.SetBboxChanged());
    for (const E of b)
        if (l.TestOverlap(a, E)) {
            C = !0;
            if (n)
                break;
            t && rToPick.add(E)
        }
    e && (g.SetXY(z, B),
    g.SetBboxChanged());
    C3$jscomp$140.clearArray(tempCandidates2);
    return C
}
function FinishCollisionConditionPicking(a) {
    a = a.GetRuntime().GetCurrentEvent().IsOrBlock();
    const b = rPickType.GetCurrentSol()
      , d = b._GetOwnInstances()
      , c = b._GetOwnElseInstances();
    b.IsSelectAll() ? (b.SetSetPicked(rToPick),
    a && (C3$jscomp$140.clearArray(c),
    b.AddElseInstances(rToPick, rPickType.GetInstances()))) : a ? rPickFromElseInstances ? b.TransferElseInstancesToOwn(rToPick) : (b.AddElseInstances(rToPick, d),
    b.SetSetPicked(rToPick)) : b.SetSetPicked(rToPick);
    rPickType.ApplySolToContainer()
}
function FinishCollisionCondition(a, b) {
    needsCollisionFinish && (b && FinishCollisionConditionPicking(a),
    rToPick.clear(),
    rPickType = null,
    needsCollisionFinish = !1)
}
function OnCollision(a) {
    if (this._runtime.IsDebugging())
        return DebugOnCollision.call(this, a);
    if (!a)
        return !1;
    var b = this._runtime;
    const d = b.GetCollisionEngine()
      , c = b.GetEventSheetManager()
      , e = c.GetEventStack();
    var g = c.GetCurrentCondition();
    const k = g.GetObjectClass();
    var l = g.GetSavedDataMap()
      , n = g.GetUnsavedDataMap();
    g = e.GetCurrentStackFrame();
    const p = b.GetTickCount()
      , t = p - 1
      , w = g.GetCurrentEvent()
      , z = e.Push(w);
    let B = l.get("collmemory");
    B || (B = C3$jscomp$140.New(C3$jscomp$140.PairMap),
    l.set("collmemory", B));
    n.get("collisionCreatedDestroyCallback") || (n.set("collisionCreatedDestroyCallback", !0),
    b.Dispatcher().addEventListener("instancedestroy", J=>CollMemory_RemoveInstance(B, J.instance)));
    l = k.GetCurrentSol();
    b = a.GetCurrentSol();
    l = l.GetInstances();
    n = null;
    for (let J = 0; J < l.length; ++J) {
        const K = l[J];
        b.IsSelectAll() ? (d.GetCollisionCandidates(K.GetWorldInfo().GetLayer(), a, K.GetWorldInfo().GetBoundingBox(), tempCandidates1),
        n = tempCandidates1,
        d.AddRegisteredCollisionCandidates(K, a, n)) : n = b.GetInstances();
        for (let M = 0; M < n.length; ++M) {
            const U = n[M];
            if (d.TestOverlap(K, U) || d.CheckRegisteredCollision(K, U)) {
                var C = CollMemory_Get(B, K, U)
                  , E = !1
                  , F = -2;
                "number" === typeof C && (E = !0,
                F = C);
                C = !E || F < t;
                CollMemory_Add(B, K, U, p);
                C && (C = w.GetSolModifiers(),
                c.PushCopySol(C),
                F = k.GetCurrentSol(),
                E = a.GetCurrentSol(),
                F._SetSelectAll(!1),
                E._SetSelectAll(!1),
                k === a ? (E = F._GetOwnInstances(),
                C3$jscomp$140.clearArray(E),
                E.push(K),
                E.push(U),
                k.ApplySolToContainer()) : (F = F._GetOwnInstances(),
                E = E._GetOwnInstances(),
                C3$jscomp$140.clearArray(F),
                C3$jscomp$140.clearArray(E),
                F.push(K),
                E.push(U),
                k.ApplySolToContainer(),
                a.ApplySolToContainer()),
                w.Retrigger(g, z),
                c.PopSol(C))
            } else
                CollMemory_Remove(B, K, U)
        }
        C3$jscomp$140.clearArray(tempCandidates1)
    }
    e.Pop();
    return !1
}
function *DebugOnCollision(a) {
    if (!a)
        return !1;
    var b = this._runtime;
    const d = b.GetCollisionEngine()
      , c = b.GetEventSheetManager()
      , e = c.GetEventStack();
    var g = c.GetCurrentCondition();
    const k = g.GetObjectClass();
    var l = g.GetSavedDataMap()
      , n = g.GetUnsavedDataMap();
    g = e.GetCurrentStackFrame();
    const p = b.GetTickCount()
      , t = p - 1
      , w = g.GetCurrentEvent()
      , z = e.Push(w);
    let B = l.get("collmemory");
    B || (B = C3$jscomp$140.New(C3$jscomp$140.PairMap),
    l.set("collmemory", B));
    n.get("collisionCreatedDestroyCallback") || (n.set("collisionCreatedDestroyCallback", !0),
    b.Dispatcher().addEventListener("instancedestroy", J=>CollMemory_RemoveInstance(B, J.instance)));
    l = k.GetCurrentSol();
    b = a.GetCurrentSol();
    l = l.GetInstances();
    n = null;
    for (let J = 0; J < l.length; ++J) {
        const K = l[J];
        b.IsSelectAll() ? (d.GetCollisionCandidates(K.GetWorldInfo().GetLayer(), a, K.GetWorldInfo().GetBoundingBox(), tempCandidates1),
        n = tempCandidates1,
        d.AddRegisteredCollisionCandidates(K, a, n)) : n = b.GetInstances();
        for (let M = 0; M < n.length; ++M) {
            const U = n[M];
            if (d.TestOverlap(K, U) || d.CheckRegisteredCollision(K, U)) {
                var C = CollMemory_Get(B, K, U)
                  , E = !1
                  , F = -2;
                "number" === typeof C && (E = !0,
                F = C);
                C = !E || F < t;
                CollMemory_Add(B, K, U, p);
                C && (C = w.GetSolModifiers(),
                c.PushCopySol(C),
                F = k.GetCurrentSol(),
                E = a.GetCurrentSol(),
                F._SetSelectAll(!1),
                E._SetSelectAll(!1),
                k === a ? (E = F._GetOwnInstances(),
                C3$jscomp$140.clearArray(E),
                E.push(K),
                E.push(U),
                k.ApplySolToContainer()) : (F = F._GetOwnInstances(),
                E = E._GetOwnInstances(),
                C3$jscomp$140.clearArray(F),
                C3$jscomp$140.clearArray(E),
                F.push(K),
                E.push(U),
                k.ApplySolToContainer(),
                a.ApplySolToContainer()),
                yield*w.DebugRetrigger(g, z),
                c.PopSol(C))
            } else
                CollMemory_Remove(B, K, U)
        }
        C3$jscomp$140.clearArray(tempCandidates1)
    }
    e.Pop();
    return !1
}
function IsOverlapping(a) {
    return DoOverlapCondition(this, a, 0, 0)
}
function IsOverlappingOffset(a, b, d) {
    return DoOverlapCondition(this, a, b, d)
}
function HasParent() {
    return this.GetWorldInfo().HasParent()
}
function HasChildren() {
    return this.GetWorldInfo().HasChildren()
}
function PickParent(a, b) {
    const d = this.GetCurrentSol().GetInstances();
    if (0 === d.length)
        return !1;
    const c = a.GetCurrentSol();
    var e = c.GetInstances();
    if (c.IsSelectAll()) {
        var g = [...this._runtime.instancesPendingCreateForObjectClass(a)];
        0 < g.length && (e = e.concat(g))
    }
    if (0 === e.length)
        return !1;
    e = new Set(e);
    g = new Set;
    for (let l = 0, n = d.length; l < n; ++l) {
        var k = d[l];
        if (1 === b)
            for (const p of k.parents())
                p.BelongsToObjectClass(a) && e.has(p) && g.add(p);
        else {
            if (0 === b) {
                if (k = k.GetParent(),
                null === k)
                    continue
            } else
                k = k.GetTopParent();
            k.BelongsToObjectClass(a) && e.has(k) && g.add(k)
        }
    }
    if (0 === g.size)
        return !1;
    c.SetSetPicked(g);
    a.ApplySolToContainer();
    return !0
}
function PickChildren(a, b) {
    const d = this.GetCurrentSol().GetInstances();
    if (0 === d.length)
        return !1;
    const c = a.GetCurrentSol();
    var e = c.GetInstances();
    if (c.IsSelectAll()) {
        var g = [...this._runtime.instancesPendingCreateForObjectClass(a)];
        0 < g.length && (e = e.concat(g))
    }
    if (0 === e.length)
        return !1;
    e = new Set(e);
    g = new Set;
    for (let k = 0, l = d.length; k < l; ++k) {
        const n = d[k];
        2 === b && !n.HasChildren() && n.BelongsToObjectClass(a) && e.has(n) && g.add(n);
        for (const p of 0 === b ? n.children() : n.allChildren())
            2 === b && p.HasChildren() || p.BelongsToObjectClass(a) && e.has(p) && g.add(p)
    }
    if (0 === g.size)
        return !1;
    c.SetSetPicked(g);
    a.ApplySolToContainer();
    return !0
}
function PickNthChild(a, b) {
    const d = this.GetCurrentSol().GetInstances();
    if (0 === d.length)
        return !1;
    const c = a.GetCurrentSol();
    var e = c.GetInstances();
    if (c.IsSelectAll()) {
        var g = [...this._runtime.instancesPendingCreateForObjectClass(a)];
        0 < g.length && (e = e.concat(g))
    }
    if (0 === e.length)
        return !1;
    e = new Set(e);
    g = [];
    for (let k = 0, l = d.length; k < l; ++k) {
        const n = d[k].GetChildAt(b);
        null !== n && n.BelongsToObjectClass(a) && e.has(n) && g.push(n)
    }
    if (0 === g.length)
        return !1;
    c.SetArrayPicked(g);
    a.ApplySolToContainer();
    return !0
}
function CompareChildCount(a, b, d) {
    switch (a) {
    default:
        return C3$jscomp$140.compare(this._inst.GetChildCount(), b, d);
    case 1:
        return C3$jscomp$140.compare(this._inst.GetAllChildCount(), b, d)
    }
}
function AddChild(a, b, d, c, e, g, k, l, n, p) {
    const t = this._inst
      , w = this._runtime.GetCurrentAction().GetObjectClass();
    for (const z of a.allCorrespondingInstances(t, w)) {
        if (!z.GetPlugin().SupportsSceneGraph())
            break;
        t.AddChild(z, {
            transformX: b,
            transformY: d,
            transformWidth: c,
            transformHeight: e,
            transformAngle: g,
            transformOpacity: k,
            transformZElevation: l,
            transformVisibility: n,
            destroyWithParent: p
        })
    }
}
function RemoveChild(a) {
    const b = this._inst
      , d = this._runtime.GetCurrentAction().GetObjectClass();
    for (const c of a.allCorrespondingInstances(b, d))
        b.RemoveChild(c)
}
function RemoveFromParent() {
    this._inst.HasParent() && this._inst.GetParent().RemoveChild(this._inst)
}
function ChildCount() {
    return this._inst.GetChildCount()
}
function AllChildCount() {
    return this._inst.GetAllChildCount()
}
function SetMeshSize(a, b) {
    a = Math.floor(a);
    b = Math.floor(b);
    const d = this.GetWorldInfo();
    2 > a || 2 > b || !isFinite(a) || !isFinite(b) ? (d.ReleaseMesh(),
    d.SetBboxChanged()) : d.CreateMesh(a, b)
}
function SetMeshPoint(a, b, d, c, e, g, k, l) {
    const n = this.GetWorldInfo();
    n.SetMeshPoint(a, b, {
        mode: 0 === d ? "absolute" : "relative",
        x: c,
        y: e,
        zElevation: g,
        u: k,
        v: l
    }) && n.SetBboxChanged()
}
function MeshColumns() {
    const a = this.GetWorldInfo();
    return a.HasMesh() ? a.GetSourceMesh().GetHSize() : 0
}
function MeshRows() {
    const a = this.GetWorldInfo();
    return a.HasMesh() ? a.GetSourceMesh().GetVSize() : 0
}
function SetElementVisible(a) {
    const b = this.GetWorldInfo();
    a = 2 === a ? !b.IsVisible() : 0 !== a;
    b.IsVisible() !== a && b.SetVisible(a)
}
function SetElementCSSStyle(a, b) {
    this.SetElementCSSStyle(a, b)
}
function SetElementAttribute(a, b) {
    this.SetElementAttribute(a, "" + b)
}
function RemoveElementAttribute(a) {
    this.RemoveElementAttribute(a)
}
function SetElementFocus() {
    this.FocusElement()
}
function SetElementBlur() {
    this.BlurElement()
}
function IsElementFocused() {
    return this.IsElementFocused()
}
function SetElementEnabled(a) {
    this._SetEnabled(0 !== a)
}
function IsElementEnabled() {
    return this._IsEnabled()
}
function CompareInstanceVar(a, b, d) {
    return C3$jscomp$140.compare(this.GetInstance().GetInstanceVariableValue(a), b, d)
}
function IsBoolInstanceVarSet(a) {
    return !!this.GetInstance().GetInstanceVariableValue(a)
}
function TemplateName() {
    return this.GetInstance().GetTemplateName()
}
function PickInstVarHiLow(a, b) {
    const d = this.GetCurrentSol()
      , c = d.GetInstances();
    if (!c.length)
        return !1;
    const e = this.IsFamily();
    let g = null
      , k = 0;
    for (let n = 0, p = c.length; n < p; ++n) {
        const t = c[n];
        var l = e ? t.GetObjectClass().GetFamilyInstanceVariableOffset(this.GetFamilyIndex()) : 0;
        l = t.GetInstanceVariableValue(l + b);
        if (null === g || 0 === a && l < k || 1 === a && l > k)
            k = l,
            g = t
    }
    d.PickOne(g);
    return !0
}
function PickByUID(a) {
    return this._runtime.GetCurrentCondition().IsInverted() ? PickByUID_Inverted(this, a) : PickByUID_Normal(this, a)
}
function PickByUID_Normal(a, b) {
    b = a.GetRuntime().GetInstanceByUID(b);
    if (!b)
        return !1;
    const d = a.GetCurrentSol();
    if (!d.IsSelectAll() && !d._GetOwnInstances().includes(b))
        return !1;
    if (a.IsFamily()) {
        if (b.GetObjectClass().BelongsToFamily(a))
            return d.PickOne(b),
            a.ApplySolToContainer(),
            !0
    } else if (b.GetObjectClass() === a)
        return d.PickOne(b),
        a.ApplySolToContainer(),
        !0;
    return !1
}
function PickByUID_Inverted(a, b) {
    const d = a.GetCurrentSol();
    if (d.IsSelectAll()) {
        d._SetSelectAll(!1);
        d.ClearArrays();
        var c = a.GetInstances();
        for (let g = 0, k = c.length; g < k; ++g) {
            var e = c[g];
            e.GetUID() === b ? d._PushElseInstance(e) : d._PushInstance(e)
        }
        a.ApplySolToContainer();
        return !!d._GetOwnInstances().length
    }
    c = d._GetOwnInstances();
    e = 0;
    for (let g = 0, k = c.length; g < k; ++g) {
        const l = c[g];
        c[e] = l;
        l.GetUID() === b ? d._PushElseInstance(l) : ++e
    }
    C3$jscomp$140.truncateArray(c, e);
    a.ApplySolToContainer();
    return !!c.length
}
function Destroy() {
    this._runtime.DestroyInstance(this._inst)
}
function OnCreated() {
    return !0
}
function OnDestroyed() {
    return !0
}
function SetInstanceVar(a, b) {
    this.GetInstance().SetInstanceVariableValue(a, b)
}
function AddInstanceVar(a, b) {
    const d = this.GetInstance()
      , c = d.GetInstanceVariableValue(a);
    "number" === typeof c && "number" !== typeof b ? b = parseFloat(b) : "string" === typeof c && "string" !== typeof b && (b = b.toString());
    d.SetInstanceVariableValue(a, c + b)
}
function SubInstanceVar(a, b) {
    const d = this.GetInstance()
      , c = d.GetInstanceVariableValue(a);
    "number" === typeof c && ("number" !== typeof b && (b = parseFloat(b)),
    d.SetInstanceVariableValue(a, c - b))
}
function SetBoolInstanceVar(a, b) {
    this.GetInstance().SetInstanceVariableValue(a, b ? 1 : 0)
}
function ToggleBoolInstanceVar(a) {
    const b = this.GetInstance();
    b.SetInstanceVariableValue(a, 0 === b.GetInstanceVariableValue(a) ? 1 : 0)
}
function LoadFromJsonString(a) {
    try {
        var b = JSON.parse(a)
    } catch (d) {
        console.error("Failed to load from JSON string: ", d);
        return
    }
    a = this.GetInstance();
    a._OnBeforeLoad("state");
    a.LoadFromJson(b, "state");
    b = C3$jscomp$140.New(C3$jscomp$140.Event, "afterloadinstance");
    b.instance = a;
    this._runtime.Dispatcher().dispatchEvent(b)
}
function AsJSON() {
    return JSON.stringify(this.GetInstance().SaveToJson("state"))
}
function ObjectTypeName() {
    return this.GetInstance().GetObjectClass().GetName()
}
function Count() {
    const a = this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();
    let b = a.GetInstanceCount();
    for (const d of this._runtime.instancesPendingCreateForObjectClass(a))
        ++b;
    return b
}
function PickedCount() {
    return this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length
}
function GetIID() {
    return this._inst.GetIID()
}
function GetUID() {
    return this._inst.GetUID()
}
C3$jscomp$140.AddCommonACEs = function(a, b) {
    const d = a[1]
      , c = a[4]
      , e = a[5]
      , g = a[6]
      , k = a[7]
      , l = a[8]
      , n = a[10]
      , p = a[11]
      , t = a[12]
      , w = a[13]
      , z = a[14]
      , B = a[15]
      , C = a[16]
      , E = b.Cnds
      , F = b.Acts
      , J = b.Exps;
    a[3] && (E.CompareX = CompareX,
    E.CompareY = CompareY,
    E.IsOnScreen = IsOnScreen,
    E.IsOutsideLayout = IsOutsideLayout,
    E.PickDistance = PickDistance,
    F.SetX = SetX,
    F.SetY = SetY,
    F.SetPos = SetPos,
    F.SetPosToObject = SetPosToObject,
    F.MoveForward = MoveForward,
    F.MoveAtAngle = MoveAtAngle,
    J.X = GetX,
    J.Y = GetY,
    J.dt = GetDt);
    c && (E.CompareWidth = CompareWidth,
    E.CompareHeight = CompareHeight,
    F.SetWidth = SetWidth,
    F.SetHeight = SetHeight,
    F.SetSize = SetSize,
    J.Width = GetWidth,
    J.Height = GetHeight,
    J.BBoxLeft = GetBboxLeft,
    J.BBoxTop = GetBboxTop,
    J.BBoxRight = GetBboxRight,
    J.BBoxBottom = GetBboxBottom,
    J.BBoxMidX = GetBboxMidX,
    J.BBoxMidY = GetBboxMidY);
    e && (E.AngleWithin = IsAngleWithin,
    E.IsClockwiseFrom = IsAngleClockwiseFrom,
    E.IsBetweenAngles = IsBetweenAngles,
    F.SetAngle = SetAngle,
    F.RotateClockwise = RotateClockwise,
    F.RotateCounterclockwise = RotateCounterclockwise,
    F.RotateTowardAngle = RotateTowardAngle,
    F.RotateTowardPosition = RotateTowardPosition,
    F.SetTowardPosition = SetTowardPosition,
    J.Angle = GetAngle);
    g && (E.IsVisible = IsVisible,
    E.CompareOpacity = CompareOpacity,
    F.SetVisible = SetVisible,
    F.SetOpacity = SetOpacity,
    F.SetDefaultColor = SetDefaultColor,
    J.Opacity = GetOpacity,
    J.ColorValue = GetColor);
    k && (E.IsOnLayer = IsOnLayer,
    E.PickTopBottom = PickTopBottom,
    E.CompareZElevation = CompareZElevation,
    F.MoveToTop = MoveToTop,
    F.MoveToBottom = MoveToBottom,
    F.MoveToLayer = MoveToLayer,
    F.ZMoveToObject = ZMoveToObject,
    F.SetZElevation = SetZElevation,
    J.LayerNumber = LayerNumber,
    J.LayerName = LayerName,
    J.ZIndex = ZIndex,
    J.ZElevation = ZElevation,
    J.TotalZElevation = TotalZElevation);
    l && (E.IsEffectEnabled = IsEffectEnabled,
    F.SetEffectEnabled = SetEffectEnabled,
    F.SetEffectParam = SetEffectParam);
    w && (E.HasParent = HasParent,
    E.HasChildren = HasChildren,
    E.PickParent = PickParent,
    E.PickChildren = PickChildren,
    E.PickNthChild = PickNthChild,
    E.CompareChildCount = CompareChildCount,
    F.AddChild = AddChild,
    F.RemoveChild = RemoveChild,
    F.RemoveFromParent = RemoveFromParent,
    J.ChildCount = ChildCount,
    J.AllChildCount = AllChildCount);
    z && (F.SetMeshSize = SetMeshSize,
    F.SetMeshPoint = SetMeshPoint,
    J.MeshColumns = MeshColumns,
    J.MeshRows = MeshRows);
    n && (E.IsVisible = IsVisible,
    F.SetVisible = SetElementVisible,
    F.SetCSSStyle = SetElementCSSStyle,
    F.SetElemAttribute = SetElementAttribute,
    F.RemoveElemAttribute = RemoveElementAttribute);
    p && (E.IsFocused = IsElementFocused,
    F.SetFocus = SetElementFocus,
    F.SetBlur = SetElementBlur);
    t && (E.IsEnabled = IsElementEnabled,
    F.SetEnabled = SetElementEnabled);
    B && (E.OnCollision = OnCollision,
    E.IsOverlapping = IsOverlapping,
    E.IsOverlappingOffset = IsOverlappingOffset,
    b.FinishCollisionCondition = FinishCollisionCondition);
    d || (E.CompareInstanceVar = CompareInstanceVar,
    E.IsBoolInstanceVarSet = IsBoolInstanceVarSet,
    E.PickInstVarHiLow = PickInstVarHiLow,
    E.PickByUID = PickByUID,
    F.SetInstanceVar = SetInstanceVar,
    F.AddInstanceVar = AddInstanceVar,
    F.SubInstanceVar = SubInstanceVar,
    F.SetBoolInstanceVar = SetBoolInstanceVar,
    F.ToggleBoolInstanceVar = ToggleBoolInstanceVar,
    E.OnCreated = OnCreated,
    E.OnDestroyed = OnDestroyed,
    F.Destroy = Destroy,
    F.LoadFromJsonString || (F.LoadFromJsonString = LoadFromJsonString),
    J.AsJSON || (J.AsJSON = AsJSON),
    J.Count = Count,
    J.PickedCount = PickedCount,
    J.IID = GetIID,
    J.UID = GetUID,
    J.ObjectTypeName = ObjectTypeName);
    C && (J.TemplateName = TemplateName)
}
;
"use strict";
const C3$jscomp$141 = self.C3;
C3$jscomp$141.ScheduledWait = class extends C3$jscomp$141.DefendedBase {
    constructor(a) {
        super();
        this._eventSheetManager = a;
        this._type = "";
        this._time = -1;
        this._signalTag = "";
        this._isSignalled = !1;
        this._event = null;
        this._actIndex = 0;
        this._solModifiers = [];
        this._dynamicSolModifiers = null;
        this._sols = new Map;
        this._callingFunctionBlock = null;
        this._asyncId = -1;
        this._functionInnerLocalVars = this._functionParameters = null;
        this._shouldRelease = !1
    }
    Release() {
        this._type = "";
        this._time = -1;
        this._signalTag = "";
        this._functionInnerLocalVars = this._functionParameters = this._callingFunctionBlock = this._event = null;
        this._asyncId = -1;
        C3$jscomp$141.clearArray(this._solModifiers);
        this._dynamicSolModifiers && (this._dynamicSolModifiers.clear(),
        this._dynamicSolModifiers = null);
        for (const a of this._sols.values())
            a.Release();
        this._sols.clear()
    }
    _Init() {
        var a = this._eventSheetManager
          , b = a.GetRuntime().GetAllObjectClasses()
          , d = a.GetCurrentEventStackFrame();
        this._event = d.GetCurrentEvent();
        this._actIndex = d.GetActionIndex() + 1;
        if (d = a.FindFirstFunctionBlockParent(this._event))
            this._callingFunctionBlock = d,
            this._functionParameters = d.CaptureFunctionParameters(),
            this._functionInnerLocalVars = d._GetAllInnerLocalVariables().map(c=>c.GetValue()),
            d.IsAsync() && (this._asyncId = d.PauseCurrentAsyncFunction());
        for (const c of b)
            if (b = c.GetCurrentSol(),
            !b.IsSelectAll() || this._event.HasSolModifier(c))
                this._solModifiers.push(c),
                this._sols.set(c, C3$jscomp$141.New(C3$jscomp$141.SolState, b));
        a = a.GetDynamicSolModifiersSet();
        this._dynamicSolModifiers = 0 < a.size ? a : null
    }
    InitTimer(a) {
        this._type = "timer";
        this._Init();
        this._time = this._eventSheetManager.GetRuntime().GetGameTime() + a
    }
    InitSignal(a) {
        this._type = "signal";
        this._Init();
        this._signalTag = a.toLowerCase()
    }
    InitPromise(a) {
        this._type = "promise";
        this._Init();
        a.then(()=>this.SetSignalled()).catch(b=>{
            console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", b);
            this.SetSignalled()
        }
        )
    }
    IsTimer() {
        return "timer" === this._type
    }
    IsSignal() {
        return "signal" === this._type
    }
    IsPromise() {
        return "promise" === this._type
    }
    GetSignalTag() {
        return this._signalTag
    }
    IsSignalled() {
        return this._isSignalled
    }
    SetSignalled() {
        this._isSignalled = !0
    }
    _ShouldRun() {
        return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsSignalled()
    }
    _RestoreState(a) {
        a._Restore(this._event, this._actIndex);
        for (const [b,d] of this._sols.entries()) {
            const c = b.GetCurrentSol();
            d._Restore(c)
        }
        this._dynamicSolModifiers && a.SetDynamicSolModifiers([...this._dynamicSolModifiers]);
        if (a = this._callingFunctionBlock)
            a.SetFunctionParameters(this._functionParameters),
            a._GetAllInnerLocalVariables().map((b,d)=>b.SetValue(this._functionInnerLocalVars[d])),
            a.IsAsync() && a.ResumeAsyncFunction(this._asyncId)
    }
    _Run(a) {
        this._RestoreState(a);
        this._event._ResumeActionsAndSubEvents(a);
        this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
        this._eventSheetManager.ClearSol(this._solModifiers);
        this._shouldRelease = !0
    }
    async _DebugRun(a) {
        this._RestoreState(a);
        for (const b of this._event._DebugResumeActionsAndSubEvents(a))
            await this._eventSheetManager.GetRuntime().DebugBreak(b);
        this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
        this._eventSheetManager.ClearSol(this._solModifiers);
        this._shouldRelease = !0
    }
    ShouldRelease() {
        return this._shouldRelease
    }
    RemoveInstances(a) {
        for (const b of this._sols.values())
            b.RemoveInstances(a)
    }
    _SaveToJson() {
        const a = {}
          , b = {
            t: this._time,
            st: this._signalTag,
            s: this._isSignalled,
            ev: this._event.GetSID(),
            sm: this._solModifiers.map(d=>d.GetSID()),
            dsm: this._dynamicSolModifiers ? [...this._dynamicSolModifiers].map(d=>d.GetSID()) : null,
            sols: a
        };
        this._event._HasActionIndex(this._actIndex) && (b.act = this._event.GetActionAt(this._actIndex).GetSID());
        for (const [d,c] of this._sols)
            a[d.GetSID().toString()] = c._SaveToJson();
        return b
    }
    static _CreateFromJson(a, b) {
        const d = a.GetRuntime();
        var c = a.GetEventBlockBySID(b.ev);
        if (!c)
            return null;
        let e = 0;
        if (b.hasOwnProperty("act")) {
            var g = a.GetActionBySID(b.act);
            if (!g)
                return null;
            e = g.GetIndex()
        }
        g = C3$jscomp$141.New(C3$jscomp$141.ScheduledWait, a);
        g._time = b.t;
        g._type = -1 === g._time ? "signal" : "timer";
        g._signalTag = b.st;
        g._isSignalled = b.s;
        g._event = c;
        g._actIndex = e;
        for (var k of b.sm)
            (c = d.GetObjectClassBySID(k)) && g._solModifiers.push(c);
        if (Array.isArray(b.dsm))
            for (var l of b.dsm)
                if (k = d.GetObjectClassBySID(l))
                    g._dynamicSolModifiers || (g._dynamicSolModifiers = new Set),
                    g._dynamicSolModifiers.add(k);
        for (const [n,p] of Object.entries(b.sols))
            if (b = parseInt(n, 10),
            b = d.GetObjectClassBySID(b))
                l = C3$jscomp$141.New(C3$jscomp$141.SolState, null),
                l._LoadFromJson(a, p),
                g._sols.set(b, l);
        return g
    }
}
;
"use strict";
const C3$jscomp$142 = self.C3;
C3$jscomp$142.SolState = class extends C3$jscomp$142.DefendedBase {
    constructor(a) {
        super();
        this._objectClass = null;
        this._isSelectAll = !0;
        this._instances = [];
        a && (this._objectClass = a.GetObjectClass(),
        this._isSelectAll = a.IsSelectAll(),
        C3$jscomp$142.shallowAssignArray(this._instances, a._GetOwnInstances()))
    }
    Release() {
        this._objectClass = null;
        C3$jscomp$142.clearArray(this._instances)
    }
    _Restore(a) {
        a._SetSelectAll(this._isSelectAll);
        C3$jscomp$142.shallowAssignArray(a._GetOwnInstances(), this._instances)
    }
    RemoveInstances(a) {
        C3$jscomp$142.arrayRemoveAllInSet(this._instances, a)
    }
    _SaveToJson() {
        return {
            sa: this._isSelectAll,
            insts: this._instances.map(a=>a.GetUID())
        }
    }
    _LoadFromJson(a, b) {
        a = a.GetRuntime();
        this._isSelectAll = !!b.sa;
        C3$jscomp$142.clearArray(this._instances);
        for (const d of b.insts)
            (b = a.GetInstanceByUID(d)) && this._instances.push(b)
    }
}
;
"use strict";
const C3$jscomp$143 = self.C3;
function GetNextParamMap(a, b) {
    let d = a.get(b);
    d || (d = new Map,
    a.set(b, d));
    return d
}
C3$jscomp$143.SDKPluginBase = class extends C3$jscomp$143.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a.runtime;
        this._isSingleGlobal = !!a.isSingleGlobal;
        this._isWorldType = !!a.isWorld;
        this._isRotatable = !!a.isRotatable;
        this._mustPredraw = !!a.mustPredraw;
        this._hasEffects = !!a.hasEffects;
        this._supportsSceneGraph = !!a.supportsSceneGraph;
        this._supportsMesh = !!a.supportsMesh;
        this._singleGlobalObjectClass = null;
        this._boundACEMethodCache = new Map;
        this._boundACEMethodCache_1param = new Map;
        this._boundACEMethodCache_2params = new Map;
        this._boundACEMethodCache_3params = new Map
    }
    Release() {
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    OnCreate() {}
    IsSingleGlobal() {
        return this._isSingleGlobal
    }
    IsWorldType() {
        return this._isWorldType
    }
    IsRotatable() {
        return this._isRotatable
    }
    MustPreDraw() {
        return this._mustPredraw
    }
    HasEffects() {
        return this._hasEffects
    }
    SupportsSceneGraph() {
        return this._supportsSceneGraph
    }
    SupportsMesh() {
        return this._supportsMesh
    }
    _GetBoundACEMethod(a, b) {
        if (!b)
            throw Error("missing 'this' binding");
        let d = this._boundACEMethodCache.get(a);
        if (d)
            return d;
        d = a.bind(b);
        this._boundACEMethodCache.set(a, d);
        return d
    }
    _GetBoundACEMethod_1param(a, b, d) {
        if (!b)
            throw Error("missing 'this' binding");
        const c = GetNextParamMap(this._boundACEMethodCache_1param, a);
        let e = c.get(d);
        if (e)
            return e;
        e = a.bind(b, d);
        c.set(d, e);
        return e
    }
    _GetBoundACEMethod_2params(a, b, d, c) {
        if (!b)
            throw Error("missing 'this' binding");
        var e = GetNextParamMap(this._boundACEMethodCache_2params, a);
        e = GetNextParamMap(e, d);
        let g = e.get(c);
        if (g)
            return g;
        g = a.bind(b, d, c);
        e.set(c, g);
        return g
    }
    _GetBoundACEMethod_3params(a, b, d, c, e) {
        if (!b)
            throw Error("missing 'this' binding");
        var g = GetNextParamMap(this._boundACEMethodCache_3params, a);
        g = GetNextParamMap(g, d);
        g = GetNextParamMap(g, c);
        let k = g.get(e);
        if (k)
            return k;
        k = a.bind(b, d, c, e);
        g.set(e, k);
        return k
    }
    _SetSingleGlobalObjectClass(a) {
        if (!this.IsSingleGlobal())
            throw Error("must be single-global plugin");
        this._singleGlobalObjectClass = a
    }
    GetSingleGlobalObjectClass() {
        if (!this.IsSingleGlobal())
            throw Error("must be single-global plugin");
        return this._singleGlobalObjectClass
    }
    GetSingleGlobalInstance() {
        if (!this.IsSingleGlobal())
            throw Error("must be single-global plugin");
        return this._singleGlobalObjectClass.GetSingleGlobalInstance()
    }
}
;
"use strict";
const C3$jscomp$144 = self.C3;
C3$jscomp$144.SDKDOMPluginBase = class extends C3$jscomp$144.SDKPluginBase {
    constructor(a, b) {
        super(a);
        this._domComponentId = b;
        this._nextElementId = 0;
        this._instMap = new Map;
        this.AddElementMessageHandler("elem-focused", d=>d._OnElemFocused());
        this.AddElementMessageHandler("elem-blurred", d=>{
            d && d._OnElemBlurred()
        }
        )
    }
    Release() {
        super.Release()
    }
    _AddElement(a) {
        const b = this._nextElementId++;
        this._instMap.set(b, a);
        return b
    }
    _RemoveElement(a) {
        this._instMap.delete(a)
    }
    AddElementMessageHandler(a, b) {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId, a, d=>{
            const c = this._instMap.get(d.elementId);
            b(c, d)
        }
        )
    }
}
;
"use strict";
const C3$jscomp$145 = self.C3;
C3$jscomp$145.SDKTypeBase = class extends C3$jscomp$145.DefendedBase {
    constructor(a) {
        super();
        this._objectClass = a;
        this._runtime = a.GetRuntime();
        this._plugin = a.GetPlugin()
    }
    Release() {
        this._plugin = this._runtime = this._objectClass = null
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetRuntime() {
        return this._runtime
    }
    GetPlugin() {
        return this._plugin
    }
    GetImageInfo() {
        return this._objectClass.GetImageInfo()
    }
    OnCreate() {}
    FinishCondition(a) {}
    BeforeRunAction(a) {}
    AfterRunAction(a) {}
    LoadTextures(a) {}
    ReleaseTextures() {}
    OnDynamicTextureLoadComplete() {}
    PreloadTexturesWithInstances(a) {}
    LoadTilemapData() {}
    GetScriptInterfaceClass() {
        return null
    }
    DispatchScriptEvent(a, b, d) {
        a = C3$jscomp$145.New(C3$jscomp$145.Event, a, b);
        a.objectClass = this;
        d && Object.assign(a, d);
        this.GetObjectClass().DispatchUserScriptEvent(a)
    }
}
;
"use strict";
const C3$jscomp$146 = self.C3;
C3$jscomp$146.SDKInstanceBase = class extends C3$jscomp$146.DefendedBase {
    constructor(a, b) {
        super();
        this._inst = a;
        this._domComponentId = b;
        this._runtime = a.GetRuntime();
        this._objectClass = this._inst.GetObjectClass();
        this._sdkType = this._objectClass.GetSdkType();
        this._tick2Func = this._tickFunc = null;
        this._isTicking2 = this._isTicking = !1;
        this._disposables = null;
        this._wasReleased = !1
    }
    Release() {
        this._wasReleased = !0;
        this._StopTicking();
        this._StopTicking2();
        this._tick2Func = this._tickFunc = null;
        this._disposables && (this._disposables.Release(),
        this._disposables = null);
        this._sdkType = this._objectClass = this._runtime = this._inst = null
    }
    WasReleased() {
        return this._wasReleased
    }
    GetInstance() {
        return this._inst
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetPlugin() {
        return this._sdkType.GetPlugin()
    }
    GetSdkType() {
        return this._sdkType
    }
    GetScriptInterface() {
        return this._inst.GetInterfaceClass()
    }
    Trigger(a) {
        return this._runtime.Trigger(a, this._inst, null)
    }
    DebugTrigger(a) {
        return this._runtime.DebugTrigger(a, this._inst, null)
    }
    TriggerAsync(a) {
        return this._runtime.TriggerAsync(a, this._inst, null)
    }
    FastTrigger(a, b) {
        return this._runtime.FastTrigger(a, this._inst, b)
    }
    DebugFastTrigger(a, b) {
        return this._runtime.DebugFastTrigger(a, this._inst, b)
    }
    ScheduleTriggers(a) {
        return this._runtime.ScheduleTriggers(a)
    }
    AddDOMMessageHandler(a, b) {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId, a, b)
    }
    AddDOMMessageHandlers(a) {
        for (const [b,d] of a)
            this.AddDOMMessageHandler(b, d)
    }
    PostToDOM(a, b) {
        this._runtime.PostComponentMessageToDOM(this._domComponentId, a, b)
    }
    PostToDOMAsync(a, b) {
        return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, a, b)
    }
    _PostToDOMMaybeSync(a, b) {
        if (this._runtime.IsInWorker())
            this.PostToDOM(a, b);
        else
            return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._domComponentId,
                handler: a,
                data: b,
                responseId: null
            })
    }
    Tick() {}
    Tick2() {}
    _StartTicking() {
        this._isTicking || (this._tickFunc || (this._tickFunc = ()=>this.Tick()),
        this._runtime.Dispatcher().addEventListener("tick", this._tickFunc),
        this._isTicking = !0)
    }
    _StopTicking() {
        this._isTicking && (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc),
        this._isTicking = !1)
    }
    IsTicking() {
        return this._isTicking
    }
    _StartTicking2() {
        this._isTicking2 || (this._tick2Func || (this._tick2Func = ()=>this.Tick2()),
        this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func),
        this._isTicking2 = !0)
    }
    _StopTicking2() {
        this._isTicking2 && (this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func),
        this._isTicking2 = !1)
    }
    IsTicking2() {
        return this._isTicking2
    }
    GetDebuggerProperties() {
        return []
    }
    SaveToJson() {
        return null
    }
    LoadFromJson(a) {}
    GetPropertyValueByIndex(a) {}
    SetPropertyValueByIndex(a, b) {}
    OffsetPropertyValueByIndex(a, b) {
        if (0 !== b) {
            var d = this.GetPropertyValueByIndex(a);
            if ("number" !== typeof d)
                throw Error("expected number");
            this.SetPropertyValueByIndex(a, d + b)
        }
    }
    SetPropertyColorOffsetValueByIndex(a, b, d, c) {}
    CallAction(a, ...b) {
        a.call(this, ...b)
    }
    CallExpression(a, ...b) {
        return a.call(this, ...b)
    }
    GetScriptInterfaceClass() {
        return null
    }
    DispatchScriptEvent(a, b, d) {
        if (this._inst.HasScriptInterface()) {
            var c = this.GetScriptInterface();
            a = C3$jscomp$146.New(C3$jscomp$146.Event, a, b);
            a.instance = c;
            d && Object.assign(a, d);
            c.dispatchEvent(a)
        }
    }
}
;
"use strict";
const C3$jscomp$147 = self.C3;
C3$jscomp$147.SDKWorldInstanceBase = class extends C3$jscomp$147.SDKInstanceBase {
    constructor(a, b) {
        super(a, b);
        this._worldInfo = a.GetWorldInfo();
        this._renderercontextrestored_handler = this._renderercontextlost_handler = null
    }
    Release() {
        if (this._renderercontextlost_handler) {
            const a = this._runtime.Dispatcher();
            a.removeEventListener("renderercontextlost", this._renderercontextlost_handler);
            a.removeEventListener("renderercontextrestored", this._renderercontextrestored_handler);
            this._renderercontextrestored_handler = this._renderercontextlost_handler = null
        }
        this._worldInfo = null;
        super.Release()
    }
    HandleWebGLContextLoss() {
        this.HandleRendererContextLoss()
    }
    OnWebGLContextLost() {}
    OnWebGLContextRestored() {}
    HandleRendererContextLoss() {
        if (!this._renderercontextlost_handler) {
            this._renderercontextlost_handler = ()=>this.OnRendererContextLost();
            this._renderercontextrestored_handler = ()=>this.OnRendererContextRestored();
            var a = this._runtime.Dispatcher();
            a.addEventListener("rendererontextlost", this._renderercontextlost_handler);
            a.addEventListener("renderercontextrestored", this._renderercontextrestored_handler)
        }
    }
    OnRendererContextLost() {
        this.OnWebGLContextLost()
    }
    OnRendererContextRestored() {
        this.OnWebGLContextRestored()
    }
    GetWorldInfo() {
        return this._worldInfo
    }
    IsOriginalSizeKnown() {
        return !1
    }
    GetOriginalWidth() {
        if (!this.IsOriginalSizeKnown())
            throw Error("original size not known");
        const a = this.GetCurrentImageInfo();
        if (a)
            return a.GetWidth()
    }
    GetOriginalHeight() {
        if (!this.IsOriginalSizeKnown())
            throw Error("original size not known");
        const a = this.GetCurrentImageInfo();
        if (a)
            return a.GetHeight()
    }
    GetCurrentImageInfo() {
        return null
    }
    GetCurrentSurfaceSize() {
        var a = this.GetCurrentImageInfo();
        return a && (a = a.GetTexture()) ? [a.GetWidth(), a.GetHeight()] : [100, 100]
    }
    GetCurrentTexRect() {
        const a = this.GetCurrentImageInfo();
        return a ? a.GetTexRect() : null
    }
    GetCurrentTexQuad() {
        const a = this.GetCurrentImageInfo();
        return a ? a.GetTexQuad() : null
    }
    IsCurrentTexRotated() {
        const a = this.GetCurrentImageInfo();
        return a ? a.IsRotated() : !1
    }
    GetImagePoint(a) {
        a = this._inst.GetWorldInfo();
        return [a.GetX(), a.GetY()]
    }
    LoadTilemapData(a, b, d) {}
    TestPointOverlapTile(a, b) {}
    RendersToOwnZPlane() {
        return !0
    }
}
;
"use strict";
const C3$jscomp$148 = self.C3
  , tempRect$jscomp$5 = C3$jscomp$148.New(C3$jscomp$148.Rect);
C3$jscomp$148.SDKDOMInstanceBase = class extends C3$jscomp$148.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a, b);
        this._elementId = this.GetPlugin()._AddElement(this);
        this._isElementShowing = !0;
        this._autoFontSize = this._elemHasFocus = !1;
        this._autoFontSizeOffset = -.2;
        this._lastRect = C3$jscomp$148.New(C3$jscomp$148.Rect, 0, 0, -1, -1);
        a = this._runtime.GetCanvasManager();
        this._lastWindowWidth = a.GetLastWidth();
        this._lastWindowHeight = a.GetLastHeight();
        this._isPendingUpdateState = !1;
        this._StartTicking()
    }
    Release() {
        this.GetPlugin()._RemoveElement(this._elementId);
        this.PostToDOMElement("destroy");
        this._elementId = -1;
        super.Release()
    }
    _GetElementInDOMMode() {
        if (this._runtime.IsInWorker())
            throw Error("not valid in worker mode");
        return this._PostToDOMElementMaybeSync("get-element")
    }
    PostToDOMElement(a, b) {
        b || (b = {});
        b.elementId = this._elementId;
        this.PostToDOM(a, b)
    }
    _PostToDOMElementMaybeSync(a, b) {
        b || (b = {});
        b.elementId = this._elementId;
        return this._PostToDOMMaybeSync(a, b)
    }
    PostToDOMElementAsync(a, b) {
        b || (b = {});
        b.elementId = this._elementId;
        return this.PostToDOMAsync(a, b)
    }
    CreateElement(a) {
        a || (a = {});
        const b = this.GetWorldInfo().IsVisible();
        a.elementId = this._elementId;
        a.isVisible = b;
        Object.assign(a, this.GetElementState());
        this._isElementShowing = !!a.isVisible;
        this._PostToDOMMaybeSync("create", a);
        this._UpdatePosition(!0)
    }
    SetElementVisible(a) {
        a = !!a;
        this._isElementShowing !== a && (this._isElementShowing = a,
        this.PostToDOMElement("set-visible", {
            isVisible: a
        }))
    }
    Tick() {
        this._UpdatePosition(!1)
    }
    _ShouldPreserveElement() {
        const a = this._runtime.GetCanvasManager().GetFullscreenMode();
        return "Android" === C3$jscomp$148.Platform.OS && ("scale-inner" === a || "scale-outer" === a || "crop" === a)
    }
    _UpdatePosition(a) {
        var b = this.GetWorldInfo();
        const d = b.GetLayer();
        var c = b.GetBoundingBox();
        let[e,g] = d.LayerToCanvasCss(c.getLeft(), c.getTop())
          , [k,l] = d.LayerToCanvasCss(c.getRight(), c.getBottom());
        c = this._runtime.GetCanvasManager();
        var n = c.GetCssWidth();
        const p = c.GetCssHeight();
        if (b.IsVisible() && d.IsVisible()) {
            if (!this._ShouldPreserveElement()) {
                if (0 >= k || 0 >= l || e >= n || g >= p) {
                    this.SetElementVisible(!1);
                    return
                }
                1 > e && (e = 1);
                1 > g && (g = 1);
                k >= n && (k = n - 1);
                l >= p && (l = p - 1)
            }
            tempRect$jscomp$5.set(e, g, k, l);
            b = c.GetLastWidth();
            n = c.GetLastHeight();
            !a && tempRect$jscomp$5.equals(this._lastRect) && this._lastWindowWidth === b && this._lastWindowHeight === n ? this.SetElementVisible(!0) : (this._lastRect.copy(tempRect$jscomp$5),
            this._lastWindowWidth = b,
            this._lastWindowHeight = n,
            this.SetElementVisible(!0),
            a = null,
            this._autoFontSize && (a = d.GetDisplayScale() + this._autoFontSizeOffset),
            this.PostToDOMElement("update-position", {
                left: Math.round(this._lastRect.getLeft()) + c.GetCanvasClientX(),
                top: Math.round(this._lastRect.getTop()) + c.GetCanvasClientY(),
                width: Math.round(this._lastRect.width()),
                height: Math.round(this._lastRect.height()),
                fontSize: a
            }))
        } else
            this.SetElementVisible(!1)
    }
    FocusElement() {
        this._PostToDOMElementMaybeSync("focus", {
            focus: !0
        })
    }
    BlurElement() {
        this._PostToDOMElementMaybeSync("focus", {
            focus: !1
        })
    }
    _OnElemFocused() {
        this._elemHasFocus = !0
    }
    _OnElemBlurred() {
        this._elemHasFocus = !1
    }
    IsElementFocused() {
        return this._elemHasFocus
    }
    SetElementCSSStyle(a, b) {
        this.PostToDOMElement("set-css-style", {
            prop: C3$jscomp$148.CSSToCamelCase(a),
            val: b
        })
    }
    SetElementAttribute(a, b) {
        this.PostToDOMElement("set-attribute", {
            name: a,
            val: b
        })
    }
    RemoveElementAttribute(a) {
        this.PostToDOMElement("remove-attribute", {
            name: a
        })
    }
    UpdateElementState() {
        this._isPendingUpdateState || (this._isPendingUpdateState = !0,
        Promise.resolve().then(()=>{
            this._isPendingUpdateState = !1;
            this.PostToDOMElement("update-state", this.GetElementState())
        }
        ))
    }
    GetElementState() {}
    GetElementId() {
        return this._elementId
    }
}
;
"use strict";
const C3$jscomp$149 = self.C3
  , IBehavior$jscomp$1 = self.IBehavior;
C3$jscomp$149.SDKBehaviorBase = class extends C3$jscomp$149.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a.runtime;
        this._myObjectClasses = C3$jscomp$149.New(C3$jscomp$149.ArraySet);
        this._myInstances = C3$jscomp$149.New(C3$jscomp$149.ArraySet);
        this._iBehavior = null;
        this._scriptInterfaceClass = a.scriptInterfaceClass || null
    }
    Release() {
        this._myInstances.Release();
        this._myObjectClasses.Release();
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    OnCreate() {}
    _AddObjectClass(a) {
        this._myObjectClasses.Add(a)
    }
    GetObjectClasses() {
        return this._myObjectClasses.GetArray()
    }
    _AddInstance(a) {
        this._myInstances.Add(a)
    }
    _RemoveInstance(a) {
        this._myInstances.Delete(a)
    }
    GetInstances() {
        return this._myInstances.GetArray()
    }
    GetIBehavior() {
        if (null === this._iBehavior) {
            const a = this._scriptInterfaceClass;
            if (a) {
                if (this._iBehavior = new a(this),
                !(this._iBehavior instanceof IBehavior$jscomp$1))
                    throw new TypeError("script interface class must derive from IBehavior");
            } else
                this._iBehavior = new IBehavior$jscomp$1(this)
        }
        return this._iBehavior
    }
}
;
"use strict";
const C3$jscomp$150 = self.C3;
C3$jscomp$150.SDKBehaviorTypeBase = class extends C3$jscomp$150.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a.GetRuntime();
        this._behaviorType = a;
        this._objectClass = a.GetObjectClass();
        this._behavior = a.GetBehavior();
        this._behavior._AddObjectClass(this._objectClass)
    }
    Release() {
        this._behavior = this._objectClass = this._behaviorType = this._runtime = null
    }
    OnCreate() {}
    GetBehaviorType() {
        return this._behaviorType
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetRuntime() {
        return this._runtime
    }
    GetBehavior() {
        return this._behavior
    }
}
;
"use strict";
const C3$jscomp$151 = self.C3;
C3$jscomp$151.SDKBehaviorInstanceBase = class extends C3$jscomp$151.DefendedBase {
    constructor(a, b) {
        super();
        this._behInst = a;
        this._domComponentId = b;
        this._inst = a.GetObjectInstance();
        this._runtime = a.GetRuntime();
        this._behaviorType = a.GetBehaviorType();
        this._sdkType = this._behaviorType.GetSdkType();
        this._isPostTicking = this._isTicking2 = this._isTicking = !1;
        this._disposables = null
    }
    Release() {
        this._StopTicking();
        this._StopTicking2();
        this._StopPostTicking();
        this._disposables && (this._disposables.Release(),
        this._disposables = null);
        this._sdkType = this._behaviorType = this._runtime = this._inst = this._behInst = null
    }
    GetBehavior() {
        return this._behaviorType.GetBehavior()
    }
    GetBehaviorInstance() {
        return this._behInst
    }
    GetObjectInstance() {
        return this._inst
    }
    GetObjectClass() {
        return this._inst.GetObjectClass()
    }
    GetWorldInfo() {
        return this._inst.GetWorldInfo()
    }
    GetRuntime() {
        return this._runtime
    }
    GetBehaviorType() {
        return this._behaviorType
    }
    GetSdkType() {
        return this._sdkType
    }
    GetScriptInterface() {
        return this._behInst.GetScriptInterface()
    }
    Trigger(a) {
        return this._runtime.Trigger(a, this._inst, this._behaviorType)
    }
    DebugTrigger(a) {
        return this._runtime.DebugTrigger(a, this._inst, this._behaviorType)
    }
    TriggerAsync(a) {
        return this._runtime.TriggerAsync(a, this._inst, this._behaviorType)
    }
    PostCreate() {}
    Tick() {}
    Tick2() {}
    PostTick() {}
    _StartTicking() {
        this._isTicking || (this._runtime._AddBehInstToTick(this),
        this._isTicking = !0)
    }
    _StopTicking() {
        this._isTicking && (this._runtime._RemoveBehInstToTick(this),
        this._isTicking = !1)
    }
    IsTicking() {
        return this._isTicking
    }
    _StartTicking2() {
        this._isTicking2 || (this._runtime._AddBehInstToTick2(this),
        this._isTicking2 = !0)
    }
    _StopTicking2() {
        this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this),
        this._isTicking2 = !1)
    }
    IsTicking2() {
        return this._isTicking2
    }
    _StartPostTicking() {
        this._isPostTicking || (this._runtime._AddBehInstToPostTick(this),
        this._isPostTicking = !0)
    }
    _StopPostTicking() {
        this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this),
        this._isPostTicking = !1)
    }
    IsPostTicking() {
        return this._isPostTicking
    }
    GetDebuggerProperties() {
        return []
    }
    AddDOMMessageHandler(a, b) {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId, a, b)
    }
    OnSpriteFrameChanged(a, b) {}
    SaveToJson() {
        return null
    }
    LoadFromJson(a) {}
    GetPropertyValueByIndex(a) {}
    SetPropertyValueByIndex(a, b) {}
    OffsetPropertyValueByIndex(a, b) {
        if (0 !== b) {
            var d = this.GetPropertyValueByIndex(a);
            if ("number" !== typeof d)
                throw Error("expected number");
            this.SetPropertyValueByIndex(a, d + b)
        }
    }
    SetPropertyColorOffsetValueByIndex(a, b, d, c) {}
    CallAction(a, ...b) {
        a.call(this, ...b)
    }
    CallExpression(a, ...b) {
        return a.call(this, ...b)
    }
    GetScriptInterfaceClass() {
        return null
    }
    DispatchScriptEvent(a, b, d) {
        if (this._behInst.HasScriptInterface()) {
            var c = this.GetScriptInterface();
            a = C3$jscomp$151.New(C3$jscomp$151.Event, a, b);
            a.behaviorInstance = c;
            a.instance = c.instance;
            d && Object.assign(a, d);
            c.dispatchEvent(a)
        }
    }
}
;
"use strict";
const C3$jscomp$152 = self.C3;
C3$jscomp$152.Plugins = {};
C3$jscomp$152.Behaviors = {};
C3$jscomp$152.PluginManager = class extends C3$jscomp$152.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._allPlugins = [];
        this._pluginsByCtor = new Map;
        this._systemPlugin = null;
        this._allBehaviors = [];
        this._behaviorsByCtor = new Map;
        this._jumpthruBehavior = this._solidBehavior = null
    }
    CreatePlugin(a) {
        const b = this._runtime.GetObjectReference(a[0]);
        if (!b)
            throw Error("missing plugin");
        C3$jscomp$152.AddCommonACEs(a, b);
        a = C3$jscomp$152.New(b, {
            runtime: this._runtime,
            isSingleGlobal: a[1],
            isWorld: a[2],
            isRotatable: a[5],
            hasEffects: a[8],
            mustPredraw: a[9],
            supportsSceneGraph: a[13],
            supportsMesh: a[14]
        });
        a.OnCreate();
        this._allPlugins.push(a);
        this._pluginsByCtor.set(b, a)
    }
    CreateSystemPlugin() {
        this._systemPlugin = C3$jscomp$152.New(C3$jscomp$152.Plugins.System, {
            runtime: this._runtime,
            isSingleGlobal: !0
        });
        this._systemPlugin.OnCreate()
    }
    CreateBehavior(a) {
        a = this._runtime.GetObjectReference(a[1]);
        if (!a)
            throw Error("missing behavior");
        const b = C3$jscomp$152.New(a, {
            runtime: this._runtime
        });
        b.OnCreate();
        this._allBehaviors.push(b);
        this._behaviorsByCtor.set(a, b);
        !this._solidBehavior && C3$jscomp$152.Behaviors.solid && b instanceof C3$jscomp$152.Behaviors.solid ? this._solidBehavior = b : !this._jumpthruBehavior && C3$jscomp$152.Behaviors.jumpthru && b instanceof C3$jscomp$152.Behaviors.jumpthru && (this._jumpthruBehavior = b)
    }
    GetPluginByConstructorFunction(a) {
        return this._pluginsByCtor.get(a) || null
    }
    HasBehaviorByConstructorFunction(a) {
        return this._behaviorsByCtor.has(a)
    }
    GetBehaviorByConstructorFunction(a) {
        return this._behaviorsByCtor.get(a) || null
    }
    GetSystemPlugin() {
        return this._systemPlugin
    }
    GetSolidBehavior() {
        return this._solidBehavior
    }
    GetJumpthruBehavior() {
        return this._jumpthruBehavior
    }
}
;
"use strict";
const C3$jscomp$153 = self.C3
  , allImageInfos = new Set;
C3$jscomp$153.ImageInfo = class extends C3$jscomp$153.DefendedBase {
    constructor() {
        super();
        this._generation = 0;
        this._url = "";
        this._height = this._width = this._offsetY = this._offsetX = this._size = 0;
        this._hasMetaData = this._isRotated = !1;
        this._imageAsset = null;
        this._textureState = "";
        this._rcTex = C3$jscomp$153.New(C3$jscomp$153.Rect);
        this._quadTex = C3$jscomp$153.New(C3$jscomp$153.Quad);
        this._blobUrl = "";
        this._iImageInfo = new self.IImageInfo(this);
        allImageInfos.add(this)
    }
    Release() {
        this.ReleaseTexture();
        this._imageAsset = null;
        allImageInfos.delete(this);
        this.ReleaseBlobURL()
    }
    static OnRendererContextLost() {
        for (const a of allImageInfos)
            a._textureState = "",
            a._rcTex.set(0, 0, 0, 0),
            a._quadTex.setFromRect(a._rcTex)
    }
    LoadData(a) {
        this._url = a[0];
        this._size = a[1];
        this._offsetX = a[2];
        this._offsetY = a[3];
        this._width = a[4];
        this._height = a[5];
        this._isRotated = a[6];
        this._hasMetaData = !0
    }
    LoadDynamicAsset(a, b) {
        if (this._imageAsset)
            throw Error("already loaded asset");
        this._url = b;
        const d = {};
        C3$jscomp$153.IsAbsoluteURL(b) && (d.loadPolicy = "remote");
        this.LoadAsset(a, d);
        return this._imageAsset.Load()
    }
    ReplaceWith(a) {
        if (a === this)
            throw Error("cannot replace with self");
        this._generation++;
        this.ReleaseTexture();
        this._url = a._url;
        this._size = a._size;
        this._offsetX = a._offsetX;
        this._offsetY = a._offsetY;
        this._width = a._width;
        this._height = a._height;
        this._isRotated = a._isRotated;
        this._hasMetaData = a._hasMetaData;
        this._imageAsset = a._imageAsset;
        this._textureState = a._textureState;
        this._rcTex = a._rcTex;
        this._quadTex = a._quadTex;
        this.ReleaseBlobURL()
    }
    GetURL() {
        return this._url
    }
    GetSize() {
        return this._size
    }
    GetOffsetX() {
        return this._offsetX
    }
    GetOffsetY() {
        return this._offsetY
    }
    IsRotated() {
        return this._isRotated
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    GetSheetWidth() {
        return this._imageAsset.GetWidth()
    }
    GetSheetHeight() {
        return this._imageAsset.GetHeight()
    }
    LoadAsset(a, b) {
        if (this._imageAsset)
            throw Error("already got asset");
        b = Object.assign({}, b, {
            url: this.GetURL(),
            size: this.GetSize()
        });
        this._imageAsset = a.LoadImage(b)
    }
    IsLoaded() {
        return this._imageAsset && this._imageAsset.IsLoaded()
    }
    async LoadStaticTexture(a, b) {
        if (!this._imageAsset)
            throw Error("no asset");
        if (this._textureState)
            throw Error("already loaded texture");
        const d = this._generation;
        this._textureState = "loading";
        a = await this._imageAsset.LoadStaticTexture(a, b);
        if (this._generation !== d)
            return null;
        if (!a)
            return this._textureState = "",
            null;
        this._textureState = "loaded";
        this._hasMetaData || (this._width = a.GetWidth(),
        this._height = a.GetHeight(),
        this._hasMetaData = !0);
        this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + (this._isRotated ? this._height : this._width), this._offsetY + (this._isRotated ? this._width : this._height));
        this._rcTex.divide(a.GetWidth(), a.GetHeight());
        this._quadTex.setFromRect(this._rcTex);
        this._isRotated && this._quadTex.rotatePointsAnticlockwise();
        return a
    }
    ReleaseTexture() {
        this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(),
        this._textureState = "",
        this._rcTex.set(0, 0, 0, 0),
        this._quadTex.setFromRect(this._rcTex))
    }
    GetTexture() {
        return this._imageAsset ? this._imageAsset.GetTexture() : null
    }
    GetTexRect() {
        return this._rcTex
    }
    GetTexQuad() {
        return this._quadTex
    }
    GetIImageInfo() {
        return this._iImageInfo
    }
    async ExtractImageToCanvas() {
        const a = await this._imageAsset.LoadToDrawable()
          , b = C3$jscomp$153.CreateCanvas(this._width, this._height)
          , d = b.getContext("2d");
        this._isRotated ? (d.rotate(Math.PI / -2),
        d.translate(-this._height, 0),
        d.drawImage(a, this._offsetX, this._offsetY, this._height, this._width, 0, 0, this._height, this._width)) : d.drawImage(a, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height);
        return b
    }
    async ExtractImageToBlobURL() {
        if (this._blobUrl)
            return this._blobUrl;
        var a = await this.ExtractImageToCanvas();
        a = await C3$jscomp$153.CanvasToBlob(a);
        return this._blobUrl = URL.createObjectURL(a)
    }
    ReleaseBlobURL() {
        this._blobUrl && (URL.revokeObjectURL(this._blobUrl),
        this._blobUrl = "")
    }
}
;
"use strict";
const C3$jscomp$154 = self.C3;
C3$jscomp$154.AnimationInfo = class extends C3$jscomp$154.DefendedBase {
    constructor(a) {
        super();
        this._name = a[0];
        this._speed = a[1];
        this._isLooping = !!a[2];
        this._repeatCount = a[3];
        this._repeatTo = a[4];
        this._isPingPong = !!a[5];
        this._sid = a[6];
        this._frames = a[7].map(b=>C3$jscomp$154.New(C3$jscomp$154.AnimationFrameInfo, b));
        this._iAnimation = new self.IAnimation(this)
    }
    Release() {
        for (const a of this._frames)
            a.Release();
        C3$jscomp$154.clearArray(this._frames)
    }
    LoadAllAssets(a) {
        for (const b of this._frames)
            b.GetImageInfo().LoadAsset(a)
    }
    LoadAllTextures(a, b) {
        return Promise.all(this._frames.map(d=>d.GetImageInfo().LoadStaticTexture(a, b)))
    }
    ReleaseAllTextures() {
        for (const a of this._frames)
            a.GetImageInfo().ReleaseTexture()
    }
    GetName() {
        return this._name
    }
    GetSID() {
        return this._sid
    }
    GetFrameCount() {
        return this._frames.length
    }
    GetFrames() {
        return this._frames
    }
    GetFrameAt(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._frames.length)
            throw new RangeError("invalid frame");
        return this._frames[a]
    }
    GetSpeed() {
        return this._speed
    }
    IsLooping() {
        return this._isLooping
    }
    GetRepeatCount() {
        return this._repeatCount
    }
    GetRepeatTo() {
        return this._repeatTo
    }
    IsPingPong() {
        return this._isPingPong
    }
    GetIAnimation() {
        return this._iAnimation
    }
}
;
"use strict";
const C3$jscomp$155 = self.C3;
C3$jscomp$155.AnimationFrameInfo = class extends C3$jscomp$155.DefendedBase {
    constructor(a) {
        super();
        this._imageInfo = C3$jscomp$155.New(C3$jscomp$155.ImageInfo);
        this._imageInfo.LoadData(a);
        this._duration = a[7];
        this._origin = C3$jscomp$155.New(C3$jscomp$155.Vector2, a[8], a[9]);
        this._imagePoints = a[10].map(b=>C3$jscomp$155.New(C3$jscomp$155.ImagePoint, this, b));
        this._imagePointsByName = new Map;
        for (const b of this._imagePoints)
            this._imagePointsByName.set(b.GetName().toLowerCase(), b);
        this._collisionPoly = null;
        a = a[11];
        6 <= a.length && (this._collisionPoly = C3$jscomp$155.New(C3$jscomp$155.CollisionPoly, a));
        this._iAnimationFrame = new self.IAnimationFrame(this)
    }
    Release() {
        this._collisionPoly && (this._collisionPoly.Release(),
        this._collisionPoly = null);
        this._imageInfo.Release();
        this._imageInfo = null
    }
    GetImageInfo() {
        return this._imageInfo
    }
    GetDuration() {
        return this._duration
    }
    GetOriginX() {
        return this._origin.getX()
    }
    GetOriginY() {
        return this._origin.getY()
    }
    GetCollisionPoly() {
        return this._collisionPoly
    }
    GetImagePointByName(a) {
        return this._imagePointsByName.get(a.toLowerCase()) || null
    }
    GetImagePointByIndex(a) {
        a = Math.floor(a);
        return 0 > a || a >= this._imagePoints.length ? null : this._imagePoints[a]
    }
    GetImagePointCount() {
        return this._imagePoints.length
    }
    GetIAnimationFrame() {
        return this._iAnimationFrame
    }
}
;
"use strict";
const C3$jscomp$156 = self.C3;
C3$jscomp$156.ImagePoint = class extends C3$jscomp$156.DefendedBase {
    constructor(a, b) {
        super();
        this._afi = a;
        this._name = b[0];
        this._pos = C3$jscomp$156.New(C3$jscomp$156.Vector2, b[1], b[2])
    }
    Release() {}
    GetName() {
        return this._name
    }
    GetX() {
        return this._pos.getX()
    }
    GetY() {
        return this._pos.getY()
    }
    GetVec2() {
        return this._pos
    }
}
;
"use strict";
const C3$jscomp$157 = self.C3
  , C3Debugger$jscomp$1 = self.C3Debugger
  , IObjectClass$jscomp$1 = self.IObjectClass;
C3$jscomp$157.ObjectClass = class extends C3$jscomp$157.DefendedBase {
    constructor(a, b, d) {
        super();
        const c = a.GetObjectReference(d[1]);
        this._runtime = a;
        this._plugin = a.GetPluginManager().GetPluginByConstructorFunction(c);
        this._sdkType = null;
        this._instSdkCtor = c.Instance;
        this._index = b;
        this._sid = d[11];
        this._name = d[0];
        this._jsPropName = this._runtime.GetJsPropName(d[14]);
        this._isGlobal = !!d[9];
        this._isFamily = !!d[2];
        this._isOnLoaderLayout = !!d[10];
        this._instVars = d[3].map(e=>({
            sid: e[0],
            type: e[1],
            name: e[2],
            jsPropName: a.GetJsPropName(e[3])
        }));
        this._behaviorsCount = d[4];
        this._effectsCount = d[5];
        this._isWorldType = this._plugin.IsWorldType();
        this._effectList = null;
        this._collisionGrid = C3$jscomp$157.New(C3$jscomp$157.SparseGrid, a.GetOriginalViewportWidth(), a.GetOriginalViewportHeight());
        this._anyCollisionCellChanged = !0;
        this._anyInstanceParallaxed = !1;
        this._familyMembersSet = this._familyMembers = null;
        this._familyIndex = -1;
        this._familyEffectMap = this._familyBehaviorMap = this._familyInstVarMap = this._familiesSet = this._families = null;
        this._isInContainer = !1;
        this._container = null;
        this._behaviorTypes = d[8].map(e=>C3$jscomp$157.BehaviorType.Create(this, e));
        this._behaviorTypesIncludingInherited = [];
        this._behaviorsByName = new Map;
        this._behaviorNameToIndex = new Map;
        this._usedBehaviorCtors = new Set;
        this._customActionMap = new Map;
        this._solStack = C3$jscomp$157.New(C3$jscomp$157.SolStack, this);
        this._defaultInstanceData = null;
        this._defaultLayerIndex = 0;
        this._isContained = !1;
        this._animationsBySid = this._animationsByName = this._animations = this._imageInfo = this._container = null;
        this._textureRefCount = 0;
        this._savedData = new Map;
        this._unsavedData = new Map;
        this._instances = [];
        this._iidsStale = !0;
        this._plugin.HasEffects() && (this._effectList = C3$jscomp$157.New(C3$jscomp$157.EffectList, this, d[12]));
        d[6] && (this._imageInfo = C3$jscomp$157.New(C3$jscomp$157.ImageInfo),
        this._imageInfo.LoadData(d[6]));
        if (d[7]) {
            this._animations = d[7].map(e=>C3$jscomp$157.New(C3$jscomp$157.AnimationInfo, e));
            this._animationsByName = new Map;
            this._animationsBySid = new Map;
            for (const e of this._animations)
                this._animationsByName.set(e.GetName().toLowerCase(), e),
                this._animationsBySid.set(e.GetSID(), e)
        }
        this._isFamily ? (this._familyMembers = [],
        this._familyMembersSet = new Set,
        this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [],
        this._familiesSet = new Set,
        this._familyInstVarMap = [],
        this._familyBehaviorMap = [],
        this._familyEffectMap = []);
        this._sdkType = C3$jscomp$157.New(c.Type, this, d[15]);
        this._instanceUserScriptClass = this._iObjectClass = null;
        this._userScriptDispatcher = C3$jscomp$157.New(C3$jscomp$157.Event.Dispatcher);
        if (b = this._sdkType.GetScriptInterfaceClass()) {
            if (this._iObjectClass = new b(this),
            !(this._iObjectClass instanceof IObjectClass$jscomp$1))
                throw new TypeError("script interface class must derive from IObjectClass");
        } else
            this._iObjectClass = new IObjectClass$jscomp$1(this);
        d[13] && (b = d[13]) && this._sdkType.LoadTilemapData(b[0], b[1], b[2]);
        this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate();
        this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this),
        this._CreateSingleGlobalInstance(d));
        this._loadInstancesJson = null
    }
    static Create(a, b, d) {
        return C3$jscomp$157.New(C3$jscomp$157.ObjectClass, a, b, d)
    }
    Release() {
        this._imageInfo && (this._imageInfo.Release(),
        this._imageInfo = null);
        if (this._animations) {
            for (const a of this._animations)
                a.Release();
            C3$jscomp$157.clearArray(this._animations);
            this._animationsByName.clear();
            this._animationsBySid.clear()
        }
        this._loadInstancesJson = null;
        this._solStack.Release();
        this._solStack = null;
        this._savedData.clear();
        this._unsavedData.clear();
        this._runtime = this._container = null
    }
    _LoadFamily(a) {
        for (let b = 1, d = a.length; b < d; ++b) {
            const c = this._runtime.GetObjectClassByIndex(a[b]);
            this._familyMembers.push(c);
            this._familyMembersSet.add(c);
            c._families.push(this);
            c._familiesSet.add(this)
        }
    }
    _SetContainer(a) {
        this._isInContainer = !0;
        this._container = a
    }
    IsInContainer() {
        return this._isInContainer
    }
    GetContainer() {
        return this._container
    }
    _OnAfterCreate() {
        var a = 0;
        if (!this._isFamily)
            for (var b of this._families)
                for (var d of b.GetBehaviorTypes()) {
                    const g = d.GetName().toLowerCase();
                    this._behaviorsByName.set(g, d);
                    this._behaviorNameToIndex.set(g, a);
                    this._behaviorTypesIncludingInherited.push(d);
                    ++a
                }
        for (var c of this.GetBehaviorTypes())
            b = c.GetName().toLowerCase(),
            this._behaviorsByName.set(b, c),
            this._behaviorNameToIndex.set(b, a),
            this._behaviorTypesIncludingInherited.push(c),
            ++a;
        for (var e of this._behaviorTypesIncludingInherited)
            this._usedBehaviorCtors.add(e.GetBehavior().constructor);
        if (!this._isFamily && this._families.length) {
            a = this._runtime.GetFamilyCount();
            C3$jscomp$157.extendArray(this._familyInstVarMap, a, 0);
            C3$jscomp$157.extendArray(this._familyBehaviorMap, a, 0);
            C3$jscomp$157.extendArray(this._familyEffectMap, a, 0);
            a = [];
            b = e = c = 0;
            for (const g of this._families)
                if (d = g.GetFamilyIndex(),
                this._familyInstVarMap[d] = c,
                c += g.GetInstanceVariablesCount(),
                this._familyBehaviorMap[d] = e,
                e += g.GetBehaviorTypesCount(),
                this._familyEffectMap[d] = b,
                b += g.GetEffectTypesCount(),
                (d = g.GetEffectList()) && this._effectList)
                    for (const k of d.GetAllEffectTypes())
                        a.push(k.Clone(this._effectList));
            this._effectList && this._effectList.PrependEffectTypes(a)
        }
    }
    _CreateSingleGlobalInstance(a) {
        const b = this._runtime._GetNewUID()
          , d = C3$jscomp$157.New(C3$jscomp$157.Instance, {
            runtime: this._runtime,
            objectType: this,
            uid: b
        });
        d._CreateSdkInstance(a[16], []);
        this._runtime._MapInstanceByUID(b, d);
        this._instances.push(d)
    }
    GetSdkType() {
        return this._sdkType
    }
    IsOnLoaderLayout() {
        return this._isOnLoaderLayout
    }
    OnCreate() {
        this._isFamily || this._sdkType.OnCreate()
    }
    HasLoadedTextures() {
        return 0 < this._textureRefCount
    }
    LoadTextures(a) {
        if (this._isFamily)
            return Promise.resolve();
        this._textureRefCount++;
        return 1 === this._textureRefCount ? this._sdkType.LoadTextures(a) || Promise.resolve() : Promise.resolve()
    }
    ReleaseTextures() {
        if (!this._isFamily) {
            this._textureRefCount--;
            if (0 > this._textureRefCount)
                throw Error("released textures too many times");
            0 === this._textureRefCount && this._sdkType.ReleaseTextures()
        }
    }
    OnDynamicTextureLoadComplete() {
        if (this._isFamily)
            throw Error("not applicable to family");
        this._sdkType.OnDynamicTextureLoadComplete()
    }
    PreloadTexturesWithInstances(a) {
        return this._isFamily ? Promise.resolve() : this._sdkType.PreloadTexturesWithInstances(a)
    }
    GetRuntime() {
        return this._runtime
    }
    GetPlugin() {
        return this._plugin
    }
    GetInstanceSdkCtor() {
        return this._instSdkCtor
    }
    GetName() {
        return this._name
    }
    GetJsPropName() {
        return this._jsPropName
    }
    GetIndex() {
        return this._index
    }
    GetSID() {
        return this._sid
    }
    IsFamily() {
        return this._isFamily
    }
    IsGlobal() {
        return this._isGlobal
    }
    IsWorldType() {
        return this._isWorldType
    }
    GetFamilyIndex() {
        return this._familyIndex
    }
    GetBehaviorTypes() {
        return this._behaviorTypes
    }
    GetBehaviorTypesCount() {
        return this._behaviorsCount
    }
    UsesBehaviorByCtor(a) {
        return a && this._usedBehaviorCtors.has(a)
    }
    GetInstanceVariablesCount() {
        return this._instVars.length
    }
    GetInstanceVariableSIDs() {
        return this._instVars.map(a=>a.sid)
    }
    GetInstanceVariableIndexBySID(a) {
        return this._instVars.findIndex(b=>b.sid === a)
    }
    GetInstanceVariableIndexByName(a) {
        return this._instVars.findIndex(b=>b.name === a)
    }
    _GetAllInstanceVariableNames() {
        return this._instVars.map(a=>a.name)
    }
    _GetAllInstanceVariableJsPropNames() {
        return this._instVars.map(a=>a.jsPropName)
    }
    GetInstanceVariableType(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._instVars.length)
            throw new RangeError("invalid instance variable index");
        return this._instVars[a].type
    }
    GetInstanceVariableName(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._instVars.length)
            throw new RangeError("invalid instance variable index");
        return this._instVars[a].name
    }
    GetEffectTypesCount() {
        return this._effectsCount
    }
    GetBehaviorTypesIncludingInherited() {
        return this._behaviorTypesIncludingInherited
    }
    GetBehaviorTypeByName(a) {
        return this._behaviorsByName.get(a.toLowerCase()) || null
    }
    GetBehaviorIndexByName(a) {
        a = this._behaviorNameToIndex.get(a.toLowerCase());
        return "undefined" === typeof a ? -1 : a
    }
    GetEffectList() {
        return this._effectList
    }
    HasEffects() {
        return this._plugin.HasEffects()
    }
    UsesEffects() {
        return this._effectList && this._effectList.HasAnyEffectType()
    }
    GetSolStack() {
        return this._solStack
    }
    GetCurrentSol() {
        return this._solStack.GetCurrentSol()
    }
    GetImageInfo() {
        return this._imageInfo
    }
    SetDefaultInstanceData(a) {
        this._defaultInstanceData = a
    }
    GetDefaultInstanceData() {
        return this._defaultInstanceData
    }
    _SetDefaultLayerIndex(a) {
        this._defaultLayerIndex = a
    }
    GetDefaultLayerIndex() {
        return this._defaultLayerIndex
    }
    GetAnimations() {
        return this._animations
    }
    GetAnimationCount() {
        return this._animations.length
    }
    GetFamilies() {
        return this._families
    }
    BelongsToFamily(a) {
        return this._familiesSet.has(a)
    }
    GetFamilyMembers() {
        return this._familyMembers
    }
    FamilyHasMember(a) {
        return this._familyMembersSet.has(a)
    }
    GetFamilyBehaviorOffset(a) {
        return this._familyBehaviorMap[a]
    }
    GetFamilyInstanceVariableOffset(a) {
        return this._familyInstVarMap[a]
    }
    AddCustomAction(a) {
        this._customActionMap.set(a.GetACEName().toLowerCase(), a)
    }
    HasOwnCustomActionByName(a) {
        return !!this.GetOwnCustomActionByName(a)
    }
    GetOwnCustomActionByName(a) {
        return (a = this._customActionMap.get(a.toLowerCase())) && a.IsEnabled() ? a : null
    }
    GetAnimationByName(a) {
        if (!this._animations)
            throw Error("no animations");
        return this._animationsByName.get(a.toLowerCase()) || null
    }
    GetAnimationBySID(a) {
        if (!this._animations)
            throw Error("no animations");
        return this._animationsBySid.get(a) || null
    }
    GetFirstAnimationFrame() {
        if (!this._animations)
            throw Error("no animations");
        return this._animations[0].GetFrameAt(0)
    }
    GetDefaultInstanceSize() {
        if (this._animations) {
            const a = this.GetFirstAnimationFrame().GetImageInfo();
            return [a.GetWidth(), a.GetHeight()]
        }
        return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100]
    }
    GetSingleGlobalInstance() {
        if (!this._plugin.IsSingleGlobal())
            throw Error("not a single-global plugin");
        return this._instances[0]
    }
    GetInstances() {
        return this._instances
    }
    *instances() {
        yield*this._instances
    }
    *instancesIncludingPendingCreate() {
        yield*this._instances;
        yield*this._runtime.instancesPendingCreateForObjectClass(this)
    }
    GetInstanceCount() {
        return this._instances.length
    }
    _AddInstance(a) {
        this._instances.push(a)
    }
    _SetIIDsStale() {
        this._iidsStale = !0
    }
    _UpdateIIDs() {
        if (this._iidsStale && !this._isFamily) {
            var a = this._instances
              , b = 0;
            for (let d = a.length; b < d; ++b)
                a[b]._SetIID(b);
            a = this._runtime._GetInstancesPendingCreate();
            for (const d of a)
                d.GetObjectClass() === this && d._SetIID(b++);
            this._iidsStale = !1
        }
    }
    GetInstanceByIID(a) {
        var b = this._instances;
        if (a < b.length)
            return b[a];
        a -= b.length;
        b = this._runtime._GetInstancesPendingCreate();
        for (const d of b)
            if (d.GetObjectClass() === this) {
                if (0 === a)
                    return d;
                --a
            }
        return null
    }
    GetFirstPicked(a) {
        if (a && a.IsInContainer() && a.GetObjectClass() !== this)
            for (const b of a.siblings())
                if (b.GetObjectClass() === this)
                    return b;
        a = this.GetCurrentSol().GetInstances();
        return a.length ? a[0] : null
    }
    GetPairedInstance(a) {
        const b = this.GetCurrentSol().GetInstances();
        return 0 < b.length ? b[a.GetIID() % b.length] : null
    }
    *allCorrespondingInstances(a, b) {
        const d = this.GetCurrentSol().GetInstances();
        var c = d.length;
        const e = b.GetCurrentSol()
          , g = b.GetCurrentSol().GetInstances()
          , k = g.length;
        var l = a.GetIID();
        if (b.IsFamily() || !e.IsSelectAll())
            l = g.indexOf(a);
        a = Math.ceil(c / k);
        c %= k;
        0 === c || l < c ? (l *= a,
        c = a) : (l = c * a + (l - c) * (a - 1),
        c = a - 1);
        for (let n = l, p = l + c; n < p; ++n)
            yield d[n]
    }
    FinishCondition(a) {
        this._sdkType.FinishCondition(a)
    }
    ApplySolToContainer() {
        if (this._isInContainer && !this._isFamily) {
            this._UpdateIIDs();
            var a = this.GetCurrentSol()
              , b = a._GetOwnInstances()
              , d = a.IsSelectAll()
              , c = this._runtime.GetCurrentEventStackFrame();
            c = c && c.GetCurrentEvent() && c.GetCurrentEvent().IsOrBlock();
            for (const k of this._container.objectTypes())
                if (k !== this) {
                    k._UpdateIIDs();
                    var e = k.GetCurrentSol();
                    e._SetSelectAll(d);
                    if (!d) {
                        var g = e._GetOwnInstances();
                        C3$jscomp$157.clearArray(g);
                        for (const l of b)
                            g.push(k.GetInstanceByIID(l.GetIID()));
                        if (c) {
                            g = a._GetOwnElseInstances();
                            e = e._GetOwnElseInstances();
                            C3$jscomp$157.clearArray(e);
                            for (const l of g)
                                e.push(k.GetInstanceByIID(l.GetIID()))
                        }
                    }
                }
        }
    }
    _TruncateContainerSols(a, b) {
        for (const d of this.GetContainer().objectTypes()) {
            const c = d.GetCurrentSol();
            a ? C3$jscomp$157.truncateArray(c._GetOwnElseInstances(), b) : C3$jscomp$157.truncateArray(c._GetOwnInstances(), b)
        }
    }
    _GetCollisionCellGrid() {
        return this._collisionGrid
    }
    _SetAnyCollisionCellChanged(a) {
        this._anyCollisionCellChanged = !!a
    }
    _SetAnyInstanceParallaxed(a) {
        this._anyInstanceParallaxed = !!a
    }
    IsAnyInstanceParallaxed() {
        return this._anyInstanceParallaxed
    }
    _UpdateAllCollisionCells() {
        if (this._anyCollisionCellChanged && this._isWorldType) {
            for (const a of this._instances)
                a.GetWorldInfo()._UpdateCollisionCell();
            for (const a of this._runtime._GetInstancesPendingCreate())
                a.GetObjectClass() === this && a.GetWorldInfo()._UpdateCollisionCell();
            this._anyCollisionCellChanged = !1
        }
    }
    GetSavedDataMap() {
        this._savedData || (this._savedData = new Map);
        return this._savedData
    }
    GetUnsavedDataMap() {
        this._unsavedData || (this._unsavedData = new Map);
        return this._unsavedData
    }
    HasSolidBehavior() {
        return this.UsesBehaviorByCtor(C3$jscomp$157.Behaviors.solid)
    }
    HasJumpthruBehavior() {
        return this.UsesBehaviorByCtor(C3$jscomp$157.Behaviors.jumpthru)
    }
    HasNoSaveBehavior() {
        return this.UsesBehaviorByCtor(C3$jscomp$157.Behaviors.NoSave)
    }
    HasPersistBehavior() {
        return this.UsesBehaviorByCtor(C3$jscomp$157.Behaviors.Persist)
    }
    _SaveToJson() {
        const a = {
            instances: this._instances.map(b=>b.SaveToJson())
        };
        this._savedData && this._savedData.size && (a.ex = C3$jscomp$157.ToSuperJSON(this._savedData));
        return a
    }
    _LoadFromJson(a) {
        this._savedData && (this._savedData.clear(),
        this._savedData = null);
        var b = a.ex;
        b && (this._savedData = C3$jscomp$157.FromSuperJSON(b));
        b = this._instances;
        a = a.instances;
        for (let d = 0, c = Math.min(b.length, a.length); d < c; ++d)
            b[d].LoadFromJson(a[d]);
        for (let d = a.length, c = b.length; d < c; ++d)
            this._runtime.DestroyInstance(b[d]);
        for (let d = b.length, c = a.length; d < c; ++d) {
            b = a[d];
            let e = null;
            if (this.IsWorldType() && (e = this._runtime.GetMainRunningLayout().GetLayerBySID(b.w.l),
            !e))
                continue;
            this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, e, !1, 0, 0, !0).LoadFromJson(b)
        }
        this._loadInstancesJson = a;
        this._SetIIDsStale()
    }
    _GetLoadInstancesJson() {
        return this._loadInstancesJson
    }
    _ClearLoadInstancesJson() {
        this._loadInstancesJson = null
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
        for (let a = 0, b = this._instances; a < b; ++a)
            this._instances[a]._SetupSceneGraphConnectionsOnChangeOfLayout()
    }
    GetIObjectClass() {
        return this._iObjectClass
    }
    UserScriptDispatcher() {
        return this._userScriptDispatcher
    }
    _GetUserScriptInstanceClass() {
        return this._instanceUserScriptClass
    }
    _SetUserScriptInstanceClass(a) {
        this._instanceUserScriptClass = a
    }
    DispatchUserScriptEvent(a) {
        var b = this._runtime;
        (b = b.IsDebug() && !b.GetEventSheetManager().IsInEventEngine()) && C3Debugger$jscomp$1.StartMeasuringScriptTime();
        this._userScriptDispatcher.dispatchEvent(a);
        b && C3Debugger$jscomp$1.AddScriptTime()
    }
}
;
"use strict";
const C3$jscomp$158 = self.C3;
C3$jscomp$158.Container = class extends C3$jscomp$158.DefendedBase {
    constructor(a, b) {
        super();
        this._runtime = a;
        this._objectTypes = b;
        for (const d of this._objectTypes)
            d._SetContainer(this)
    }
    Release() {
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectTypes() {
        return this._objectTypes
    }
    objectTypes() {
        return this._objectTypes
    }
    HasAnyWorldType() {
        return this._objectTypes.some(a=>a.IsWorldType())
    }
}
;
"use strict";
const C3$jscomp$159 = self.C3
  , C3Debugger$jscomp$2 = self.C3Debugger
  , IInstance$jscomp$2 = self.IInstance
  , EMPTY_ARRAY$jscomp$1 = [];
let nextPuid = 0;
const savedDataMaps = new WeakMap
  , unsavedDataMaps = new WeakMap
  , FLAG_DESTROYED = 1
  , FLAG_TILEMAP = 2
  , FLAG_MUST_PREDRAW = 4
  , FLAG_SOLID_ENABLED = 8
  , FLAG_JUMPTHRU_ENABLED = 16
  , FLAG_MUST_MITIGATE_Z_FIGHTING = 32
  , FLAG_IS_DRAWING_WITH_EFFECTS = 64;
C3$jscomp$159.Instance = class extends C3$jscomp$159.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a.runtime;
        this._objectType = a.objectType;
        this._iScriptInterface = this._sdkInst = this._worldInfo = null;
        this._iid = 0;
        this._uid = a.uid;
        this._puid = nextPuid++;
        this._flags = 0;
        this._behaviorInstances = this._instVarValues = EMPTY_ARRAY$jscomp$1;
        var b = this._objectType.GetBehaviorTypesIncludingInherited();
        0 < b.length && (this._behaviorInstances = b.map((d,c)=>C3$jscomp$159.New(C3$jscomp$159.BehaviorInstance, {
            runtime: this._runtime,
            behaviorType: d,
            instance: this,
            index: c
        })));
        this._siblings = this._objectType.IsInContainer() ? [] : null;
        this._timeScale = -1;
        this._dispatcher = null;
        b = this.GetPlugin();
        b.MustPreDraw() && (this._flags |= FLAG_MUST_PREDRAW);
        if (b.IsWorldType())
            if (this._worldInfo = C3$jscomp$159.New(C3$jscomp$159.WorldInfo, this, a.layer),
            a.worldData)
                this._worldInfo.Init(a.worldData);
            else {
                this._worldInfo.InitNoData();
                const [d,c] = this._objectType.GetDefaultInstanceSize();
                this._worldInfo.SetSize(d, c);
                this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters()
            }
        a.instVarData ? this._LoadInstanceVariableData(a.instVarData) : this._LoadDefaultInstanceVariables()
    }
    Release() {
        this._iScriptInterface && (this._iScriptInterface._Release(),
        this._iScriptInterface = null);
        if (0 < this._behaviorInstances.length) {
            for (var a of this._behaviorInstances)
                a.Release();
            C3$jscomp$159.clearArray(this._behaviorInstances)
        }
        this._sdkInst.Release();
        this._sdkInst = null;
        if (a = savedDataMaps.get(this))
            a.clear(),
            savedDataMaps.delete(this);
        if (a = unsavedDataMaps.get(this))
            a.clear(),
            unsavedDataMaps.delete(this);
        this._siblings && C3$jscomp$159.clearArray(this._siblings);
        this._dispatcher && (this._dispatcher.Release(),
        this._dispatcher = null);
        this._objectType = this._runtime = null;
        0 < this._instVarValues.length && C3$jscomp$159.clearArray(this._instVarValues);
        this._worldInfo && (this._worldInfo.Release(),
        this._worldInfo = null)
    }
    _LoadInstanceVariableData(a) {
        0 < a.length && (this._instVarValues = [],
        C3$jscomp$159.shallowAssignArray(this._instVarValues, a))
    }
    _LoadDefaultInstanceVariables() {
        const a = this._objectType.GetInstanceVariablesCount();
        if (0 !== a) {
            this._instVarValues = [];
            var b = [0, 0, ""];
            for (let d = 0; d < a; ++d)
                this._instVarValues.push(b[this._objectType.GetInstanceVariableType(d)])
        }
    }
    _CreateSdkInstance(a, b) {
        if (this._sdkInst)
            throw Error("already got sdk instance");
        for (let d = 0, c = this._behaviorInstances.length; d < c; ++d)
            this._behaviorInstances[d]._CreateSdkInstance(b ? b[d] : null);
        this._sdkInst = C3$jscomp$159.New(this._objectType.GetInstanceSdkCtor(), this, a);
        if (!(this._sdkInst instanceof C3$jscomp$159.SDKInstanceBase))
            throw Error("sdk type must derive from SDKInstanceBase");
        for (let d = 0, c = this._behaviorInstances.length; d < c; ++d)
            this._behaviorInstances[d].PostCreate()
    }
    GetSdkInstance() {
        return this._sdkInst
    }
    GetWorldInfo() {
        return this._worldInfo
    }
    GetRuntime() {
        return this._runtime
    }
    GetTimeScale() {
        return this._timeScale
    }
    GetActiveTimeScale() {
        const a = this._timeScale;
        return -1 === a ? this.GetRuntime().GetTimeScale() : a
    }
    SetTimeScale(a) {
        a = +a;
        if (0 > a || !isFinite(a))
            a = 0;
        this._timeScale = a;
        this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, !0)
    }
    RestoreTimeScale() {
        this._timeScale = -1;
        this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, !1)
    }
    GetInstanceGameTime() {
        return this._runtime._GetInstanceGameTime(this)
    }
    Dispatcher() {
        this._dispatcher || (this._dispatcher = C3$jscomp$159.New(C3$jscomp$159.Event.Dispatcher));
        return this._dispatcher
    }
    Draw(a) {
        this._sdkInst.Draw(a)
    }
    OnCreate(a) {
        this._sdkInst.OnCreate(a)
    }
    _SetHasTilemap() {
        this._flags |= FLAG_TILEMAP
    }
    HasTilemap() {
        return 0 !== (this._flags & FLAG_TILEMAP)
    }
    _MarkDestroyed() {
        this._flags |= FLAG_DESTROYED
    }
    IsDestroyed() {
        return 0 !== (this._flags & FLAG_DESTROYED)
    }
    MustPreDraw() {
        return 0 !== (this._flags & FLAG_MUST_PREDRAW)
    }
    SetMustMitigateZFighting() {
        this._flags |= FLAG_MUST_MITIGATE_Z_FIGHTING
    }
    MustMitigateZFighting() {
        return 0 !== (this._flags & FLAG_MUST_MITIGATE_Z_FIGHTING)
    }
    _IsSolidEnabled() {
        return 0 !== (this._flags & FLAG_SOLID_ENABLED)
    }
    _SetSolidEnabled(a) {
        this._flags = a ? this._flags | FLAG_SOLID_ENABLED : this._flags & ~FLAG_SOLID_ENABLED
    }
    _IsJumpthruEnabled() {
        return 0 !== (this._flags & FLAG_JUMPTHRU_ENABLED)
    }
    _SetJumpthruEnabled(a) {
        this._flags = a ? this._flags | FLAG_JUMPTHRU_ENABLED : this._flags & ~FLAG_JUMPTHRU_ENABLED
    }
    _IsDrawingWithEffects() {
        return 0 !== (this._flags & FLAG_IS_DRAWING_WITH_EFFECTS)
    }
    _SetIsDrawingWithEffects(a) {
        this._flags = a ? this._flags | FLAG_IS_DRAWING_WITH_EFFECTS : this._flags & ~FLAG_IS_DRAWING_WITH_EFFECTS
    }
    SetFlag(a, b) {
        a <<= 16;
        this._flags = b ? this._flags | a : this._flags & ~a
    }
    GetFlag(a) {
        return 0 !== (this._flags & a << 16)
    }
    GetCurrentImageInfo() {
        return this._sdkInst.GetCurrentImageInfo()
    }
    GetCurrentSurfaceSize() {
        return this._sdkInst.GetCurrentSurfaceSize()
    }
    GetCurrentTexRect() {
        return this._sdkInst.GetCurrentTexRect()
    }
    GetCurrentTexQuad() {
        return this._sdkInst.GetCurrentTexQuad()
    }
    IsCurrentTexRotated() {
        return this._sdkInst.IsCurrentTexRotated()
    }
    GetImagePoint(a) {
        return this._sdkInst.GetImagePoint(a)
    }
    GetObjectClass() {
        return this._objectType
    }
    RendersToOwnZPlane() {
        return this._sdkInst.RendersToOwnZPlane()
    }
    BelongsToObjectClass(a) {
        return a.IsFamily() ? a.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === a
    }
    CollectInstancesToPick(a, b, d) {
        const c = (e,g)=>{
            g = g || e.GetObjectClass();
            const k = a.get(g);
            k ? k.add(e) : a.set(g, new Set([e]))
        }
        ;
        c(this, b);
        if (this.IsInContainer())
            for (const e of this.siblings())
                c(e);
        if (d)
            for (const e of this.allChildren())
                c(e)
    }
    VerifySupportsSceneGraph() {
        if (!this.GetPlugin().SupportsSceneGraph())
            throw Error("object does not support scene graph");
    }
    HasParent() {
        return null !== this.GetParent()
    }
    GetParent() {
        var a = this.GetWorldInfo();
        return a ? (a = a.GetParent()) ? a.GetInstance() : null : null
    }
    GetTopParent() {
        var a = this.GetWorldInfo();
        return a ? (a = a.GetTopParent()) ? a.GetInstance() : null : null
    }
    *parents() {
        const a = this.GetWorldInfo();
        if (a)
            for (const b of a.parents())
                yield b.GetInstance()
    }
    HasChild(a) {
        if (!a)
            return !1;
        for (const b of this.children())
            if (b === a)
                return !0;
        return !1
    }
    HasChildren() {
        const a = this.GetWorldInfo();
        return a ? a.HasChildren() : !1
    }
    GetChildrenOfObjectClass(a) {
        const b = this.GetWorldInfo();
        if (!b)
            return [];
        const d = a.GetName();
        return b.GetChildren().map(c=>c.GetInstance()).filter(c=>c.GetObjectClass().GetName() === d)
    }
    GetChildren() {
        const a = this.GetWorldInfo();
        return a ? a.GetChildren().map(b=>b.GetInstance()) : []
    }
    *children() {
        const a = this.GetWorldInfo();
        if (a)
            for (const b of a.children())
                yield b.GetInstance()
    }
    *allChildren() {
        const a = this.GetWorldInfo();
        if (a)
            for (const b of a.allChildren())
                yield b.GetInstance()
    }
    GetChildCount() {
        const a = this.GetWorldInfo();
        return a ? a.GetChildCount() : 0
    }
    GetParentCount() {
        return [...this.parents()].length
    }
    GetAllChildCount() {
        const a = this.GetWorldInfo();
        return a ? a.GetAllChildCount() : 0
    }
    GetChildAt(a) {
        const b = this.GetWorldInfo();
        return b ? (a = b.GetChildAt(a)) ? a.GetInstance() : null : null
    }
    AddChild(a, b) {
        this.VerifySupportsSceneGraph();
        a.VerifySupportsSceneGraph();
        this.GetWorldInfo().AddChild(a.GetWorldInfo(), b || {})
    }
    RemoveChild(a) {
        const b = this.GetWorldInfo();
        b && b.RemoveChild(a.GetWorldInfo())
    }
    GetDestroyWithParent() {
        const a = this.GetWorldInfo();
        return a ? a.GetDestroyWithParent() : !1
    }
    SetupInitialSceneGraphConnections() {
        var a = this.GetWorldInfo();
        if (a && (a = a.GetSceneGraphChildrenExportData()))
            for (const b of a)
                if (a = this._runtime.GetInstanceByUID(b[2])) {
                    const d = b[3];
                    this.AddChild(a, {
                        transformX: !!(d >> 0 & 1),
                        transformY: !!(d >> 1 & 1),
                        transformWidth: !!(d >> 2 & 1),
                        transformHeight: !!(d >> 3 & 1),
                        transformAngle: !!(d >> 4 & 1),
                        destroyWithParent: !!(d >> 5 & 1),
                        transformZElevation: !!(d >> 6 & 1),
                        transformOpacity: !!(d >> 7 & 1),
                        transformVisibility: !!(d >> 8 & 1)
                    })
                }
    }
    SetupPersistedSceneGraphConnections(a, b) {
        if (a = a.get(this))
            for (const d of a.sceneGraphJson.children) {
                a = b.get(d.index);
                if (!a)
                    continue;
                const c = d.flags;
                this.AddChild(a, {
                    transformX: !!(c >> 0 & 1),
                    transformY: !!(c >> 1 & 1),
                    transformWidth: !!(c >> 2 & 1),
                    transformHeight: !!(c >> 3 & 1),
                    transformAngle: !!(c >> 4 & 1),
                    destroyWithParent: !!(c >> 5 & 1),
                    transformZElevation: !!(c >> 6 & 1),
                    transformOpacity: !!(c >> 7 & 1),
                    transformVisibility: !!(c >> 8 & 1)
                })
            }
    }
    GetTemplateName() {
        const a = this._runtime.GetTemplateManager();
        return a ? a.GetInstanceTemplateName(this) : ""
    }
    IsInContainer() {
        return null !== this._siblings
    }
    _AddSibling(a) {
        this._siblings.push(a)
    }
    GetSiblings() {
        return this._siblings
    }
    HasSibling(a) {
        return !!this.GetSibling(a)
    }
    GetSibling(a) {
        const b = this.siblings();
        if (null === b || 0 === b.length)
            return !1;
        for (const d of b)
            if (d.GetObjectClass() === a)
                return d;
        return null
    }
    siblings() {
        return this._siblings
    }
    SetSiblingsSinglePicked() {
        for (const a of this.siblings())
            a.GetObjectClass().GetCurrentSol().SetSinglePicked(a)
    }
    _PushSiblingsToSolInstances() {
        for (const a of this.siblings())
            a.GetObjectClass().GetCurrentSol()._PushInstance(a)
    }
    _SetSiblingsToSolInstancesIndex(a) {
        for (const b of this.siblings())
            b.GetObjectClass().GetCurrentSol()._GetOwnInstances()[a] = b
    }
    _PushSiblingsToSolElseInstances() {
        for (const a of this.siblings())
            a.GetObjectClass().GetCurrentSol()._PushElseInstance(a)
    }
    _SetSiblingsToSolElseInstancesIndex(a) {
        for (const b of this.siblings())
            b.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[a] = b
    }
    GetPlugin() {
        return this._objectType.GetPlugin()
    }
    _SetIID(a) {
        this._iid = a
    }
    GetIID() {
        this._objectType._UpdateIIDs();
        return this._iid
    }
    GetUID() {
        return this._uid
    }
    GetPUID() {
        return this._puid
    }
    GetBehaviorInstances() {
        return this._behaviorInstances
    }
    GetBehaviorInstanceFromCtor(a) {
        if (!a)
            return null;
        for (const b of this._behaviorInstances)
            if (b.GetBehavior()instanceof a)
                return b;
        return null
    }
    GetBehaviorSdkInstanceFromCtor(a) {
        return a ? (a = this.GetBehaviorInstanceFromCtor(a)) ? a.GetSdkInstance() : null : null
    }
    GetBehaviorIndexBySID(a) {
        const b = this._behaviorInstances;
        for (let d = 0, c = b.length; d < c; ++d)
            if (b[d].GetBehaviorType().GetSID() === a)
                return d;
        return -1
    }
    GetAllInstanceVariableValues() {
        return this._instVarValues
    }
    _GetAllInstanceVariableNames() {
        return this._objectType._GetAllInstanceVariableNames()
    }
    GetInstanceVariableCount() {
        return this._instVarValues.length
    }
    GetInstanceVariableValue(a) {
        a |= 0;
        const b = this._instVarValues;
        if (0 > a || a >= b.length)
            throw new RangeError("invalid instance variable");
        return b[a]
    }
    _GetInstanceVariableValueUnchecked(a) {
        return this._instVarValues[a]
    }
    _GetInstanceVariableTypedValue(a) {
        const b = this._instVarValues[a];
        return 0 === this._objectType.GetInstanceVariableType(a) ? !!b : b
    }
    SetInstanceVariableValue(a, b) {
        a |= 0;
        const d = this._instVarValues;
        if (0 > a || a >= d.length)
            throw new RangeError("invalid instance variable");
        switch (this._objectType.GetInstanceVariableType(a)) {
        case 0:
            d[a] = b ? 1 : 0;
            break;
        case 1:
            d[a] = "number" === typeof b ? b : parseFloat(b);
            break;
        case 2:
            d[a] = "string" === typeof b ? b : b.toString();
            break;
        default:
            throw Error("unknown instance variable type");
        }
    }
    SetInstanceVariableOffset(a, b) {
        if (0 !== b) {
            a |= 0;
            var d = this._instVarValues;
            if (0 > a || a >= d.length)
                throw new RangeError("invalid instance variable");
            var c = d[a];
            if ("number" === typeof c)
                d[a] = "number" === typeof b ? d[a] + b : d[a] + parseFloat(b);
            else {
                if ("boolean" === typeof c)
                    throw Error("can not set offset of boolean variable");
                if ("string" === typeof c)
                    throw Error("can not set offset of string variable");
                throw Error("unknown instance variable type");
            }
        }
    }
    GetSavedDataMap() {
        let a = savedDataMaps.get(this);
        if (a)
            return a;
        a = new Map;
        savedDataMaps.set(this, a);
        return a
    }
    GetUnsavedDataMap() {
        let a = unsavedDataMaps.get(this);
        if (a)
            return a;
        a = new Map;
        unsavedDataMaps.set(this, a);
        return a
    }
    _HasAnyCreateDestroyHandler(a) {
        const b = this.GetObjectClass();
        if (b.UserScriptDispatcher().HasAnyHandlerFor(a))
            return !0;
        for (const d of b.GetFamilies())
            if (d.UserScriptDispatcher().HasAnyHandlerFor(a))
                return !0;
        return this._runtime.UserScriptDispatcher().HasAnyHandlerFor(a) ? !0 : !1
    }
    _TriggerOnCreatedOnSelfAndRelated() {
        const a = new Set;
        a.add(this);
        const b = this.GetWorldInfo();
        if (b && b.HasChildren())
            for (const d of this.allChildren())
                if (a.add(d),
                d.IsInContainer())
                    for (const c of d.siblings())
                        a.add(c);
        if (this.IsInContainer())
            for (const d of this.siblings())
                a.add(d);
        for (const d of a.values())
            d._TriggerOnCreated()
    }
    _TriggerOnCreated() {
        this._objectType._GetUserScriptInstanceClass() && this._InitUserScriptInterface();
        if (this._HasAnyCreateDestroyHandler("instancecreate")) {
            const a = this.GetObjectClass()
              , b = new C3$jscomp$159.Event("instancecreate");
            b.instance = this.GetInterfaceClass();
            a.DispatchUserScriptEvent(b);
            for (const d of a.GetFamilies())
                d.DispatchUserScriptEvent(b);
            this._runtime.DispatchUserScriptEvent(b)
        }
        this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnCreated, this, null)
    }
    _TriggerOnDestroyed() {
        this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnDestroyed, this, null)
    }
    _FireDestroyedScriptEvents(a) {
        if (this._iScriptInterface) {
            var b = new C3$jscomp$159.Event("destroy");
            b.isEndingLayout = a;
            this.DispatchUserScriptEvent(b)
        }
        if (this._HasAnyCreateDestroyHandler("instancedestroy")) {
            b = this.GetObjectClass();
            var d = new C3$jscomp$159.Event("instancedestroy");
            d.instance = this.GetInterfaceClass();
            d.isEndingLayout = a;
            b.DispatchUserScriptEvent(d);
            for (const c of b.GetFamilies())
                c.DispatchUserScriptEvent(d);
            this._runtime.DispatchUserScriptEvent(d)
        }
    }
    _GetDebuggerProperties() {
        return this._sdkInst.GetDebuggerProperties()
    }
    SaveToJson(a="full") {
        const b = {};
        "full" === a ? b.uid = this.GetUID() : b.c3 = !0;
        if ("visual-state" !== a) {
            var d = savedDataMaps.get(this);
            d && d.size && (b.ex = C3$jscomp$159.ToSuperJSON(d));
            -1 !== this.GetTimeScale() && (b.mts = this.GetTimeScale());
            if (0 < this._objectType.GetInstanceVariablesCount()) {
                d = {};
                var c = this._objectType.GetInstanceVariableSIDs();
                for (let e = 0, g = this._instVarValues.length; e < g; ++e)
                    d[c[e].toString()] = this._instVarValues[e];
                b.ivs = d
            }
            if (this._behaviorInstances.length) {
                d = {};
                for (const e of this._behaviorInstances)
                    (c = e.SaveToJson()) && (d[e.GetBehaviorType().GetSID().toString()] = c);
                b.behs = d
            }
        }
        this._worldInfo && (b.w = this._worldInfo._SaveToJson(a));
        (a = this._sdkInst.SaveToJson()) && (b.data = a);
        return b
    }
    _OnBeforeLoad(a="full") {
        this._worldInfo && this._worldInfo._OnBeforeLoad(a)
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
        this.GetPlugin().IsWorldType() && this._worldInfo._SetupSceneGraphConnectionsOnChangeOfLayout()
    }
    LoadFromJson(a, b="full") {
        if ("full" === b)
            this._uid = a.uid;
        else if (!a.c3)
            return;
        if ("visual-state" !== b) {
            var d = savedDataMaps.get(this);
            d && (d.clear(),
            savedDataMaps.delete(this));
            if (d = a.ex)
                d = C3$jscomp$159.FromSuperJSON(d),
                savedDataMaps.set(this, d);
            this._timeScale = a.hasOwnProperty("mts") ? a.mts : -1;
            if (d = a.ivs)
                for (const [g,k] of Object.entries(d))
                    if (d = parseInt(g, 10),
                    d = this._objectType.GetInstanceVariableIndexBySID(d),
                    !(0 > d || d >= this._instVarValues.length)) {
                        var c = k;
                        null === c && (c = NaN);
                        this._instVarValues[d] = c
                    }
        }
        if (this.GetPlugin().IsWorldType()) {
            d = a.w;
            var e = d.l;
            this._worldInfo.GetLayer().GetSID() !== e && (c = this._worldInfo.GetLayer(),
            (e = c.GetLayout().GetLayerBySID(e)) ? (this._worldInfo._SetLayer(e),
            c._RemoveInstance(this, !0),
            e._AddInstance(this, !0),
            e.SetZIndicesChanged(),
            this._worldInfo.SetBboxChanged()) : "full" === b && this._runtime.DestroyInstance(this));
            this._worldInfo._LoadFromJson(d, b)
        }
        if ("visual-state" !== b && (d = a.behs))
            for (const [g,k] of Object.entries(d))
                d = parseInt(g, 10),
                d = this.GetBehaviorIndexBySID(d),
                0 > d || d >= this._behaviorInstances.length || this._behaviorInstances[d].LoadFromJson(k);
        (a = a.data) && this._sdkInst.LoadFromJson(a, b)
    }
    GetInterfaceClass() {
        return this._iScriptInterface || this._InitUserScriptInterface()
    }
    HasScriptInterface() {
        return !!this._iScriptInterface
    }
    _InitUserScriptInterface() {
        var a = this._worldInfo ? self.IWorldInstance : IInstance$jscomp$2;
        const b = this._sdkInst.GetScriptInterfaceClass()
          , d = this._objectType._GetUserScriptInstanceClass()
          , c = d || b || a;
        IInstance$jscomp$2._Init(this);
        this._iScriptInterface = new c;
        IInstance$jscomp$2._Init(null);
        if (b && !(this._iScriptInterface instanceof a))
            throw new TypeError(`script interface class '${b.name}' does not extend the right base class '${a.name}'`);
        if (d && (a = b || a,
        !(this._iScriptInterface instanceof a)))
            throw new TypeError(`setInstanceClass(): class '${d.name}' does not extend the right base class '${a.name}'`);
        return this._iScriptInterface
    }
    _GetInstVarsScriptDescriptor(a) {
        if (0 !== this._instVarValues.length) {
            var b = {}
              , d = this._objectType._GetAllInstanceVariableJsPropNames();
            for (let c = 0, e = d.length; c < e; ++c)
                b[d[c]] = {
                    configurable: !1,
                    enumerable: !0,
                    get: C3$jscomp$159.Instance.prototype._GetInstanceVariableTypedValue.bind(this, c),
                    set: C3$jscomp$159.Instance.prototype.SetInstanceVariableValue.bind(this, c)
                };
            b = Object.create(Object.prototype, b);
            a.instVars = {
                value: b,
                writable: !1
            }
        }
    }
    _GetBehaviorsScriptDescriptor(a) {
        var b = this._behaviorInstances;
        if (0 !== b.length) {
            var d = {};
            for (const c of b)
                d[c.GetBehaviorType().GetJsPropName()] = {
                    value: c.GetScriptInterface(),
                    writable: !1
                };
            b = Object.create(Object.prototype, d);
            a.behaviors = {
                value: b,
                writable: !1
            }
        }
    }
    DispatchUserScriptEvent(a) {
        if (this.HasScriptInterface()) {
            var b = this.GetInterfaceClass();
            a.instance = b;
            var d = this._runtime;
            (d = d.IsDebug() && !d.GetEventSheetManager().IsInEventEngine()) && C3Debugger$jscomp$2.StartMeasuringScriptTime();
            b.dispatchEvent(a);
            d && C3Debugger$jscomp$2.AddScriptTime()
        }
    }
}
;
"use strict";
const C3$jscomp$160 = self.C3;
C3$jscomp$160.SceneGraphInfo = class extends C3$jscomp$160.DefendedBase {
    constructor(a) {
        super();
        this._owner = a;
        this._parent = null;
        this._children = [];
        this._startWidth = a.GetWidth();
        this._startHeight = a.GetHeight();
        this._startScaleY = this._startScaleX = 1;
        this._parentStartAngle = 0;
        this._ownOpacity = 1;
        this._startOpacity = a.GetOpacity();
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = null
    }
    Release() {
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = this._parent = null;
        C3$jscomp$160.clearArray(this._children)
    }
    SetParent(a) {
        this._startOpacity = this._ownOpacity = this._owner.GetOpacity();
        this._parentStartAngle = (this._parent = a) ? a.GetAngle() : 0
    }
    GetParent() {
        return this._parent
    }
    HasChildren() {
        return 0 < this._children.length
    }
    GetChildren() {
        return this._children
    }
    _MaybeSortChildren() {
        this.HasChildren() && this._tmpSceneGraphChildrenIndexes && 1 !== this._children.length && this._children.sort((a,b)=>{
            a = this._tmpSceneGraphChildrenIndexes.get(a.GetInstance());
            b = this._tmpSceneGraphChildrenIndexes.get(b.GetInstance());
            return C3$jscomp$160.IsFiniteNumber(a) && C3$jscomp$160.IsFiniteNumber(b) ? a - b : 0
        }
        )
    }
    GetStartScaleX() {
        return this._startScaleX
    }
    SetStartScaleX(a) {
        this._startScaleX = a
    }
    GetStartScaleY() {
        return this._startScaleY
    }
    SetStartScaleY(a) {
        this._startScaleY = a
    }
    GetStartOpacity() {
        return this._startOpacity
    }
    GetOwnOpacity() {
        return this._ownOpacity
    }
    SetOwnOpacity(a) {
        this._ownOpacity = a
    }
    _GetStartWidth() {
        return 0 === this._startWidth ? Number.EPSILON : this._startWidth
    }
    _GetStartHeight() {
        return 0 === this._startHeight ? Number.EPSILON : this._startHeight
    }
    GetParentScaleX() {
        if (this._owner.GetTransformWithParentWidth()) {
            var a = this._parent;
            let b = a.GetWidth()
              , d = a._GetSceneGraphInfo()._GetStartWidth();
            0 === b && (b = Number.EPSILON);
            return d === Number.EPSILON && b === Number.EPSILON ? 1 : d === Number.EPSILON && b !== Number.EPSILON && (a = a.GetInstance().GetSdkInstance(),
            a.IsOriginalSizeKnown()) ? 1 + b / a.GetOriginalWidth() : b / d
        }
        return 1
    }
    GetParentScaleY() {
        if (this._owner.GetTransformWithParentHeight()) {
            var a = this._parent;
            let b = a.GetHeight()
              , d = a._GetSceneGraphInfo()._GetStartHeight();
            0 === b && (b = Number.EPSILON);
            return d === Number.EPSILON && b === Number.EPSILON ? 1 : d === Number.EPSILON && b !== Number.EPSILON && (a = a.GetInstance().GetSdkInstance(),
            a.IsOriginalSizeKnown()) ? 1 + b / a.GetOriginalHeight() : b / d
        }
        return 1
    }
    GetParentStartAngle() {
        return this._parentStartAngle
    }
    _SaveToJson(a) {
        return {
            sw: this._startWidth,
            sh: this._startHeight,
            sx: this._startScaleX,
            sy: this._startScaleY,
            psa: this._parentStartAngle,
            oo: this._ownOpacity,
            so: this._startOpacity,
            p: this._GetParentJson(a),
            c: this._GetChildrenJson(a)
        }
    }
    _GetFlagsString(a) {
        let b = "";
        a.GetTransformWithParentX() && (b += "x");
        a.GetTransformWithParentY() && (b += "y");
        a.GetTransformWithParentWidth() && (b += "w");
        a.GetTransformWithParentHeight() && (b += "h");
        a.GetTransformWithParentAngle() && (b += "a");
        a.GetTransformWithParentZElevation() && (b += "z");
        a.GetDestroyWithParent() && (b += "d");
        a.GetTransformWithParentOpacity() && (b += "o");
        a.GetTransformWithParentVisibility() && (b += "v");
        return b
    }
    _GetParentJson(a) {
        return this._parent && this._parent.GetInstance() && !this._parent.GetInstance().IsDestroyed() ? this._GetInstanceJson(this._parent, this._owner, a) : null
    }
    _GetChildrenJson(a) {
        return this._children.map(b=>this._GetInstanceJson(b, b, a))
    }
    _GetInstanceJson(a, b, d) {
        a = a.GetInstance();
        const c = {};
        c.uid = a.GetUID();
        c.f = this._GetFlagsString(b);
        c.offsets = b._SaveSceneGraphPropertiesToJson();
        c.data = C3$jscomp$160.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(a);
        c.oci = a.GetObjectClass().GetIndex();
        "state" === d ? (c.inst = a.SaveToJson(),
        c.instIndex = NaN) : (c.instIndex = a.GetObjectClass().GetInstances().indexOf(a),
        c.inst = null);
        return c
    }
    _LoadFromJson(a) {
        this._startWidth = a.sw;
        this._startHeight = a.sh;
        this._startScaleX = a.sx;
        this._startScaleY = a.sy;
        this._parentStartAngle = a.psa;
        this._ownOpacity = a.oo;
        this._startOpacity = a.so
    }
    _SetTmpSceneGraphChildren(a, b) {
        this._tmpSceneGraphChildren = a;
        this._tmpSceneGraphChildrenIndexes = b
    }
    _OnAfterLoad(a, b) {
        const d = this._owner
          , c = d.GetRuntime()
          , e = new Set;
        if (a.p && !this._parent) {
            var g = c.GetInstanceByUID(a.p.uid);
            if (g) {
                var k = g.GetWorldInfo();
                g.HasChild(this._owner.GetInstance()) ? this._parent = k : (g.AddChild(this._owner.GetInstance(), this._GetFlagsObj(a.p.f)),
                e.has(this._owner) || this._owner._LoadSceneGraphPropertiesFromJson(a.p.offsets),
                e.add(this._owner),
                g.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren())
            } else
                C3$jscomp$160.IsFiniteNumber(a.p.oci) && (g = c.GetObjectClassByIndex(a.p.oci),
                c.GetSystemPlugin(),
                g = c.CreateInstance(g, d.GetLayer(), 0, 0, !0)) && (k = this._GetInstanceData(a.p, c),
                g.LoadFromJson(k),
                g.GetWorldInfo().GetLayer().SortAndAddInstancesByZIndex(g),
                g.AddChild(d.GetInstance(), this._GetFlagsObj(a.p.f)),
                g.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren())
        }
        g = [];
        for (var l of a.c)
            (k = c.GetInstanceByUID(l.uid)) && g.push(k);
        l = 0;
        for (const t of a.c) {
            if (k = c.GetInstanceByUID(t.uid)) {
                if (this._tmpSceneGraphChildren && this._tmpSceneGraphChildren[l]) {
                    var n = this._tmpSceneGraphChildren[l];
                    if (n.GetObjectClass() !== k.GetObjectClass()) {
                        l++;
                        continue
                    }
                    if (n.IsDestroyed()) {
                        l++;
                        continue
                    }
                    k = a.c[l];
                    this._AddAndSetChildInstance(n.GetWorldInfo(), k, e, !1);
                    l++;
                    continue
                }
                var p = k.GetObjectClass();
                n = this._GetInstancesOfObjectClassCount(g, p);
                p = d.GetInstance().GetChildrenOfObjectClass(p).length;
                if (n === p) {
                    if (k = d.GetInstance().GetChildAt(l).GetWorldInfo())
                        e.has(k) || k._LoadSceneGraphPropertiesFromJson(t.offsets),
                        e.add(k);
                    l++;
                    continue
                }
                if (k.HasParent()) {
                    k = this._CreateNewChildInstance(t, b);
                    this._AddAndSetChildInstance(k, t, e);
                    l++;
                    continue
                }
                this._AddAndSetChildInstance(k.GetWorldInfo(), t, e)
            } else
                k = this._CreateNewChildInstance(t, b),
                this._AddAndSetChildInstance(k, t, e);
            l++
        }
    }
    _GetFlagsObj(a) {
        const b = {};
        b.transformX = a.includes("x");
        b.transformY = a.includes("y");
        b.transformWidth = a.includes("w");
        b.transformHeight = a.includes("h");
        b.transformAngle = a.includes("a");
        b.transformZElevation = a.includes("z");
        b.destroyWithParent = a.includes("d");
        b.transformOpacity = a.includes("o");
        b.transformVisibility = a.includes("v");
        return b
    }
    _CreateNewChildInstance(a, b) {
        if (C3$jscomp$160.IsFiniteNumber(a.oci)) {
            var d = this._owner;
            b = d.GetRuntime();
            if (a.data)
                d = b.CreateInstanceFromData(a.data, d.GetLayer(), !1, 0, 0, !1, !0);
            else {
                const c = b.GetObjectClassByIndex(a.oci);
                d = b.CreateInstance(c, d.GetLayer(), 0, 0, !0)
            }
            if (d)
                return a = this._GetInstanceData(a, b),
                d.LoadFromJson(a),
                a = d.GetWorldInfo(),
                a.GetLayer().SortAndAddInstancesByZIndex(d, !0),
                a
        }
    }
    _AddAndSetChildInstance(a, b, d, c=!0) {
        this._owner.AddChild(a, this._GetFlagsObj(b.f));
        c && (d.has(a) || a._LoadSceneGraphPropertiesFromJson(b.offsets),
        d.add(a));
        this._MaybeSortChildren()
    }
    _GetInstancesOfObjectClassCount(a, b) {
        return a.filter(d=>d.GetObjectClass().GetName() === b.GetName()).length
    }
    _GetInstanceData(a, b) {
        if (C3$jscomp$160.IsFiniteNumber(a.instIndex))
            return b.GetObjectClassByIndex(a.oci)._GetLoadInstancesJson()[a.instIndex];
        if (C3$jscomp$160.IsString(a.inst))
            return JSON.parse(a.inst);
        if (a.inst)
            return a.inst
    }
    static GetSceneGraphInstanceDataFromInstance(a) {
        let b = a.GetWorldInfo().GetLayer().GetInitialInstanceData(a.GetUID());
        if (!b)
            return null;
        b = JSON.parse(JSON.stringify(b));
        const d = [];
        for (const c of [...a.GetChildren()]) {
            const e = c.GetWorldInfo();
            d.push([e.GetLayout().GetSID(), e.GetLayer().GetIndex(), c.GetUID(), C3$jscomp$160.SceneGraphInfo._GetFlagsNumber(e), c.GetObjectClass().IsInContainer() ? 1 : 0, e.GetZIndex(), C3$jscomp$160.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(c)])
        }
        C3$jscomp$160.IsArray(b[0][14]) ? b[0][14][1] = d : (b[0][14] = [],
        b[0][14][0] = C3$jscomp$160.SceneGraphInfo._GetDefaultFlagsNumber(),
        b[0][14][1] = d,
        b[0][14][2] = a.GetWorldInfo().GetZIndex());
        return b
    }
    static _GetFlagsNumber(a) {
        let b;
        b = 0 | Number(a.GetTransformWithParentVisibility()) << 8;
        b |= Number(a.GetTransformWithParentOpacity()) << 7;
        b |= Number(a.GetTransformWithParentZElevation()) << 6;
        b |= Number(a.GetDestroyWithParent()) << 5;
        b |= Number(a.GetTransformWithParentAngle()) << 4;
        b |= Number(a.GetTransformWithParentHeight()) << 3;
        b |= Number(a.GetTransformWithParentWidth()) << 2;
        b |= Number(a.GetTransformWithParentY()) << 1;
        return b |= Number(a.GetTransformWithParentX()) << 0
    }
    static _GetDefaultFlagsNumber(a) {
        return 511
    }
}
;
"use strict";
const C3$jscomp$161 = self.C3
  , tempRect$jscomp$6 = C3$jscomp$161.New(C3$jscomp$161.Rect)
  , tempQuad$jscomp$3 = C3$jscomp$161.New(C3$jscomp$161.Quad)
  , bboxChangeEvent = C3$jscomp$161.New(C3$jscomp$161.Event, "bboxchange", !1)
  , tempColor$jscomp$6 = C3$jscomp$161.New(C3$jscomp$161.Color, 0, 0, 0, 0)
  , tempCollisionPoly = C3$jscomp$161.New(C3$jscomp$161.CollisionPoly)
  , DEFAULT_COLOR = C3$jscomp$161.New(C3$jscomp$161.Color, 1, 1, 1, 1)
  , DEFAULT_RENDER_CELLS = C3$jscomp$161.New(C3$jscomp$161.Rect, 0, 0, -1, -1)
  , DEFAULT_COLLISION_CELLS = C3$jscomp$161.New(C3$jscomp$161.Rect, 0, 0, -1, -1)
  , VALID_SET_MESH_POINT_MODES = new Set(["absolute", "relative"])
  , EMPTY_ARRAY$jscomp$2 = [];
let enableUpdateRendererStateGroup = !0;
const FLAG_IS_VISIBLE = 1
  , FLAG_BBOX_CHANGED = 2
  , FLAG_ENABLE_BBOX_CHANGED_EVENT = 4
  , FLAG_COLLISION_ENABLED = 8
  , FLAG_COLLISION_CELL_CHANGED = 16
  , FLAG_SOLID_FILTER_INCLUSIVE = 32
  , FLAG_HAS_ANY_ACTIVE_EFFECT = 64
  , FLAG_IS_ROTATABLE = 128
  , FLAG_DESTROYED$jscomp$1 = 256
  , FLAG_DESTROY_WITH_PARENT = 512
  , FLAG_TRANSFORM_WITH_PARENT_X = 1024
  , FLAG_TRANSFORM_WITH_PARENT_Y = 2048
  , FLAG_TRANSFORM_WITH_PARENT_W = 4096
  , FLAG_TRANSFORM_WITH_PARENT_H = 8192
  , FLAG_TRANSFORM_WITH_PARENT_A = 16384
  , FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 32768
  , FLAG_TRANSFORM_WITH_PARENT_OPACITY = 4194304
  , FLAG_TRANSFORM_WITH_PARENT_VISIBILITY = 8388608
  , MASK_ALL_SCENE_GRAPH_FLAGS = FLAG_DESTROY_WITH_PARENT | FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y | FLAG_TRANSFORM_WITH_PARENT_W | FLAG_TRANSFORM_WITH_PARENT_H | FLAG_TRANSFORM_WITH_PARENT_A | FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION | FLAG_TRANSFORM_WITH_PARENT_OPACITY | FLAG_TRANSFORM_WITH_PARENT_VISIBILITY
  , FLAG_MESH_CHANGED = 65536
  , FLAG_PHYSICS_BODY_CHANGED = 131072
  , FLAG_SIN_COS_ANGLE_CHANGED = 262144
  , FLAG_USE_POINTS_SHADER_PROGRAM = 524288
  , FLAG_DRAW_BACK_FACE_ONLY = 1048576
  , FLAG_DRAW_NON_BACK_FACES_ONLY = 2097152
  , FLAG_BLEND_MODE_MASK = 2080374784
  , sceneGraphExportDataMap = new WeakMap
  , sceneGraphZIndexMap = new WeakMap
  , needsSceneGraphAfterLoad = new WeakMap;
C3$jscomp$161.WorldInfo = class extends C3$jscomp$161.DefendedBase {
    constructor(a, b) {
        super();
        this._inst = a;
        this._objectClass = a.GetObjectClass();
        this._runtime = a.GetRuntime();
        this._layer = b;
        this._zIndex = -1;
        this._flags = FLAG_IS_VISIBLE | FLAG_BBOX_CHANGED | FLAG_COLLISION_ENABLED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED | FLAG_PHYSICS_BODY_CHANGED;
        this._objectClass.GetPlugin().IsRotatable() && (this._flags |= FLAG_IS_ROTATABLE);
        this._oy = this._ox = this._cosA = this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = NaN;
        this._boundingBox = C3$jscomp$161.New(C3$jscomp$161.Rect);
        this._boundingQuad = C3$jscomp$161.New(C3$jscomp$161.Quad);
        this._collisionCells = DEFAULT_COLLISION_CELLS;
        this._renderCells = DEFAULT_RENDER_CELLS;
        this._solidFilterTags = this._transformedPolyInfo = this._sourceCollisionPoly = null;
        this._colorPremultiplied = this._color = DEFAULT_COLOR;
        this._instanceEffectList = this._stateGroup = null;
        this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = C3$jscomp$161.New(C3$jscomp$161.InstanceEffectList, this._inst, this));
        this._meshInfo = this._after_load_instance = this._after_load = this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = this._sceneGraphInfo = null
    }
    _MarkDestroyed() {
        this._flags |= FLAG_DESTROYED$jscomp$1
    }
    Release() {
        this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup),
        this._stateGroup = null);
        this._sourceCollisionPoly = null;
        this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(),
        this._transformedPolyInfo = null);
        this._solidFilterTags && (this._solidFilterTags.clear(),
        this._solidFilterTags = null);
        this.ReleaseMesh();
        this._instanceEffectList && this._instanceEffectList.Release();
        this.HasParent() && this.GetParent().RemoveChild(this);
        if (this.HasChildren()) {
            const a = [...this.GetChildren()];
            for (const b of a)
                this.RemoveChild(b)
        }
        this._ReleaseSceneGraphInfo();
        this._ReleaseTmpSceneGraphInfo();
        sceneGraphExportDataMap.delete(this);
        sceneGraphZIndexMap.delete(this);
        this._after_load && (this.GetRuntime().Dispatcher().removeEventListener("afterload", this._after_load),
        this._after_load = null);
        this._after_load_instance && (this.GetRuntime().Dispatcher().removeEventListener("afterloadinstance", this._after_load_instance),
        this._after_load_instance = null);
        this._layer = this._runtime = this._objectClass = this._inst = null
    }
    Init(a) {
        enableUpdateRendererStateGroup = !1;
        this.SetXY(a[0], a[1]);
        this.SetZElevation(a[2]);
        this.SetSize(a[3], a[4]);
        this._depth = 0;
        this.IsRotatable() ? this.SetAngle(a[6]) : this._a = 0;
        tempColor$jscomp$6.setFromJSON(a[7]);
        this._SetColor(tempColor$jscomp$6);
        this.SetOriginX(a[8]);
        this.SetOriginY(a[9]);
        this.SetBlendMode(a[10]);
        this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(a[12]);
        a[14] && sceneGraphExportDataMap.set(this, {
            childrenData: a[14][1],
            zIndexData: a[14][2]
        });
        if (a[15]) {
            var b = a[15];
            this.CreateMesh(b[0], b[1]);
            var d = this.GetSourceMesh();
            b = b[2];
            for (let g = 0, k = b.length; g < k; ++g) {
                var c = b[g];
                for (let l = 0, n = c.length; l < n; ++l) {
                    var e = c[l];
                    const p = d.GetMeshPointAt(l, g);
                    p.SetX(e[0]);
                    p.SetY(e[1]);
                    p.SetZElevation(e[2]);
                    p.SetU(e[3]);
                    p.SetV(e[4])
                }
            }
        }
        a[16] && (d = a[16][0],
        a = a[16][1],
        b = !!a,
        c = !b,
        e = this._runtime.GetTemplateManager(),
        b && e && e.MapInstanceToTemplateName(this.GetInstance(), a),
        c && e && e.MapInstanceToTemplateName(this.GetInstance(), d));
        enableUpdateRendererStateGroup = !0;
        this._UpdateRendererStateGroup()
    }
    InitNoData() {
        this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = 0;
        this._cosA = 1;
        this._oy = this._ox = 0;
        this._UpdateRendererStateGroup()
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetInstance() {
        return this._inst
    }
    _GetParentOffsetAngle() {
        return this.GetTransformWithParentAngle() ? this.GetParent().GetAngle() - this._sceneGraphInfo.GetParentStartAngle() : 0
    }
    SetX(a) {
        a = +a;
        if (this.GetTransformWithParentX()) {
            const b = this._sceneGraphInfo;
            a -= this.GetX();
            const d = -this._GetParentOffsetAngle();
            0 === d ? this._x += a / b.GetParentScaleX() : (this._x += Math.cos(d) * a / b.GetParentScaleX(),
            this.GetTransformWithParentY() && (this._y += Math.sin(d) * a / b.GetParentScaleY()))
        } else
            this._x = a
    }
    OffsetX(a, b=!1) {
        a = +a;
        b ? this._x += a : this.GetTransformWithParentX() ? this.SetX(this.GetX() + a) : this._x += a
    }
    GetX() {
        if (this.GetTransformWithParentX()) {
            let a = this._x;
            const b = this._sceneGraphInfo
              , d = this.GetParent()
              , c = this._GetParentOffsetAngle();
            0 === c ? a *= b.GetParentScaleX() : (a = a * b.GetParentScaleX() * Math.cos(c),
            this.GetTransformWithParentY() && (a -= this._y * b.GetParentScaleY() * Math.sin(c)));
            return d.GetX() + a
        }
        return this._x
    }
    SetY(a) {
        a = +a;
        if (this.GetTransformWithParentY()) {
            const b = this._sceneGraphInfo;
            a -= this.GetY();
            const d = -this._GetParentOffsetAngle();
            0 === d ? this._y += a / b.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(d) * a / b.GetParentScaleX()),
            this._y += Math.cos(d) * a / b.GetParentScaleY())
        } else
            this._y = a
    }
    OffsetY(a, b=!1) {
        a = +a;
        b ? this._y += a : this.GetTransformWithParentY() ? this.SetY(this.GetY() + a) : this._y += a
    }
    GetY() {
        if (this.GetTransformWithParentY()) {
            let a = this._y;
            const b = this._sceneGraphInfo
              , d = this.GetParent()
              , c = this._GetParentOffsetAngle();
            0 === c ? a *= b.GetParentScaleY() : (a = a * b.GetParentScaleY() * Math.cos(c),
            this.GetTransformWithParentX() && (a += this._x * b.GetParentScaleX() * Math.sin(c)));
            return d.GetY() + a
        }
        return this._y
    }
    SetXY(a, b) {
        a = +a;
        b = +b;
        if (this.GetTransformWithParentXOrY()) {
            const c = this.GetTransformWithParentX()
              , e = this.GetTransformWithParentY()
              , g = this._sceneGraphInfo
              , k = a - this.GetX()
              , l = b - this.GetY();
            var d = -this._GetParentOffsetAngle();
            if (0 === d)
                this._x = c ? this._x + k / g.GetParentScaleX() : a,
                this._y = e ? this._y + l / g.GetParentScaleY() : b;
            else {
                const n = Math.sin(d);
                d = Math.cos(d);
                this._x = c ? e ? this._x + (d * k - n * l) / g.GetParentScaleX() : this._x + d * k / g.GetParentScaleX() : a;
                this._y = e ? c ? this._y + (n * k + d * l) / g.GetParentScaleY() : this._y + d * l / g.GetParentScaleY() : b
            }
        } else
            this._x = a,
            this._y = b
    }
    OffsetXY(a, b) {
        a = +a;
        b = +b;
        this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + a, this.GetY() + b) : (this._x += a,
        this._y += b)
    }
    EqualsXY(a, b) {
        return this.GetX() === a && this.GetY() === b
    }
    SetZElevation(a) {
        a = +a;
        this.GetTransformWithParentZElevation() && (a -= this.GetParent().GetZElevation());
        this._zElevation !== a && (this._zElevation = a,
        this._UpdateZElevation(),
        a = this.GetLayer(),
        0 !== this._zElevation && a._SetAnyInstanceZElevated(),
        a.SetZIndicesChanged())
    }
    _UpdateZElevation() {
        this._UpdateRendererStateGroup();
        if (this.HasChildren()) {
            const a = this.GetChildren();
            for (let b = 0, d = a.length; b < d; b++) {
                const c = a[b];
                c.GetTransformWithParentZElevation() && c._UpdateZElevation()
            }
        }
    }
    OffsetZElevation(a) {
        this.SetZElevation(this.GetZElevation() + a)
    }
    GetZElevation() {
        return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation
    }
    GetTotalZElevation() {
        return this.GetLayer().GetZElevation() + this.GetZElevation()
    }
    SetWidth(a) {
        a = +a;
        if (this.GetTransformWithParentWidth()) {
            const b = this.GetWidth();
            this._w = 0 === b ? Number.EPSILON : a / b * this._w
        } else
            this._w = a
    }
    OffsetWidth(a, b) {
        a = +a;
        b ? this._w += a : this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + a) : this._w += a
    }
    GetWidth() {
        if (this.GetTransformWithParentWidth()) {
            const a = this.GetParent()
              , b = a.GetWidth();
            return a._GetSceneGraphInfo()._GetStartWidth() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartWidth() + b) * this._w : b * this._w
        }
        return this._w
    }
    SetHeight(a) {
        a = +a;
        if (this.GetTransformWithParentHeight()) {
            const b = this.GetHeight();
            this._h = 0 === b ? Number.EPSILON : a / b * this._h
        } else
            this._h = a
    }
    OffsetHeight(a, b) {
        a = +a;
        b ? this._h += a : this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + a) : this._h += a
    }
    GetHeight() {
        if (this.GetTransformWithParentHeight()) {
            const a = this.GetParent()
              , b = a.GetHeight();
            return a._GetSceneGraphInfo()._GetStartHeight() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartHeight() + b) * this._h : b * this._h
        }
        return this._h
    }
    SetSize(a, b) {
        a = +a;
        b = +b;
        if (this.GetTransformWithParentWidth()) {
            const d = this.GetWidth();
            this._w = 0 === d ? Number.EPSILON : a / d * this._w
        } else
            this._w = a;
        this.GetTransformWithParentHeight() ? (a = this.GetHeight(),
        this._h = 0 === a ? Number.EPSILON : b / a * this._h) : this._h = b
    }
    GetDepth() {
        return this._depth
    }
    SetDepth(a) {
        if (0 > a)
            throw new RangeError("invalid depth");
        this._depth = a
    }
    GetSceneGraphScale() {
        if (this.HasParent()) {
            const a = this._sceneGraphInfo;
            return Math.min(a.GetParentScaleX(), a.GetParentScaleY())
        }
        return 1
    }
    IsRotatable() {
        return 0 !== (this._flags & FLAG_IS_ROTATABLE)
    }
    SetAngle(a) {
        a = +a;
        this.IsRotatable() && (this.GetTransformWithParentAngle() && (a -= this.GetParent().GetAngle()),
        a = C3$jscomp$161.clampAngle(a),
        this._a !== a && (this._a = a,
        this._MarkSinCosAngleChanged()))
    }
    OffsetAngle(a) {
        a = +a;
        0 !== a && this.IsRotatable() && (this._a = C3$jscomp$161.clampAngle(this._a + a),
        this._MarkSinCosAngleChanged())
    }
    _MarkSinCosAngleChanged() {
        this._flags |= FLAG_SIN_COS_ANGLE_CHANGED;
        if (this.HasChildren()) {
            const a = this.GetChildren();
            for (let b = 0, d = a.length; b < d; b++)
                a[b]._MarkSinCosAngleChanged()
        }
    }
    GetAngle() {
        return this.GetTransformWithParentAngle() ? this.IsRotatable() ? C3$jscomp$161.clampAngle(this.GetParent().GetAngle() + this._a) : this._a : this._a
    }
    _MaybeUpdateSinCosAngle() {
        const a = this._flags;
        if (0 !== (a & FLAG_SIN_COS_ANGLE_CHANGED)) {
            var b = this.GetAngle();
            this._sinA = Math.sin(b);
            this._cosA = Math.cos(b);
            this._flags = a & ~FLAG_SIN_COS_ANGLE_CHANGED
        }
    }
    GetSinAngle() {
        this._MaybeUpdateSinCosAngle();
        return this._sinA
    }
    GetCosAngle() {
        this._MaybeUpdateSinCosAngle();
        return this._cosA
    }
    SetOriginX(a) {
        this._ox = +a
    }
    OffsetOriginX(a) {
        this._ox += +a
    }
    GetOriginX() {
        return this._ox
    }
    SetOriginY(a) {
        this._oy = +a
    }
    OffsetOriginY(a) {
        this._oy += +a
    }
    GetOriginY() {
        return this._oy
    }
    _SetColor(a) {
        this._color.equals(a) || (this._color === DEFAULT_COLOR ? (this._color = C3$jscomp$161.New(C3$jscomp$161.Color, a),
        this._colorPremultiplied = C3$jscomp$161.New(C3$jscomp$161.Color, a),
        this._colorPremultiplied.premultiply()) : a.equalsRgba(1, 1, 1, 1) ? this._colorPremultiplied = this._color = DEFAULT_COLOR : (this._color.set(a),
        this._colorPremultiplied.set(a),
        this._colorPremultiplied.premultiply()),
        this._UpdateRendererStateGroup())
    }
    SetOpacity(a) {
        a = C3$jscomp$161.clamp(+a, 0, 1);
        if (this.GetTransformWithParentOpacity()) {
            if (this._GetSceneGraphInfo().GetOwnOpacity() === a)
                return;
            this._GetSceneGraphInfo().SetOwnOpacity(a);
            a = this.GetOpacity()
        } else if (this._color.a === a)
            return;
        this._SetColorWithOpacity(a)
    }
    _SetOpacityOfChildren() {
        if (this.HasChildren()) {
            var a = this.GetChildren();
            for (let b = 0, d = a.length; b < d; b++) {
                const c = a[b];
                c._SetColorWithOpacity(c.GetOpacity())
            }
        }
    }
    _SetColorWithOpacity(a) {
        tempColor$jscomp$6.copyRgb(this._color);
        tempColor$jscomp$6.a = a;
        this._SetColor(tempColor$jscomp$6);
        this._SetOpacityOfChildren()
    }
    OffsetOpacity(a) {
        this.GetTransformWithParentOpacity() ? this.SetOpacity(this._GetSceneGraphInfo().GetOwnOpacity() + a) : this.SetOpacity(this.GetOpacity() + a)
    }
    GetOpacity() {
        return this.GetTransformWithParentOpacity() ? this.GetParent().GetOpacity() * this._GetSceneGraphInfo().GetOwnOpacity() : this._color.a
    }
    SetUnpremultipliedColor(a) {
        this._color.equalsIgnoringAlpha(a) || (tempColor$jscomp$6.copyRgb(a),
        tempColor$jscomp$6.a = this.GetOpacity(),
        this._SetColor(tempColor$jscomp$6))
    }
    SetUnpremultipliedColorRGB(a, b, d) {
        tempColor$jscomp$6.setRgb(a, b, d);
        this.SetUnpremultipliedColor(tempColor$jscomp$6)
    }
    OffsetUnpremultipliedColorRGB(a, b, d) {
        if (0 !== a || 0 !== b || 0 !== d)
            tempColor$jscomp$6.copyRgb(this._color),
            tempColor$jscomp$6.r += a,
            tempColor$jscomp$6.g += b,
            tempColor$jscomp$6.b += d,
            this.SetUnpremultipliedColor(tempColor$jscomp$6)
    }
    GetUnpremultipliedColor() {
        return this._color
    }
    GetPremultipliedColor() {
        return this._colorPremultiplied
    }
    GetDestroyWithParent() {
        return 0 !== (this._flags & FLAG_DESTROY_WITH_PARENT)
    }
    SetDestroyWithParent(a) {
        this._SetFlag(FLAG_DESTROY_WITH_PARENT, a)
    }
    GetTransformWithParentX() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_X)
    }
    SetTransformWithParentX(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_X, a)
    }
    GetTransformWithParentY() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_Y)
    }
    GetTransformWithParentXOrY() {
        return 0 !== (this._flags & (FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y))
    }
    SetTransformWithParentY(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Y, a)
    }
    GetTransformWithParentWidth() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_W)
    }
    SetTransformWithParentWidth(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_W, a)
    }
    GetTransformWithParentHeight() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_H)
    }
    SetTransformWithParentHeight(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_H, a)
    }
    GetTransformWithParentAngle() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_A)
    }
    SetTransformWithParentAngle(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_A, a)
    }
    GetTransformWithParentZElevation() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION)
    }
    SetTransformWithParentZElevation(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION, a)
    }
    GetTransformWithParentOpacity() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_OPACITY)
    }
    SetTransformWithParentOpacity(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_OPACITY, a)
    }
    GetTransformWithParentVisibility() {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_VISIBILITY)
    }
    SetTransformWithParentVisibility(a) {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_VISIBILITY, a)
    }
    _ClearAllSceneGraphFlags() {
        this._flags &= ~MASK_ALL_SCENE_GRAPH_FLAGS
    }
    AddChild(a, b) {
        if (a !== this && !a.HasParent() && !this._HasChildRecursive(a) && !this._HasAnyParent(a)) {
            var d = a.GetX()
              , c = a.GetY()
              , e = a.GetWidth()
              , g = a.GetHeight()
              , k = a.GetAngle()
              , l = a.GetZElevation()
              , n = a.GetOpacity();
            a._SetParent(this);
            a.SetTransformWithParentX(b.transformX);
            a.SetTransformWithParentY(b.transformY);
            a.SetTransformWithParentWidth(b.transformWidth);
            a.SetTransformWithParentHeight(b.transformHeight);
            a.SetTransformWithParentAngle(b.transformAngle);
            a.SetTransformWithParentZElevation(b.transformZElevation);
            a.SetTransformWithParentOpacity(b.transformOpacity);
            a.SetTransformWithParentVisibility(b.transformVisibility);
            a.SetDestroyWithParent(b.destroyWithParent);
            b.transformX && (a._x = d - this.GetX(),
            b.transformWidth && (a._x /= this.GetWidth() / this._sceneGraphInfo._GetStartWidth()));
            b.transformY && (a._y = c - this.GetY(),
            b.transformHeight && (a._y /= this.GetHeight() / this._sceneGraphInfo._GetStartHeight()));
            b.transformWidth && (d = this.GetWidth(),
            0 === d || d === Number.EPSILON ? (a._w = 1,
            a._sceneGraphInfo.SetStartScaleX(1)) : (a._w = e / this.GetWidth(),
            a._sceneGraphInfo.SetStartScaleX(a._w)));
            b.transformHeight && (e = this.GetHeight(),
            0 === e || e === Number.EPSILON ? (a._h = 1,
            a._sceneGraphInfo.SetStartScaleY(1)) : (a._h = g / this.GetHeight(),
            a._sceneGraphInfo.SetStartScaleY(a._h)));
            b.transformAngle && (a._a = k - this.GetAngle());
            b.transformZElevation && (a._zElevation = l - this.GetZElevation());
            b.transformOpacity && a._sceneGraphInfo.SetOwnOpacity(n);
            b.transformVisibility && a.SetVisible(this.IsVisible());
            this._AddChildToSceneGraphInfo(a);
            this.SetBboxChanged();
            this._SetOpacityOfChildren()
        }
    }
    RemoveChild(a) {
        if (a.GetParent() === this) {
            var b = a.GetX()
              , d = a.GetY()
              , c = a.GetWidth()
              , e = a.GetHeight()
              , g = a.GetAngle()
              , k = a.GetZElevation()
              , l = a.GetOpacity();
            a._SetParent(null);
            a._ClearAllSceneGraphFlags();
            a.SetXY(b, d);
            a.SetSize(c, e);
            a.SetAngle(g);
            a.SetZElevation(k);
            a.SetOpacity(l);
            this._RemoveChildFromSceneGraphInfo(a);
            this.SetBboxChanged()
        }
    }
    _ResetAllSceneGraphState() {
        this._BuildTmpSceneGraphChildren();
        var a = [...this.children()];
        for (const b of a)
            this.RemoveChild(b);
        (a = this.GetParent()) && a.RemoveChild(this);
        this._ClearAllSceneGraphFlags()
    }
    _BuildTmpSceneGraphChildren() {
        if (!this._tmpSceneGraphChildren) {
            var a = [...this.children()];
            a.length && (this._tmpSceneGraphChildren = [],
            this._tmpSceneGraphChildrenIndexes = new WeakMap);
            var b = 0;
            for (const d of a)
                a = d.GetInstance(),
                this._tmpSceneGraphChildren.push(a),
                this._tmpSceneGraphChildrenIndexes.set(a, b),
                b++
        }
        (b = this.GetParent()) && b._BuildTmpSceneGraphChildren()
    }
    _ReleaseTmpSceneGraphInfo() {
        this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren.length = 0);
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = null;
        needsSceneGraphAfterLoad.delete(this);
        const a = this.GetParent();
        a && !needsSceneGraphAfterLoad.has(a) && a._ReleaseTmpSceneGraphInfo()
    }
    HasParent() {
        return null !== this.GetParent()
    }
    GetParent() {
        const a = this._sceneGraphInfo;
        return null !== a ? a.GetParent() : null
    }
    GetTopParent() {
        let a = this;
        for (; a.HasParent(); )
            a = a.GetParent();
        return a
    }
    *parents() {
        let a = this.GetParent();
        for (; a; )
            yield a,
            a = a.GetParent()
    }
    HasChild(a) {
        return this.GetChildren().includes(a)
    }
    HasChildren() {
        const a = this._sceneGraphInfo;
        return null !== a ? a.HasChildren() : !1
    }
    GetChildren() {
        const a = this._sceneGraphInfo;
        return null !== a ? a.GetChildren() : EMPTY_ARRAY$jscomp$2
    }
    children() {
        return this.GetChildren()
    }
    *allChildren() {
        for (const a of this.children())
            yield a,
            yield*a.allChildren()
    }
    GetChildCount() {
        return this.GetChildren().length
    }
    GetAllChildCount() {
        return [...this.allChildren()].length
    }
    GetChildAt(a) {
        const b = this.GetChildren();
        a = Math.floor(+a);
        return 0 > a || a >= b.length ? null : b[a]
    }
    _CreateSceneGraphInfo(a) {
        this._sceneGraphInfo || (this._sceneGraphInfo = C3$jscomp$161.New(C3$jscomp$161.SceneGraphInfo, this));
        a && this._sceneGraphInfo.SetParent(a)
    }
    _GetSceneGraphInfo() {
        return this._sceneGraphInfo
    }
    _ReleaseSceneGraphInfo() {
        this._sceneGraphInfo && (this._sceneGraphInfo.Release(),
        this._sceneGraphInfo = null)
    }
    _SetParent(a) {
        a ? (a._CreateSceneGraphInfo(null),
        this._CreateSceneGraphInfo(a)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null),
        this.HasChildren() || this._ReleaseSceneGraphInfo())
    }
    _HasAnyParent(a) {
        if (!this.HasParent())
            return !1;
        const b = this.GetParent();
        return b === a ? !0 : b._HasAnyParent(a)
    }
    _HasChildRecursive(a) {
        if (this.HasChild(a))
            return !0;
        for (const b of this.GetChildren())
            if (b._HasChildRecursive(a))
                return !0;
        return !1
    }
    _AddChildToSceneGraphInfo(a) {
        this._sceneGraphInfo.GetChildren().push(a)
    }
    _RemoveChildFromSceneGraphInfo(a) {
        const b = this._sceneGraphInfo.GetChildren()
          , d = b.indexOf(a);
        -1 !== d && b.splice(d, 1);
        0 !== b.length || this.HasParent() || this._ReleaseSceneGraphInfo();
        a.HasChildren() || a._ReleaseSceneGraphInfo()
    }
    GetSceneGraphChildrenExportData() {
        const a = sceneGraphExportDataMap.get(this);
        return a ? a.childrenData : null
    }
    GetSceneGraphZIndexExportData() {
        const a = sceneGraphExportDataMap.get(this);
        return a ? a.zIndexData : NaN
    }
    GetSceneGraphZIndex() {
        const a = sceneGraphZIndexMap.get(this);
        return C3$jscomp$161.IsFiniteNumber(a) ? a : NaN
    }
    SetSceneGraphZIndex(a) {
        sceneGraphZIndexMap.set(this, a)
    }
    SetUsePointsShaderProgram() {
        this._SetFlag(FLAG_USE_POINTS_SHADER_PROGRAM, !0);
        this._UpdateRendererStateGroup()
    }
    _UpdateRendererStateGroup() {
        if (enableUpdateRendererStateGroup) {
            var a = this._runtime.GetRenderer();
            this._stateGroup && a.ReleaseStateGroup(this._stateGroup);
            var b = 0 !== (this._flags & FLAG_USE_POINTS_SHADER_PROGRAM) ? a.GetPointsRenderingProgram() || "<point>" : a.GetTextureFillShaderProgram() || "<default>";
            this._stateGroup = a.AcquireStateGroup(b, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation())
        }
    }
    GetRendererStateGroup() {
        return this._stateGroup
    }
    HasDefaultColor() {
        return this._color === DEFAULT_COLOR
    }
    SetBlendMode(a) {
        a |= 0;
        if (0 > a || 31 < a)
            throw new RangeError("invalid blend mode");
        this.GetBlendMode() !== a && (this._flags = this._flags & ~FLAG_BLEND_MODE_MASK | a << 26,
        this._UpdateRendererStateGroup())
    }
    GetBlendMode() {
        return (this._flags & FLAG_BLEND_MODE_MASK) >> 26
    }
    _SetLayer(a, b) {
        (b = b && this._layer !== a) && this._RemoveFromRenderCells();
        this._layer = a;
        b && this._UpdateRenderCell();
        0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated()
    }
    GetLayer() {
        return this._layer
    }
    GetLayout() {
        return this.GetLayer().GetLayout()
    }
    _SetZIndex(a) {
        this._zIndex = a | 0
    }
    GetZIndex() {
        this._layer._UpdateZIndices();
        return this._zIndex
    }
    _GetLastCachedZIndex() {
        return this._zIndex
    }
    _SetFlag(a, b) {
        this._flags = b ? this._flags | a : this._flags & ~a
    }
    IsVisible() {
        return 0 !== (this._flags & FLAG_IS_VISIBLE)
    }
    SetVisible(a) {
        this._SetFlag(FLAG_IS_VISIBLE, a);
        if (this.HasChildren())
            for (const b of this.GetChildren())
                b.GetTransformWithParentVisibility() && b.SetVisible(a)
    }
    IsCollisionEnabled() {
        return 0 !== (this._flags & FLAG_COLLISION_ENABLED)
    }
    SetCollisionEnabled(a) {
        a = !!a;
        this.IsCollisionEnabled() !== a && (this._SetFlag(FLAG_COLLISION_ENABLED, a),
        a ? this.SetBboxChanged() : this._RemoveFromCollisionCells())
    }
    SetSolidCollisionFilter(a, b) {
        this._SetFlag(FLAG_SOLID_FILTER_INCLUSIVE, a);
        this._solidFilterTags && this._solidFilterTags.clear();
        if (b.trim()) {
            this._solidFilterTags || (this._solidFilterTags = new Set);
            for (const d of b.split(" "))
                d && this._solidFilterTags.add(d.toLowerCase())
        } else
            this._solidFilterTags = null
    }
    IsSolidCollisionAllowed(a) {
        const b = 0 !== (this._flags & FLAG_SOLID_FILTER_INCLUSIVE)
          , d = this._solidFilterTags;
        if (!a || !d)
            return !b;
        for (const c of d)
            if (a.has(c))
                return b;
        return !b
    }
    SetBboxChanged() {
        this._flags = this._flags | FLAG_BBOX_CHANGED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED;
        this._objectClass._SetAnyCollisionCellChanged(!0);
        this._runtime.UpdateRender();
        this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0),
        this._flags &= ~FLAG_BBOX_CHANGED,
        this._UpdateRenderCell());
        0 !== (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT) && this._inst.Dispatcher().dispatchEvent(bboxChangeEvent);
        if (null !== this._sceneGraphInfo) {
            const a = this._sceneGraphInfo.GetChildren();
            for (let b = 0, d = a.length; b < d; ++b)
                a[b].SetBboxChanged()
        }
    }
    CalculateBbox(a, b, d) {
        const c = this.GetX()
          , e = this.GetY()
          , g = this.GetWidth()
          , k = this.GetHeight()
          , l = this.GetAngle();
        a.setWH(c - this._ox * g, e - this._oy * k, g, k);
        d && this.HasMesh() && this._ExpandBboxForMesh(a);
        0 === l ? b.setFromRect(a) : (a.offset(-c, -e),
        b.setFromRotatedRectPrecalc(a, this.GetSinAngle(), this.GetCosAngle()),
        b.offset(c, e),
        b.getBoundingBox(a));
        a.normalize()
    }
    _UpdateBbox() {
        const a = this._flags;
        0 !== (a & FLAG_BBOX_CHANGED) && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0),
        this._flags = a & ~FLAG_BBOX_CHANGED)
    }
    GetBoundingBox() {
        this._UpdateBbox();
        return this._boundingBox
    }
    GetBoundingQuad() {
        this._UpdateBbox();
        return this._boundingQuad
    }
    PixelRoundQuad(a) {
        var b = this.GetX()
          , d = this.GetY();
        b = Math.round(b) - b;
        d = Math.round(d) - d;
        if (0 === b && 0 === d)
            return a;
        tempQuad$jscomp$3.copy(a);
        tempQuad$jscomp$3.offset(b, d);
        return tempQuad$jscomp$3
    }
    OverwriteBoundingBox(a) {
        this._boundingBox.copy(a);
        this._boundingQuad.setFromRect(this._boundingBox);
        this._flags &= ~FLAG_BBOX_CHANGED;
        this._UpdateCollisionCell();
        this._UpdateRenderCell()
    }
    SetBboxChangeEventEnabled(a) {
        this._SetFlag(FLAG_ENABLE_BBOX_CHANGED_EVENT, a)
    }
    IsBboxChangeEventEnabled() {
        return 0 !== (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT)
    }
    IsInViewport(a, b, d) {
        return b && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || d ? a.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated()
    }
    _IsInViewport_ZElevated() {
        const a = this.GetLayer()
          , b = this.GetTotalZElevation();
        if (b >= a.GetCameraZ())
            return !1;
        a.GetViewportForZ(b, tempRect$jscomp$6);
        return tempRect$jscomp$6.intersectsRect(this.GetBoundingBox())
    }
    IsInViewport3D(a) {
        var b = this.GetBoundingBox();
        const d = b.getLeft()
          , c = b.getRight()
          , e = b.getTop();
        b = b.getBottom();
        const g = this.GetTotalZElevation()
          , k = g + this.GetDepth();
        return a.ContainsAABB(d, e, g, c, b, k)
    }
    IsInViewport2() {
        const a = this.GetLayer();
        if (a.Has3DCamera())
            return this.IsInViewport3D(a._GetViewFrustum());
        const b = a.GetLayout();
        return this.IsInViewport(a.GetViewport(), b.HasVanishingPointOutsideViewport(), b.IsOrthographicProjection())
    }
    _SetDrawBackFaceOnly(a) {
        this._SetFlag(FLAG_DRAW_BACK_FACE_ONLY, a)
    }
    _SetDrawNonBackFacesOnly(a) {
        this._SetFlag(FLAG_DRAW_NON_BACK_FACES_ONLY, a)
    }
    IsDrawBackFaceOnly() {
        return 0 !== (this._flags & FLAG_DRAW_BACK_FACE_ONLY)
    }
    IsDrawNonBackFacesOnly() {
        return 0 !== (this._flags & FLAG_DRAW_NON_BACK_FACES_ONLY)
    }
    SetSourceCollisionPoly(a) {
        this._sourceCollisionPoly = a;
        this._DiscardTransformedCollisionPoly();
        this.HasMesh() && (this._meshInfo.meshPoly = null)
    }
    GetSourceCollisionPoly() {
        return this._sourceCollisionPoly
    }
    HasOwnCollisionPoly() {
        return null !== this._sourceCollisionPoly || this.HasMesh()
    }
    GetTransformedCollisionPoly() {
        return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle())
    }
    GetCustomTransformedCollisionPoly(a, b, d) {
        let c = 0
          , e = 1;
        0 !== d && (c = Math.sin(d),
        e = Math.cos(d));
        return this._GetCustomTransformedCollisionPolyPrecalc(a, b, d, c, e)
    }
    _GetCustomTransformedCollisionPolyPrecalc(a, b, d, c, e) {
        let g = this._transformedPolyInfo;
        null === g && (this._transformedPolyInfo = g = {
            poly: C3$jscomp$161.New(C3$jscomp$161.CollisionPoly),
            width: NaN,
            height: NaN,
            angle: NaN
        });
        const k = g.poly;
        if (g.width === a && g.height === b && g.angle === d)
            return k;
        const l = this._sourceCollisionPoly;
        if (this.HasMesh()) {
            const n = this.GetOriginX()
              , p = this.GetOriginY()
              , t = this.GetSourceMesh();
            let w = this._meshInfo.meshPoly;
            w || (l ? (tempCollisionPoly.copy(l),
            tempCollisionPoly.offset(n, p)) : tempCollisionPoly.setDefaultPoints(),
            w = t.InsertPolyMeshVertices(tempCollisionPoly),
            this._meshInfo.meshPoly = w);
            t.TransformCollisionPoly(w, k);
            k.offset(-n, -p);
            k.transformPrecalc(a, b, c, e)
        } else
            l ? (k.copy(l),
            k.transformPrecalc(a, b, c, e)) : k.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
        g.width = a;
        g.height = b;
        g.angle = d;
        return k
    }
    _DiscardTransformedCollisionPoly() {
        this.SetPhysicsBodyChanged(!0);
        const a = this._transformedPolyInfo;
        null !== a && (a.width = NaN)
    }
    CreateMesh(a, b) {
        a = Math.floor(a);
        b = Math.floor(b);
        if (!this.GetInstance().GetPlugin().SupportsMesh())
            throw Error("object does not support mesh");
        this.ReleaseMesh();
        this._meshInfo = {
            sourceMesh: C3$jscomp$161.New(C3$jscomp$161.Gfx.Mesh, a, b),
            transformedMesh: C3$jscomp$161.New(C3$jscomp$161.Gfx.Mesh, a, b),
            meshPoly: null
        }
    }
    HasMesh() {
        return null !== this._meshInfo
    }
    GetSourceMesh() {
        if (!this.HasMesh())
            throw Error("no mesh");
        return this._meshInfo.sourceMesh
    }
    GetTransformedMesh() {
        if (!this.HasMesh())
            throw Error("no mesh");
        return this._meshInfo.transformedMesh
    }
    SetMeshChanged(a) {
        this._SetFlag(FLAG_MESH_CHANGED, a)
    }
    IsMeshChanged() {
        return 0 !== (this._flags & FLAG_MESH_CHANGED)
    }
    SetPhysicsBodyChanged(a) {
        this._SetFlag(FLAG_PHYSICS_BODY_CHANGED, a)
    }
    IsPhysicsBodyChanged() {
        return 0 !== (this._flags & FLAG_PHYSICS_BODY_CHANGED)
    }
    _ExpandBboxForMesh(a) {
        const b = this._meshInfo.sourceMesh
          , d = Math.min(b.GetMinX(), 0)
          , c = Math.min(b.GetMinY(), 0)
          , e = Math.max(b.GetMaxX(), 1)
          , g = Math.max(b.GetMaxY(), 1)
          , k = a.width()
          , l = a.height();
        a.offsetLeft(d * k);
        a.offsetTop(c * l);
        a.offsetRight((e - 1) * k);
        a.offsetBottom((g - 1) * l);
        this._depth = b.GetMaxZ()
    }
    ReleaseMesh() {
        this._meshInfo && (this._meshInfo.sourceMesh.Release(),
        this._meshInfo.transformedMesh.Release(),
        this._meshInfo = null,
        this._DiscardTransformedCollisionPoly())
    }
    SetMeshPoint(a, b, d) {
        a = Math.floor(a);
        b = Math.floor(b);
        var c = d.mode || "absolute";
        if (!VALID_SET_MESH_POINT_MODES.has(c))
            throw Error("invalid mode");
        c = "relative" === c;
        let e = d.x
          , g = d.y;
        const k = d.zElevation;
        let l = "number" === typeof d.u ? d.u : c ? 0 : -1;
        d = "number" === typeof d.v ? d.v : c ? 0 : -1;
        if (!this.HasMesh())
            return !1;
        const n = this.GetSourceMesh()
          , p = n.GetMeshPointAt(a, b);
        if (null === p)
            return !1;
        let t = !1;
        "number" === typeof k && p.GetZElevation() !== k && (p.SetZElevation(k),
        t = !0);
        c && (e += a / (n.GetHSize() - 1),
        g += b / (n.GetVSize() - 1));
        -1 !== l || c ? (c && (l += a / (n.GetHSize() - 1)),
        l = C3$jscomp$161.clamp(l, 0, 1)) : l = p.GetU();
        -1 !== d || c ? (c && (d += b / (n.GetVSize() - 1)),
        d = C3$jscomp$161.clamp(d, 0, 1)) : d = p.GetV();
        if (p.GetX() === e && p.GetY() === g && p.GetU() === l && p.GetV() === d)
            return t;
        p.SetX(e);
        p.SetY(g);
        p.SetU(l);
        p.SetV(d);
        this._DiscardTransformedCollisionPoly();
        return !0
    }
    HasTilemap() {
        return this._inst.HasTilemap()
    }
    ContainsPoint(a, b) {
        return this.GetBoundingBox().containsPoint(a, b) && this.GetBoundingQuad().containsPoint(a, b) ? this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(a, b) : this.HasOwnCollisionPoly() ? this.GetTransformedCollisionPoly().containsPoint(a - this.GetX(), b - this.GetY()) : !0 : !1
    }
    _IsCollisionCellChanged() {
        return 0 !== (this._flags & FLAG_COLLISION_CELL_CHANGED)
    }
    _UpdateCollisionCell() {
        if (this._IsCollisionCellChanged() && this.IsCollisionEnabled() && 0 === (this._flags & FLAG_DESTROYED$jscomp$1)) {
            var a = this.GetBoundingBox()
              , b = this._objectClass._GetCollisionCellGrid()
              , d = this._collisionCells;
            tempRect$jscomp$6.set(b.XToCell(a.getLeft()), b.YToCell(a.getTop()), b.XToCell(a.getRight()), b.YToCell(a.getBottom()));
            d.equals(tempRect$jscomp$6) || (a = this._inst,
            d === DEFAULT_COLLISION_CELLS ? (b.Update(a, null, tempRect$jscomp$6),
            this._collisionCells = C3$jscomp$161.New(C3$jscomp$161.Rect, tempRect$jscomp$6)) : (b.Update(a, d, tempRect$jscomp$6),
            d.copy(tempRect$jscomp$6)),
            this._flags &= ~FLAG_COLLISION_CELL_CHANGED)
        }
    }
    _RemoveFromCollisionCells() {
        const a = this._collisionCells;
        a !== DEFAULT_COLLISION_CELLS && (this._objectClass._GetCollisionCellGrid().Update(this._inst, a, null),
        this._collisionCells = DEFAULT_COLLISION_CELLS)
    }
    _UpdateRenderCell() {
        const a = this.GetLayer();
        if (a.UsesRenderCells() && 0 === (this._flags & FLAG_DESTROYED$jscomp$1)) {
            var b = a.GetRenderGrid()
              , d = this.GetBoundingBox()
              , c = this._renderCells;
            tempRect$jscomp$6.set(b.XToCell(d.getLeft()), b.YToCell(d.getTop()), b.XToCell(d.getRight()), b.YToCell(d.getBottom()));
            c.equals(tempRect$jscomp$6) || (d = this._inst,
            c === DEFAULT_RENDER_CELLS ? (b.Update(d, null, tempRect$jscomp$6),
            this._renderCells = C3$jscomp$161.New(C3$jscomp$161.Rect, tempRect$jscomp$6)) : (b.Update(d, c, tempRect$jscomp$6),
            c.copy(tempRect$jscomp$6)),
            a.SetRenderListStale())
        }
    }
    _RemoveFromRenderCells() {
        const a = this._renderCells;
        a !== DEFAULT_RENDER_CELLS && (this.GetLayer().GetRenderGrid().Update(this._inst, a, null),
        this._renderCells = DEFAULT_RENDER_CELLS)
    }
    GetRenderCellRange() {
        return this._renderCells
    }
    ZOrderMoveToTop() {
        const a = this._inst
          , b = this._layer
          , d = b._GetInstances();
        d.length && d.at(-1) === a || (b._RemoveInstance(a, !1),
        b._AddInstance(a, !1),
        this._runtime.UpdateRender())
    }
    ZOrderMoveToBottom() {
        const a = this._inst
          , b = this._layer
          , d = b._GetInstances();
        d.length && d[0] === a || (b._RemoveInstance(a, !1),
        b._PrependInstance(a, !1),
        this._runtime.UpdateRender())
    }
    ZOrderMoveToLayer(a) {
        const b = this._inst
          , d = this._layer;
        if (d.GetLayout() !== a.GetLayout())
            throw Error("layer from different layout");
        a !== d && (d._RemoveInstance(b, !0),
        this._SetLayer(a),
        a._AddInstance(b, !0),
        this._runtime.UpdateRender())
    }
    ZOrderMoveAdjacentToInstance(a, b) {
        const d = this._inst;
        let c = !1;
        const e = this._layer;
        if (a.GetUID() !== d.GetUID()) {
            var g = a.GetWorldInfo();
            if (!g)
                throw Error("expected world instance");
            g = g.GetLayer();
            e.GetIndex() !== g.GetIndex() && (e._RemoveInstance(d, !0),
            this._SetLayer(g),
            g._AddInstance(d, !0),
            c = !0);
            a = g.MoveInstanceAdjacent(d, a, !!b);
            (c || a) && this._runtime.UpdateRender()
        }
    }
    GetInstanceEffectList() {
        return this._instanceEffectList
    }
    _SetHasAnyActiveEffect(a) {
        this._SetFlag(FLAG_HAS_ANY_ACTIVE_EFFECT, a)
    }
    HasAnyActiveEffect() {
        return 0 !== (this._flags & FLAG_HAS_ANY_ACTIVE_EFFECT)
    }
    _SaveToJson(a) {
        const b = {
            x: this.GetX(),
            y: this.GetY(),
            w: this.GetWidth(),
            h: this.GetHeight(),
            l: this.GetLayer().GetSID(),
            zi: this.GetZIndex()
        };
        0 !== this.GetZElevation() && (b.ze = this.GetZElevation());
        0 !== this.GetAngle() && (b.a = this.GetAngle());
        this.HasDefaultColor() || (b.c = this._color.toJSON());
        .5 !== this.GetOriginX() && (b.oX = this.GetOriginX());
        .5 !== this.GetOriginY() && (b.oY = this.GetOriginY());
        0 !== this.GetBlendMode() && (b.bm = this.GetBlendMode());
        this.IsVisible() || (b.v = this.IsVisible());
        this.IsCollisionEnabled() || (b.ce = this.IsCollisionEnabled());
        this.IsBboxChangeEventEnabled() && (b.be = this.IsBboxChangeEventEnabled());
        this._instanceEffectList && (b.fx = this._instanceEffectList._SaveToJson());
        const d = 0 !== (this._flags & FLAG_SOLID_FILTER_INCLUSIVE);
        d && (b.sfi = d);
        this._solidFilterTags && (b.sft = [...this._solidFilterTags].join(" "));
        this._sceneGraphInfo && "visual-state" !== a && (b.sgi = this._sceneGraphInfo._SaveToJson(a),
        sceneGraphExportDataMap.has(this) && (b.sgcd = sceneGraphExportDataMap.get(this).childrenData,
        b.sgzid = sceneGraphExportDataMap.get(this).zIndexData));
        this.HasMesh() && (b.mesh = this.GetSourceMesh().SaveToJson());
        return b
    }
    _SaveSceneGraphPropertiesToJson() {
        return {
            x: this._x,
            y: this._y,
            z: this._zElevation,
            w: this._w,
            h: this._h,
            a: this._a
        }
    }
    _LoadSceneGraphPropertiesFromJson(a) {
        a && (this._x = a.x,
        this._y = a.y,
        this._zElevation = a.z,
        this._w = a.w,
        this._h = a.h,
        this._a = a.a,
        this._MarkSinCosAngleChanged(),
        this.SetBboxChanged())
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
        this._ReleaseTmpSceneGraphInfo();
        this._ResetAllSceneGraphState();
        this._CreateSceneGraphInfo(null);
        this._sceneGraphInfo && this._sceneGraphInfo._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes)
    }
    _OnBeforeLoad(a) {
        "visual-state" !== a && this._ResetAllSceneGraphState()
    }
    _LoadFromJson(a, b) {
        enableUpdateRendererStateGroup = !1;
        this.SetX(a.x);
        this.SetY(a.y);
        this.SetWidth(a.w);
        this.SetHeight(a.h);
        this._SetZIndex(a.zi);
        this.SetZElevation(a.hasOwnProperty("ze") ? a.ze : 0);
        this.SetAngle(a.hasOwnProperty("a") ? a.a : 0);
        a.hasOwnProperty("c") ? tempColor$jscomp$6.setFromJSON(a.c) : a.hasOwnProperty("o") ? (tempColor$jscomp$6.copyRgb(this._color),
        tempColor$jscomp$6.a = a.o) : tempColor$jscomp$6.setRgba(1, 1, 1, 1);
        this._SetColor(tempColor$jscomp$6);
        this.SetOriginX(a.hasOwnProperty("oX") ? a.oX : .5);
        this.SetOriginY(a.hasOwnProperty("oY") ? a.oY : .5);
        this.SetBlendMode(a.hasOwnProperty("bm") ? a.bm : 0);
        this.SetVisible(a.hasOwnProperty("v") ? a.v : !0);
        this.SetCollisionEnabled(a.hasOwnProperty("ce") ? a.ce : !0);
        this.SetBboxChangeEventEnabled(a.hasOwnProperty("be") ? a.be : !1);
        this.SetSolidCollisionFilter(a.hasOwnProperty("sfi") ? a.sfi : !1, a.hasOwnProperty("sft") ? a.sft : "");
        this._instanceEffectList && a.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(a.fx);
        if (!a.hasOwnProperty("sgi") && "visual-state" !== b && this._tmpSceneGraphChildren)
            for (const d of this._tmpSceneGraphChildren)
                d.IsDestroyed() || this._runtime.DestroyInstance(d);
        if (a.hasOwnProperty("sgi") && "visual-state" !== b) {
            this._CreateSceneGraphInfo(null);
            const d = this._sceneGraphInfo
              , c = a.sgi;
            d._LoadFromJson(c);
            d._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes);
            needsSceneGraphAfterLoad.set(this, !0);
            const e = this.GetRuntime().Dispatcher();
            this._after_load && e.removeEventListener("afterload", this._after_load);
            this._after_load_instance && e.removeEventListener("afterloadinstance", this._after_load_instance);
            this._after_load_instance = this._after_load = null;
            this._after_load = (g,k)=>{
                this._after_load && e.removeEventListener("afterload", this._after_load);
                this._after_load_instance && e.removeEventListener("afterloadinstance", this._after_load_instance);
                this._after_load = this._after_load_instance = null;
                0 === (this._flags & FLAG_DESTROYED$jscomp$1) && (d._OnAfterLoad(c, k),
                d._SetTmpSceneGraphChildren(null, null),
                this._ReleaseTmpSceneGraphInfo(),
                this.SetBboxChanged())
            }
            ;
            this._after_load_instance = g=>{
                g.instance === this.GetInstance() && this._after_load(g, {
                    ignoreMissingInstances: !0
                })
            }
            ;
            e.addEventListener("afterload", this._after_load);
            e.addEventListener("afterloadinstance", this._after_load_instance);
            a.sgcd && C3$jscomp$161.IsFiniteNumber(a.sgzid) && sceneGraphExportDataMap.set(this, {
                childrenData: a.sgcd,
                zIndexData: a.sgzid
            })
        }
        a.hasOwnProperty("mesh") ? (a = a.mesh,
        this.CreateMesh(a.cols, a.rows),
        this.GetSourceMesh().LoadFromJson(a)) : this.ReleaseMesh();
        this.SetBboxChanged();
        enableUpdateRendererStateGroup = !0;
        this._UpdateRendererStateGroup()
    }
}
;
"use strict";
const C3$jscomp$162 = self.C3;
C3$jscomp$162.BehaviorType = class extends C3$jscomp$162.DefendedBase {
    constructor(a, b) {
        super();
        const d = a.GetRuntime()
          , c = d.GetPluginManager()
          , e = d.GetObjectReference(b[1]);
        c.HasBehaviorByConstructorFunction(e) || c.CreateBehavior(b);
        this._runtime = d;
        this._objectClass = a;
        this._behavior = c.GetBehaviorByConstructorFunction(e);
        this._sdkType = null;
        this._instSdkCtor = e.Instance;
        this._sid = b[2];
        this._name = b[0];
        this._jsPropName = this._runtime.GetJsPropName(b[3]);
        this._sdkType = C3$jscomp$162.New(e.Type, this);
        this.OnCreate()
    }
    static Create(a, b) {
        return C3$jscomp$162.New(C3$jscomp$162.BehaviorType, a, b)
    }
    Release() {
        this._behavior = this._runtime = null;
        this._sdkType.Release();
        this._instSdkCtor = this._sdkType = null
    }
    GetSdkType() {
        return this._sdkType
    }
    OnCreate() {
        this._sdkType.OnCreate()
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetBehavior() {
        return this._behavior
    }
    GetInstanceSdkCtor() {
        return this._instSdkCtor
    }
    GetName() {
        return this._name
    }
    GetSID() {
        return this._sid
    }
    GetJsPropName() {
        return this._jsPropName
    }
}
;
"use strict";
const C3$jscomp$163 = self.C3
  , IBehaviorInstance$jscomp$1 = self.IBehaviorInstance;
C3$jscomp$163.BehaviorInstance = class extends C3$jscomp$163.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a.runtime;
        this._behaviorType = a.behaviorType;
        this._behavior = this._behaviorType.GetBehavior();
        this._inst = a.instance;
        this._index = a.index;
        this._iScriptInterface = this._sdkInst = null;
        this._behavior._AddInstance(this._inst)
    }
    Release() {
        this._iScriptInterface && (this._iScriptInterface._Release(),
        this._iScriptInterface = null);
        this._behavior._RemoveInstance(this._inst);
        this._sdkInst.Release();
        this._inst = this._behavior = this._behaviorType = this._runtime = this._sdkInst = null
    }
    _CreateSdkInstance(a) {
        if (this._sdkInst)
            throw Error("already got sdk instance");
        this._sdkInst = C3$jscomp$163.New(this._behaviorType.GetInstanceSdkCtor(), this, a)
    }
    GetSdkInstance() {
        return this._sdkInst
    }
    GetObjectInstance() {
        return this._inst
    }
    GetRuntime() {
        return this._runtime
    }
    GetBehaviorType() {
        return this._behaviorType
    }
    GetBehavior() {
        return this._behavior
    }
    _GetIndex() {
        return this._index
    }
    PostCreate() {
        this._sdkInst.PostCreate()
    }
    OnSpriteFrameChanged(a, b) {
        this._sdkInst.OnSpriteFrameChanged(a, b)
    }
    _GetDebuggerProperties() {
        return this._sdkInst.GetDebuggerProperties()
    }
    SaveToJson() {
        return this._sdkInst.SaveToJson()
    }
    LoadFromJson(a) {
        return this._sdkInst.LoadFromJson(a)
    }
    static SortByTickSequence(a, b) {
        var d = a.GetObjectInstance()
          , c = b.GetObjectInstance();
        const e = d.GetObjectClass().GetIndex()
          , g = c.GetObjectClass().GetIndex();
        if (e !== g)
            return e - g;
        d = d.GetPUID();
        c = c.GetPUID();
        return d !== c ? d - c : a.GetBehaviorInstance()._GetIndex() - b.GetBehaviorInstance()._GetIndex()
    }
    _InitScriptInterface() {
        const a = this._sdkInst.GetScriptInterfaceClass()
          , b = a || IBehaviorInstance$jscomp$1;
        IBehaviorInstance$jscomp$1._Init(this);
        this._iScriptInterface = new b;
        IBehaviorInstance$jscomp$1._Init(null);
        if (a && !(this._iScriptInterface instanceof IBehaviorInstance$jscomp$1))
            throw new TypeError(`script interface class '${a.name}' does not extend the right base class '${IBehaviorInstance$jscomp$1.name}'`);
        return this._iScriptInterface
    }
    GetScriptInterface() {
        return this._iScriptInterface || this._InitScriptInterface()
    }
    HasScriptInterface() {
        return !!this._iScriptInterface
    }
}
;
"use strict";
const C3$jscomp$164 = self.C3;
C3$jscomp$164.EffectList = class extends C3$jscomp$164.DefendedBase {
    constructor(a, b) {
        super();
        this._owner = a;
        this._allEffectTypes = [];
        this._activeEffectTypes = [];
        this._effectTypesByName = new Map;
        this._effectParams = [];
        this._effectParamBuffers = [];
        this._allInstanceEffectLists = new Set;
        this._preservesOpaqueness = !0;
        for (const d of b)
            a = C3$jscomp$164.New(C3$jscomp$164.EffectType, this, d, this._allEffectTypes.length),
            this._allEffectTypes.push(a),
            this._effectTypesByName.set(a.GetName().toLowerCase(), a),
            3 <= d.length && this._effectParams.push(this._LoadSingleEffectParameters(a, d[2]));
        this.GetRuntime()._AddEffectList(this)
    }
    Release() {
        for (const a of this._effectParamBuffers)
            a.Release();
        C3$jscomp$164.clearArray(this._effectParamBuffers);
        C3$jscomp$164.clearArray(this._allEffectTypes);
        C3$jscomp$164.clearArray(this._activeEffectTypes);
        this._effectTypesByName.clear();
        C3$jscomp$164.clearArray(this._effectParams);
        this._owner = null
    }
    _AddInstanceEffectList(a) {
        this._allInstanceEffectLists.add(a)
    }
    _RemoveInstanceEffectList(a) {
        this._allInstanceEffectLists.delete(a)
    }
    _InitRenderer(a) {
        a.IsWebGPU() && (this._effectParamBuffers = this._allEffectTypes.map(b=>{
            b = b.GetShaderProgram();
            return 0 < b.GetCustomParametersByteSize() ? C3$jscomp$164.New(C3$jscomp$164.Gfx.WebGPUEffectCustomParamsBuffer, b) : null
        }
        ),
        this._UpdateAllEffectParamBuffers());
        for (const b of this._allInstanceEffectLists)
            b._InitRenderer(a)
    }
    PrependEffectTypes(a) {
        if (a.length) {
            this._allEffectTypes = a.concat(this._allEffectTypes);
            for (const b of a)
                this._effectTypesByName.set(b.GetName().toLowerCase(), b);
            for (let b = 0, d = this._allEffectTypes.length; b < d; ++b)
                this._allEffectTypes[b]._SetIndex(b)
        }
    }
    _LoadSingleEffectParameters(a, b) {
        a.SetActive(b[0]);
        a = b.slice(1);
        for (let d = 0, c = a.length; d < c; ++d)
            if (b = a[d],
            Array.isArray(b)) {
                const e = C3$jscomp$164.New(C3$jscomp$164.Color);
                e.setFromJSON(b);
                a[d] = e
            }
        return a
    }
    GetOwner() {
        return this._owner
    }
    GetRuntime() {
        return this._owner.GetRuntime()
    }
    UpdateActiveEffects() {
        C3$jscomp$164.clearArray(this._activeEffectTypes);
        let a = !0;
        for (const b of this._allEffectTypes)
            b.IsActive() && (this._activeEffectTypes.push(b),
            b.GetShaderProgram().PreservesOpaqueness() || (a = !1));
        this._preservesOpaqueness = a
    }
    GetAllEffectTypes() {
        return this._allEffectTypes
    }
    HasAnyEffectType() {
        return 0 < this._allEffectTypes.length
    }
    GetEffectTypeByName(a) {
        return this._effectTypesByName.get(a.toLowerCase()) || null
    }
    GetEffectTypeByIndex(a) {
        a = Math.floor(+a);
        if (0 > a || a >= this._allEffectTypes.length)
            throw new RangeError("invalid effect type index");
        return this._allEffectTypes[a]
    }
    IsEffectIndexActive(a) {
        return this.GetEffectTypeByIndex(a).IsActive()
    }
    SetEffectIndexActive(a, b) {
        this.GetEffectTypeByIndex(a).SetActive(b)
    }
    GetActiveEffectTypes() {
        return this._activeEffectTypes
    }
    HasAnyActiveEffect() {
        return 0 < this._activeEffectTypes.length
    }
    PreservesOpaqueness() {
        return this._preservesOpaqueness
    }
    GetEffectParametersForIndex(a) {
        return this._effectParams[a]
    }
    _GetEffectChainShaderParametersForIndex(a) {
        return a < this._effectParamBuffers.length ? this._effectParamBuffers[a] : this._effectParams[a]
    }
    GetEffectParameter(a, b) {
        if (0 > a || a >= this._effectParams.length)
            return null;
        a = this._effectParams[a];
        return 0 > b || b >= a.length ? null : a[b]
    }
    SetEffectParameter(a, b, d) {
        if (0 > a || a >= this._effectParams.length)
            return !1;
        const c = this._effectParams[a];
        if (0 > b || b >= c.length)
            return !1;
        const e = c[b];
        if (e instanceof C3$jscomp$164.Color) {
            if (e.equalsIgnoringAlpha(d))
                return !1;
            e.copyRgb(d)
        } else {
            if (e === d)
                return !1;
            c[b] = d
        }
        a < this._effectParamBuffers.length && this._effectParamBuffers[a].SetParameterValue(b, d);
        return !0
    }
    _UpdateAllEffectParamBuffers() {
        const a = this._effectParams
          , b = this._effectParamBuffers;
        for (let d = 0, c = Math.min(a.length, b.length); d < c; ++d) {
            const e = b[d]
              , g = a[d];
            for (let k = 0, l = g.length; k < l; ++k)
                e.SetParameterValue(k, g[k])
        }
    }
    static SaveFxParamToJson(a) {
        return a && a instanceof C3$jscomp$164.Color ? {
            t: "color",
            v: a.toJSON()
        } : a
    }
    static LoadFxParamFromJson(a) {
        if (null === a)
            return NaN;
        if ("object" === typeof a) {
            if ("color" === a.t) {
                const b = C3$jscomp$164.New(C3$jscomp$164.Color);
                b.setFromJSON(a.v);
                return b
            }
            throw Error("invalid effect parameter type");
        }
        return a
    }
    static SaveFxParamsToJson(a) {
        return a.map(C3$jscomp$164.EffectList.SaveFxParamToJson)
    }
    static LoadFxParamsFromJson(a) {
        return a.map(C3$jscomp$164.EffectList.LoadFxParamFromJson)
    }
    SaveToJson() {
        return this._allEffectTypes.map(a=>({
            name: a.GetName(),
            active: a.IsActive(),
            params: C3$jscomp$164.EffectList.SaveFxParamsToJson(this._effectParams[a.GetIndex()])
        }))
    }
    LoadFromJson(a) {
        for (const b of a)
            if (a = this.GetEffectTypeByName(b.name))
                a.SetActive(b.active),
                this._effectParams[a.GetIndex()] = C3$jscomp$164.EffectList.LoadFxParamsFromJson(b.params);
        this.UpdateActiveEffects();
        this._UpdateAllEffectParamBuffers()
    }
}
;
"use strict";
const C3$jscomp$165 = self.C3;
C3$jscomp$165.EffectType = class extends C3$jscomp$165.DefendedBase {
    constructor(a, b, d) {
        super();
        this._effectList = a;
        this._id = b[0];
        this._name = b[1];
        this._index = d;
        this._shaderProgram = null;
        this._isActive = !0
    }
    Release() {
        this._shaderProgram = this._effectList = null
    }
    Clone(a) {
        a = C3$jscomp$165.New(C3$jscomp$165.EffectType, a, [this._id, this._name], -1);
        a._shaderProgram = this._shaderProgram;
        a._isActive = this._isActive;
        return a
    }
    _InitRenderer(a) {
        a = a.GetShaderProgramByName(this._id);
        if (!a)
            throw Error("failed to find shader program '" + this._id + "'");
        this._shaderProgram = a
    }
    GetEffectList() {
        return this._effectList
    }
    GetName() {
        return this._name
    }
    _SetIndex(a) {
        this._index = a
    }
    GetIndex() {
        return this._index
    }
    GetOwner() {
        return this._effectList.GetOwner()
    }
    GetRuntime() {
        return this._effectList.GetRuntime()
    }
    SetActive(a) {
        this._isActive = !!a
    }
    IsActive() {
        return this._isActive
    }
    GetShaderProgram() {
        return this._shaderProgram
    }
    GetDefaultParameterValues() {
        const a = [];
        for (let b = 0, d = this._shaderProgram.GetParameterCount(); b < d; ++b) {
            const c = this._shaderProgram.GetParameterType(b);
            if ("float" === c || "percent" === c)
                a.push(0);
            else if ("color" === c)
                a.push(C3$jscomp$165.New(C3$jscomp$165.Color, 1, 1, 1, 1));
            else
                throw new TypeError("unknown effect parameter type");
        }
        return a
    }
}
;
"use strict";
const C3$jscomp$166 = self.C3;
C3$jscomp$166.InstanceEffectList = class extends C3$jscomp$166.DefendedBase {
    constructor(a, b) {
        super();
        this._inst = a;
        this._wi = b;
        this._effectList = a.GetObjectClass().GetEffectList();
        this._wasDefaultColor = this._needsRebuildSteps = !0;
        this._wasTexRotated = this._wasRotatedOrNegativeSize = this._was3D = !1;
        this._effectChain = C3$jscomp$166.New(C3$jscomp$166.Gfx.EffectChain, a.GetRuntime().GetCanvasManager().GetEffectChainManager(), {
            drawContent: (d,c)=>{
                c = c.GetContentObject();
                const e = c.GetWorldInfo();
                d.SetColor(e.GetPremultipliedColor());
                d.SetCurrentZ(e.GetTotalZElevation());
                c.Draw(d);
                d.SetCurrentZ(0)
            }
            ,
            getSourceTextureInfo: d=>{
                const c = d.GetCurrentTexRect()
                  , [e,g] = d.GetCurrentSurfaceSize();
                return {
                    srcTexRect: c,
                    srcWidth: e,
                    srcHeight: g
                }
            }
            ,
            getShaderParameters: d=>this._GetEffectChainShaderParametersForIndex(d)
        });
        this._activeEffectFlags = [];
        this._activeEffectTypes = [];
        this._preservesOpaqueness = !0;
        this._effectParams = [];
        this._effectParamBuffers = [];
        this._InitRenderer(a.GetRuntime().GetRenderer());
        for (let d = 0, c = this._effectList.GetAllEffectTypes().length; d < c; ++d)
            this._activeEffectFlags.push(!0);
        this.UpdateActiveEffects();
        this._effectList._AddInstanceEffectList(this)
    }
    Release() {
        this._effectList._RemoveInstanceEffectList(this);
        for (const a of this._effectParamBuffers)
            a.Release();
        C3$jscomp$166.clearArray(this._effectParamBuffers);
        this._effectChain.Release();
        this._effectChain = null;
        C3$jscomp$166.clearArray(this._activeEffectFlags);
        C3$jscomp$166.clearArray(this._activeEffectTypes);
        C3$jscomp$166.clearArray(this._effectParams);
        this._effectList = this._inst = null
    }
    _InitRenderer(a) {
        a.IsWebGPU() && (this._effectParamBuffers = this._effectList.GetAllEffectTypes().map(b=>{
            b = b.GetShaderProgram();
            return 0 < b.GetCustomParametersByteSize() ? C3$jscomp$166.New(C3$jscomp$166.Gfx.WebGPUEffectCustomParamsBuffer, b) : null
        }
        ))
    }
    _LoadEffectParameters(a) {
        let b = 0;
        for (const d of a)
            this._effectParams.push(this._LoadSingleEffectParameters(b, d)),
            ++b;
        this._UpdateAllEffectParamBuffers();
        this.UpdateActiveEffects()
    }
    _LoadSingleEffectParameters(a, b) {
        this._activeEffectFlags[a] = b[0];
        a = b.slice(1);
        for (let d = 0, c = a.length; d < c; ++d)
            if (b = a[d],
            Array.isArray(b)) {
                const e = C3$jscomp$166.New(C3$jscomp$166.Color);
                e.setFromJSON(b);
                a[d] = e
            }
        return a
    }
    LoadDefaultEffectParameters() {
        for (const a of this._effectList.GetAllEffectTypes())
            this._effectParams.push(a.GetDefaultParameterValues());
        this._UpdateAllEffectParamBuffers()
    }
    GetOwner() {
        return this._owner
    }
    GetEffectList() {
        return this._effectList
    }
    GetEffectChain() {
        this._MaybeRebuildEffectChainSteps();
        return this._effectChain
    }
    GetRuntime() {
        return this._inst.GetRuntime()
    }
    UpdateActiveEffects() {
        C3$jscomp$166.clearArray(this._activeEffectTypes);
        const a = this._wi
          , b = this._effectList.GetAllEffectTypes()
          , d = this._activeEffectTypes
          , c = this._activeEffectFlags;
        let e = !0;
        for (let g = 0, k = b.length; g < k; ++g)
            if (c[g]) {
                const l = b[g];
                d.push(l);
                l.GetShaderProgram().PreservesOpaqueness() || (e = !1)
            }
        this._preservesOpaqueness = e;
        a._SetHasAnyActiveEffect(!!d.length);
        this._needsRebuildSteps = !0
    }
    _MaybeRebuildEffectChainSteps() {
        const a = this._inst;
        var b = this._wi;
        const d = b.HasDefaultColor()
          , c = 0 < b.GetDepth();
        b = 0 !== b.GetAngle() || 0 > b.GetWidth() || 0 > b.GetHeight();
        const e = a.IsCurrentTexRotated();
        if (this._needsRebuildSteps || d !== this._wasDefaultColor || c !== this._was3D || b !== this._wasRotatedOrNegativeSize || e !== this._wasTexRotated || this._effectChain.NeedsRebuild())
            this._effectChain.BuildSteps(this._activeEffectTypes.map(g=>g.GetShaderProgram()), {
                indexMap: this._activeEffectTypes.map(g=>g.GetIndex()),
                forcePreDraw: !d || a.MustPreDraw(),
                is3D: c,
                isSourceTextureRotated: e,
                isRotatedOrNegativeSizeInstance: b
            }),
            this._needsRebuildSteps = !1,
            this._wasDefaultColor = d,
            this._was3D = c,
            this._wasRotatedOrNegativeSize = b,
            this._wasTexRotated = e
    }
    GetActiveEffectTypes() {
        return this._activeEffectTypes
    }
    GetEffectParametersForIndex(a) {
        return this._effectParams[a]
    }
    _GetEffectChainShaderParametersForIndex(a) {
        return a < this._effectParamBuffers.length ? this._effectParamBuffers[a] : this._effectParams[a]
    }
    GetEffectParameter(a, b) {
        if (0 > a || a >= this._effectParams.length)
            return null;
        a = this._effectParams[a];
        return 0 > b || b >= a.length ? null : a[b]
    }
    SetEffectParameter(a, b, d) {
        if (0 > a || a >= this._effectParams.length)
            return !1;
        const c = this._effectParams[a];
        if (0 > b || b >= c.length)
            return !1;
        const e = c[b];
        if (e instanceof C3$jscomp$166.Color) {
            if (e.equalsIgnoringAlpha(d))
                return !1;
            e.copyRgb(d)
        } else {
            if (e === d)
                return !1;
            c[b] = d
        }
        a < this._effectParamBuffers.length && this._effectParamBuffers[a].SetParameterValue(b, d);
        return !0
    }
    _UpdateAllEffectParamBuffers() {
        const a = this._effectParams
          , b = this._effectParamBuffers;
        for (let d = 0, c = b.length; d < c; ++d) {
            const e = b[d]
              , g = a[d];
            for (let k = 0, l = g.length; k < l; ++k)
                e.SetParameterValue(k, g[k])
        }
    }
    PreservesOpaqueness() {
        return this._preservesOpaqueness
    }
    HasAnyActiveBackgroundBlendingEffect() {
        return this._activeEffectTypes.some(a=>a.GetShaderProgram().BlendsBackground())
    }
    IsEffectIndexActive(a) {
        return this._activeEffectFlags[a]
    }
    SetEffectIndexActive(a, b) {
        this._activeEffectFlags[a] = !!b
    }
    GetAllEffectTypes() {
        return this._effectList.GetAllEffectTypes()
    }
    _SaveToJson() {
        return this._effectList.GetAllEffectTypes().map(a=>({
            name: a.GetName(),
            active: this._activeEffectFlags[a.GetIndex()],
            params: C3$jscomp$166.EffectList.SaveFxParamsToJson(this._effectParams[a.GetIndex()])
        }))
    }
    _LoadFromJson(a) {
        for (const b of a)
            if (a = this._effectList.GetEffectTypeByName(b.name))
                this._activeEffectFlags[a.GetIndex()] = b.active,
                this._effectParams[a.GetIndex()] = C3$jscomp$166.EffectList.LoadFxParamsFromJson(b.params);
        this.UpdateActiveEffects();
        this._UpdateAllEffectParamBuffers()
    }
}
;
"use strict";
const C3$jscomp$167 = self.C3
  , tempCandidates = []
  , tileCollRectCandidates = []
  , tempJumpthruRet = []
  , tempPolyA = C3$jscomp$167.New(C3$jscomp$167.CollisionPoly)
  , tempPolyB = C3$jscomp$167.New(C3$jscomp$167.CollisionPoly)
  , tempQuad$jscomp$4 = C3$jscomp$167.New(C3$jscomp$167.Quad)
  , tempRect$jscomp$7 = C3$jscomp$167.New(C3$jscomp$167.Rect)
  , tempRect2$jscomp$1 = C3$jscomp$167.New(C3$jscomp$167.Rect);
let tempPolyC = null
  , tempRect3$jscomp$1 = null
  , tempQuadB = null;
C3$jscomp$167.CollisionEngine = class extends C3$jscomp$167.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._registeredCollisions = [];
        this._polyCheckSec = this._polyCheckCount = this._collisionCheckSec = this._collisionCheckCount = 0
    }
    Release() {
        this._runtime = null
    }
    _Update1sStats() {
        this._collisionCheckSec = this._collisionCheckCount;
        this._collisionCheckCount = 0;
        this._polyCheckSec = this._polyCheckCount;
        this._polyCheckCount = 0
    }
    Get1secCollisionChecks() {
        return this._collisionCheckSec
    }
    Get1secPolyChecks() {
        return this._polyCheckSec
    }
    RegisterCollision(a, b) {
        const d = a.GetWorldInfo()
          , c = b.GetWorldInfo();
        d && c && d.IsCollisionEnabled() && c.IsCollisionEnabled() && this._registeredCollisions.push([a, b])
    }
    AddRegisteredCollisionCandidates(a, b, d) {
        for (const [c,e] of this._registeredCollisions) {
            let g;
            if (a === c)
                g = e;
            else if (a === e)
                g = c;
            else
                continue;
            g.BelongsToObjectClass(b) && (d.includes(g) || d.push(g))
        }
    }
    CheckRegisteredCollision(a, b) {
        if (!this._registeredCollisions.length)
            return !1;
        for (const [d,c] of this._registeredCollisions)
            if (a === d && b === c || a === c && b === d)
                return !0;
        return !1
    }
    ClearRegisteredCollisions() {
        C3$jscomp$167.clearArray(this._registeredCollisions)
    }
    TestOverlap(a, b) {
        if (!a || !b || a === b)
            return !1;
        a = a.GetWorldInfo();
        b = b.GetWorldInfo();
        if (!a.IsCollisionEnabled() || !b.IsCollisionEnabled())
            return !1;
        this._collisionCheckCount++;
        const d = a.GetLayer()
          , c = b.GetLayer();
        return d.IsTransformCompatibleWith(c) ? this._TestOverlap_SameLayers(a, b) : this._TestOverlap_DifferentLayers(a, b)
    }
    _TestOverlap_SameLayers(a, b) {
        if (!a.GetBoundingBox().intersectsRect(b.GetBoundingBox()))
            return !1;
        this._polyCheckCount++;
        if (!a.GetBoundingQuad().intersectsQuad(b.GetBoundingQuad()) || a.HasTilemap() && b.HasTilemap())
            return !1;
        if (a.HasTilemap())
            return this.TestTilemapOverlap(a, b);
        if (b.HasTilemap())
            return this.TestTilemapOverlap(b, a);
        if (!a.HasOwnCollisionPoly() && !b.HasOwnCollisionPoly())
            return !0;
        const d = a.GetTransformedCollisionPoly()
          , c = b.GetTransformedCollisionPoly();
        return d.intersectsPoly(c, b.GetX() - a.GetX(), b.GetY() - a.GetY())
    }
    _TestOverlap_DifferentLayers(a, b) {
        var d = a.HasTilemap()
          , c = b.HasTilemap();
        if (d && !c)
            return this.TestTilemapOverlapDifferentLayers(a, b);
        if (c && !d)
            return this.TestTilemapOverlapDifferentLayers(b, a);
        if (c || d)
            return !1;
        c = a.GetLayer();
        d = b.GetLayer();
        tempPolyA.copy(a.GetTransformedCollisionPoly());
        tempPolyB.copy(b.GetTransformedCollisionPoly());
        var e = tempPolyA.pointsArr();
        for (let g = 0, k = e.length; g < k; g += 2) {
            const l = g + 1
              , n = e[l]
              , [p,t] = c.LayerToCanvasCss(e[g] + a.GetX(), n + a.GetY());
            e[g] = p;
            e[l] = t
        }
        a = tempPolyB.pointsArr();
        for (let g = 0, k = a.length; g < k; g += 2) {
            c = g + 1;
            e = a[c];
            const [l,n] = d.LayerToCanvasCss(a[g] + b.GetX(), e + b.GetY());
            a[g] = l;
            a[c] = n
        }
        tempPolyA.setBboxChanged();
        tempPolyB.setBboxChanged();
        this._polyCheckCount++;
        return tempPolyA.intersectsPoly(tempPolyB, 0, 0)
    }
    TestTilemapOverlapDifferentLayers(a, b) {
        var d = a.GetLayer()
          , c = b.GetLayer();
        tempPolyC || (tempPolyC = C3$jscomp$167.New(C3$jscomp$167.CollisionPoly));
        tempRect3$jscomp$1 || (tempRect3$jscomp$1 = C3$jscomp$167.New(C3$jscomp$167.Rect));
        tempQuadB || (tempQuadB = C3$jscomp$167.New(C3$jscomp$167.Quad));
        var e = b.GetX()
          , g = b.GetY();
        const [k,l] = c.LayerToCanvasCss(e, g)
          , [n,p] = d.CanvasCssToLayer(k, l);
        d = n - e;
        g = p - g;
        tempRect3$jscomp$1.copy(b.GetBoundingBox());
        tempRect3$jscomp$1.offset(d, g);
        if (!a.GetBoundingBox().intersectsRect(tempRect3$jscomp$1))
            return !1;
        tempQuadB.copy(b.GetBoundingQuad());
        tempQuadB.offset(d, g);
        this._polyCheckCount++;
        if (!a.GetBoundingQuad().intersectsQuad(tempQuadB))
            return !1;
        tempPolyC.copy(b.GetTransformedCollisionPoly());
        c = tempPolyC.pointsArr();
        for (let t = 0, w = c.length; t < w; t += 2)
            e = t + 1,
            c[t] += d,
            c[e] += g;
        tempPolyC.setBboxChanged();
        return this.TestTilemapOverlap(a, b, n, p, tempPolyC, tempRect3$jscomp$1, tempQuadB)
    }
    TestTilemapOverlap(a, b, d, c, e, g, k) {
        g = void 0 !== g ? g : b.GetBoundingBox();
        const l = a.GetX()
          , n = a.GetY();
        var p = a.GetInstance().GetSdkInstance();
        d = void 0 !== d ? d : b.GetX();
        c = void 0 !== c ? c : b.GetY();
        a = b.HasOwnCollisionPoly();
        k = void 0 !== k ? k : b.GetBoundingQuad();
        p.GetCollisionRectCandidates(g, tileCollRectCandidates);
        for (let z = 0, B = tileCollRectCandidates.length; z < B; ++z) {
            var t = tileCollRectCandidates[z];
            p = t.GetRect();
            this._collisionCheckCount++;
            if (g.intersectsRectOffset(p, l, n) && (tempQuad$jscomp$4.setFromRect(p),
            tempQuad$jscomp$4.offset(l, n),
            tempQuad$jscomp$4.intersectsQuad(k)))
                if (a) {
                    var w = void 0 !== e ? e : b.GetTransformedCollisionPoly();
                    if (t = t.GetPoly()) {
                        if (this._polyCheckCount++,
                        t.intersectsPoly(w, d - (l + p.getLeft()), c - (n + p.getTop())))
                            return C3$jscomp$167.clearArray(tileCollRectCandidates),
                            !0
                    } else if (tempPolyA.setFromQuad(tempQuad$jscomp$4, 0, 0),
                    tempPolyA.intersectsPoly(w, d, c))
                        return C3$jscomp$167.clearArray(tileCollRectCandidates),
                        !0
                } else if (w = t.GetPoly()) {
                    if (tempPolyA.setFromQuad(k, 0, 0),
                    w.intersectsPoly(tempPolyA, -(l + p.getLeft()), -(n + p.getTop())))
                        return C3$jscomp$167.clearArray(tileCollRectCandidates),
                        !0
                } else
                    return C3$jscomp$167.clearArray(tileCollRectCandidates),
                    !0
        }
        C3$jscomp$167.clearArray(tileCollRectCandidates);
        return !1
    }
    TestAndSelectCanvasPointOverlap(a, b, d, c) {
        const e = a.GetCurrentSol();
        var g = this._runtime.GetCurrentEvent();
        if (!g)
            throw Error("cannot call outside event");
        g = g.IsOrBlock();
        const k = new Map
          , l = z=>{
            let B = k.get(z);
            "undefined" === typeof B && (B = z.IsSelfAndParentsInteractive(),
            k.set(z, B));
            return B
        }
        ;
        if (e.IsSelectAll()) {
            c || (e._SetSelectAll(!1),
            C3$jscomp$167.clearArray(e._GetOwnInstances()));
            for (var n of a.GetInstances()) {
                var p = n.GetWorldInfo()
                  , t = p.GetLayer()
                  , w = !1;
                if (l(t) && p.IsInViewport2()) {
                    const [z,B] = t.CanvasCssToLayer(b, d, p.GetTotalZElevation());
                    w = p.ContainsPoint(z, B)
                }
                if (w) {
                    if (c)
                        return !1;
                    e._PushInstance(n)
                } else
                    g && e._PushElseInstance(n)
            }
        } else {
            p = !1;
            g ? this._runtime.IsCurrentConditionFirst() && !e._GetOwnElseInstances().length && e._GetOwnInstances().length ? n = e._GetOwnInstances() : (n = e._GetOwnElseInstances(),
            p = !0) : n = e._GetOwnInstances();
            t = 0;
            for (let z = 0, B = n.length; z < B; ++z) {
                w = n[z];
                const C = w.GetWorldInfo()
                  , E = C.GetLayer();
                let F = !1;
                if (l(E) && C.IsInViewport2()) {
                    const [J,K] = E.CanvasCssToLayer(b, d, C.GetTotalZElevation());
                    F = C.ContainsPoint(J, K)
                }
                if (F) {
                    if (c)
                        return !1;
                    p ? e._PushInstance(w) : n[t++] = w
                } else
                    p ? n[t++] = w : g && e._PushElseInstance(w)
            }
            c || (n.length = t)
        }
        a.ApplySolToContainer();
        k.clear();
        return c ? !0 : e.HasAnyInstances()
    }
    GetCollisionCandidates(a, b, d, c) {
        a = a ? 1 !== a.GetParallaxX() || 1 !== a.GetParallaxY() : !1;
        if (b.IsFamily())
            for (const e of b.GetFamilyMembers())
                a || e.IsAnyInstanceParallaxed() ? C3$jscomp$167.appendArray(c, e.GetInstances()) : (e._UpdateAllCollisionCells(),
                e._GetCollisionCellGrid().QueryRange(d, c));
        else
            a || b.IsAnyInstanceParallaxed() ? C3$jscomp$167.appendArray(c, b.GetInstances()) : (b._UpdateAllCollisionCells(),
            b._GetCollisionCellGrid().QueryRange(d, c))
    }
    GetObjectClassesCollisionCandidates(a, b, d, c) {
        for (const e of b)
            this.GetCollisionCandidates(a, e, d, c)
    }
    GetSolidCollisionCandidates(a, b, d) {
        const c = this._runtime.GetSolidBehavior();
        c && this.GetObjectClassesCollisionCandidates(a, c.GetObjectClasses(), b, d)
    }
    GetJumpthruCollisionCandidates(a, b, d) {
        const c = this._runtime.GetJumpthruBehavior();
        c && this.GetObjectClassesCollisionCandidates(a, c.GetObjectClasses(), b, d)
    }
    IsSolidCollisionAllowed(a, b) {
        return a._IsSolidEnabled() && (!b || b.GetWorldInfo().IsSolidCollisionAllowed(a.GetSavedDataMap().get("solidTags")))
    }
    TestOverlapSolid(a) {
        const b = a.GetWorldInfo();
        this.GetSolidCollisionCandidates(b.GetLayer(), b.GetBoundingBox(), tempCandidates);
        for (const d of tempCandidates)
            if (this.IsSolidCollisionAllowed(d, a) && this.TestOverlap(a, d))
                return C3$jscomp$167.clearArray(tempCandidates),
                d;
        C3$jscomp$167.clearArray(tempCandidates);
        return null
    }
    TestRectOverlapSolid(a, b) {
        this.GetSolidCollisionCandidates(null, a, tempCandidates);
        for (const d of tempCandidates)
            if (this.IsSolidCollisionAllowed(d, b) && this.TestRectOverlap(a, d))
                return C3$jscomp$167.clearArray(tempCandidates),
                d;
        C3$jscomp$167.clearArray(tempCandidates);
        return null
    }
    TestOverlapJumpthru(a, b) {
        let d = null;
        b && (d = tempJumpthruRet,
        C3$jscomp$167.clearArray(d));
        const c = a.GetWorldInfo();
        this.GetJumpthruCollisionCandidates(c.GetLayer(), c.GetBoundingBox(), tempCandidates);
        for (const e of tempCandidates)
            if (e._IsJumpthruEnabled() && this.TestOverlap(a, e))
                if (b)
                    d.push(e);
                else
                    return C3$jscomp$167.clearArray(tempCandidates),
                    e;
        C3$jscomp$167.clearArray(tempCandidates);
        return d
    }
    PushOut(a, b, d, c, e) {
        c = c || 50;
        const g = a.GetWorldInfo()
          , k = g.GetX()
          , l = g.GetY();
        for (let n = 0; n < c; ++n)
            if (g.SetXY(k + b * n, l + d * n),
            g.SetBboxChanged(),
            !this.TestOverlap(a, e))
                return !0;
        g.SetXY(k, l);
        g.SetBboxChanged();
        return !1
    }
    PushOutSolid(a, b, d, c, e, g) {
        c = c || 50;
        const k = a.GetWorldInfo()
          , l = k.GetX()
          , n = k.GetY();
        let p = null
          , t = null;
        for (let w = 0; w < c; ++w)
            if (k.SetXY(l + b * w, n + d * w),
            k.SetBboxChanged(),
            !this.TestOverlap(a, p))
                if (p = this.TestOverlapSolid(a))
                    t = p;
                else if (e && (p = g ? this.TestOverlap(a, g) ? g : null : this.TestOverlapJumpthru(a)) && (t = p),
                !p)
                    return t && this.PushInFractional(a, b, d, t, 16, !0),
                    !0;
        k.SetXY(l, n);
        k.SetBboxChanged();
        return !1
    }
    PushOutSolidAxis(a, b, d, c) {
        c = c || 50;
        const e = a.GetWorldInfo()
          , g = e.GetX()
          , k = e.GetY();
        let l = null
          , n = null;
        for (let p = 0; p < c; ++p)
            for (let t = 0; 2 > t; ++t) {
                const w = 2 * t - 1;
                e.SetXY(g + b * p * w, k + d * p * w);
                e.SetBboxChanged();
                if (!this.TestOverlap(a, l))
                    if (l = this.TestOverlapSolid(a))
                        n = l;
                    else
                        return n && this.PushInFractional(a, b * w, d * w, n, 16, !0),
                        !0
            }
        e.SetXY(g, k);
        e.SetBboxChanged();
        return !1
    }
    PushInFractional(a, b, d, c, e, g) {
        let k = 2
          , l = !1;
        var n = !1;
        const p = a.GetWorldInfo();
        let t = p.GetX()
          , w = p.GetY();
        for (; k <= e; )
            n = 1 / k,
            k *= 2,
            p.OffsetXY(b * n * (l ? 1 : -1), d * n * (l ? 1 : -1)),
            p.SetBboxChanged(),
            this.TestOverlap(a, c) || g && this.TestOverlapSolid(a) ? n = l = !0 : (n = l = !1,
            t = p.GetX(),
            w = p.GetY());
        n && (p.SetXY(t, w),
        p.SetBboxChanged())
    }
    PushOutSolidNearest(a, b=100) {
        let d = 0;
        const c = a.GetWorldInfo()
          , e = c.GetX()
          , g = c.GetY();
        let k = 0
          , l = this.TestOverlapSolid(a);
        if (!l)
            return !0;
        for (; d <= b; ) {
            let n = 0
              , p = 0;
            switch (k) {
            case 0:
                n = 0;
                p = -1;
                d++;
                break;
            case 1:
                n = 1;
                p = -1;
                break;
            case 2:
                n = 1;
                p = 0;
                break;
            case 3:
                p = n = 1;
                break;
            case 4:
                n = 0;
                p = 1;
                break;
            case 5:
                n = -1;
                p = 1;
                break;
            case 6:
                n = -1;
                p = 0;
                break;
            case 7:
                p = n = -1
            }
            k = (k + 1) % 8;
            c.SetXY(Math.floor(e + n * d), Math.floor(g + p * d));
            c.SetBboxChanged();
            if (!this.TestOverlap(a, l) && (l = this.TestOverlapSolid(a),
            !l))
                return !0
        }
        c.SetXY(e, g);
        c.SetBboxChanged();
        return !1
    }
    CalculateBounceAngle(a, b, d, c) {
        const e = a.GetWorldInfo()
          , g = e.GetX()
          , k = e.GetY()
          , l = Math.max(10, C3$jscomp$167.distanceTo(b, d, g, k));
        var n = C3$jscomp$167.angleTo(b, d, g, k)
          , p = c || this.TestOverlapSolid(a);
        if (!p)
            return C3$jscomp$167.clampAngle(n + Math.PI);
        let t = p;
        var w = 0
          , z = 0;
        const B = C3$jscomp$167.toRadians(5);
        let C;
        for (C = 1; 36 > C; ++C) {
            const E = n - C * B;
            e.SetXY(b + Math.cos(E) * l, d + Math.sin(E) * l);
            e.SetBboxChanged();
            if (!this.TestOverlap(a, t) && (t = c ? null : this.TestOverlapSolid(a),
            !t)) {
                w = E;
                break
            }
        }
        36 === C && (w = C3$jscomp$167.clampAngle(n + Math.PI));
        t = p;
        for (C = 1; 36 > C; ++C)
            if (p = n + C * B,
            e.SetXY(b + Math.cos(p) * l, d + Math.sin(p) * l),
            e.SetBboxChanged(),
            !this.TestOverlap(a, t) && (t = c ? null : this.TestOverlapSolid(a),
            !t)) {
                z = p;
                break
            }
        36 === C && (z = C3$jscomp$167.clampAngle(n + Math.PI));
        e.SetXY(g, k);
        e.SetBboxChanged();
        if (z === w)
            return z;
        a = C3$jscomp$167.angleDiff(z, w) / 2;
        a = C3$jscomp$167.angleClockwise(z, w) ? C3$jscomp$167.clampAngle(w + a + Math.PI) : C3$jscomp$167.clampAngle(z + a);
        w = Math.cos(n);
        n = Math.sin(n);
        z = Math.cos(a);
        a = Math.sin(a);
        b = w * z + n * a;
        return C3$jscomp$167.angleTo(0, 0, w - 2 * b * z, n - 2 * b * a)
    }
    TestSegmentOverlap(a, b, d, c, e) {
        if (!e)
            return !1;
        const g = e.GetWorldInfo();
        if (!g.IsCollisionEnabled())
            return !1;
        this._collisionCheckCount++;
        tempRect$jscomp$7.set(Math.min(a, d), Math.min(b, c), Math.max(a, d), Math.max(b, c));
        if (!g.GetBoundingBox().intersectsRect(tempRect$jscomp$7))
            return !1;
        if (e.HasTilemap())
            return this._TestSegmentOverlapTilemap(a, b, d, c, e, g);
        this._polyCheckCount++;
        return g.GetBoundingQuad().intersectsSegment(a, b, d, c) ? g.HasOwnCollisionPoly() ? g.GetTransformedCollisionPoly().intersectsSegment(g.GetX(), g.GetY(), a, b, d, c) : !0 : !1
    }
    _TestSegmentOverlapTilemap(a, b, d, c, e, g) {
        const k = g.GetX();
        g = g.GetY();
        e = e.GetSdkInstance();
        tempRect2$jscomp$1.set(a, b, d, c);
        tempRect2$jscomp$1.normalize();
        e.GetCollisionRectCandidates(tempRect2$jscomp$1, tileCollRectCandidates);
        for (let n = 0, p = tileCollRectCandidates.length; n < p; ++n) {
            var l = tileCollRectCandidates[n];
            e = l.GetRect();
            this._collisionCheckCount++;
            if (tempRect$jscomp$7.intersectsRectOffset(e, k, g) && (tempQuad$jscomp$4.setFromRect(e),
            tempQuad$jscomp$4.offset(k, g),
            tempQuad$jscomp$4.intersectsSegment(a, b, d, c)))
                if (l = l.GetPoly()) {
                    if (this._polyCheckCount++,
                    l.intersectsSegment(k + e.getLeft(), g + e.getTop(), a, b, d, c))
                        return C3$jscomp$167.clearArray(tileCollRectCandidates),
                        !0
                } else
                    return C3$jscomp$167.clearArray(tileCollRectCandidates),
                    !0
        }
        C3$jscomp$167.clearArray(tileCollRectCandidates);
        return !1
    }
    TestRectOverlap(a, b) {
        if (!b)
            return !1;
        const d = b.GetWorldInfo();
        if (!d.IsCollisionEnabled())
            return !1;
        this._collisionCheckCount++;
        if (!d.GetBoundingBox().intersectsRect(a))
            return !1;
        if (b.HasTilemap())
            return this._TestRectOverlapTilemap(a, b, d);
        this._polyCheckCount++;
        tempQuad$jscomp$4.setFromRect(a);
        if (!d.GetBoundingQuad().intersectsQuad(tempQuad$jscomp$4))
            return !1;
        if (!d.HasOwnCollisionPoly())
            return !0;
        tempPolyA.setFromRect(a, d.GetX(), d.GetY());
        a = d.GetTransformedCollisionPoly();
        return tempPolyA.intersectsPoly(a, 0, 0)
    }
    _TestRectOverlapTilemap(a, b, d) {
        const c = d.GetX();
        d = d.GetY();
        b.GetSdkInstance().GetCollisionRectCandidates(a, tileCollRectCandidates);
        for (let g = 0, k = tileCollRectCandidates.length; g < k; ++g) {
            var e = tileCollRectCandidates[g];
            b = e.GetRect();
            this._collisionCheckCount++;
            if (a.intersectsRectOffset(b, c, d))
                if (e = e.GetPoly()) {
                    if (this._polyCheckCount++,
                    tempPolyA.setFromRect(a, 0, 0),
                    e.intersectsPoly(tempPolyA, -(c + b.getLeft()), -(d + b.getTop())))
                        return C3$jscomp$167.clearArray(tileCollRectCandidates),
                        !0
                } else
                    return C3$jscomp$167.clearArray(tileCollRectCandidates),
                    !0
        }
        C3$jscomp$167.clearArray(tileCollRectCandidates);
        return !1
    }
    TestRayIntersectsInstance(a, b) {
        if (a) {
            var d = a.GetWorldInfo();
            d.IsCollisionEnabled() && (this._collisionCheckCount++,
            d.GetBoundingBox().intersectsRect(b.rect) && (a.HasTilemap() ? this._TestRayIntersectsTilemap(a, d, b) : (this._polyCheckCount++,
            d.HasOwnCollisionPoly() ? b.TestInstancePoly(a, d.GetX(), d.GetY(), d.GetTransformedCollisionPoly()) : b.TestInstanceQuad(a, d.GetBoundingQuad()))))
        }
    }
    _TestRayIntersectsTilemap(a, b, d) {
        const c = b.GetX()
          , e = b.GetY();
        a.GetSdkInstance().GetCollisionRectCandidates(d.rect, tileCollRectCandidates);
        for (let k = 0, l = tileCollRectCandidates.length; k < l; k++) {
            var g = tileCollRectCandidates[k];
            const n = g.GetRect();
            this._collisionCheckCount++;
            d.rect.intersectsRectOffset(n, c, e) && (g = g.GetPoly(),
            this._polyCheckCount++,
            g ? d.TestInstancePoly(a, c + n.getLeft(), e + n.getTop(), g) : d.TestInstanceRect(a, b.GetX(), b.GetY(), n))
        }
        C3$jscomp$167.clearArray(tileCollRectCandidates)
    }
}
;
"use strict";
const C3$jscomp$168 = self.C3;
C3$jscomp$168.SparseGrid = class extends C3$jscomp$168.DefendedBase {
    constructor(a, b) {
        super();
        this._cellWidth = a;
        this._cellHeight = b;
        this._cells = C3$jscomp$168.New(C3$jscomp$168.PairMap)
    }
    Release() {
        this._cells.Release();
        this._cells = null
    }
    GetCell(a, b, d) {
        let c = this._cells.Get(a, b);
        return c ? c : d ? (c = C3$jscomp$168.New(C3$jscomp$168.GridCell, this, a, b),
        this._cells.Set(a, b, c),
        c) : null
    }
    XToCell(a) {
        a = Math.floor(a / this._cellWidth);
        return isFinite(a) ? a : 0
    }
    YToCell(a) {
        a = Math.floor(a / this._cellHeight);
        return isFinite(a) ? a : 0
    }
    Update(a, b, d) {
        if (b)
            for (let c = b.getLeft(), e = b.getRight(); c <= e; ++c)
                for (let g = b.getTop(), k = b.getBottom(); g <= k; ++g) {
                    if (d && d.containsPoint(c, g))
                        continue;
                    const l = this.GetCell(c, g, !1);
                    l && (l.Remove(a),
                    l.IsEmpty() && this._cells.Delete(c, g))
                }
        if (d)
            for (let c = d.getLeft(), e = d.getRight(); c <= e; ++c)
                for (let g = d.getTop(), k = d.getBottom(); g <= k; ++g)
                    b && b.containsPoint(c, g) || this.GetCell(c, g, !0).Insert(a)
    }
    QueryRange(a, b) {
        let d = this.XToCell(a.getLeft());
        const c = this.YToCell(a.getTop())
          , e = this.XToCell(a.getRight());
        a = this.YToCell(a.getBottom());
        if (isFinite(e) && isFinite(a))
            for (; d <= e; ++d)
                for (let g = c; g <= a; ++g) {
                    const k = this.GetCell(d, g, !1);
                    k && k.Dump(b)
                }
    }
}
;
"use strict";
const C3$jscomp$169 = self.C3;
C3$jscomp$169.GridCell = class extends C3$jscomp$169.DefendedBase {
    constructor(a, b, d) {
        super();
        this._grid = a;
        this._x = b;
        this._y = d;
        this._instances = C3$jscomp$169.New(C3$jscomp$169.ArraySet)
    }
    Release() {
        this._instances.Release();
        this._grid = this._instances = null
    }
    IsEmpty() {
        return this._instances.IsEmpty()
    }
    Insert(a) {
        this._instances.Add(a)
    }
    Remove(a) {
        this._instances.Delete(a)
    }
    Dump(a) {
        C3$jscomp$169.appendArray(a, this._instances.GetArray())
    }
}
;
"use strict";
const C3$jscomp$170 = self.C3;
C3$jscomp$170.Ray = class {
    constructor() {
        this.dy = this.dx = this.y2 = this.x2 = this.y1 = this.x1 = 0;
        this.rect = new C3$jscomp$170.Rect;
        this.hitFraction = 2;
        this.hitUid = null;
        this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
        this.normalX = 1;
        this.normalY = 0;
        this.reflectionX = 1;
        this.reflectionY = 0
    }
    DidCollide() {
        return 1.000001 > this.hitFraction
    }
    Reset() {
        this.hitFraction = 2
    }
    Set(a, b, d, c) {
        this.x1 = a;
        this.y1 = b;
        this.x2 = d;
        this.y2 = c;
        this.dx = d - a;
        this.dy = c - b;
        this.rect.set(a, b, d, c);
        this.rect.normalize();
        this.hitFraction = 2;
        this.hitUid = null;
        this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
        this.normalX = 1;
        this.normalY = 0;
        this.reflectionX = 1;
        this.reflectionY = 0;
        return this
    }
    Complete() {
        if (!1 !== this.DidCollide()) {
            var a = this.dx * this.hitFraction
              , b = this.dy * this.hitFraction
              , d = Math.hypot(a, b);
            a /= d;
            b /= d;
            this.distance = d - 1E-6;
            this.hitX = this.x1 + a * this.distance;
            this.hitY = this.y1 + b * this.distance;
            this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2;
            this.normalX = Math.cos(this.hitNormal);
            this.normalY = Math.sin(this.hitNormal);
            d = a * this.normalX + b * this.normalY;
            this.reflectionX = a - 2 * this.normalX * d;
            this.reflectionY = b - 2 * this.normalY * d;
            0 < d && (this.hitNormal = C3$jscomp$170.clampAngle(this.hitNormal + Math.PI),
            this.normalX = -this.normalX,
            this.normalY = -this.normalY)
        }
    }
    TestInstanceSegment(a, b, d, c, e) {
        const g = C3$jscomp$170.rayIntersect(this.x1, this.y1, this.x2, this.y2, b, d, c, e);
        0 <= g && g < this.hitFraction && (this.hitFraction = g,
        this.hitUid = a.GetUID(),
        this.hitNormalDx = b - c,
        this.hitNormalDy = d - e)
    }
    TestInstanceRect(a, b, d, c) {
        const e = b + c.getLeft();
        b += c.getRight();
        const g = d + c.getTop();
        d += c.getBottom();
        this.TestInstanceSegment(a, e, g, b, g);
        this.TestInstanceSegment(a, b, g, b, d);
        this.TestInstanceSegment(a, b, d, e, d);
        this.TestInstanceSegment(a, e, d, e, g)
    }
    TestInstanceQuad(a, b) {
        const d = b.getTlx()
          , c = b.getTly()
          , e = b.getTrx()
          , g = b.getTry()
          , k = b.getBrx()
          , l = b.getBry()
          , n = b.getBlx();
        b = b.getBly();
        this.TestInstanceSegment(a, d, c, e, g);
        this.TestInstanceSegment(a, e, g, k, l);
        this.TestInstanceSegment(a, k, l, n, b);
        this.TestInstanceSegment(a, n, b, d, c)
    }
    TestInstancePoly(a, b, d, c) {
        c = c.pointsArr();
        for (let e = 0, g = c.length; e < g; e += 2) {
            const k = (e + 2) % g;
            this.TestInstanceSegment(a, c[e] + b, c[e + 1] + d, c[k] + b, c[k + 1] + d)
        }
    }
}
;
"use strict";
const C3$jscomp$171 = self.C3
  , VALID_FULLSCREEN_MODES = new Set("off crop scale-inner scale-outer letterbox-scale letterbox-integer-scale".split(" "))
  , VALID_FULLSCREEN_SCALING_QUALITIES = new Set(["high", "low"])
  , glMatrix$jscomp$11 = self.glMatrix
  , mat4$jscomp$10 = glMatrix$jscomp$11.mat4
  , tempProjection = mat4$jscomp$10.create()
  , tempQuad$jscomp$5 = C3$jscomp$171.New(C3$jscomp$171.Quad)
  , tempRect$jscomp$8 = C3$jscomp$171.New(C3$jscomp$171.Rect);
C3$jscomp$171.CanvasManager = class extends C3$jscomp$171.DefendedBase {
    constructor(a) {
        super();
        this._runtime = a;
        this._canvas = null;
        this._isWebGPUEnabled = !1;
        this._webgpuRenderer = this._webglRenderer = null;
        this._gpuPreference = "high-performance";
        this._isLimitedToWebGL1 = !1;
        this._canvasCssOffsetY = this._canvasCssOffsetX = this._canvasDeviceHeight = this._canvasDeviceWidth = this._canvasCssHeight = this._canvasCssWidth = this._windowInnerHeight = this._windowInnerWidth = 0;
        this._zAxisScale = "normalized";
        this._fieldOfView = 0;
        this._zNear = 1;
        this._zFar = 1E4;
        this._enableMipmaps = !0;
        this._drawHeight = this._drawWidth = this._textureAnisotropy = 0;
        this._documentFullscreenMode = this._fullscreenMode = "letterbox-scale";
        this._deviceTransformOffY = this._deviceTransformOffX = 0;
        this._defaultProjectionMatrix = mat4$jscomp$10.create();
        this._fullscreenScalingQuality = this._wantFullscreenScalingQuality = "high";
        this._isDocumentFullscreen = !1;
        this._availableAdditionalRenderTargets = [];
        this._usedAdditionalRenderTargets = new Set;
        this._shaderData = self.C3_Shaders;
        this._effectChainManager = C3$jscomp$171.New(C3$jscomp$171.Gfx.EffectChainManager, {
            getDrawSize: ()=>[this.GetDrawWidth(), this.GetDrawHeight()],
            getRenderTarget: ()=>this.GetEffectCompositorRenderTarget(),
            releaseRenderTarget: b=>this.ReleaseEffectCompositorRenderTarget(b),
            getTime: ()=>this.GetRuntime().GetGameTime(),
            redraw: ()=>this.GetRuntime().UpdateRender()
        });
        this._gpuTimeEndFrame = this._gpuTimeStartFrame = 0;
        this._gpuLastUtilisation = NaN;
        this._gpuFrameTimingsBuffer = null;
        this._layersGpuProfile = new Map;
        this._gpuCurUtilisation = NaN;
        this._webgpuFrameTimings = new Map;
        this._snapshotFormat = "";
        this._snapshotQuality = 1;
        this._snapshotArea = C3$jscomp$171.New(C3$jscomp$171.Rect);
        this._snapshotUrl = "";
        this._snapshotResolve = this._snapshotPromise = null;
        this._loaderStartTime = this._isPastingToDrawingCanvas = 0;
        this._rafId = -1;
        this._loadingProgress = 0;
        this._loadingprogress_handler = b=>this._loadingProgress = b.progress;
        this._percentText = null;
        this._splashTextures = {
            logo: null,
            powered: null,
            website: null
        };
        this._splashFadeOutStartTime = this._splashFadeInFinishTime = this._splashFrameNumber = 0;
        this._splashState = "fade-in";
        this._splashDoneResolve = null;
        this._splashDonePromise = new Promise(b=>this._splashDoneResolve = b)
    }
    _SetGPUPowerPreference(a) {
        this._gpuPreference = a
    }
    _SetWebGPUEnabled(a) {
        this._isWebGPUEnabled = !!a
    }
    _SetZAxisScale(a) {
        this._zAxisScale = a
    }
    _SetFieldOfView(a) {
        this._fieldOfView = a
    }
    _SetZDistances(a, b) {
        this._zNear = a;
        this._zFar = b
    }
    _SetLimitedToWebGL1(a) {
        this._isLimitedToWebGL1 = !!a
    }
    async CreateCanvas(a) {
        this._canvas = a.canvas;
        this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", c=>this._OnWindowResize(c));
        this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", c=>this._OnFullscreenChange(c));
        this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", c=>this._OnFullscreenError(c));
        this._canvas.addEventListener("webglcontextlost", c=>this._OnWebGLContextLost(c));
        this._canvas.addEventListener("webglcontextrestored", c=>this._OnWebGLContextRestored(c));
        this._isDocumentFullscreen = !!a.isFullscreen;
        var b = navigator.gpu && this._isWebGPUEnabled;
        let d = !1;
        if (b)
            try {
                await this._InitWebGPUContext(!0)
            } catch (c) {
                this._MaybeLogRendererError("WebGPU", c),
                this._webgpuRenderer = null
            }
        if (!this.GetRenderer())
            try {
                await this._InitWebGLContext(!0)
            } catch (c) {
                this._MaybeLogRendererError("WebGL", c),
                this._webglRenderer = null
            }
        this.GetRenderer() || (d = !0);
        if (!this.GetRenderer() && b)
            try {
                await this._InitWebGPUContext(!1)
            } catch (c) {
                this._MaybeLogRendererError("WebGPU", c),
                this._webgpuRenderer = null
            }
        if (!this.GetRenderer())
            try {
                await this._InitWebGLContext(!1)
            } catch (c) {
                this._MaybeLogRendererError("WebGL", c),
                this._webglRenderer = null
            }
        b = this.GetRenderer();
        if (!b)
            throw Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
        b.SetHasMajorPerformanceCaveat(d);
        this._webgpuRenderer && (this._webgpuRenderer.ondevicelost = ()=>this._OnWebGPUDeviceLost(),
        this._webgpuRenderer.ondevicerestored = ()=>this._OnWebGPUDeviceRestored());
        "normalized" === this._zAxisScale ? b.SetZAxisScaleNormalized() : (b.SetZAxisScaleRegular(),
        b.SetFovY(this._fieldOfView));
        this.SetSize(a.windowInnerWidth, a.windowInnerHeight, !0);
        await this._InitRenderer()
    }
    _MaybeLogRendererError(a, b) {
        b && "string" === typeof b.message && b.message.startsWith("renderer-unavailable") || console.error(`Error creating ${a} renderer: `, b)
    }
    async _InitWebGPUContext(a) {
        a = {
            powerPreference: this._gpuPreference,
            depth: this._runtime.Uses3DFeatures(),
            failIfMajorPerformanceCaveat: a,
            usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(),
            canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(),
            canSampleDepth: this._runtime.UsesAnyDepthSampling(),
            nearZ: this._zNear,
            farZ: this._zFar
        };
        this._webgpuRenderer = C3$jscomp$171.New(C3$jscomp$171.Gfx.WebGPURenderer);
        await this._webgpuRenderer.Create(this._canvas, a)
    }
    async _InitWebGLContext(a) {
        a = {
            powerPreference: this._gpuPreference,
            enableGpuProfiling: !0,
            depth: this._runtime.Uses3DFeatures(),
            canSampleDepth: this._runtime.UsesAnyDepthSampling(),
            failIfMajorPerformanceCaveat: a,
            nearZ: this._zNear,
            farZ: this._zFar
        };
        this._isLimitedToWebGL1 && (a.maxWebGLVersion = 1);
        "Android" === C3$jscomp$171.Platform.OS && "Chromium" === C3$jscomp$171.Platform.BrowserEngine && 75 > C3$jscomp$171.Platform.BrowserVersionNumber && (console.warn("[Construct] Disabling WebGL 2 because this device appears to be affected by crbug.com/934823. Install software updates to avoid this."),
        a.maxWebGLVersion = 1);
        "standard" === this._runtime.GetCompositingMode() ? a.alpha = !0 : (a.alpha = !1,
        a.lowLatency = !0);
        this._webglRenderer = C3$jscomp$171.New(C3$jscomp$171.Gfx.WebGLRenderer, this._canvas, a);
        await this._webglRenderer.InitState()
    }
    async _InitWebGPU() {
        if (this._shaderData) {
            const a = [];
            for (const [b,d] of Object.entries(this._shaderData)) {
                d.src = d.wgsl;
                const c = C3$jscomp$171.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource();
                a.push(this._webgpuRenderer.CreateShaderProgram(Object.assign({
                    vertexSrc: c,
                    name: b
                }, d)))
            }
            await Promise.all(a)
        }
    }
    async _InitWebGL() {
        if (this._shaderData) {
            const a = [];
            for (const [b,d] of Object.entries(this._shaderData)) {
                let c;
                if (d.glslWebGL2 && 2 <= this._webglRenderer.GetWebGLVersionNumber())
                    d.src = d.glslWebGL2,
                    c = C3$jscomp$171.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2();
                else {
                    if (!d.glsl)
                        throw Error(`shader '${b}' does not support WebGL 1`);
                    d.src = d.glsl;
                    c = C3$jscomp$171.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource()
                }
                a.push(this._webglRenderer.CreateShaderProgram(Object.assign({
                    vertexSrc: c,
                    name: b
                }, d)))
            }
            await Promise.all(a);
            this._webglRenderer.ResetLastProgram();
            this._webglRenderer.SetTextureFillMode()
        }
        this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = C3$jscomp$171.New(C3$jscomp$171.Gfx.WebGLQueryResultBuffer, this._webglRenderer))
    }
    async _InitRenderer() {
        this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();
        const a = this.GetRenderer();
        a.SetMipmapsEnabled(this._enableMipmaps);
        a.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);
        for (const b of this._runtime._GetAllEffectLists()) {
            for (const d of b.GetAllEffectTypes())
                d._InitRenderer(a);
            b._InitRenderer(a);
            b.UpdateActiveEffects()
        }
    }
    Release() {
        this._canvas = this._webglRenderer = this._runtime = null
    }
    _OnWindowResize(a) {
        const b = this._runtime;
        if (!b.IsExportToVideo()) {
            var d = a.devicePixelRatio;
            b.IsInWorker() && (self.devicePixelRatio = d);
            b._SetDevicePixelRatio(d);
            this._isDocumentFullscreen = !!a.isFullscreen;
            this.SetSize(a.innerWidth, a.innerHeight);
            b.UpdateRender();
            d = new C3$jscomp$171.Event("window-resize");
            d.data = a;
            b.Dispatcher().dispatchEventAndWaitAsyncSequential(d);
            a = new C3$jscomp$171.Event("resize");
            a.cssWidth = this.GetCssWidth();
            a.cssHeight = this.GetCssHeight();
            a.deviceWidth = this.GetDeviceWidth();
            a.deviceHeight = this.GetDeviceHeight();
            b.DispatchUserScriptEvent(a);
            b.IsDebug() && (b.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && b.Render()
        }
    }
    _OnFullscreenChange(a) {
        this._isDocumentFullscreen = !!a.isFullscreen;
        this.SetSize(a.innerWidth, a.innerHeight, !0);
        this._runtime.UpdateRender()
    }
    _OnFullscreenError(a) {
        this._isDocumentFullscreen = !!a.isFullscreen;
        this.SetSize(a.innerWidth, a.innerHeight, !0);
        this._runtime.UpdateRender()
    }
    SetSize(a, b, d=!1) {
        a = Math.floor(a);
        b = Math.floor(b);
        if (0 >= a || 0 >= b)
            throw Error("invalid size");
        if (this._windowInnerWidth !== a || this._windowInnerHeight !== b || d) {
            this._windowInnerWidth = a;
            this._windowInnerHeight = b;
            d = this.GetCurrentFullscreenMode();
            "letterbox-scale" === d ? this._CalculateLetterboxScale(a, b) : "letterbox-integer-scale" === d ? this._CalculateLetterboxIntegerScale(a, b) : "off" === d ? this._CalculateFixedSizeCanvas(a, b) : this._CalculateFullsizeCanvas(a, b);
            this._UpdateFullscreenScalingQuality(d);
            this._canvas.width = this._canvasDeviceWidth;
            this._canvas.height = this._canvasDeviceHeight;
            this._runtime.PostComponentMessageToDOM("canvas", "update-size", {
                marginLeft: this._canvasCssOffsetX,
                marginTop: this._canvasCssOffsetY,
                styleWidth: this._canvasCssWidth,
                styleHeight: this._canvasCssHeight,
                displayScale: this.GetDisplayScale()
            });
            a = this.GetRenderer();
            a.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, !0);
            for (var c of this._availableAdditionalRenderTargets)
                a.DeleteRenderTarget(c);
            C3$jscomp$171.clearArray(this._availableAdditionalRenderTargets);
            a.CalculatePerspectiveMatrix(this._defaultProjectionMatrix, this.GetDrawWidth() / this.GetDrawHeight());
            c = this._runtime.GetLayoutManager();
            c.SetAllLayerProjectionChanged();
            c.SetAllLayerMVChanged()
        }
    }
    GetDefaultProjectionMatrix() {
        return this._defaultProjectionMatrix
    }
    _CalculateLetterboxScale(a, b) {
        const d = this._runtime.GetDevicePixelRatio()
          , c = this._runtime.GetOriginalViewportWidth()
          , e = this._runtime.GetOriginalViewportHeight()
          , g = c / e;
        a / b > g ? (this._canvasCssWidth = Math.round(b * g),
        this._canvasCssHeight = b,
        this._canvasCssOffsetX = Math.floor((a - this._canvasCssWidth) / 2),
        this._canvasCssOffsetY = 0) : (this._canvasCssWidth = a,
        this._canvasCssHeight = Math.round(a / g),
        this._canvasCssOffsetX = 0,
        this._canvasCssOffsetY = Math.floor((b - this._canvasCssHeight) / 2));
        this._canvasDeviceWidth = Math.round(this._canvasCssWidth * d);
        this._canvasDeviceHeight = Math.round(this._canvasCssHeight * d);
        this._runtime.SetViewportSize(c, e)
    }
    _CalculateLetterboxIntegerScale(a, b) {
        const d = this._runtime.GetDevicePixelRatio();
        1 !== d && (a += 1,
        b += 1);
        const c = this._runtime.GetOriginalViewportWidth()
          , e = this._runtime.GetOriginalViewportHeight();
        var g = c / e;
        g = a / b > g ? b * g * d / c : a / g * d / e;
        1 < g ? g = Math.floor(g) : 1 > g && (g = 1 / Math.ceil(1 / g));
        this._canvasDeviceWidth = Math.round(c * g);
        this._canvasDeviceHeight = Math.round(e * g);
        this._canvasCssWidth = this._canvasDeviceWidth / d;
        this._canvasCssHeight = this._canvasDeviceHeight / d;
        this._canvasCssOffsetX = Math.max(Math.floor((a - this._canvasCssWidth) / 2), 0);
        this._canvasCssOffsetY = Math.max(Math.floor((b - this._canvasCssHeight) / 2), 0);
        this._runtime.SetViewportSize(c, e)
    }
    _CalculateFullsizeCanvas(a, b) {
        const d = this._runtime.GetDevicePixelRatio();
        this._canvasCssWidth = a;
        this._canvasCssHeight = b;
        this._canvasDeviceWidth = Math.round(this._canvasCssWidth * d);
        this._canvasDeviceHeight = Math.round(this._canvasCssHeight * d);
        this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
        a = this.GetDisplayScale();
        this._runtime.SetViewportSize(this._canvasCssWidth / a, this._canvasCssHeight / a)
    }
    _CalculateFixedSizeCanvas(a, b) {
        const d = this._runtime.GetDevicePixelRatio();
        this._canvasCssWidth = this._runtime.GetViewportWidth();
        this._canvasCssHeight = this._runtime.GetViewportHeight();
        this._canvasDeviceWidth = Math.round(this._canvasCssWidth * d);
        this._canvasDeviceHeight = Math.round(this._canvasCssHeight * d);
        this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((a - this._canvasCssWidth) / 2),
        this._canvasCssOffsetY = Math.floor((b - this._canvasCssHeight) / 2)) : this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
        this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight())
    }
    _UpdateFullscreenScalingQuality(a) {
        if ("high" === this._wantFullscreenScalingQuality)
            this._drawWidth = this._canvasDeviceWidth,
            this._drawHeight = this._canvasDeviceHeight,
            this._fullscreenScalingQuality = "high";
        else {
            let d;
            if ("off" === this.GetCurrentFullscreenMode()) {
                var b = this._runtime.GetViewportWidth();
                d = this._runtime.GetViewportHeight()
            } else
                b = this._runtime.GetOriginalViewportWidth(),
                d = this._runtime.GetOriginalViewportHeight();
            this._canvasDeviceWidth < b || this._canvasDeviceHeight < d ? (this._drawWidth = this._canvasDeviceWidth,
            this._drawHeight = this._canvasDeviceHeight,
            this._fullscreenScalingQuality = "high") : (this._drawWidth = b,
            this._drawHeight = d,
            this._fullscreenScalingQuality = "low",
            "scale-inner" === a ? (a = b / d,
            b = this._windowInnerWidth / this._windowInnerHeight,
            b < a ? this._drawWidth = this._drawHeight * b : b > a && (this._drawHeight = this._drawWidth / b)) : "scale-outer" === a && (a = b / d,
            b = this._windowInnerWidth / this._windowInnerHeight,
            b > a ? this._drawWidth = this._drawHeight * b : b < a && (this._drawHeight = this._drawWidth / b)))
        }
    }
    GetRuntime() {
        return this._runtime
    }
    GetCanvas() {
        return this._canvas
    }
    GetEffectChainManager() {
        return this._effectChainManager
    }
    IsDocumentFullscreen() {
        return this._isDocumentFullscreen
    }
    SetFullscreenMode(a) {
        if (!VALID_FULLSCREEN_MODES.has(a))
            throw Error("invalid fullscreen mode");
        this._fullscreenMode = a;
        a = this._runtime.GetLayoutManager();
        a.SetAllLayerProjectionChanged();
        a.SetAllLayerMVChanged()
    }
    GetFullscreenMode() {
        return this._fullscreenMode
    }
    SetDocumentFullscreenMode(a) {
        if (!VALID_FULLSCREEN_MODES.has(a))
            throw Error("invalid fullscreen mode");
        this._documentFullscreenMode = a;
        a = this._runtime.GetLayoutManager();
        a.SetAllLayerProjectionChanged();
        a.SetAllLayerMVChanged()
    }
    GetDocumentFullscreenMode() {
        return this._documentFullscreenMode
    }
    GetCurrentFullscreenMode() {
        return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode()
    }
    SetFullscreenScalingQuality(a) {
        if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(a))
            throw Error("invalid fullscreen scaling quality");
        this._wantFullscreenScalingQuality = a;
        this._runtime.GetLayoutManager().SetAllLayerProjectionChanged()
    }
    GetSetFullscreenScalingQuality() {
        return this._wantFullscreenScalingQuality
    }
    GetCurrentFullscreenScalingQuality() {
        return this._fullscreenScalingQuality
    }
    static _FullscreenModeNumberToString(a) {
        switch (a) {
        case 0:
            return "off";
        case 1:
            return "crop";
        case 2:
            return "scale-inner";
        case 3:
            return "scale-outer";
        case 4:
            return "letterbox-scale";
        case 5:
            return "letterbox-integer-scale";
        default:
            throw Error("invalid fullscreen mode");
        }
    }
    GetLastWidth() {
        return this._windowInnerWidth
    }
    GetLastHeight() {
        return this._windowInnerHeight
    }
    GetDrawWidth() {
        return this._drawWidth
    }
    GetDrawHeight() {
        return this._drawHeight
    }
    SetMipmapsEnabled(a) {
        this._enableMipmaps = !!a
    }
    _SetTextureAnisotropy(a) {
        this._textureAnisotropy = a
    }
    GetTextureAnisotropy() {
        return this._textureAnisotropy
    }
    IsRendererContextLost() {
        return this.GetRenderer().IsContextLost()
    }
    _OnWebGLContextLost(a) {
        console.log("[Construct] WebGL context lost");
        a.preventDefault();
        this._availableAdditionalRenderTargets = [];
        this._usedAdditionalRenderTargets.clear();
        this._effectChainManager.OnContextLost();
        this._webglRenderer.OnContextLost();
        this._runtime._OnRendererContextLost()
    }
    _OnWebGPUDeviceLost() {
        console.log("[Construct] WebGPU device lost");
        this._availableAdditionalRenderTargets = [];
        this._usedAdditionalRenderTargets.clear();
        this._effectChainManager.OnContextLost();
        this._runtime._OnRendererContextLost()
    }
    async _OnWebGLContextRestored(a) {
        await this._webglRenderer.OnContextRestored();
        await this._InitRenderer();
        await this._runtime._OnRendererContextRestored();
        console.log("[Construct] WebGL context restored")
    }
    async _OnWebGPUDeviceRestored() {
        await this._InitRenderer();
        await this._runtime._OnRendererContextRestored();
        console.log("[Construct] WebGPU device restored")
    }
    GetWebGLRenderer() {
        return this._webglRenderer
    }
    GetWebGPURenderer() {
        return this._webgpuRenderer
    }
    GetRenderer() {
        return this._webgpuRenderer || this._webglRenderer
    }
    GetRenderScale() {
        return "low" === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale()
    }
    GetDisplayScale() {
        const a = this.GetCurrentFullscreenMode();
        if ("off" === a || "crop" === a)
            return 1;
        const b = this._runtime.GetOriginalViewportWidth()
          , d = this._runtime.GetOriginalViewportHeight()
          , c = b / d
          , e = this._canvasDeviceWidth / this._canvasDeviceHeight;
        return "scale-inner" !== a && e > c || "scale-inner" === a && e < c ? this._canvasCssHeight / d : this._canvasCssWidth / b
    }
    GetEffectLayerScaleParam() {
        return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this.GetDisplayScale()
    }
    GetEffectDevicePixelRatioParam() {
        return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this._runtime.GetDevicePixelRatio()
    }
    SetDeviceTransformOffset(a, b) {
        this._deviceTransformOffX = a;
        this._deviceTransformOffY = b
    }
    SetDeviceTransform(a, b, d, c=!0) {
        b = b || this._drawWidth;
        d = d || this._drawHeight;
        const e = b / 2 + this._deviceTransformOffX
          , g = d / 2 + this._deviceTransformOffY;
        if (c) {
            c = this.GetDefaultProjectionMatrix();
            if (b !== this._drawWidth || d !== this._drawHeight)
                a.CalculatePerspectiveMatrix(tempProjection, b / d),
                c = tempProjection;
            a.SetProjectionMatrix(c)
        }
        b = a.CalculateLookAtModelView2(e, g, a.GetDefaultCameraZ(d), e, g, 0, d);
        a.SetModelViewMatrix(b)
    }
    SetCssTransform(a, b=!0) {
        var d = this.GetCssWidth();
        const c = this.GetCssHeight();
        d /= 2;
        const e = c / 2;
        b && a.SetProjectionMatrix(this.GetDefaultProjectionMatrix());
        b = a.CalculateLookAtModelView2(d, e, a.GetDefaultCameraZ(c), d, e, 0, c);
        a.SetModelViewMatrix(b)
    }
    GetDeviceWidth() {
        return this._canvasDeviceWidth
    }
    GetDeviceHeight() {
        return this._canvasDeviceHeight
    }
    GetCssWidth() {
        return this._canvasCssWidth
    }
    GetCssHeight() {
        return this._canvasCssHeight
    }
    GetCanvasClientX() {
        return this._canvasCssOffsetX
    }
    GetCanvasClientY() {
        return this._canvasCssOffsetY
    }
    GetAdditionalRenderTarget(a) {
        a.depth = this._runtime.Uses3DFeatures();
        const b = this._availableAdditionalRenderTargets
          , d = b.findIndex(e=>e.IsCompatibleWithOptions(a));
        let c;
        -1 !== d ? (c = b[d],
        b.splice(d, 1)) : c = this.GetRenderer().CreateRenderTarget(a);
        this._usedAdditionalRenderTargets.add(c);
        return c
    }
    ReleaseAdditionalRenderTarget(a) {
        if (!this._usedAdditionalRenderTargets.has(a))
            throw Error("render target not in use");
        this._usedAdditionalRenderTargets.delete(a);
        this._availableAdditionalRenderTargets.push(a)
    }
    GetEffectCompositorRenderTarget() {
        const a = {
            sampling: this._runtime.GetSampling()
        };
        "low" === this.GetCurrentFullscreenScalingQuality() && (a.width = this.GetDrawWidth(),
        a.height = this.GetDrawHeight());
        return this.GetAdditionalRenderTarget(a)
    }
    ReleaseEffectCompositorRenderTarget(a) {
        this.ReleaseAdditionalRenderTarget(a)
    }
    *activeLayersGpuProfiles() {
        for (const a of this._runtime.GetLayoutManager().runningLayouts())
            for (const b of a.GetLayers()) {
                const d = this._layersGpuProfile.get(b);
                d && (yield d)
            }
    }
    GetLayerTimingsBuffer(a) {
        if (!this.GetRenderer().SupportsGPUProfiling())
            return null;
        let b = this._layersGpuProfile.get(a);
        b || (b = {
            name: a.GetName(),
            timingsBuffer: C3$jscomp$171.New(C3$jscomp$171.Gfx.WebGLQueryResultBuffer, this._webglRenderer),
            curUtilisation: 0,
            lastUtilisation: 0
        },
        this._layersGpuProfile.set(a, b));
        return b.timingsBuffer
    }
    _Update1sFrameRange() {
        const a = this.GetRenderer();
        if (a.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
            this._gpuTimeEndFrame = a.GetFrameNumber();
            this._gpuCurUtilisation = NaN;
            for (const b of this.activeLayersGpuProfiles())
                b.curUtilisation = NaN
        }
    }
    _UpdateTick() {
        this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL();
        this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU()
    }
    _UpdateTick_WebGL() {
        if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame),
        !isNaN(this._gpuCurUtilisation))) {
            if (this._runtime.IsDebug())
                for (const a of this.activeLayersGpuProfiles())
                    if (a.curUtilisation = a.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame),
                    isNaN(a.curUtilisation))
                        return;
            this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame);
            this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1);
            if (this._runtime.IsDebug()) {
                for (const a of this.activeLayersGpuProfiles())
                    a.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame),
                    a.lastUtilisation = Math.min(a.curUtilisation, 1);
                self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()])
            }
            this._gpuTimeStartFrame = this._gpuTimeEndFrame;
            this._gpuTimeEndFrame = 0
        }
    }
    GetGPUFrameTimingsBuffer() {
        return this._gpuFrameTimingsBuffer
    }
    _UpdateTick_WebGPU() {
        if (0 !== this._gpuTimeEndFrame) {
            for (var a = this._gpuTimeStartFrame; a < this._gpuTimeEndFrame; ++a) {
                var b = this._webgpuFrameTimings.get(a);
                if (b && !b.HasResult())
                    return
            }
            b = this._runtime.GetMainRunningLayout();
            a = C3$jscomp$171.MakeFilledArray(b.GetLayerCount() + 1, 0);
            for (var d = this._gpuTimeStartFrame; d < this._gpuTimeEndFrame; ++d) {
                var c = this._webgpuFrameTimings.get(d);
                if (c) {
                    c = c.GetResult();
                    for (let e = 0, g = Math.min(a.length, c.length / 2); e < g; ++e) {
                        const k = c[2 * e]
                          , l = c[2 * e + 1];
                        a[e] = 0 === Number(k) || 0 === Number(l) ? NaN : a[e] + Number(l - k) / 1E9
                    }
                }
            }
            this._gpuLastUtilisation = C3$jscomp$171.clamp(a[0], 0, 1);
            if (this._runtime.IsDebug()) {
                d = [];
                b = b.GetLayers();
                for (let e = 0, g = Math.min(b.length, a.length - 1); e < g; ++e)
                    d.push({
                        name: b[e].GetName(),
                        lastUtilisation: C3$jscomp$171.clamp(a[e + 1], 0, 1)
                    });
                self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, d)
            }
            for (a = this._gpuTimeStartFrame; a < this._gpuTimeEndFrame; ++a)
                this._webgpuFrameTimings.delete(a);
            this._gpuTimeStartFrame = this._gpuTimeEndFrame;
            this._gpuTimeEndFrame = 0
        }
    }
    _AddWebGPUFrameTiming(a) {
        this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), a)
    }
    GetGPUUtilisation() {
        return this._gpuLastUtilisation
    }
    SnapshotCanvas(a, b, d, c, e, g) {
        this._snapshotFormat = a;
        this._snapshotQuality = b;
        this._snapshotArea.setWH(d, c, e, g);
        return this._snapshotPromise ? this._snapshotPromise : this._snapshotPromise = new Promise(k=>{
            this._snapshotResolve = k
        }
        )
    }
    _MaybeTakeSnapshot() {
        if (this._snapshotFormat) {
            var a = this._canvas
              , b = this._snapshotArea
              , d = C3$jscomp$171.clamp(Math.floor(b.getLeft()), 0, a.width)
              , c = C3$jscomp$171.clamp(Math.floor(b.getTop()), 0, a.height)
              , e = b.width();
            e = 0 === e ? a.width - d : C3$jscomp$171.clamp(Math.floor(e), 0, a.width - d);
            b = b.height();
            b = 0 === b ? a.height - c : C3$jscomp$171.clamp(Math.floor(b), 0, a.height - c);
            (0 !== d || 0 !== c || e !== a.width || b !== a.height) && 0 < e && 0 < b && (a = C3$jscomp$171.CreateCanvas(e, b),
            a.getContext("2d").drawImage(this._canvas, d, c, e, b, 0, 0, e, b));
            C3$jscomp$171.CanvasToBlob(a, this._snapshotFormat, this._snapshotQuality).then(g=>{
                this._snapshotUrl && URL.revokeObjectURL(this._snapshotUrl);
                this._snapshotUrl = URL.createObjectURL(g);
                this._snapshotPromise = null;
                this._snapshotResolve(this._snapshotUrl)
            }
            );
            this._snapshotFormat = "";
            this._snapshotQuality = 1
        }
    }
    GetCanvasSnapshotUrl() {
        return this._snapshotUrl
    }
    SetIsPastingToDrawingCanvas(a) {
        a ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--
    }
    IsPastingToDrawingCanvas() {
        return 0 < this._isPastingToDrawingCanvas
    }
    InitLoadingScreen(a) {
        const b = this.GetRenderer();
        2 === a ? (this._percentText = C3$jscomp$171.New(C3$jscomp$171.Gfx.RendererText, this.GetRenderer()),
        this._percentText.SetIsAsync(!1),
        this._percentText.SetFontName("Arial"),
        this._percentText.SetFontSize(16),
        this._percentText.SetHorizontalAlignment("center"),
        this._percentText.SetVerticalAlignment("center"),
        this._percentText.SetSize(300, 200)) : 0 === a ? (a = this._runtime.GetLoadingLogoAsset()) && a.LoadStaticTexture(b).catch(d=>console.warn("[C3 runtime] Failed to create texture for loading logo: ", d)) : 4 === a && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then(d=>{
            "done" === this._splashState ? b.DeleteTexture(d) : this._splashTextures.logo = d
        }
        ).catch(d=>console.warn("Failed to load splash image: ", d)),
        this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then(d=>{
            "done" === this._splashState ? b.DeleteTexture(d) : this._splashTextures.powered = d
        }
        ).catch(d=>console.warn("Failed to load splash image: ", d)),
        this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then(d=>{
            "done" === this._splashState ? b.DeleteTexture(d) : this._splashTextures.website = d
        }
        ).catch(d=>console.warn("Failed to load splash image: ", d)))
    }
    async _LoadSvgSplashImage(a) {
        a = (new URL(a,this._runtime.GetRuntimeBaseURL())).toString();
        a = await C3$jscomp$171.FetchBlob(a);
        a = await this._runtime.RasterSvgImage(a, 2048, 2048);
        return await this.GetRenderer().CreateStaticTextureAsync(a, {
            mipMapQuality: "high"
        })
    }
    async _LoadBitmapSplashImage(a) {
        a = (new URL(a,this._runtime.GetRuntimeBaseURL())).toString();
        a = await C3$jscomp$171.FetchBlob(a);
        return await this.GetRenderer().CreateStaticTextureAsync(a, {
            mipMapQuality: "high"
        })
    }
    HideCordovaSplashScreen() {
        this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash")
    }
    StartLoadingScreen() {
        this._loaderStartTime = Date.now();
        this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler);
        this._rafId = requestAnimationFrame(()=>this._DrawLoadingScreen());
        3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen()
    }
    async EndLoadingScreen() {
        const a = this.GetRenderer();
        this._loadingProgress = 1;
        const b = this._runtime.GetLoaderStyle();
        4 === b && await this._splashDonePromise;
        this._splashDonePromise = this._splashDoneResolve = null;
        -1 !== this._rafId && (cancelAnimationFrame(this._rafId),
        this._rafId = -1);
        this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler);
        this._loadingprogress_handler = null;
        this._percentText && (this._percentText.Release(),
        this._percentText = null);
        this._runtime.ReleaseLoadingLogoAsset();
        a.Start();
        this._splashTextures.logo && (a.DeleteTexture(this._splashTextures.logo),
        this._splashTextures.logo = null);
        this._splashTextures.powered && (a.DeleteTexture(this._splashTextures.powered),
        this._splashTextures.powered = null);
        this._splashTextures.website && (a.DeleteTexture(this._splashTextures.website),
        this._splashTextures.website = null);
        a.ClearRgba(0, 0, 0, 0);
        a.Finish();
        this._splashState = "done";
        this._gpuTimeStartFrame = a.GetFrameNumber();
        3 === b && this.HideCordovaSplashScreen()
    }
    _DrawLoadingScreen() {
        if (-1 !== this._rafId) {
            var a = this.GetRenderer();
            a.Start();
            this._rafId = -1;
            var b = this._runtime.GetAssetManager().HasHadErrorLoading()
              , d = this._runtime.GetLoaderStyle();
            3 !== d && (this.SetCssTransform(a),
            a.ClearRgba(0, 0, 0, 0),
            a.ResetColor(),
            a.SetTextureFillMode(),
            a.SetTexture(null));
            if (0 === d)
                this._DrawProgressBarAndLogoLoadingScreen(b);
            else if (1 === d)
                this._DrawProgressBarLoadingScreen(b, 120, 0);
            else if (2 === d)
                this._DrawPercentTextLoadingScreen(b);
            else if (3 === d)
                C3$jscomp$171.noop();
            else if (4 === d)
                this._DrawSplashLoadingScreen(b);
            else
                throw Error("invalid loader style");
            a.Finish();
            this._rafId = requestAnimationFrame(()=>this._DrawLoadingScreen())
        }
    }
    _DrawPercentTextLoadingScreen(a) {
        a ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(.6, .6, .6);
        this._percentText.SetText(Math.round(100 * this._loadingProgress) + "%");
        a = this._canvasCssWidth / 2;
        const b = this._canvasCssHeight / 2;
        tempQuad$jscomp$5.setRect(a - 150, b - 100, a + 150, b + 100);
        a = this.GetRenderer();
        a.SetTexture(this._percentText.GetTexture());
        a.Quad3(tempQuad$jscomp$5, this._percentText.GetTexRect())
    }
    _DrawProgressBarLoadingScreen(a, b, d) {
        const c = this.GetRenderer();
        c.SetColorFillMode();
        a ? c.SetColorRgba(1, 0, 0, 1) : c.SetColorRgba(.118, .565, 1, 1);
        a = this._canvasCssWidth / 2;
        const e = this._canvasCssHeight / 2
          , g = b / 2;
        tempRect$jscomp$8.setWH(a - g, e - 4 + d, Math.floor(b * this._loadingProgress), 8);
        c.Rect(tempRect$jscomp$8);
        tempRect$jscomp$8.setWH(a - g, e - 4 + d, b, 8);
        tempRect$jscomp$8.offset(-.5, -.5);
        tempRect$jscomp$8.inflate(.5, .5);
        c.SetColorRgba(0, 0, 0, 1);
        c.LineRect2(tempRect$jscomp$8);
        tempRect$jscomp$8.inflate(1, 1);
        c.SetColorRgba(1, 1, 1, 1);
        c.LineRect2(tempRect$jscomp$8)
    }
    _DrawProgressBarAndLogoLoadingScreen(a) {
        const b = this.GetRenderer();
        var d = this._runtime.GetLoadingLogoAsset();
        if (d)
            if (d = d.GetTexture()) {
                var c = d.GetWidth()
                  , e = d.GetHeight()
                  , g = this._canvasCssWidth / 2
                  , k = this._canvasCssHeight / 2
                  , l = c / 2;
                e /= 2;
                tempQuad$jscomp$5.setRect(g - l, k - e, g + l, k + e);
                b.SetTexture(d);
                b.Quad(tempQuad$jscomp$5);
                this._DrawProgressBarLoadingScreen(a, c, e + 16)
            } else
                this._DrawProgressBarLoadingScreen(a, 120, 0);
        else
            this._DrawProgressBarLoadingScreen(a, 120, 0)
    }
    _DrawSplashLoadingScreen(a) {
        const b = this.GetRenderer()
          , d = this._splashTextures.logo
          , c = this._splashTextures.powered
          , e = this._splashTextures.website
          , g = Date.now();
        0 === this._splashFrameNumber && (this._loaderStartTime = g);
        const k = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova()
          , l = k ? 0 : 200
          , n = k ? 0 : 3E3;
        let p = 1;
        "fade-in" === this._splashState ? p = Math.min((g - this._loaderStartTime) / 300, 1) : "fade-out" === this._splashState && (p = Math.max(1 - (g - this._splashFadeOutStartTime) / 300, 0));
        b.SetColorFillMode();
        b.SetColorRgba(.231 * p, .251 * p, .271 * p, p);
        tempRect$jscomp$8.set(0, 0, this._canvasCssWidth, this._canvasCssHeight);
        b.Rect(tempRect$jscomp$8);
        const t = Math.ceil(this._canvasCssWidth)
          , w = Math.ceil(this._canvasCssHeight);
        let z;
        256 < this._canvasCssHeight ? (b.SetColorRgba(.302 * p, .334 * p, .365 * p, p),
        z = Math.max(.005 * w, 2),
        tempRect$jscomp$8.setWH(0, .8 * w - z / 2, t, z),
        b.Rect(tempRect$jscomp$8),
        a ? b.SetColorRgba(p, 0, 0, p) : b.SetColorRgba(.161 * p, .953 * p, .816 * p, p),
        a = t * this._loadingProgress,
        tempRect$jscomp$8.setWH(.5 * t - a / 2, .8 * w - z / 2, a, z),
        b.Rect(tempRect$jscomp$8),
        b.SetColorRgba(p, p, p, p),
        b.SetTextureFillMode(),
        c && (a = 1.5 * C3$jscomp$171.clamp(.22 * w, 105, .6 * t),
        z = a / 8,
        tempRect$jscomp$8.setWH(.5 * t - a / 2, .2 * w - z / 2, a, z),
        b.SetTexture(c),
        b.Rect(tempRect$jscomp$8)),
        d && (z = a = Math.min(.395 * w, .95 * t),
        tempRect$jscomp$8.setWH(.5 * t - a / 2, .485 * w - z / 2, a, z),
        b.SetTexture(d),
        b.Rect(tempRect$jscomp$8)),
        e && (a = 1.5 * C3$jscomp$171.clamp(.22 * w, 105, .6 * t),
        z = a / 8,
        tempRect$jscomp$8.setWH(.5 * t - a / 2, .868 * w - z / 2, a, z),
        b.SetTexture(e),
        b.Rect(tempRect$jscomp$8))) : (b.SetColorRgba(.302 * p, .334 * p, .365 * p, p),
        z = Math.max(.005 * w, 2),
        tempRect$jscomp$8.setWH(0, .85 * w - z / 2, t, z),
        b.Rect(tempRect$jscomp$8),
        a ? b.SetColorRgba(p, 0, 0, p) : b.SetColorRgba(.161 * p, .953 * p, .816 * p, p),
        a = t * this._loadingProgress,
        tempRect$jscomp$8.setWH(.5 * t - a / 2, .85 * w - z / 2, a, z),
        b.Rect(tempRect$jscomp$8),
        b.SetColorRgba(p, p, p, p),
        b.SetTextureFillMode(),
        d && (z = a = .55 * w,
        tempRect$jscomp$8.setWH(.5 * t - a / 2, .45 * w - z / 2, a, z),
        b.SetTexture(d),
        b.Rect(tempRect$jscomp$8)));
        this._splashFrameNumber++;
        "fade-in" === this._splashState && 300 <= g - this._loaderStartTime && 2 <= this._splashFrameNumber && (this._splashState = "wait",
        this._splashFadeInFinishTime = g);
        "wait" === this._splashState && g - this._splashFadeInFinishTime >= n && 1 <= this._loadingProgress && (this._splashState = "fade-out",
        this._splashFadeOutStartTime = g);
        ("fade-out" === this._splashState && g - this._splashFadeOutStartTime >= 300 + l || k && 1 <= this._loadingProgress && 500 > g - this._loaderStartTime) && this._splashDoneResolve()
    }
}
;
"use strict";
const C3$jscomp$172 = self.C3
  , C3Debugger$jscomp$3 = self.C3Debugger
  , DEFAULT_RUNTIME_OPTS = {
    messagePort: null,
    runtimeBaseUrl: "",
    headless: !1,
    hasDom: !0,
    isInWorker: !1,
    useAudio: !0,
    projectData: "",
    exportType: ""
};
let ife = !0;
C3$jscomp$172.Runtime = class extends C3$jscomp$172.DefendedBase {
    constructor(a) {
        a = Object.assign({}, DEFAULT_RUNTIME_OPTS, a);
        super();
        this._messagePort = a.messagePort;
        this._runtimeBaseUrl = a.runtimeBaseUrl;
        this._previewUrl = a.previewUrl;
        this._isHeadless = !!a.headless;
        this._hasDom = !!a.hasDom;
        this._isInWorker = !!a.isInWorker;
        ife = a.ife;
        this._useAudio = !!a.useAudio;
        this._exportType = a.exportType;
        this._isiOSCordova = !!a.isiOSCordova;
        this._isiOSWebView = !!a.isiOSWebView;
        this._isFBInstantAvailable = !!a.isFBInstantAvailable;
        this._opusWasmScriptUrl = a.opusWasmScriptUrl;
        this._opusWasmBinaryUrl = a.opusWasmBinaryUrl;
        this._isDebugging = this._breakpointsEnabled = this._isDebug = !("preview" !== this._exportType || !a.isDebug);
        this._debuggingDisabled = 0;
        this._additionalLoadPromises = [];
        this._additionalCreatePromises = [];
        this._isUsingCreatePromises = !1;
        this._appId = this._projectUniqueId = this._projectVersion = this._projectName = "";
        this._originalViewportHeight = this._originalViewportWidth = 0;
        this._devicePixelRatio = self.devicePixelRatio;
        this._loaderStyle = this._viewportHeight = this._viewportWidth = this._parallaxYorigin = this._parallaxXorigin = 0;
        this._usesLoaderLayout = !1;
        this._isLoading = !0;
        this._usesAnyDepthSampling = this._usesAnyCrossSampling = this._usesAnyBackgroundBlending = !1;
        this._loadingLogoAsset = null;
        this._assetManager = C3$jscomp$172.New(C3$jscomp$172.AssetManager, this, a);
        this._layoutManager = C3$jscomp$172.New(C3$jscomp$172.LayoutManager, this);
        this._eventSheetManager = C3$jscomp$172.New(C3$jscomp$172.EventSheetManager, this);
        this._pluginManager = C3$jscomp$172.New(C3$jscomp$172.PluginManager, this);
        this._collisionEngine = C3$jscomp$172.New(C3$jscomp$172.CollisionEngine, this);
        this._timelineManager = C3$jscomp$172.New(C3$jscomp$172.TimelineManager, this);
        this._transitionManager = C3$jscomp$172.New(C3$jscomp$172.TransitionManager, this);
        this._templateManager = C3$jscomp$172.New(C3$jscomp$172.TemplateManager, this);
        this._allObjectClasses = [];
        this._objectClassesByName = new Map;
        this._objectClassesBySid = new Map;
        this._familyCount = 0;
        this._allContainers = [];
        this._allEffectLists = [];
        this._currentLayoutStack = [];
        this._instancesPendingCreate = [];
        this._instancesPendingDestroy = new Map;
        this._isFlushingPendingInstances = this._hasPendingInstances = !1;
        this._nextUid = this._objectCount = 0;
        this._instancesByUid = new Map;
        this._instancesToReleaseAtEndOfTick = new Set;
        this._instancesToReleaseAffectedObjectClasses = new Set;
        this._objectReferenceTable = [];
        this._jsPropNameTable = [];
        this._canvasManager = null;
        this._uses3dFeatures = !1;
        this._framerateMode = "vsync";
        this._compositingMode = "standard";
        this._sampling = "trilinear";
        this._isPixelRoundingEnabled = !1;
        this._needRender = !0;
        this._isPausedOnBlur = this._pauseOnBlur = !1;
        this._exportToVideo = null;
        this._tickCallbacks = {
            normal: b=>{
                this._ruafId = this._rafId = -1;
                this.Tick(b)
            }
            ,
            tickOnly: b=>{
                this._ruafId = -1;
                this.Tick(b, !1, "skip-render")
            }
            ,
            renderOnly: ()=>{
                this._rafId = -1;
                this.Render()
            }
        };
        this._ruafId = this._rafId = -1;
        this._tickCountNoSave = this._tickCount = 0;
        this._hasStartedTicking = this._isInTick = this._hasStarted = !1;
        this._isLayoutFirstTick = !0;
        this._suspendCount = 0;
        this._scheduleTriggersThrottle = new C3$jscomp$172.PromiseThrottle(1);
        this._randomNumberCallback = ()=>Math.random();
        this._dt = this._dt1 = this._dtRaw = this._lastTickTime = this._startTime = 0;
        this._timeScale = 1;
        this._minimumFramerate = 30;
        this._gameTime = C3$jscomp$172.New(C3$jscomp$172.KahanSum);
        this._gameTimeRaw = C3$jscomp$172.New(C3$jscomp$172.KahanSum);
        this._wallTime = C3$jscomp$172.New(C3$jscomp$172.KahanSum);
        this._instanceTimes = new Map;
        this._fpsFrameCount = -1;
        this._mainThreadTime = this._mainThreadTimeCounter = this._fps = this._fpsLastTime = 0;
        this._isLoadingState = !1;
        this._loadFromSlotName = this._saveToSlotName = "";
        this._loadFromJson = null;
        this._lastSaveJson = "";
        this._savegamesStorage = this._projectStorage = null;
        this._dispatcher = C3$jscomp$172.New(C3$jscomp$172.Event.Dispatcher);
        this._domEventHandlers = new Map;
        this._pendingResponsePromises = new Map;
        this._nextDomResponseId = 0;
        this._isReadyToHandleEvents = this._didRequestDeviceMotionEvent = this._didRequestDeviceOrientationEvent = !1;
        this._waitingToHandleEvents = [];
        this._eventObjects = {
            pretick: C3$jscomp$172.New(C3$jscomp$172.Event, "pretick", !1),
            tick: C3$jscomp$172.New(C3$jscomp$172.Event, "tick", !1),
            tick2: C3$jscomp$172.New(C3$jscomp$172.Event, "tick2", !1),
            instancedestroy: C3$jscomp$172.New(C3$jscomp$172.Event, "instancedestroy", !1),
            beforelayoutchange: C3$jscomp$172.New(C3$jscomp$172.Event, "beforelayoutchange", !1),
            layoutchange: C3$jscomp$172.New(C3$jscomp$172.Event, "layoutchange", !1)
        };
        this._eventObjects.instancedestroy.instance = null;
        this._userScriptDispatcher = C3$jscomp$172.New(C3$jscomp$172.Event.Dispatcher);
        this._userScriptEventObjects = null;
        this._behInstsToTick = C3$jscomp$172.New(C3$jscomp$172.RedBlackSet, C3$jscomp$172.BehaviorInstance.SortByTickSequence);
        this._behInstsToPostTick = C3$jscomp$172.New(C3$jscomp$172.RedBlackSet, C3$jscomp$172.BehaviorInstance.SortByTickSequence);
        this._behInstsToTick2 = C3$jscomp$172.New(C3$jscomp$172.RedBlackSet, C3$jscomp$172.BehaviorInstance.SortByTickSequence);
        this._jobScheduler = C3$jscomp$172.New(C3$jscomp$172.JobSchedulerRuntime, this, a.jobScheduler);
        a.canvas && (this._canvasManager = C3$jscomp$172.New(C3$jscomp$172.CanvasManager, this));
        this._messagePort.onmessage = b=>this._OnMessageFromDOM(b.data);
        this.AddDOMComponentMessageHandler("runtime", "visibilitychange", b=>this._OnVisibilityChange(b));
        this.AddDOMComponentMessageHandler("runtime", "opus-decode", b=>this._WasmDecodeWebMOpus(b.arrayBuffer));
        this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", ()=>this._GetRemotePreviewStatusInfo());
        this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", b=>this._InvokeFunctionFromJS(b));
        this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self.goToLastErrorScript);
        this.AddDOMComponentMessageHandler("runtime", "offline-audio-render-completed", b=>this._OnOfflineAudioRenderCompleted(b));
        this._dispatcher.addEventListener("window-blur", b=>this._OnWindowBlur(b));
        this._dispatcher.addEventListener("window-focus", ()=>this._OnWindowFocus());
        this._timelineManager.AddRuntimeListeners();
        this._templateManager.AddRuntimeListeners();
        this._iRuntime = null;
        this._interfaceMap = new WeakMap;
        this._commonScriptInterfaces = {
            keyboard: null,
            mouse: null,
            touch: null
        }
    }
    static Create(a) {
        return C3$jscomp$172.New(C3$jscomp$172.Runtime, a)
    }
    Release() {
        C3$jscomp$172.clearArray(this._allObjectClasses);
        this._objectClassesByName.clear();
        this._objectClassesBySid.clear();
        this._layoutManager.Release();
        this._layoutManager = null;
        this._eventSheetManager.Release();
        this._eventSheetManager = null;
        this._pluginManager.Release();
        this._pluginManager = null;
        this._assetManager.Release();
        this._assetManager = null;
        this._collisionEngine.Release();
        this._collisionEngine = null;
        this._timelineManager.Release();
        this._timelineManager = null;
        this._transitionManager.Release();
        this._transitionManager = null;
        this._templateManager.Release();
        this._templateManager = null;
        this._canvasManager && (this._canvasManager.Release(),
        this._canvasManager = null);
        this._dispatcher.Release();
        this._tickEvent = this._dispatcher = null
    }
    _OnMessageFromDOM(a) {
        const b = a.type;
        if ("event" === b)
            this._OnEventFromDOM(a);
        else if ("result" === b)
            this._OnResultFromDOM(a);
        else
            throw Error(`unknown message '${b}'`);
    }
    _OnEventFromDOM(a) {
        if (this._isReadyToHandleEvents) {
            var b = a.component
              , d = a.handler
              , c = a.data
              , e = a.dispatchOpts
              , g = !(!e || !e.dispatchRuntimeEvent);
            e = !(!e || !e.dispatchUserScriptEvent);
            var k = a.responseId;
            if ("runtime" === b && (g && (a = new C3$jscomp$172.Event(d),
            a.data = c,
            this._dispatcher.dispatchEventAndWaitAsyncSequential(a)),
            e)) {
                a = new C3$jscomp$172.Event(d,!0);
                for (const [l,n] of Object.entries(c))
                    a[l] = n;
                this.DispatchUserScriptEvent(a)
            }
            if (a = this._domEventHandlers.get(b))
                if (a = a.get(d)) {
                    g = null;
                    try {
                        g = a(c)
                    } catch (l) {
                        console.error(`Exception in '${b}' handler '${d}':`, l);
                        null !== k && this._PostResultToDOM(k, !1, "" + l);
                        return
                    }
                    null !== k && (g && g.then ? g.then(l=>this._PostResultToDOM(k, !0, l)).catch(l=>{
                        console.error(`Rejection from '${b}' handler '${d}':`, l);
                        this._PostResultToDOM(k, !1, "" + l)
                    }
                    ) : this._PostResultToDOM(k, !0, g))
                } else
                    g || e || console.warn(`[Runtime] No DOM handler '${d}' for component '${b}'`);
            else
                g || e || console.warn(`[Runtime] No DOM event handlers for component '${b}'`)
        } else
            this._waitingToHandleEvents.push(a)
    }
    _PostResultToDOM(a, b, d) {
        this._messagePort.postMessage({
            type: "result",
            responseId: a,
            isOk: b,
            result: d
        })
    }
    _OnResultFromDOM(a) {
        const b = a.responseId
          , d = a.isOk;
        a = a.result;
        const c = this._pendingResponsePromises.get(b);
        d ? c.resolve(a) : c.reject(a);
        this._pendingResponsePromises.delete(b)
    }
    AddDOMComponentMessageHandler(a, b, d) {
        let c = this._domEventHandlers.get(a);
        c || (c = new Map,
        this._domEventHandlers.set(a, c));
        if (c.has(b))
            throw Error(`[Runtime] Component '${a}' already has handler '${b}'`);
        c.set(b, d)
    }
    PostComponentMessageToDOM(a, b, d, c) {
        this._messagePort.postMessage({
            type: "event",
            component: a,
            handler: b,
            data: d,
            responseId: null
        }, c)
    }
    PostComponentMessageToDOMAsync(a, b, d, c) {
        const e = this._nextDomResponseId++
          , g = new Promise((k,l)=>{
            this._pendingResponsePromises.set(e, {
                resolve: k,
                reject: l
            })
        }
        );
        this._messagePort.postMessage({
            type: "event",
            component: a,
            handler: b,
            data: d,
            responseId: e
        }, c);
        return g
    }
    PostToDebugger(a) {
        if (!this.IsDebug())
            throw Error("not in debug mode");
        this.PostComponentMessageToDOM("runtime", "post-to-debugger", a)
    }
    async Init(a) {
        this.IsDebug() ? await C3Debugger$jscomp$3.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
        var [b] = await Promise.all([this._assetManager.FetchJson("data.json"), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init()]);
        await this._LoadDataJson(b);
        await this._InitialiseCanvas(a);
        this.IsPreview() || console.info("Made with Construct, the game and app creator :: https://www.construct.net");
        this.GetWebGLRenderer() ? (b = this.GetWebGLRenderer(),
        console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGL ${b.GetWebGLVersionNumber()} [${b.GetUnmaskedRenderer()}] (${b.IsDesynchronized() ? "desynchronized" : "standard"} compositing)`)) : this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with experimental WebGPU [${this.GetWebGPURenderer().GetBasicAdapterInfoString()}]`);
        this.GetRenderer().HasMajorPerformanceCaveat() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.");
        this._isReadyToHandleEvents = !0;
        for (const d of this._waitingToHandleEvents)
            this._OnEventFromDOM(d);
        C3$jscomp$172.clearArray(this._waitingToHandleEvents);
        this._canvasManager && this._canvasManager.StartLoadingScreen();
        for (const d of a.runOnStartupFunctions)
            this._additionalLoadPromises.push(this._RunOnStartupFunction(d));
        await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]);
        C3$jscomp$172.clearArray(this._additionalLoadPromises);
        if (this._assetManager.HasHadErrorLoading())
            this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
        else
            return this._canvasManager && await this._canvasManager.EndLoadingScreen(),
            await this._dispatcher.dispatchEventAndWaitAsync(new C3$jscomp$172.Event("beforeruntimestart")),
            await this.Start(),
            this._messagePort.postMessage({
                type: "runtime-ready"
            }),
            this
    }
    async _RunOnStartupFunction(a) {
        try {
            await a(this._iRuntime)
        } catch (b) {
            console.error("[C3 runtime] Error in runOnStartup function: ", b)
        }
    }
    async _LoadDataJson(a) {
        a = a.project;
        this._projectName = a[0];
        this._projectVersion = a[16];
        this._projectUniqueId = a[31];
        this._appId = a[38];
        var b = a[39] || "loading-logo.png";
        this._isPixelRoundingEnabled = !!a[9];
        this._originalViewportWidth = this._viewportWidth = a[10];
        this._originalViewportHeight = this._viewportHeight = a[11];
        this._parallaxXorigin = this._originalViewportWidth / 2;
        this._parallaxYorigin = this._originalViewportHeight / 2;
        this._compositingMode = a[36];
        this._framerateMode = a[37];
        "low-latency" === this._compositingMode && this.IsAndroidWebView() && 77 >= C3$jscomp$172.Platform.BrowserVersionNumber && (console.warn("[C3 runtime] Desynchronized (low-latency) compositing is enabled, but is disabled in the Android WebView <=77 due to crbug.com/1008842. Reverting to synchronized (standard) compositing."),
        this._compositingMode = "standard");
        this._uses3dFeatures = !!a[40];
        this._sampling = a[14];
        this._usesAnyBackgroundBlending = a[15];
        this._usesAnyCrossSampling = a[42];
        this._usesAnyDepthSampling = a[17];
        this._usesLoaderLayout = !!a[18];
        this._loaderStyle = a[19];
        this._nextUid = a[21];
        this._pauseOnBlur = a[22];
        const d = this._assetManager;
        d._SetFileStructure(a[45]);
        d._SetAudioFiles(a[7], a[25]);
        d._SetMediaSubfolder(a[8]);
        d._SetFontsSubfolder(a[32]);
        d._SetIconsSubfolder(a[28]);
        d._SetWebFonts(a[29]);
        if (0 === this._loaderStyle) {
            let l = "";
            this.IsPreview() ? d._HasLocalUrlBlob(b) && (l = d.GetLocalUrlAsBlobUrl(b)) : l = "flat" === d.GetFileStructure() ? d.GetIconsSubfolder() + b : b;
            l && (this._loadingLogoAsset = d.LoadImage({
                url: l
            }))
        }
        this._canvasManager && (this._canvasManager.SetFullscreenMode(C3$jscomp$172.CanvasManager._FullscreenModeNumberToString(a[12])),
        this._canvasManager.SetFullscreenScalingQuality(a[23] ? "high" : "low"),
        this._canvasManager.SetMipmapsEnabled(0 !== a[24]),
        this._canvasManager._SetGPUPowerPreference(a[34]),
        this._canvasManager._SetTextureAnisotropy(a[41]),
        this._canvasManager._SetWebGPUEnabled(a[13]),
        this._canvasManager._SetZAxisScale(a[30]),
        this._canvasManager._SetZDistances(a[46], a[47]),
        this._canvasManager._SetFieldOfView(a[26]),
        this._canvasManager._SetLimitedToWebGL1(a[48]));
        (b = a[43]) && await this._LoadExportToVideoData(b);
        this._pluginManager.CreateSystemPlugin();
        this._objectReferenceTable = self.C3_GetObjectRefTable();
        for (var c of a[2])
            this._pluginManager.CreatePlugin(c);
        this._objectReferenceTable = self.C3_GetObjectRefTable();
        this._LoadJsPropNameTable();
        for (var e of a[3])
            c = C3$jscomp$172.ObjectClass.Create(this, this._allObjectClasses.length, e),
            this._allObjectClasses.push(c),
            this._objectClassesByName.set(c.GetName().toLowerCase(), c),
            this._objectClassesBySid.set(c.GetSID(), c);
        for (const l of a[4])
            this._allObjectClasses[l[0]]._LoadFamily(l);
        for (var g of a[27])
            e = g.map(l=>this._allObjectClasses[l]),
            this._allContainers.push(C3$jscomp$172.New(C3$jscomp$172.Container, this, e));
        for (const l of this._allObjectClasses)
            l._OnAfterCreate();
        for (const l of a[5])
            this._layoutManager.Create(l);
        (g = a[1]) && (g = this._layoutManager.GetLayoutByName(g)) && this._layoutManager.SetFirstLayout(g);
        for (var k of a[33])
            this._timelineManager.Create(k);
        for (const l of a[35])
            this._transitionManager.Create(l);
        for (const l of a[44])
            this._templateManager.Create(l);
        this._templateManager.HasTemplates() || (this._templateManager.Release(),
        this._templateManager = null);
        this._InitScriptInterfaces();
        for (const l of a[6])
            this._eventSheetManager.Create(l);
        this._eventSheetManager._PostInit();
        this._InitGlobalVariableScriptInterface();
        C3$jscomp$172.clearArray(this._objectReferenceTable);
        this.FlushPendingInstances();
        k = "any";
        a = a[20];
        1 === a ? k = "portrait" : 2 === a && (k = "landscape");
        this.PostComponentMessageToDOM("runtime", "set-target-orientation", {
            targetOrientation: k
        })
    }
    async _LoadExportToVideoData(a) {
        const b = a.format;
        "image-sequence" === b ? this._exportToVideo = new self.C3ExportToImageSequence(this,a) : "image-sequence-gif" === b ? this._exportToVideo = new self.C3ExportToGIF(this,a) : "webm" === b ? this._exportToVideo = new self.C3ExportToWebMVideo(this,a) : "mp4" === b && (this._exportToVideo = new self.C3ExportToMP4Video(this,a));
        this._framerateMode = "unlimited-frame";
        this._canvasManager.SetFullscreenMode("off");
        this._devicePixelRatio = 1;
        self.devicePixelRatio = 1;
        await this.PostComponentMessageToDOMAsync("runtime", "set-exporting-to-video", {
            message: this._exportToVideo.GetExportingMessageForPercent(0),
            duration: this._exportToVideo.GetDuration()
        })
    }
    GetLoaderStyle() {
        return this._loaderStyle
    }
    IsExportToVideo() {
        return null !== this._exportToVideo
    }
    GetExportVideoDuration() {
        return this._exportToVideo.GetDuration()
    }
    GetExportVideoFramerate() {
        return this._exportToVideo.GetFramerate()
    }
    _InitExportToVideo() {
        return this._exportToVideo.Init({
            width: this._canvasManager.GetDeviceWidth(),
            height: this._canvasManager.GetDeviceHeight()
        })
    }
    _ExportToVideoAddFrame() {
        const a = this._tickCount / this.GetExportVideoFramerate();
        return this._exportToVideo.AddFrame(this._canvasManager.GetCanvas(), a)
    }
    _ExportToVideoAddKeyframe() {
        this._exportToVideo && this._exportToVideo.AddKeyframe()
    }
    _OnOfflineAudioRenderCompleted(a) {
        this._exportToVideo.OnOfflineAudioRenderCompleted(a)
    }
    _ExportToVideoFinish() {
        return this._exportToVideo.Finish()
    }
    IsFBInstantAvailable() {
        return this._isFBInstantAvailable
    }
    IsLoading() {
        return this._isLoading
    }
    AddLoadPromise(a) {
        this._additionalLoadPromises.push(a)
    }
    SetUsingCreatePromises(a) {
        this._isUsingCreatePromises = !!a
    }
    AddCreatePromise(a) {
        this._isUsingCreatePromises && this._additionalCreatePromises.push(a)
    }
    GetCreatePromises() {
        return this._additionalCreatePromises
    }
    _GetNextFamilyIndex() {
        return this._familyCount++
    }
    GetFamilyCount() {
        return this._familyCount
    }
    _AddEffectList(a) {
        this._allEffectLists.push(a)
    }
    _GetAllEffectLists() {
        return this._allEffectLists
    }
    async _InitialiseCanvas(a) {
        this._canvasManager && (await this._canvasManager.CreateCanvas(a),
        this._canvasManager.InitLoadingScreen(this._loaderStyle))
    }
    async _MaybeLoadOpusDecoder() {
        if (!this._assetManager.IsAudioFormatSupported("audio/webm; codecs=opus")) {
            var a = null;
            try {
                a = this.IsiOSCordova() && this._assetManager.IsFileProtocol() ? await this._assetManager.CordovaFetchLocalFileAsArrayBuffer(this._opusWasmBinaryUrl) : await this._assetManager.FetchArrayBuffer(this._opusWasmBinaryUrl)
            } catch (b) {
                console.info("Failed to fetch Opus decoder WASM; assuming project has no Opus audio.", b);
                return
            }
            a ? this.AddJobWorkerBuffer(a, "opus-decoder-wasm") : this.AddJobWorkerBlob(null, "opus-decoder-wasm");
            await this.AddJobWorkerScripts([this._opusWasmScriptUrl])
        }
    }
    async _WasmDecodeWebMOpus(a) {
        return await this.AddJob("OpusDecode", {
            arrayBuffer: a
        }, [a])
    }
    async Start() {
        this._hasStarted = !0;
        this._startTime = Date.now();
        if (this._usesLoaderLayout) {
            for (var a of this._allObjectClasses)
                a.IsFamily() || a.IsOnLoaderLayout() || !a.IsWorldType() || a.OnCreate();
            this._assetManager.WaitForAllToLoad().then(()=>{
                this._isLoading = !1;
                this._OnLoadFinished()
            }
            )
        } else
            this._isLoading = !1;
        this._assetManager.SetInitialLoadFinished();
        this.IsDebug() && C3Debugger$jscomp$3.RuntimeInit(ife);
        for (const b of this._layoutManager.GetAllLayouts())
            b._CreateGlobalNonWorlds();
        this.IsExportToVideo() && await this._InitExportToVideo();
        a = this._layoutManager.GetFirstLayout();
        await a._Load(null, this.GetRenderer());
        await a._StartRunning(!0);
        this._fpsLastTime = performance.now();
        this._usesLoaderLayout || this._OnLoadFinished();
        (await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking")).isSuspended && !this.IsExportToVideo() ? this._suspendCount++ : this.Tick()
    }
    _OnLoadFinished() {
        this.Trigger(C3$jscomp$172.Plugins.System.Cnds.OnLoadFinished, null, null);
        this.PostComponentMessageToDOM("runtime", "register-sw")
    }
    GetObjectReference(a) {
        a = Math.floor(a);
        const b = this._objectReferenceTable;
        if (0 > a || a >= b.length)
            throw Error("invalid object reference");
        return b[a]
    }
    _LoadJsPropNameTable() {
        for (const a of self.C3_JsPropNameTable) {
            const b = C3$jscomp$172.first(Object.keys(a));
            this._jsPropNameTable.push(b)
        }
    }
    GetJsPropName(a) {
        a = Math.floor(a);
        const b = this._jsPropNameTable;
        if (0 > a || a >= b.length)
            throw Error("invalid prop reference");
        return b[a]
    }
    HasDOM() {
        return this._hasDom
    }
    IsHeadless() {
        return this._isHeadless
    }
    IsInWorker() {
        return this._isInWorker
    }
    GetRuntimeBaseURL() {
        return this._runtimeBaseUrl
    }
    GetPreviewURL() {
        return this._previewUrl
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetEventStack() {
        return this._eventSheetManager.GetEventStack()
    }
    GetCurrentEventStackFrame() {
        return this._eventSheetManager.GetCurrentEventStackFrame()
    }
    GetCurrentEvent() {
        return this._eventSheetManager.GetCurrentEvent()
    }
    GetCurrentCondition() {
        return this._eventSheetManager.GetCurrentCondition()
    }
    IsCurrentConditionFirst() {
        return 0 === this.GetCurrentEventStackFrame().GetConditionIndex()
    }
    GetCurrentAction() {
        return this._eventSheetManager.GetCurrentAction()
    }
    GetPluginManager() {
        return this._pluginManager
    }
    GetSystemPlugin() {
        return this._pluginManager.GetSystemPlugin()
    }
    GetObjectClassByIndex(a) {
        a = Math.floor(a);
        if (0 > a || a >= this._allObjectClasses.length)
            throw new RangeError("invalid index");
        return this._allObjectClasses[a]
    }
    GetObjectClassByName(a) {
        return this._objectClassesByName.get(a.toLowerCase()) || null
    }
    GetObjectClassBySID(a) {
        return this._objectClassesBySid.get(a) || null
    }
    GetSingleGlobalObjectClassByCtor(a) {
        return (a = this._pluginManager.GetPluginByConstructorFunction(a)) ? a.GetSingleGlobalObjectClass() : null
    }
    GetAllObjectClasses() {
        return this._allObjectClasses
    }
    *allInstances() {
        for (const a of this._allObjectClasses)
            a.IsFamily() || (yield*a.instances())
    }
    Dispatcher() {
        return this._dispatcher
    }
    UserScriptDispatcher() {
        return this._userScriptDispatcher
    }
    DispatchUserScriptEvent(a) {
        a.runtime = this.GetIRuntime();
        const b = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
        b && C3Debugger$jscomp$3.StartMeasuringScriptTime();
        this._userScriptDispatcher.dispatchEvent(a);
        b && C3Debugger$jscomp$3.AddScriptTime()
    }
    DispatchUserScriptEventAsyncWait(a) {
        a.runtime = this.GetIRuntime();
        return this._userScriptDispatcher.dispatchEventAndWaitAsync(a)
    }
    GetOriginalViewportWidth() {
        return this._originalViewportWidth
    }
    GetOriginalViewportHeight() {
        return this._originalViewportHeight
    }
    SetOriginalViewportSize(a, b) {
        if (this._originalViewportWidth !== a || this._originalViewportHeight !== b)
            this._originalViewportWidth = a,
            this._originalViewportHeight = b,
            a = this.GetLayoutManager(),
            a.SetAllLayerProjectionChanged(),
            a.SetAllLayerMVChanged()
    }
    GetViewportWidth() {
        return this._viewportWidth
    }
    GetViewportHeight() {
        return this._viewportHeight
    }
    SetViewportSize(a, b) {
        if (this._viewportWidth !== a || this._viewportHeight !== b)
            this._viewportWidth = a,
            this._viewportHeight = b,
            a = this.GetLayoutManager(),
            a.SetAllLayerProjectionChanged(),
            a.SetAllLayerMVChanged()
    }
    _SetDevicePixelRatio(a) {
        this.IsExportToVideo() || (this._devicePixelRatio = a)
    }
    GetDevicePixelRatio() {
        return this._devicePixelRatio
    }
    GetParallaxXOrigin() {
        return this._parallaxXorigin
    }
    GetParallaxYOrigin() {
        return this._parallaxYorigin
    }
    GetCanvasManager() {
        return this._canvasManager
    }
    GetDrawWidth() {
        return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth
    }
    GetDrawHeight() {
        return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight
    }
    GetRenderScale() {
        return this._canvasManager ? this._canvasManager.GetRenderScale() : 1
    }
    GetDisplayScale() {
        return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1
    }
    GetEffectLayerScaleParam() {
        return this._canvasManager ? this._canvasManager.GetEffectLayerScaleParam() : 1
    }
    GetEffectDevicePixelRatioParam() {
        return this._canvasManager ? this._canvasManager.GetEffectDevicePixelRatioParam() : 1
    }
    GetCanvasClientX() {
        return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0
    }
    GetCanvasClientY() {
        return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0
    }
    GetCanvasCssWidth() {
        return this._canvasManager ? this._canvasManager.GetCssWidth() : 0
    }
    GetCanvasCssHeight() {
        return this._canvasManager ? this._canvasManager.GetCssHeight() : 0
    }
    GetFullscreenMode() {
        return this._canvasManager ? this._canvasManager.GetFullscreenMode() : "off"
    }
    GetAdditionalRenderTarget(a) {
        return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(a) : null
    }
    ReleaseAdditionalRenderTarget(a) {
        this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(a)
    }
    UsesAnyBackgroundBlending() {
        return this._usesAnyBackgroundBlending
    }
    UsesAnyCrossSampling() {
        return this._usesAnyCrossSampling
    }
    UsesAnyDepthSampling() {
        return this._usesAnyDepthSampling
    }
    GetGPUUtilisation() {
        return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN
    }
    IsLinearSampling() {
        return "nearest" !== this.GetSampling()
    }
    GetFramerateMode() {
        return this._framerateMode
    }
    GetCompositingMode() {
        return this._compositingMode
    }
    GetSampling() {
        return this._sampling
    }
    UsesLoaderLayout() {
        return this._usesLoaderLayout
    }
    GetLoadingLogoAsset() {
        return this._loadingLogoAsset
    }
    ReleaseLoadingLogoAsset() {
        this._loadingLogoAsset && (this._loadingLogoAsset.Release(),
        this._loadingLogoAsset = null)
    }
    GetLayoutManager() {
        return this._layoutManager
    }
    GetMainRunningLayout() {
        return this._layoutManager.GetMainRunningLayout()
    }
    GetTimelineManager() {
        return this._timelineManager
    }
    GetTransitionManager() {
        return this._transitionManager
    }
    GetTemplateManager() {
        return this._templateManager
    }
    GetAssetManager() {
        return this._assetManager
    }
    LoadImage(a) {
        return this._assetManager.LoadImage(a)
    }
    CreateInstance(a, b, d, c, e, g) {
        if (g && this._templateManager) {
            const k = this._templateManager.GetTemplateData(a, g);
            if (k)
                return a = this.CreateInstanceFromData(k, b, !1, d, c, !1, e, void 0, e),
                this._templateManager.MapInstanceToTemplateName(a, g),
                a
        }
        return this.CreateInstanceFromData(a, b, !1, d, c, !1, e, void 0, e)
    }
    CreateInstanceFromData(a, b, d, c, e, g, k, l, n) {
        var p = null;
        let t = null;
        if (a instanceof C3$jscomp$172.ObjectClass) {
            t = a;
            if (t.IsFamily()) {
                a = t.GetFamilyMembers();
                var w = Math.floor(this.Random() * a.length);
                t = a[w]
            }
            p = t.GetDefaultInstanceData()
        } else
            p = a,
            t = this.GetObjectClassByIndex(p[1]);
        var z = t.GetPlugin().IsWorldType();
        if (this._isLoading && z && !t.IsOnLoaderLayout())
            return null;
        const B = b;
        z || (b = null);
        var C = d && !g && p && !this._instancesByUid.has(p[2]) ? p[2] : this._nextUid++;
        w = p ? p[0] : null;
        a = C3$jscomp$172.New(C3$jscomp$172.Instance, {
            runtime: this,
            objectType: t,
            layer: b,
            worldData: w,
            instVarData: p ? p[3] : null,
            uid: C
        });
        this._instancesByUid.set(C, a);
        C = null;
        z && (C = a.GetWorldInfo(),
        "undefined" !== typeof c && "undefined" !== typeof e && (C.SetX(c),
        C.SetY(e)),
        t._SetAnyCollisionCellChanged(!0));
        b && (n || b._AddInstance(a, !0),
        1 === b.GetParallaxX() && 1 === b.GetParallaxY() || t._SetAnyInstanceParallaxed(!0),
        b.GetLayout().MaybeLoadTexturesFor(t));
        this._objectCount++;
        let E = !0;
        if (l) {
            var F = l.GetObjectClass();
            F.IsInContainer() && t.IsInContainer() && (l = t.GetContainer(),
            F = F.GetContainer(),
            l === F && (E = !1))
        }
        if (t.IsInContainer() && !d && !g && E) {
            for (var J of t.GetContainer().objectTypes())
                J !== t && (l = this.CreateInstanceFromData(J, B, !1, C ? C.GetX() : c, C ? C.GetY() : e, !0, !1, void 0, n),
                a._AddSibling(l));
            for (var K of a.siblings()) {
                K._AddSibling(a);
                for (const M of a.siblings())
                    K !== M && K._AddSibling(M)
            }
        }
        z && !d && k && this._CreateChildInstancesFromData(a, w, C, b, c, e, n);
        if (t.IsInContainer() && !d && !g && k)
            for (const M of a.siblings())
                if (d = M.GetWorldInfo())
                    J = M.GetPlugin(),
                    K = M.GetObjectClass().GetDefaultInstanceData()[0],
                    J.IsWorldType() ? this._CreateChildInstancesFromData(M, K, d, b, d.GetX(), d.GetY(), n) : this._CreateChildInstancesFromData(M, K, d, b, void 0, void 0, n);
        !g && k && ("undefined" === typeof c && (c = w[0]),
        "undefined" === typeof e && (e = w[1]),
        b = C.GetTopParent(),
        c = c - C.GetX() + b.GetX(),
        e = e - C.GetY() + b.GetY(),
        b.SetXY(c, e));
        t._SetIIDsStale();
        e = p ? C3$jscomp$172.cloneArray(p[5]) : null;
        p = p ? p[4].map(M=>C3$jscomp$172.cloneArray(M)) : null;
        (z = z && w && w[13]) && a._SetHasTilemap();
        a._CreateSdkInstance(e, p);
        z && (w = w[13],
        a.GetSdkInstance().LoadTilemapData(w[2], w[0], w[1]));
        this._instancesPendingCreate.push(a);
        this._hasPendingInstances = !0;
        this.IsDebug() && C3Debugger$jscomp$3.InstanceCreated(a);
        return a
    }
    _CreateChildInstancesFromData(a, b, d, c, e, g, k) {
        var l = d.GetSceneGraphZIndexExportData()
          , n = d.GetSceneGraphChildrenExportData();
        a.GetWorldInfo().SetSceneGraphZIndex(l);
        if (n) {
            "undefined" === typeof e && (e = b[0]);
            "undefined" === typeof g && (g = b[1]);
            l = new Set;
            d = b[0];
            b = b[1];
            for (const C of n) {
                var p = C[0]
                  , t = C[1]
                  , w = C[2];
                n = C[3];
                var z = !!C[4];
                const E = C[5];
                var B = C[6];
                t = B ? B : this._layoutManager.GetLayoutBySID(p).GetLayer(t).GetInitialInstanceData(w);
                p = this.GetObjectClassByIndex(t[1]);
                w = a.HasSibling(p);
                B = l.has(p);
                w && !B && z ? (z = a.GetSibling(p),
                w = e + t[0][0] - d,
                t = g + t[0][1] - b,
                z.GetWorldInfo().SetXY(w, t),
                z.GetWorldInfo().SetSceneGraphZIndex(E),
                a.AddChild(z, {
                    transformX: !!(n >> 0 & 1),
                    transformY: !!(n >> 1 & 1),
                    transformWidth: !!(n >> 2 & 1),
                    transformHeight: !!(n >> 3 & 1),
                    transformAngle: !!(n >> 4 & 1),
                    destroyWithParent: !!(n >> 5 & 1),
                    transformZElevation: !!(n >> 6 & 1),
                    transformOpacity: !!(n >> 7 & 1),
                    transformVisibility: !!(n >> 8 & 1)
                }),
                l.add(p)) : (z = this.CreateInstanceFromData(t, c, !1, e + t[0][0] - d, g + t[0][1] - b, !1, !0, a, k),
                z.GetWorldInfo().SetSceneGraphZIndex(E),
                a.AddChild(z, {
                    transformX: !!(n >> 0 & 1),
                    transformY: !!(n >> 1 & 1),
                    transformWidth: !!(n >> 2 & 1),
                    transformHeight: !!(n >> 3 & 1),
                    transformAngle: !!(n >> 4 & 1),
                    destroyWithParent: !!(n >> 5 & 1),
                    transformZElevation: !!(n >> 6 & 1),
                    transformOpacity: !!(n >> 7 & 1),
                    transformVisibility: !!(n >> 8 & 1)
                }))
            }
        }
    }
    DestroyInstance(a) {
        if (!this._instancesToReleaseAtEndOfTick.has(a)) {
            var b = a.GetObjectClass()
              , d = this._instancesPendingDestroy.get(b);
            if (d) {
                if (d.has(a))
                    return;
                d.add(a)
            } else
                d = new Set,
                d.add(a),
                this._instancesPendingDestroy.set(b, d);
            this.IsDebug() && C3Debugger$jscomp$3.InstanceDestroyed(a);
            a._MarkDestroyed();
            this._hasPendingInstances = !0;
            if (a.IsInContainer())
                for (const c of a.siblings())
                    this.DestroyInstance(c);
            for (const c of a.children())
                c.GetDestroyWithParent() && this.DestroyInstance(c);
            this._layoutManager.IsEndingLayout() || this._isLoadingState || (b = this.GetEventSheetManager(),
            b.BlockFlushingInstances(!0),
            a._TriggerOnDestroyed(),
            b.BlockFlushingInstances(!1));
            a._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout())
        }
    }
    FlushPendingInstances() {
        this._hasPendingInstances && (this._isFlushingPendingInstances = !0,
        this._FlushInstancesPendingCreate(),
        this._FlushInstancesPendingDestroy(),
        this._hasPendingInstances = this._isFlushingPendingInstances = !1,
        this.UpdateRender())
    }
    _FlushInstancesPendingCreate() {
        for (const a of this._instancesPendingCreate) {
            const b = a.GetObjectClass();
            b._AddInstance(a);
            for (const d of b.GetFamilies())
                d._AddInstance(a),
                d._SetIIDsStale()
        }
        C3$jscomp$172.clearArray(this._instancesPendingCreate)
    }
    _FlushInstancesPendingDestroy() {
        this._dispatcher.SetDelayRemoveEventsEnabled(!0);
        for (const [a,b] of this._instancesPendingDestroy.entries())
            this._FlushInstancesPendingDestroyForObjectClass(a, b),
            b.clear();
        this._instancesPendingDestroy.clear();
        this._dispatcher.SetDelayRemoveEventsEnabled(!1)
    }
    _FlushInstancesPendingDestroyForObjectClass(a, b) {
        for (const c of b) {
            var d = this._eventObjects.instancedestroy;
            d.instance = c;
            this._dispatcher.dispatchEvent(d);
            this._instancesByUid.delete(c.GetUID());
            this._instanceTimes.delete(c);
            if (d = c.GetWorldInfo())
                d._RemoveFromCollisionCells(),
                d._RemoveFromRenderCells(),
                d._MarkDestroyed();
            this._instancesToReleaseAtEndOfTick.add(c);
            this._objectCount--
        }
        C3$jscomp$172.arrayRemoveAllInSet(a.GetInstances(), b);
        a._SetIIDsStale();
        this._instancesToReleaseAffectedObjectClasses.add(a);
        0 === a.GetInstances().length && a._SetAnyInstanceParallaxed(!1);
        for (const c of a.GetFamilies())
            C3$jscomp$172.arrayRemoveAllInSet(c.GetInstances(), b),
            c._SetIIDsStale(),
            this._instancesToReleaseAffectedObjectClasses.add(c);
        if (a.GetPlugin().IsWorldType()) {
            a = new Set([...b].map(c=>c.GetWorldInfo().GetLayer()));
            for (const c of a)
                c._RemoveAllInstancesInSet(b)
        }
    }
    _GetInstancesPendingCreate() {
        return this._instancesPendingCreate
    }
    *instancesPendingCreateForObjectClass(a) {
        for (const b of this._GetInstancesPendingCreate())
            a.IsFamily() ? b.GetObjectClass().BelongsToFamily(a) && (yield b) : b.GetObjectClass() === a && (yield b)
    }
    _GetNewUID() {
        return this._nextUid++
    }
    _MapInstanceByUID(a, b) {
        this._instancesByUid.set(a, b)
    }
    _OnRendererContextLost() {
        this._dispatcher.dispatchEvent(C3$jscomp$172.New(C3$jscomp$172.Event, "renderercontextlost"));
        this.SetSuspended(!0);
        for (var a of this._allObjectClasses)
            !a.IsFamily() && a.HasLoadedTextures() && a.ReleaseTextures();
        (a = this.GetMainRunningLayout()) && a._OnRendererContextLost();
        C3$jscomp$172.ImageInfo.OnRendererContextLost();
        C3$jscomp$172.ImageAsset.OnRendererContextLost()
    }
    async _OnRendererContextRestored() {
        await this.GetMainRunningLayout()._Load(null, this.GetRenderer());
        this._dispatcher.dispatchEvent(C3$jscomp$172.New(C3$jscomp$172.Event, "renderercontextrestored"));
        this.SetSuspended(!1);
        this.UpdateRender()
    }
    _OnVisibilityChange(a) {
        this.SetSuspended(a.hidden)
    }
    _OnWindowBlur(a) {
        this.IsPreview() && this._pauseOnBlur && !C3$jscomp$172.Platform.IsMobile && !a.data.parentHasFocus && (this.SetSuspended(!0),
        this._isPausedOnBlur = !0)
    }
    _OnWindowFocus() {
        this._isPausedOnBlur && (this.SetSuspended(!1),
        this._isPausedOnBlur = !1)
    }
    _RequestAnimationFrame() {
        const a = this._tickCallbacks;
        "vsync" === this._framerateMode ? -1 === this._rafId && (this._rafId = self.requestAnimationFrame(a.normal)) : "unlimited-tick" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = C3$jscomp$172.RequestUnlimitedAnimationFrame(a.tickOnly)),
        -1 === this._rafId && (this._rafId = self.requestAnimationFrame(a.renderOnly))) : -1 === this._ruafId && (this._ruafId = C3$jscomp$172.RequestUnlimitedAnimationFrame(a.normal))
    }
    _CancelAnimationFrame() {
        -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId),
        this._rafId = -1);
        -1 !== this._ruafId && (C3$jscomp$172.CancelUnlimitedAnimationFrame(this._ruafId),
        this._ruafId = -1)
    }
    IsSuspended() {
        return 0 < this._suspendCount
    }
    SetSuspended(a) {
        if (!this.IsExportToVideo()) {
            var b = this.IsSuspended();
            this._suspendCount += a ? 1 : -1;
            0 > this._suspendCount && (this._suspendCount = 0);
            a = this.IsSuspended();
            !b && a ? (console.log("[Construct] Suspending"),
            this._CancelAnimationFrame(),
            this._dispatcher.dispatchEvent(C3$jscomp$172.New(C3$jscomp$172.Event, "suspend")),
            this.Trigger(C3$jscomp$172.Plugins.System.Cnds.OnSuspend, null, null)) : b && !a && (console.log("[Construct] Resuming"),
            this._fpsLastTime = this._lastTickTime = b = performance.now(),
            this._mainThreadTimeCounter = this._mainThreadTime = this._fps = this._fpsFrameCount = 0,
            this._dispatcher.dispatchEvent(C3$jscomp$172.New(C3$jscomp$172.Event, "resume")),
            this.Trigger(C3$jscomp$172.Plugins.System.Cnds.OnResume, null, null),
            this.HitBreakpoint() || this.Tick(b))
        }
    }
    _AddBehInstToTick(a) {
        this._behInstsToTick.Add(a)
    }
    _AddBehInstToPostTick(a) {
        this._behInstsToPostTick.Add(a)
    }
    _AddBehInstToTick2(a) {
        this._behInstsToTick2.Add(a)
    }
    _RemoveBehInstToTick(a) {
        this._behInstsToTick.Remove(a)
    }
    _RemoveBehInstToPostTick(a) {
        this._behInstsToPostTick.Remove(a)
    }
    _RemoveBehInstToTick2(a) {
        this._behInstsToTick2.Remove(a)
    }
    _BehaviorTick() {
        this._behInstsToTick.SetQueueingEnabled(!0);
        for (const a of this._behInstsToTick)
            a.Tick();
        this._behInstsToTick.SetQueueingEnabled(!1)
    }
    _BehaviorPostTick() {
        this._behInstsToPostTick.SetQueueingEnabled(!0);
        for (const a of this._behInstsToPostTick)
            a.PostTick();
        this._behInstsToPostTick.SetQueueingEnabled(!1)
    }
    _BehaviorTick2() {
        this._behInstsToTick2.SetQueueingEnabled(!0);
        for (const a of this._behInstsToTick2)
            a.Tick2();
        this._behInstsToTick2.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorTick() {
        this._behInstsToTick.SetQueueingEnabled(!0);
        for (const a of this._behInstsToTick) {
            const b = a.Tick();
            C3$jscomp$172.IsIterator(b) && (yield*b)
        }
        this._behInstsToTick.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorPostTick() {
        this._behInstsToPostTick.SetQueueingEnabled(!0);
        for (const a of this._behInstsToPostTick) {
            const b = a.PostTick();
            C3$jscomp$172.IsIterator(b) && (yield*b)
        }
        this._behInstsToPostTick.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorTick2() {
        this._behInstsToTick2.SetQueueingEnabled(!0);
        for (const a of this._behInstsToTick2) {
            const b = a.Tick2();
            C3$jscomp$172.IsIterator(b) && (yield*b)
        }
        this._behInstsToTick2.SetQueueingEnabled(!1)
    }
    async Tick(a, b, d) {
        this._hasStartedTicking = !0;
        const c = "background-wake" === d;
        d = "background-wake" !== d && "skip-render" !== d;
        if (this._hasStarted && (!this.IsSuspended() || b || c)) {
            b = performance.now();
            this._isInTick = !0;
            this._MeasureDt(a || 0);
            a = this.Step_BeforePreTick();
            this.IsDebugging() && await a;
            a = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects.pretick);
            a instanceof Promise && await a;
            a = this.Step_AfterPreTick();
            this.IsDebugging() && await a;
            this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad();
            this.GetLayoutManager().IsPendingChangeMainLayout() && await this._MaybeChangeLayout();
            a = this.Step_RunEventsEtc();
            this.IsDebugging() && await a;
            d && this.Render();
            if (this.IsExportToVideo() && (await this._ExportToVideoAddFrame(),
            this.GetGameTime() >= this.GetExportVideoDuration())) {
                this._ExportToVideoFinish();
                return
            }
            this.IsSuspended() || c || this._RequestAnimationFrame();
            this._tickCount++;
            this._tickCountNoSave++;
            this._isInTick = !1;
            this._mainThreadTimeCounter += performance.now() - b
        }
    }
    async Step_BeforePreTick() {
        const a = this._eventSheetManager
          , b = this.IsDebug();
        this.FlushPendingInstances();
        a.BlockFlushingInstances(!0);
        this.PushCurrentLayout(this.GetMainRunningLayout());
        b && C3Debugger$jscomp$3.StartMeasuringTime();
        this.IsDebugging() ? await a.DebugRunScheduledWaits() : a.RunScheduledWaits();
        b && C3Debugger$jscomp$3.AddEventsTime();
        this.PopCurrentLayout();
        a.BlockFlushingInstances(!1);
        this.FlushPendingInstances();
        a.BlockFlushingInstances(!0)
    }
    async Step_AfterPreTick() {
        const a = this.IsDebug()
          , b = this.IsDebugging()
          , d = this._dispatcher
          , c = this._eventObjects
          , e = this._userScriptEventObjects;
        a && C3Debugger$jscomp$3.StartMeasuringTime();
        b ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick();
        b ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick();
        a && C3Debugger$jscomp$3.AddBehaviorTickTime();
        a && C3Debugger$jscomp$3.StartMeasuringTime();
        b ? await this.DebugFireGeneratorEventAndBreak(c.tick) : d.dispatchEvent(c.tick);
        a && C3Debugger$jscomp$3.AddPluginTickTime();
        this._eventSheetManager.BlockFlushingInstances(!1);
        this.DispatchUserScriptEvent(e.tick)
    }
    async Step_RunEventsEtc() {
        const a = this._eventSheetManager
          , b = this._dispatcher
          , d = this._eventObjects
          , c = this.IsDebug()
          , e = this.IsDebugging();
        c && C3Debugger$jscomp$3.StartMeasuringTime();
        e ? await a.DebugRunEvents(this._layoutManager) : a.RunEvents(this._layoutManager);
        c && C3Debugger$jscomp$3.AddEventsTime();
        this._collisionEngine.ClearRegisteredCollisions();
        this._ReleaseInstancesAtEndOfTick();
        this._isLayoutFirstTick = !1;
        a.BlockFlushingInstances(!0);
        c && C3Debugger$jscomp$3.StartMeasuringTime();
        e ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2();
        c && C3Debugger$jscomp$3.AddBehaviorTickTime();
        c && C3Debugger$jscomp$3.StartMeasuringTime();
        e ? await this.DebugFireGeneratorEventAndBreak(d.tick2) : b.dispatchEvent(d.tick2);
        c && C3Debugger$jscomp$3.AddPluginTickTime();
        a.BlockFlushingInstances(!1);
        e && await a.RunQueuedDebugTriggersAsync()
    }
    _ReleaseInstancesAtEndOfTick() {
        if (0 !== this._instancesToReleaseAtEndOfTick.size) {
            var a = this._dispatcher;
            a.SetDelayRemoveEventsEnabled(!0);
            for (const b of this._instancesToReleaseAffectedObjectClasses)
                b.GetSolStack().RemoveInstances(this._instancesToReleaseAtEndOfTick);
            this._instancesToReleaseAffectedObjectClasses.clear();
            this._eventSheetManager.RemoveInstancesFromScheduledWaits(this._instancesToReleaseAtEndOfTick);
            for (const b of this._instancesToReleaseAtEndOfTick)
                b.Release();
            this._instancesToReleaseAtEndOfTick.clear();
            a.SetDelayRemoveEventsEnabled(!1)
        }
    }
    async _MaybeChangeLayout() {
        const a = this.GetLayoutManager();
        let b = 0;
        for (; a.IsPendingChangeMainLayout() && 10 > b++; )
            await this._DoChangeLayout(a.GetPendingChangeMainLayout())
    }
    _MeasureDt(a) {
        let b = 0;
        this.IsExportToVideo() ? this._dt1 = this._dtRaw = b = 1 / this.GetExportVideoFramerate() : 0 !== this._lastTickTime && (b = Math.max(a - this._lastTickTime, 0) / 1E3,
        .5 < b && (b = 0),
        this._dtRaw = b,
        this._dt1 = Math.min(b, 1 / this._minimumFramerate));
        this._lastTickTime = a;
        this._dt = this._dt1 * this._timeScale;
        this._gameTime.Add(this._dt);
        this._gameTimeRaw.Add(b * this._timeScale);
        this._wallTime.Add(this._dt1);
        for (const [d,c] of this._instanceTimes)
            c.Add(this._dt1 * d.GetTimeScale());
        this._canvasManager && this._canvasManager._UpdateTick();
        1E3 <= a - this._fpsLastTime && (this._fpsLastTime += 1E3,
        1E3 <= a - this._fpsLastTime && (this._fpsLastTime = a),
        this._fps = this._fpsFrameCount,
        this._fpsFrameCount = 0,
        this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1E3, 1),
        this._mainThreadTimeCounter = 0,
        this._canvasManager && this._canvasManager._Update1sFrameRange(),
        this._collisionEngine._Update1sStats(),
        this.IsDebug() && C3Debugger$jscomp$3.Update1sPerfStats());
        this._fpsFrameCount++
    }
    _SetTrackingInstanceTime(a, b) {
        b ? this._instanceTimes.has(a) || (b = C3$jscomp$172.New(C3$jscomp$172.KahanSum),
        b.Copy(this._gameTime),
        this._instanceTimes.set(a, b)) : this._instanceTimes.delete(a)
    }
    _GetInstanceGameTime(a) {
        return (a = this._instanceTimes.get(a)) ? a.Get() : this.GetGameTime()
    }
    async _DoChangeLayout(a) {
        const b = this._dispatcher
          , d = this.GetLayoutManager().GetMainRunningLayout();
        await d._StopRunning();
        d._Unload(a, this.GetRenderer());
        d === a && this._eventSheetManager.ClearAllScheduledWaits();
        this._collisionEngine.ClearRegisteredCollisions();
        this._ReleaseInstancesAtEndOfTick();
        b.dispatchEvent(this._eventObjects.beforelayoutchange);
        C3$jscomp$172.Asyncify.SetHighThroughputMode(!0);
        await a._Load(d, this.GetRenderer());
        C3$jscomp$172.Asyncify.SetHighThroughputMode(!1);
        await a._StartRunning(!1);
        b.dispatchEvent(this._eventObjects.layoutchange);
        this.UpdateRender();
        this._isLayoutFirstTick = !0;
        this.FlushPendingInstances();
        this._ExportToVideoAddKeyframe()
    }
    UpdateRender() {
        this._needRender = !0
    }
    GetWebGLRenderer() {
        return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null
    }
    GetWebGPURenderer() {
        return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null
    }
    GetRenderer() {
        return this._canvasManager ? this._canvasManager.GetRenderer() : null
    }
    Render() {
        const a = this._canvasManager;
        if (a && !a.IsRendererContextLost()) {
            var b = this.GetRenderer()
              , d = b.SupportsGPUProfiling()
              , c = d && b.IsWebGL();
            d = d && b.IsWebGPU();
            c && b.CheckForQueryResults();
            if (this._needRender || this.IsExportToVideo()) {
                var e = this._layoutManager.GetMainRunningLayout();
                b.Start();
                var g = this.IsDebug();
                g && C3Debugger$jscomp$3.StartMeasuringTime();
                this._needRender = !1;
                var k = null;
                c && (k = a.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(),
                b.StartQuery(k));
                c = null;
                d && (c = b.StartFrameTiming(2 * (1 + e.GetLayerCount())),
                b.WriteTimestamp(0));
                this.Uses3DFeatures() && "low" === a.GetCurrentFullscreenScalingQuality() ? b.SetFixedSizeDepthBuffer(a.GetDrawWidth(), a.GetDrawHeight()) : b.SetAutoSizeDepthBuffer();
                this._Render(this.GetRenderer(), e);
                k && b.EndQuery(k);
                d && (b.WriteTimestamp(1),
                this._canvasManager._AddWebGPUFrameTiming(c));
                b.Finish();
                g && (C3Debugger$jscomp$3.AddDrawCallsTime(),
                C3Debugger$jscomp$3.UpdateInspectHighlight());
                a && a._MaybeTakeSnapshot()
            } else
                b.IncrementFrameNumber()
        }
    }
    _Render(a, b) {
        a.SetTextureFillMode();
        a.SetAlphaBlend();
        a.SetColorRgba(1, 1, 1, 1);
        a.SetRenderTarget(null);
        a.SetTexture(null);
        a.SetDepthEnabled(this.Uses3DFeatures());
        b.Draw(a)
    }
    Trigger(a, b, d) {
        if (!this._hasStarted)
            return !1;
        var c = !this._isInTick && !this._eventSheetManager.IsInTrigger();
        let e = 0;
        c && (e = performance.now());
        const g = this.IsDebug();
        g && this.SetDebuggingEnabled(!1);
        a = this._eventSheetManager._Trigger(this._layoutManager, a, b, d);
        c && (c = performance.now() - e,
        this._mainThreadTimeCounter += c,
        g && C3Debugger$jscomp$3.AddTriggersTime(c));
        g && this.SetDebuggingEnabled(!0);
        return a
    }
    DebugTrigger(a, b, d) {
        if (!this.IsDebug())
            return this.Trigger(a, b, d);
        if (this.HitBreakpoint())
            throw Error("called DebugTrigger() while stopped on breakpoint");
        if (!this._isInTick && !this._eventSheetManager.IsInTrigger())
            throw Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
        return this._eventSheetManager._DebugTrigger(this._layoutManager, a, b, d)
    }
    async TriggerAsync(a, b, d) {
        if (!this.IsDebugging())
            return this.Trigger(a, b, d);
        if (!this._hasStarted)
            return !1;
        if (this.HitBreakpoint())
            return this._eventSheetManager.QueueDebugTrigger(a, b, d);
        if (!this.GetMainRunningLayout())
            return this._eventSheetManager.QueueTrigger(a, b, d);
        const c = performance.now();
        a = this._eventSheetManager._DebugTrigger(this._layoutManager, a, b, d);
        for (b = a.next(); !b.done; )
            await this.DebugBreak(b.value),
            b = a.next();
        this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(),
        this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame());
        this._mainThreadTimeCounter += performance.now() - c;
        return b.value
    }
    FastTrigger(a, b, d) {
        const c = this.IsDebug();
        c && this.SetDebuggingEnabled(!1);
        a = this._eventSheetManager._FastTrigger(this._layoutManager, a, b, d);
        c && this.SetDebuggingEnabled(!0);
        return a
    }
    DebugFastTrigger(a, b, d) {
        return this._eventSheetManager._DebugFastTrigger(this._layoutManager, a, b, d)
    }
    ScheduleTriggers(a) {
        return this._scheduleTriggersThrottle.Add(a)
    }
    PushCurrentLayout(a) {
        this._currentLayoutStack.push(a)
    }
    PopCurrentLayout() {
        if (!this._currentLayoutStack.length)
            throw Error("layout stack empty");
        this._currentLayoutStack.pop()
    }
    GetCurrentLayout() {
        return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout()
    }
    GetDt(a) {
        return a && -1 !== a.GetTimeScale() ? this._dt1 * a.GetTimeScale() : this._dt
    }
    _GetDtFast() {
        return this._dt
    }
    GetDt1() {
        return this._dt1
    }
    GetDtRaw() {
        return this._dtRaw
    }
    GetTimeScale() {
        return this._timeScale
    }
    SetTimeScale(a) {
        if (isNaN(a) || 0 > a)
            a = 0;
        this._timeScale = a
    }
    SetMinimumFramerate(a) {
        this._minimumFramerate = C3$jscomp$172.clamp(a, 1, 120)
    }
    GetMinimumFramerate() {
        return this._minimumFramerate
    }
    GetFPS() {
        return this._fps
    }
    GetMainThreadTime() {
        return this._mainThreadTime
    }
    GetStartTime() {
        return this._startTime
    }
    GetGameTime() {
        return this._gameTime.Get()
    }
    GetGameTimeRaw() {
        return this._gameTimeRaw.Get()
    }
    GetWallTime() {
        return this._wallTime.Get()
    }
    GetTickCount() {
        return this._tickCount
    }
    GetTickCountNoSave() {
        return this._tickCountNoSave
    }
    GetObjectCount() {
        return this._objectCount
    }
    GetProjectName() {
        return this._projectName
    }
    GetProjectVersion() {
        return this._projectVersion
    }
    GetProjectUniqueId() {
        return this._projectUniqueId
    }
    GetAppId() {
        return this._appId
    }
    GetInstanceByUID(a) {
        if (this._isLoadingState)
            throw Error("cannot call while loading state - wait until afterload event");
        return this._instancesByUid.get(a) || null
    }
    _RefreshUidMap() {
        this._instancesByUid.clear();
        for (const a of this._allObjectClasses)
            if (!a.IsFamily())
                for (const b of a.GetInstances())
                    this._instancesByUid.set(b.GetUID(), b)
    }
    IsPreview() {
        return "preview" === this._exportType
    }
    IsDebug() {
        return this._isDebug
    }
    GetExportType() {
        return this._exportType
    }
    IsCordova() {
        return "cordova" === this._exportType
    }
    IsAndroidWebView() {
        return "Android" === C3$jscomp$172.Platform.OS && ("cordova" === this._exportType || "playable-ad" === this._exportType || "instant-games" === this._exportType)
    }
    IsiOSCordova() {
        return this._isiOSCordova
    }
    IsiOSWebView() {
        return this._isiOSWebView
    }
    GetCollisionEngine() {
        return this._collisionEngine
    }
    GetSolidBehavior() {
        return this._pluginManager.GetSolidBehavior()
    }
    GetJumpthruBehavior() {
        return this._pluginManager.GetJumpthruBehavior()
    }
    Uses3DFeatures() {
        return this._uses3dFeatures
    }
    GetZScaleFactor() {
        return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight())
    }
    GetDefaultCameraZ(a) {
        return this.GetRenderer().GetDefaultCameraZ(a || this.GetViewportHeight())
    }
    IsLayoutFirstTick() {
        return this._isLayoutFirstTick
    }
    SetPixelRoundingEnabled(a) {
        a = !!a;
        this._isPixelRoundingEnabled !== a && (this._isPixelRoundingEnabled = a,
        this.GetLayoutManager().SetAllLayerMVChanged(),
        this.UpdateRender())
    }
    IsPixelRoundingEnabled() {
        return this._isPixelRoundingEnabled
    }
    SaveToSlot(a) {
        this._saveToSlotName = a
    }
    LoadFromSlot(a) {
        this._loadFromSlotName = a
    }
    LoadFromJsonString(a) {
        this._loadFromJson = a
    }
    GetLastSaveJsonString() {
        return this._lastSaveJson
    }
    _NeedsHandleSaveOrLoad() {
        return !(!this._saveToSlotName && !this._loadFromSlotName && null === this._loadFromJson)
    }
    async _HandleSaveOrLoad() {
        this._saveToSlotName && (this.FlushPendingInstances(),
        await this._DoSaveToSlot(this._saveToSlotName),
        this._ClearSaveOrLoad());
        this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName),
        this._ClearSaveOrLoad(),
        this.IsDebug() && C3Debugger$jscomp$3.StepIfPausedInDebugger());
        if (null !== this._loadFromJson) {
            this.FlushPendingInstances();
            try {
                await this._DoLoadFromJsonString(this._loadFromJson),
                this._lastSaveJson = this._loadFromJson,
                await this.TriggerAsync(C3$jscomp$172.Plugins.System.Cnds.OnLoadComplete, null),
                this._lastSaveJson = ""
            } catch (a) {
                console.error("[Construct] Failed to load state from JSON string: ", a),
                await this.TriggerAsync(C3$jscomp$172.Plugins.System.Cnds.OnLoadFailed, null)
            }
            this._ClearSaveOrLoad()
        }
    }
    _ClearSaveOrLoad() {
        this._loadFromSlotName = this._saveToSlotName = "";
        this._loadFromJson = null
    }
    _GetProjectStorage() {
        this._projectStorage || (this._projectStorage = localforage.createInstance({
            name: "c3-localstorage-" + this.GetProjectUniqueId(),
            description: this.GetProjectName()
        }));
        return this._projectStorage
    }
    _GetSavegamesStorage() {
        this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({
            name: "c3-savegames-" + this.GetProjectUniqueId(),
            description: this.GetProjectName()
        }));
        return this._savegamesStorage
    }
    async _DoSaveToSlot(a) {
        const b = await this._SaveToJsonString();
        try {
            await this._GetSavegamesStorage().setItem(a, b),
            console.log("[Construct] Saved state to storage (" + b.length + " chars)"),
            this._lastSaveJson = b,
            await this.TriggerAsync(C3$jscomp$172.Plugins.System.Cnds.OnSaveComplete, null),
            this._lastSaveJson = ""
        } catch (d) {
            console.error("[Construct] Failed to save state to storage: ", d),
            await this.TriggerAsync(C3$jscomp$172.Plugins.System.Cnds.OnSaveFailed, null)
        }
    }
    async _DoLoadFromSlot(a) {
        try {
            const b = await this._GetSavegamesStorage().getItem(a);
            if (!b)
                throw Error("empty slot");
            console.log("[Construct] Loaded state from storage (" + b.length + " chars)");
            await this._DoLoadFromJsonString(b);
            this._lastSaveJson = b;
            await this.TriggerAsync(C3$jscomp$172.Plugins.System.Cnds.OnLoadComplete, null);
            this._lastSaveJson = ""
        } catch (b) {
            console.error("[Construct] Failed to load state from storage: ", b),
            await this.TriggerAsync(C3$jscomp$172.Plugins.System.Cnds.OnLoadFailed, null)
        }
    }
    async _SaveToJsonString() {
        const a = {
            c3save: !0,
            version: 1,
            rt: {
                time: this.GetGameTime(),
                timeRaw: this.GetGameTimeRaw(),
                walltime: this.GetWallTime(),
                timescale: this.GetTimeScale(),
                tickcount: this.GetTickCount(),
                next_uid: this._nextUid,
                running_layout: this.GetMainRunningLayout().GetSID(),
                start_time_offset: Date.now() - this._startTime
            },
            types: {},
            layouts: {},
            events: this._eventSheetManager._SaveToJson(),
            timelines: this._timelineManager._SaveToJson(),
            user_script_data: null
        };
        for (var b of this._allObjectClasses)
            b.IsFamily() || b.HasNoSaveBehavior() || (a.types[b.GetSID().toString()] = b._SaveToJson());
        for (const d of this._layoutManager.GetAllLayouts())
            a.layouts[d.GetSID().toString()] = d._SaveToJson();
        b = this._CreateUserScriptEvent("save");
        b.saveData = null;
        await this.DispatchUserScriptEventAsyncWait(b);
        a.user_script_data = b.saveData;
        return JSON.stringify(a)
    }
    IsLoadingState() {
        return this._isLoadingState
    }
    async _DoLoadFromJsonString(a) {
        var b = this.GetLayoutManager();
        a = JSON.parse(a);
        if (a.c2save)
            throw Error("C2 saves are incompatible with C3 runtime");
        if (!a.c3save)
            throw Error("not valid C3 save data");
        if (1 < a.version)
            throw Error("C3 save data from future version");
        this._dispatcher.dispatchEvent(C3$jscomp$172.New(C3$jscomp$172.Event, "beforeload"));
        for (var d of this.allInstances())
            d.GetObjectClass().HasNoSaveBehavior() || d._OnBeforeLoad();
        d = a.rt;
        this._gameTime.Set(d.time);
        d.hasOwnProperty("timeRaw") && this._gameTimeRaw.Set(d.timeRaw);
        this._wallTime.Set(d.walltime);
        this._timeScale = d.timescale;
        this._tickCount = d.tickcount;
        this._startTime = Date.now() - d.start_time_offset;
        var c = d.running_layout;
        this._isLoadingState = !0;
        var e = !1;
        if (c !== this.GetMainRunningLayout().GetSID())
            if (e = b.GetLayoutBySID(c))
                await this._DoChangeLayout(e),
                e = !0;
            else
                return;
        for (const [l,n] of Object.entries(a.types))
            c = parseInt(l, 10),
            c = this.GetObjectClassBySID(c),
            !c || c.IsFamily() || c.HasNoSaveBehavior() || c._LoadFromJson(n);
        this.FlushPendingInstances();
        this._RefreshUidMap();
        this._isLoadingState = !1;
        if (e) {
            for (var g of this.allInstances())
                g.SetupInitialSceneGraphConnections();
            for (const [l,n] of Object.entries(a.types))
                g = parseInt(l, 10),
                g = this.GetObjectClassBySID(g),
                !g || g.IsFamily() || g.HasNoSaveBehavior() || g._SetupSceneGraphConnectionsOnChangeOfLayout(n)
        }
        this._nextUid = d.next_uid;
        for (const [l,n] of Object.entries(a.layouts))
            d = parseInt(l, 10),
            (d = b.GetLayoutBySID(d)) && d._LoadFromJson(n);
        this._eventSheetManager._LoadFromJson(a.events);
        for (const l of this._allObjectClasses)
            if (!l.IsFamily() && l.IsInContainer())
                for (const n of l.GetInstances()) {
                    d = n.GetIID();
                    for (const p of l.GetContainer().objectTypes())
                        if (p !== l) {
                            g = p.GetInstances();
                            if (0 > d || d >= g.length)
                                throw Error("missing sibling instance");
                            n._AddSibling(g[d])
                        }
                }
        this._timelineManager._LoadFromJson(a.timelines);
        b.SetAllLayerProjectionChanged();
        b.SetAllLayerMVChanged();
        this._dispatcher.dispatchEvent(C3$jscomp$172.New(C3$jscomp$172.Event, "afterload"));
        for (var [k] of Object.entries(a.types))
            b = parseInt(k, 10),
            (b = this.GetObjectClassBySID(b)) && b._ClearLoadInstancesJson();
        k = this._CreateUserScriptEvent("load");
        k.saveData = a.user_script_data;
        await this.DispatchUserScriptEventAsyncWait(k);
        this.UpdateRender()
    }
    async AddJobWorkerScripts(a) {
        a = await Promise.all(a.map(async b=>{
            const d = C3$jscomp$172.IsAbsoluteURL(b) && (new URL(b)).origin !== location.origin
              , c = this.IsCordova() && this._assetManager.IsFileProtocol();
            return d || c || this.IsPreview() || "playable-ad" === this.GetExportType() ? (b = await this._assetManager.FetchBlob(b),
            URL.createObjectURL(b)) : C3$jscomp$172.IsRelativeURL(b) ? (new URL(b,this._runtimeBaseUrl)).toString() : b
        }
        ));
        this._jobScheduler.ImportScriptsToJobWorkers(a)
    }
    AddJobWorkerBlob(a, b) {
        this._jobScheduler.SendBlobToJobWorkers(a, b)
    }
    AddJobWorkerBuffer(a, b) {
        this._jobScheduler.SendBufferToJobWorkers(a, b)
    }
    AddJob(a, b, d, c) {
        return this._jobScheduler.AddJob(a, b, d, null, null, c)
    }
    BroadcastJob(a, b, d, c) {
        return this._jobScheduler.BroadcastJob(a, b, d, c)
    }
    GetMaxNumJobWorkers() {
        return this._jobScheduler.GetMaxNumWorkers()
    }
    InvokeDownload(a, b) {
        this.PostComponentMessageToDOM("runtime", "invoke-download", {
            url: a,
            filename: b
        })
    }
    async RasterSvgImage(a, b, d, c, e, g) {
        c = c || b;
        e = e || d;
        if (this.IsInWorker())
            return (await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", {
                blob: a,
                imageWidth: b,
                imageHeight: d,
                surfaceWidth: c,
                surfaceHeight: e,
                imageBitmapOpts: g
            })).imageBitmap;
        a = await self.C3_RasterSvgImageBlob(a, b, d, c, e);
        return g ? await self.createImageBitmap(a, g) : a
    }
    async GetSvgImageSize(a) {
        return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync("runtime", "get-svg-image-size", {
            blob: a
        }) : await self.C3_GetSvgImageSize(a)
    }
    RequestDeviceOrientationEvent() {
        this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = !0,
        this.PostComponentMessageToDOM("runtime", "enable-device-orientation"))
    }
    RequestDeviceMotionEvent() {
        this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = !0,
        this.PostComponentMessageToDOM("runtime", "enable-device-motion"))
    }
    Random() {
        return this._randomNumberCallback()
    }
    SetRandomNumberGeneratorCallback(a) {
        this._randomNumberCallback = a
    }
    _GetRemotePreviewStatusInfo() {
        const a = this.GetRenderer();
        return {
            fps: this.GetFPS(),
            cpu: this.GetMainThreadTime(),
            gpu: this.GetGPUUtilisation(),
            layout: this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "",
            renderer: a.IsWebGL() ? a.GetUnmaskedRenderer() : a.GetBasicAdapterInfoString()
        }
    }
    HitBreakpoint() {
        return this.IsDebug() ? C3Debugger$jscomp$3.HitBreakpoint() : !1
    }
    DebugBreak(a) {
        return this.IsDebugging() ? C3Debugger$jscomp$3.DebugBreak(a) : Promise.resolve()
    }
    DebugBreakNext() {
        return this.IsDebugging() ? C3Debugger$jscomp$3.BreakNext() : !1
    }
    SetDebugBreakpointsEnabled(a) {
        this._breakpointsEnabled = !!a;
        this._UpdateDebuggingFlag()
    }
    AreDebugBreakpointsEnabled() {
        return this._breakpointsEnabled
    }
    IsDebugging() {
        return this._isDebugging
    }
    SetDebuggingEnabled(a) {
        a ? this._debuggingDisabled-- : this._debuggingDisabled++;
        this._UpdateDebuggingFlag()
    }
    _UpdateDebuggingFlag() {
        this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled
    }
    IsCPUProfiling() {
        return this.IsDebug() && C3Debugger$jscomp$3.IsCPUProfiling()
    }
    IsGPUProfiling() {
        return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && C3Debugger$jscomp$3.IsGPUProfiling()
    }
    async DebugIterateAndBreak(a) {
        if (a)
            for (const b of a)
                await this.DebugBreak(b)
    }
    DebugFireGeneratorEventAndBreak(a) {
        return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(a))
    }
    _InvokeFunctionFromJS(a) {
        return this._eventSheetManager._InvokeFunctionFromJS(a.name, a.params)
    }
    GetIRuntime() {
        return this._iRuntime
    }
    _CreateUserScriptEvent(a) {
        a = C3$jscomp$172.New(C3$jscomp$172.Event, a, !1);
        a.runtime = this._iRuntime;
        return a
    }
    _InitScriptInterfaces() {
        var a = {};
        for (const b of this._allObjectClasses)
            a[b.GetJsPropName()] = {
                value: b.GetIObjectClass(),
                enumerable: !0,
                writable: !1
            };
        a = Object.create(Object.prototype, a);
        this._iRuntime = new self.IRuntime(this,a);
        this._userScriptEventObjects = {
            tick: this._CreateUserScriptEvent("tick")
        }
    }
    _InitGlobalVariableScriptInterface() {
        const a = {};
        for (const b of this.GetEventSheetManager().GetAllGlobalVariables())
            a[b.GetJsPropName()] = b._GetScriptInterfaceDescriptor();
        this._iRuntime._InitGlobalVars(a)
    }
    _GetCommonScriptInterfaces() {
        return this._commonScriptInterfaces
    }
    _MapScriptInterface(a, b) {
        this._interfaceMap.set(a, b)
    }
    _UnwrapScriptInterface(a) {
        return this._interfaceMap.get(a)
    }
    _UnwrapIObjectClass(a) {
        if (!(a instanceof self.IObjectClass))
            throw new TypeError("expected IObjectClass");
        a = this._UnwrapScriptInterface(a);
        if (!(a && a instanceof C3$jscomp$172.ObjectClass))
            throw Error("invalid IObjectClass");
        return a
    }
    _UnwrapIWorldInstance(a) {
        if (!(a instanceof self.IWorldInstance))
            throw new TypeError("expected IWorldInstance");
        a = this._UnwrapScriptInterface(a);
        if (!(a && a instanceof C3$jscomp$172.Instance))
            throw Error("invalid IInstance");
        return a
    }
}
;
self.C3_CreateRuntime = C3$jscomp$172.Runtime.Create;
self.C3_InitRuntime = (a,b)=>a.Init(b);
"use strict";
const C3$jscomp$173 = self.C3;
C3$jscomp$173.JobSchedulerRuntime = class extends C3$jscomp$173.DefendedBase {
    constructor(a, b) {
        super();
        this._runtime = a;
        this._jobPromises = new Map;
        this._nextJobId = 0;
        this._inputPort = b.inputPort;
        b.outputPort.onmessage = d=>this._OnJobWorkerMessage(d);
        this._maxNumWorkers = b.maxNumWorkers;
        this._jobWorkerCount = 1;
        this._hadErrorCreatingWorker = this._isCreatingWorker = !1
    }
    async Init() {}
    GetMaxNumWorkers() {
        return this._maxNumWorkers
    }
    ImportScriptsToJobWorkers(a) {
        this._inputPort.postMessage({
            type: "_import_scripts",
            scripts: a
        })
    }
    SendBlobToJobWorkers(a, b) {
        this._inputPort.postMessage({
            type: "_send_blob",
            blob: a,
            id: b
        })
    }
    SendBufferToJobWorkers(a, b) {
        this._inputPort.postMessage({
            type: "_send_buffer",
            buffer: a,
            id: b
        }, [a])
    }
    AddJob(a, b, d, c, e, g) {
        d || (d = []);
        if ("number" === typeof g && (g = Math.floor(g),
        0 >= g))
            throw Error("invalid maxWorkerNum");
        const k = this._nextJobId++;
        a = {
            type: a,
            isBroadcast: !1,
            maxWorkerNum: g,
            jobId: k,
            params: b,
            transferables: d
        };
        b = new Promise((l,n)=>{
            this._jobPromises.set(k, {
                resolve: l,
                progress: c,
                reject: n,
                cancelled: !1,
                maxWorkerNum: g
            })
        }
        );
        e && e.SetAction(()=>this._CancelJob(k));
        this._inputPort.postMessage(a, d);
        this._MaybeCreateExtraWorker();
        return b
    }
    BroadcastJob(a, b, d, c) {
        d || (d = []);
        if ("number" === typeof c && (c = Math.floor(c),
        0 >= c))
            throw Error("invalid maxWorkerNum");
        const e = this._nextJobId++;
        this._inputPort.postMessage({
            type: a,
            isBroadcast: !0,
            maxWorkerNum: c,
            jobId: e,
            params: b,
            transferables: d
        }, d)
    }
    _CancelJob(a) {
        const b = this._jobPromises.get(a);
        b && (b.cancelled = !0,
        b.resolve = null,
        b.progress = null,
        b.reject = null,
        this._inputPort.postMessage({
            type: "_cancel",
            jobId: a
        }))
    }
    _OnJobWorkerMessage(a) {
        a = a.data;
        const b = a.type
          , d = a.jobId;
        switch (b) {
        case "result":
            this._OnJobResult(d, a.result);
            break;
        case "progress":
            this._OnJobProgress(d, a.progress);
            break;
        case "error":
            this._OnJobError(d, a.error);
            break;
        case "ready":
            this._OnJobWorkerReady();
            break;
        default:
            throw Error(`unknown message from worker '${b}'`);
        }
    }
    _OnJobResult(a, b) {
        const d = this._jobPromises.get(a);
        if (!d)
            throw Error("invalid job ID");
        d.cancelled || d.resolve(b);
        this._jobPromises.delete(a)
    }
    _OnJobProgress(a, b) {
        a = this._jobPromises.get(a);
        if (!a)
            throw Error("invalid job ID");
        !a.cancelled && a.progress && a.progress(b)
    }
    _OnJobError(a, b) {
        const d = this._jobPromises.get(a);
        if (!d)
            throw Error("invalid job ID");
        d.cancelled || d.reject(b);
        this._jobPromises.delete(a)
    }
    _OnJobWorkerReady() {
        this._isCreatingWorker && (this._isCreatingWorker = !1,
        this._jobWorkerCount++,
        this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({
            type: "_no_more_workers"
        }))
    }
    _GetWorkerCountNeededForPendingJobs() {
        let a = 0;
        const b = [...this._jobPromises.values()].sort((d,c)=>(d.maxWorkerNum || Infinity) - (c.maxWorkerNum || Infinity));
        for (const d of b)
            a < (d.maxWorkerNum || Infinity) && a++;
        return a
    }
    async _MaybeCreateExtraWorker() {
        if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._GetWorkerCountNeededForPendingJobs() <= this._jobWorkerCount))
            try {
                this._isCreatingWorker = !0,
                (await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker")).outputPort.onmessage = a=>this._OnJobWorkerMessage(a)
            } catch (a) {
                this._hadErrorCreatingWorker = !0,
                this._isCreatingWorker = !1,
                console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, a)
            }
    }
}
;
self.C3_Shaders = {};
"use strict";
const C3$jscomp$174 = self.C3;
let cacheRegex = null
  , lastRegex = ""
  , lastFlags = ""
  , regexMatches = []
  , lastMatchesStr = ""
  , lastMatchesRegex = ""
  , lastMatchesFlags = "";
const forEachStack = C3$jscomp$174.New(C3$jscomp$174.ArrayStack);
function ForEachOrdered_SortInstances(a, b) {
    a = a[1];
    b = b[1];
    if ("number" === typeof a && "number" === typeof b)
        return a - b;
    a = "" + a;
    b = "" + b;
    return a < b ? -1 : a > b ? 1 : 0
}
C3$jscomp$174.Plugins.System = class extends C3$jscomp$174.SDKPluginBase {
    constructor(a) {
        super(a);
        this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack();
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._imagesLoadingComplete = this._imagesLoadingTotal = 0;
        this._functionMaps = new Map;
        this._signalTags = []
    }
    Release() {
        super.Release()
    }
    UpdateRender() {
        this._runtime.UpdateRender()
    }
    Trigger(a) {
        this._runtime.Trigger(a, null, null)
    }
    GetRegex(a, b) {
        cacheRegex && a === lastRegex && b === lastFlags || (cacheRegex = new RegExp(a,b),
        lastRegex = a,
        lastFlags = b);
        cacheRegex.lastIndex = 0;
        return cacheRegex
    }
    GetRegexMatches(a, b, d) {
        if (a === lastMatchesStr && b === lastMatchesRegex && d === lastMatchesFlags)
            return regexMatches;
        const c = this.GetRegex(b, d);
        regexMatches = a.match(c);
        lastMatchesStr = a;
        lastMatchesRegex = b;
        lastMatchesFlags = d;
        return regexMatches
    }
    async _LoadTexturesForObjectClasses(a, b) {
        if (b.length) {
            this._imagesLoadingTotal += b.length;
            var d = [];
            for (const c of b)
                d.push(a.MaybeLoadTexturesFor(c));
            await C3$jscomp$174.PromiseAllWithProgress(d, ()=>{
                this._imagesLoadingComplete++
            }
            );
            this._imagesLoadingComplete++;
            this._imagesLoadingComplete === this._imagesLoadingTotal && (this._imagesLoadingTotal = this._imagesLoadingComplete = 0,
            this._runtime.Trigger(C3$jscomp$174.Plugins.System.Cnds.OnImageLoadingComplete, null, null))
        }
    }
    _UnloadTexturesForObjectClasses(a, b) {
        for (const d of b)
            0 === d.GetInstanceCount() && a.MaybeUnloadTexturesFor(d)
    }
    _GetForEachStack() {
        return forEachStack
    }
    _Repeat(a) {
        var b = this._runtime.GetEventSheetManager();
        const d = b.GetEventStack()
          , c = d.GetCurrentStackFrame()
          , e = c.GetCurrentEvent()
          , g = e.GetSolModifiers();
        var k = c.IsSolModifierAfterCnds();
        const l = d.Push(e)
          , n = b.GetLoopStack()
          , p = n.Push();
        p.SetEnd(a);
        if (k)
            for (k = 0; k < a && !p.IsStopped(); ++k)
                b.PushCopySol(g),
                p.SetIndex(k),
                e.Retrigger(c, l),
                b.PopSol(g);
        else
            for (b = 0; b < a && !p.IsStopped(); ++b)
                p.SetIndex(b),
                e.Retrigger(c, l);
        d.Pop();
        n.Pop();
        return !1
    }
    *_DebugRepeat(a) {
        var b = this._runtime.GetEventSheetManager();
        const d = b.GetEventStack()
          , c = d.GetCurrentStackFrame()
          , e = c.GetCurrentEvent()
          , g = e.GetSolModifiers();
        var k = c.IsSolModifierAfterCnds();
        const l = d.Push(e)
          , n = b.GetLoopStack()
          , p = n.Push();
        p.SetEnd(a);
        if (k)
            for (k = 0; k < a && !p.IsStopped(); ++k)
                b.PushCopySol(g),
                p.SetIndex(k),
                yield*e.DebugRetrigger(c, l),
                b.PopSol(g);
        else
            for (b = 0; b < a && !p.IsStopped(); ++b)
                p.SetIndex(b),
                yield*e.DebugRetrigger(c, l);
        d.Pop();
        n.Pop();
        return !1
    }
    _While() {
        var a = this._runtime.GetEventSheetManager();
        const b = a.GetEventStack()
          , d = b.GetCurrentStackFrame()
          , c = d.GetCurrentEvent()
          , e = c.GetSolModifiers();
        var g = d.IsSolModifierAfterCnds();
        const k = b.Push(c)
          , l = a.GetLoopStack()
          , n = l.Push();
        if (g)
            for (g = 0; !n.IsStopped(); ++g)
                a.PushCopySol(e),
                n.SetIndex(g),
                c.Retrigger(d, k) || n.Stop(),
                a.PopSol(e);
        else
            for (a = 0; !n.IsStopped(); ++a)
                n.SetIndex(a),
                c.Retrigger(d, k) || n.Stop();
        b.Pop();
        l.Pop();
        return !1
    }
    *_DebugWhile() {
        var a = this._runtime.GetEventSheetManager();
        const b = a.GetEventStack()
          , d = b.GetCurrentStackFrame()
          , c = d.GetCurrentEvent()
          , e = c.GetSolModifiers();
        var g = d.IsSolModifierAfterCnds();
        const k = b.Push(c)
          , l = a.GetLoopStack()
          , n = l.Push();
        if (g)
            for (g = 0; !n.IsStopped(); ++g)
                a.PushCopySol(e),
                n.SetIndex(g),
                (yield*c.DebugRetrigger(d, k)) || n.Stop(),
                a.PopSol(e);
        else
            for (a = 0; !n.IsStopped(); ++a)
                n.SetIndex(a),
                (yield*c.DebugRetrigger(d, k)) || n.Stop();
        b.Pop();
        l.Pop();
        return !1
    }
    _For(a, b, d) {
        var c = this._runtime.GetEventSheetManager();
        const e = c.GetEventStack()
          , g = e.GetCurrentStackFrame()
          , k = g.GetCurrentEvent()
          , l = k.GetSolModifiers()
          , n = g.IsSolModifierAfterCnds()
          , p = e.Push(k)
          , t = c.GetLoopStack()
          , w = t.Push();
        w.SetName(a);
        w.SetEnd(d);
        if (d < b)
            if (n)
                for (a = b; a >= d && !w.IsStopped(); --a)
                    c.PushCopySol(l),
                    w.SetIndex(a),
                    k.Retrigger(g, p),
                    c.PopSol(l);
            else
                for (c = b; c >= d && !w.IsStopped(); --c)
                    w.SetIndex(c),
                    k.Retrigger(g, p);
        else if (n)
            for (a = b; a <= d && !w.IsStopped(); ++a)
                c.PushCopySol(l),
                w.SetIndex(a),
                k.Retrigger(g, p),
                c.PopSol(l);
        else
            for (c = b; c <= d && !w.IsStopped(); ++c)
                w.SetIndex(c),
                k.Retrigger(g, p);
        e.Pop();
        t.Pop();
        return !1
    }
    *_DebugFor(a, b, d) {
        var c = this._runtime.GetEventSheetManager();
        const e = c.GetEventStack()
          , g = e.GetCurrentStackFrame()
          , k = g.GetCurrentEvent()
          , l = k.GetSolModifiers()
          , n = g.IsSolModifierAfterCnds()
          , p = e.Push(k)
          , t = c.GetLoopStack()
          , w = t.Push();
        w.SetName(a);
        w.SetEnd(d);
        if (d < b)
            if (n)
                for (a = b; a >= d && !w.IsStopped(); --a)
                    c.PushCopySol(l),
                    w.SetIndex(a),
                    yield*k.DebugRetrigger(g, p),
                    c.PopSol(l);
            else
                for (c = b; c >= d && !w.IsStopped(); --c)
                    w.SetIndex(c),
                    yield*k.DebugRetrigger(g, p);
        else if (n)
            for (a = b; a <= d && !w.IsStopped(); ++a)
                c.PushCopySol(l),
                w.SetIndex(a),
                yield*k.DebugRetrigger(g, p),
                c.PopSol(l);
        else
            for (c = b; c <= d && !w.IsStopped(); ++c)
                w.SetIndex(c),
                yield*k.DebugRetrigger(g, p);
        e.Pop();
        t.Pop();
        return !1
    }
    _ForEach(a) {
        var b = this._runtime.GetEventSheetManager();
        const d = b.GetEventStack()
          , c = d.GetCurrentStackFrame()
          , e = c.GetCurrentEvent()
          , g = e.GetSolModifiers();
        var k = c.IsSolModifierAfterCnds();
        const l = d.Push(e)
          , n = b.GetLoopStack()
          , p = n.Push()
          , t = a.IsInContainer()
          , w = a.GetCurrentSol()
          , z = forEachStack.Push();
        C3$jscomp$174.shallowAssignArray(z, w.GetInstances());
        p.SetEnd(z.length);
        if (k)
            for (let B = 0, C = z.length; B < C && !p.IsStopped(); ++B)
                b.PushCopySol(g),
                k = z[B],
                a.GetCurrentSol().SetSinglePicked(k),
                t && k.SetSiblingsSinglePicked(),
                p.SetIndex(B),
                e.Retrigger(c, l),
                b.PopSol(g);
        else {
            w._SetSelectAll(!1);
            a = w._GetOwnInstances();
            C3$jscomp$174.clearArray(a);
            a.push(null);
            for (let B = 0, C = z.length; B < C && !p.IsStopped(); ++B)
                b = z[B],
                a[0] = b,
                t && b.SetSiblingsSinglePicked(),
                p.SetIndex(B),
                e.Retrigger(c, l)
        }
        d.Pop();
        n.Pop();
        C3$jscomp$174.clearArray(z);
        forEachStack.Pop();
        return !1
    }
    *_DebugForEach(a) {
        var b = this._runtime.GetEventSheetManager();
        const d = b.GetEventStack()
          , c = d.GetCurrentStackFrame()
          , e = c.GetCurrentEvent()
          , g = e.GetSolModifiers();
        var k = c.IsSolModifierAfterCnds();
        const l = d.Push(e)
          , n = b.GetLoopStack()
          , p = n.Push()
          , t = a.IsInContainer()
          , w = a.GetCurrentSol()
          , z = forEachStack.Push();
        C3$jscomp$174.shallowAssignArray(z, w.GetInstances());
        p.SetEnd(z.length);
        if (k)
            for (let B = 0, C = z.length; B < C && !p.IsStopped(); ++B)
                b.PushCopySol(g),
                k = z[B],
                a.GetCurrentSol().SetSinglePicked(k),
                t && k.SetSiblingsSinglePicked(),
                p.SetIndex(B),
                yield*e.DebugRetrigger(c, l),
                b.PopSol(g);
        else {
            w._SetSelectAll(!1);
            a = w._GetOwnInstances();
            C3$jscomp$174.clearArray(a);
            a.push(null);
            for (let B = 0, C = z.length; B < C && !p.IsStopped(); ++B)
                b = z[B],
                a[0] = b,
                t && b.SetSiblingsSinglePicked(),
                p.SetIndex(B),
                yield*e.DebugRetrigger(c, l)
        }
        d.Pop();
        n.Pop();
        C3$jscomp$174.clearArray(z);
        forEachStack.Pop();
        return !1
    }
    _ForEachOrdered(a, b) {
        var d = this._runtime.GetEventSheetManager();
        const c = d.GetEventStack()
          , e = d.GetCurrentCondition()
          , g = c.GetCurrentStackFrame()
          , k = g.GetCurrentEvent()
          , l = k.GetSolModifiers()
          , n = g.IsSolModifierAfterCnds()
          , p = c.Push(k)
          , t = d.GetLoopStack()
          , w = t.Push()
          , z = a.IsInContainer()
          , B = a.GetCurrentSol()
          , C = forEachStack.Push();
        C3$jscomp$174.clearArray(C);
        const E = B.GetInstances();
        w.SetEnd(E.length);
        for (let F = 0, J = E.length; F < J; ++F)
            C.push([E[F], e.ReevaluateParameter(1, F)]);
        C.sort(ForEachOrdered_SortInstances);
        1 === b && C.reverse();
        if (n)
            for (let F = 0, J = C.length; F < J && !w.IsStopped(); ++F)
                d.PushCopySol(l),
                b = C[F][0],
                a.GetCurrentSol().SetSinglePicked(b),
                z && b.SetSiblingsSinglePicked(),
                w.SetIndex(F),
                k.Retrigger(g, p),
                d.PopSol(l);
        else {
            B._SetSelectAll(!1);
            a = B._GetOwnInstances();
            C3$jscomp$174.clearArray(a);
            a.push(null);
            for (let F = 0, J = C.length; F < J && !w.IsStopped(); ++F)
                d = C[F][0],
                a[0] = d,
                z && d.SetSiblingsSinglePicked(),
                w.SetIndex(F),
                k.Retrigger(g, p)
        }
        c.Pop();
        t.Pop();
        C3$jscomp$174.clearArray(C);
        forEachStack.Pop();
        return !1
    }
    *_DebugForEachOrdered(a, b) {
        var d = this._runtime.GetEventSheetManager();
        const c = d.GetEventStack()
          , e = d.GetCurrentCondition()
          , g = c.GetCurrentStackFrame()
          , k = g.GetCurrentEvent()
          , l = k.GetSolModifiers()
          , n = g.IsSolModifierAfterCnds()
          , p = c.Push(k)
          , t = d.GetLoopStack()
          , w = t.Push()
          , z = a.IsInContainer()
          , B = a.GetCurrentSol()
          , C = forEachStack.Push();
        C3$jscomp$174.clearArray(C);
        const E = B.GetInstances();
        w.SetEnd(E.length);
        for (let F = 0, J = E.length; F < J; ++F)
            C.push([E[F], e.ReevaluateParameter(1, F)]);
        C.sort(ForEachOrdered_SortInstances);
        1 === b && C.reverse();
        if (n)
            for (let F = 0, J = C.length; F < J && !w.IsStopped(); ++F)
                d.PushCopySol(l),
                b = C[F][0],
                a.GetCurrentSol().SetSinglePicked(b),
                z && b.SetSiblingsSinglePicked(),
                w.SetIndex(F),
                yield*k.DebugRetrigger(g, p),
                d.PopSol(l);
        else {
            B._SetSelectAll(!1);
            a = B._GetOwnInstances();
            C3$jscomp$174.clearArray(a);
            a.push(null);
            for (let F = 0, J = C.length; F < J && !w.IsStopped(); ++F)
                d = C[F][0],
                a[0] = d,
                z && d.SetSiblingsSinglePicked(),
                w.SetIndex(F),
                yield*k.DebugRetrigger(g, p)
        }
        c.Pop();
        t.Pop();
        C3$jscomp$174.clearArray(C);
        forEachStack.Pop();
        return !1
    }
    _GetFunctionMap(a, b) {
        let d = this._functionMaps.get(a);
        if (d)
            return d;
        if (!b)
            return null;
        d = {
            defaultFunc: null,
            strMap: new Map
        };
        this._functionMaps.set(a, d);
        return d
    }
    _DoCallMappedFunction(a, b, d, c, e) {
        b.GetEventBlock().RunAsMappedFunctionCall(d, b.IsCopyPicked());
        c && a.PopSol(e)
    }
    *_DebugDoCallMappedFunction(a, b, d, c, e) {
        yield*b.GetEventBlock().DebugRunAsMappedFunctionCall(d, b.IsCopyPicked());
        c && a.PopSol(e)
    }
}
;
const C3$jscomp$175 = self.C3;
C3$jscomp$175.Plugins.System.Type = class extends C3$jscomp$175.DefendedBase {
    constructor(a) {
        super();
        this._objectClass = a;
        this._runtime = a.GetRuntime();
        this._plugin = a.GetPlugin()
    }
    OnCreate() {}
    Release() {
        this._plugin = this._runtime = this._objectClass = null
    }
}
;
const C3$jscomp$176 = self.C3;
C3$jscomp$176.Plugins.System.Instance = class extends C3$jscomp$176.DefendedBase {
    constructor(a, b) {
        super();
        this._inst = a;
        this._objectClass = this._inst.GetObjectClass();
        this._sdkType = this._objectClass.GetSdkType();
        this._runtime = this._inst.GetRuntime()
    }
    Release() {
        this._runtime = this._sdkType = this._objectClass = this._inst = null
    }
}
;
const C3$jscomp$177 = self.C3
  , tmpPickArray = [];
C3$jscomp$177.Plugins.System.Cnds = {
    EveryTick() {
        return !0
    },
    OnLayoutStart() {
        return !0
    },
    OnLayoutEnd() {
        return !0
    },
    OnSuspend() {
        return !0
    },
    OnResume() {
        return !0
    },
    IsSuspended() {
        return this._runtime.IsSuspended()
    },
    Else() {
        const a = this._runtime.GetCurrentEventStackFrame();
        return a.GetElseBranchRan() ? !1 : !a.GetLastEventTrue()
    },
    TriggerOnce() {
        const a = this._runtime.GetCurrentCondition().GetSavedDataMap();
        let b = a.get("TriggerOnce_lastTick");
        "undefined" === typeof b && (b = -1,
        a.set("TriggerOnce_lastTick", -1));
        const d = this._runtime.GetTickCount();
        a.set("TriggerOnce_lastTick", d);
        return this._runtime.IsLayoutFirstTick() || b !== d - 1
    },
    Every(a) {
        const b = this._runtime.GetCurrentCondition().GetSavedDataMap()
          , d = b.get("Every_lastTime") || 0
          , c = this._runtime.GetGameTime();
        b.has("Every_seconds") || b.set("Every_seconds", a);
        const e = b.get("Every_seconds");
        if (c >= d + e)
            return b.set("Every_lastTime", d + e),
            c >= b.get("Every_lastTime") + .04 && b.set("Every_lastTime", c),
            b.set("Every_seconds", a),
            !0;
        c < d - .1 && b.set("Every_lastTime", c);
        return !1
    },
    IsGroupActive(a) {
        return (a = this._runtime.GetEventSheetManager().GetEventGroupByName(a)) && a.IsGroupActive()
    },
    IsPreview() {
        return this._runtime.IsPreview()
    },
    IsMobile() {
        return C3$jscomp$177.Platform.IsMobile
    },
    OnLoadFinished() {
        return !0
    },
    OnCanvasSnapshot() {
        return !0
    },
    EffectsSupported() {
        return !0
    },
    OnSaveComplete() {
        return !0
    },
    OnSaveFailed() {
        return !0
    },
    OnLoadComplete() {
        return !0
    },
    OnLoadFailed() {
        return !0
    },
    ObjectUIDExists(a) {
        return !!this._runtime.GetInstanceByUID(a)
    },
    IsOnPlatform(a) {
        switch (a) {
        case 0:
            return "browser" === C3$jscomp$177.Platform.Context;
        case 1:
            return "iOS" === C3$jscomp$177.Platform.OS;
        case 2:
            return "Android" === C3$jscomp$177.Platform.OS;
        case 8:
            return "cordova" === C3$jscomp$177.Platform.Context;
        case 9:
            return "scirra-arcade" === this._runtime.GetExportType();
        case 10:
            return "nwjs" === C3$jscomp$177.Platform.Context;
        case 13:
            return "windows-uwp" === this._runtime.GetExportType();
        default:
            return !1
        }
    },
    RegexTest(a, b, d) {
        return this.GetRegex(b, d).test(a)
    },
    Compare(a, b, d) {
        return C3$jscomp$177.compare(a, b, d)
    },
    CompareBetween(a, b, d) {
        return a >= b && a <= d
    },
    CompareVar(a, b, d) {
        return C3$jscomp$177.compare(a.GetValue(), b, d)
    },
    CompareBoolVar(a) {
        return !!a.GetValue()
    },
    CompareTime(a, b) {
        const d = this._runtime.GetGameTime();
        return 0 === a ? (a = this._runtime.GetCurrentCondition().GetSavedDataMap(),
        !a.get("CompareTime_executed") && d >= b ? (a.set("CompareTime_executed", !0),
        !0) : !1) : C3$jscomp$177.compare(d, a, b)
    },
    IsNaN(a) {
        return isNaN(a)
    },
    AngleWithin(a, b, d) {
        return C3$jscomp$177.angleDiff(C3$jscomp$177.toRadians(a), C3$jscomp$177.toRadians(d)) <= C3$jscomp$177.toRadians(b)
    },
    IsClockwiseFrom(a, b) {
        return C3$jscomp$177.angleClockwise(C3$jscomp$177.toRadians(a), C3$jscomp$177.toRadians(b))
    },
    IsBetweenAngles(a, b, d) {
        a = C3$jscomp$177.toRadians(a);
        b = C3$jscomp$177.toRadians(b);
        d = C3$jscomp$177.toRadians(d);
        return C3$jscomp$177.angleClockwise(d, b) ? C3$jscomp$177.angleClockwise(a, b) && !C3$jscomp$177.angleClockwise(a, d) : !(!C3$jscomp$177.angleClockwise(a, b) && C3$jscomp$177.angleClockwise(a, d))
    },
    IsValueType(a, b) {
        return "number" === typeof a ? 0 === b : 1 === b
    },
    EvaluateExpression(a) {
        return !!a
    },
    OnSignal(a) {
        return a.toLowerCase() === this._signalTags.at(-1)
    },
    PickByComparison(a, b, d, c) {
        if (!a)
            return !1;
        const e = this._GetForEachStack()
          , g = e.Push()
          , k = a.GetCurrentSol();
        C3$jscomp$177.shallowAssignArray(g, k.GetInstances());
        k.IsSelectAll() && C3$jscomp$177.clearArray(k._GetOwnElseInstances());
        const l = this._runtime.GetCurrentCondition();
        let n = 0;
        for (let p = 0, t = g.length; p < t; ++p) {
            const w = g[p];
            g[n] = w;
            b = l.ReevaluateParameter(1, p);
            c = l.ReevaluateParameter(3, p);
            C3$jscomp$177.compare(b, d, c) ? ++n : k._PushElseInstance(w)
        }
        C3$jscomp$177.truncateArray(g, n);
        k.SetArrayPicked(g);
        b = !!g.length;
        C3$jscomp$177.clearArray(g);
        e.Pop();
        a.ApplySolToContainer();
        return b
    },
    PickByEvaluate(a, b) {
        if (!a)
            return !1;
        const d = this._GetForEachStack()
          , c = d.Push()
          , e = a.GetCurrentSol();
        C3$jscomp$177.shallowAssignArray(c, e.GetInstances());
        e.IsSelectAll() && C3$jscomp$177.clearArray(e._GetOwnElseInstances());
        const g = this._runtime.GetCurrentCondition();
        let k = 0;
        for (let l = 0, n = c.length; l < n; ++l) {
            const p = c[l];
            c[k] = p;
            (b = g.ReevaluateParameter(1, l)) ? ++k : e._PushElseInstance(p)
        }
        C3$jscomp$177.truncateArray(c, k);
        e.SetArrayPicked(c);
        b = !!c.length;
        C3$jscomp$177.clearArray(c);
        d.Pop();
        a.ApplySolToContainer();
        return b
    },
    PickNth(a, b) {
        if (!a)
            return !1;
        const d = a.GetCurrentSol()
          , c = d.GetInstances();
        b = Math.floor(b);
        if (b >= c.length)
            return !1;
        d.PickOne(c[b]);
        a.ApplySolToContainer();
        return !0
    },
    PickRandom(a) {
        if (!a)
            return !1;
        const b = a.GetCurrentSol()
          , d = b.GetInstances()
          , c = Math.floor(this._runtime.Random() * d.length);
        if (c >= d.length)
            return !1;
        b.PickOne(d[c]);
        a.ApplySolToContainer();
        return !0
    },
    PickAll(a) {
        if (!a || !a.GetInstanceCount())
            return !1;
        a.GetCurrentSol()._SetSelectAll(!0);
        a.ApplySolToContainer();
        return !0
    },
    PickOverlappingPoint(a, b, d) {
        if (!a)
            return !1;
        const c = a.GetCurrentSol();
        var e = c.GetInstances();
        const g = this._runtime.GetCurrentEvent().IsOrBlock()
          , k = this._runtime.GetCurrentCondition().IsInverted();
        c.IsSelectAll() ? (C3$jscomp$177.shallowAssignArray(tmpPickArray, e),
        c.ClearArrays(),
        c._SetSelectAll(!1)) : g ? (C3$jscomp$177.shallowAssignArray(tmpPickArray, c._GetOwnElseInstances()),
        C3$jscomp$177.clearArray(c._GetOwnElseInstances())) : (C3$jscomp$177.shallowAssignArray(tmpPickArray, c._GetOwnInstances()),
        C3$jscomp$177.clearArray(c._GetOwnInstances()));
        for (let l = 0, n = tmpPickArray.length; l < n; ++l)
            e = tmpPickArray[l],
            C3$jscomp$177.xor(e.GetWorldInfo().ContainsPoint(b, d), k) ? c._PushInstance(e) : c._PushElseInstance(e);
        a.ApplySolToContainer();
        return C3$jscomp$177.xor(!!c._GetOwnInstances().length, k)
    },
    PickLastCreated(a) {
        if (!a)
            return !1;
        var b = a.IsFamily();
        let d = null;
        const c = this._runtime._GetInstancesPendingCreate();
        for (let e = c.length - 1; 0 <= e; --e) {
            const g = c[e];
            if (b) {
                if (g.GetObjectClass().BelongsToFamily(a)) {
                    d = g;
                    break
                }
            } else if (g.GetObjectClass() === a) {
                d = g;
                break
            }
        }
        d || (b = a.GetInstances(),
        b.length && (d = b.at(-1)));
        if (!d)
            return !1;
        a.GetCurrentSol().PickOne(d);
        a.ApplySolToContainer();
        return !0
    },
    Repeat(a) {
        return this._runtime.IsDebugging() ? this._DebugRepeat(a) : this._Repeat(a)
    },
    While() {
        return this._runtime.IsDebugging() ? this._DebugWhile() : this._While()
    },
    For(a, b, d) {
        return this._runtime.IsDebugging() ? this._DebugFor(a, b, d) : this._For(a, b, d)
    },
    ForEach(a) {
        return this._runtime.IsDebugging() ? this._DebugForEach(a) : this._ForEach(a)
    },
    ForEachOrdered(a, b, d) {
        return this._runtime.IsDebugging() ? this._DebugForEachOrdered(a, d) : this._ForEachOrdered(a, d)
    },
    LayerVisible(a) {
        return a ? a.IsVisible() : !1
    },
    LayerInteractive(a) {
        return a ? a.IsSelfAndParentsInteractive() : !1
    },
    LayerEmpty(a) {
        return a ? !a.GetInstanceCount() : !1
    },
    LayerCmpOpacity(a, b, d) {
        return a ? C3$jscomp$177.compare(100 * a.GetOpacity(), b, d) : !1
    },
    OnImageLoadingComplete() {
        return !0
    },
    IsLoadingImages() {
        return 0 < this._imagesLoadingTotal
    },
    TemplateExists(a, b) {
        const d = this._runtime.GetTemplateManager();
        return d && b ? !!d.GetTemplateData(a, b) : !1
    }
};
const C3$jscomp$178 = self.C3;
function SortZOrderList$jscomp$1(a, b) {
    const d = a[0] - b[0];
    return 0 !== d ? d : a[1] - b[1]
}
function SortInstancesByValue(a, b) {
    return a[1] - b[1]
}
const tempZOrderList$jscomp$1 = []
  , tempInstValues = []
  , tempRect$jscomp$9 = C3$jscomp$178.New(C3$jscomp$178.Rect)
  , tempColor$jscomp$7 = C3$jscomp$178.New(C3$jscomp$178.Color);
C3$jscomp$178.Plugins.System.Acts = {
    SetVar(a, b) {
        a.SetValue(b)
    },
    AddVar(a, b) {
        a.IsNumber() && "number" !== typeof b && (b = parseFloat(b));
        a.SetValue(a.GetValue() + b)
    },
    SubVar(a, b) {
        a.IsNumber() && a.SetValue(a.GetValue() - b)
    },
    SetBoolVar(a, b) {
        a.SetValue(!!b)
    },
    ToggleBoolVar(a) {
        a.SetValue(!a.GetValue())
    },
    ResetGlobals() {
        this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue()
    },
    CreateObject(a, b, d, c, e, g) {
        if (a && b && (d = this._runtime.CreateInstance(a, b, d, c, e, g))) {
            e && b.SortAndAddInstancesByZIndex(d);
            b = this._runtime.GetEventSheetManager();
            b.BlockFlushingInstances(!0);
            d._TriggerOnCreatedOnSelfAndRelated();
            b.BlockFlushingInstances(!1);
            b = new Map;
            d.CollectInstancesToPick(b, a, e);
            for (const [k,l] of b)
                k.GetCurrentSol().SetSetPicked(l)
        }
    },
    CreateObjectByName(a, b, d, c, e, g) {
        a && b && (a = this._runtime.GetObjectClassByName(a)) && C3$jscomp$178.Plugins.System.Acts.CreateObject.call(this, a, b, d, c, e, g)
    },
    RecreateInitialObjects(a, b, d, c, e, g, k, l, n, p) {
        if (a) {
            var t = this._runtime.GetCurrentLayout();
            if (g && (t = this._runtime.GetLayoutManager().GetLayoutByName(g),
            !t))
                return;
            g = null;
            if ("number" !== typeof k || 0 <= k)
                if (g = t.GetLayer(k),
                !g)
                    return;
            tempRect$jscomp$9.set(b, d, c, e);
            b = t.RecreateInitialObjects(a, tempRect$jscomp$9, g, l, n, p);
            a.GetCurrentSol().SetArrayPicked(b);
            a.ApplySolToContainer()
        }
    },
    StopLoop() {
        const a = this._loopStack;
        a.IsInLoop() && a.GetCurrent().Stop()
    },
    SetGroupActive(a, b) {
        (a = this._runtime.GetEventSheetManager().GetEventGroupByName(a)) && (0 === b ? a.SetGroupActive(!1) : 1 === b ? a.SetGroupActive(!0) : a.SetGroupActive(!a.IsGroupActive()))
    },
    SetTimescale(a) {
        this._runtime.SetTimeScale(a)
    },
    SetObjectTimescale(a, b) {
        0 > b && (b = 0);
        if (a) {
            a = a.GetCurrentSol().GetInstances();
            for (const d of a)
                d.SetTimeScale(b)
        }
    },
    RestoreObjectTimescale(a) {
        if (a) {
            a = a.GetCurrentSol().GetInstances();
            for (const b of a)
                b.RestoreTimeScale()
        }
    },
    Wait(a) {
        if (!(0 > a))
            return this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(a),
            !0
    },
    WaitForSignal(a) {
        this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(a);
        return !0
    },
    WaitForPreviousActions() {
        const a = this._runtime.GetEventSheetManager();
        a.AddScheduledWait().InitPromise(a.GetPromiseForAllAsyncActions());
        return !0
    },
    Signal(a) {
        a = a.toLowerCase();
        this._signalTags.push(a);
        this._runtime.Trigger(C3$jscomp$178.Plugins.System.Cnds.OnSignal, null);
        this._signalTags.pop();
        for (const b of this._runtime.GetEventSheetManager().scheduledWaits())
            b.IsSignal() && b.GetSignalTag() === a && b.SetSignalled()
    },
    async SnapshotCanvas(a, b, d, c, e, g) {
        const k = this._runtime.GetCanvasManager();
        k && (this.UpdateRender(),
        await k.SnapshotCanvas(0 === a ? "image/png" : "image/jpeg", b / 100, d, c, e, g),
        await this._runtime.TriggerAsync(C3$jscomp$178.Plugins.System.Cnds.OnCanvasSnapshot, null))
    },
    SetCanvasSize(a, b) {
        if (!(0 >= a || 0 >= b)) {
            this._runtime.SetViewportSize(a, b);
            this._runtime.GetCurrentLayout().BoundScrolling();
            var d = this._runtime.GetCanvasManager();
            d && ("off" !== d.GetCurrentFullscreenMode() && this._runtime.SetOriginalViewportSize(a, b),
            d.SetSize(d.GetLastWidth(), d.GetLastHeight(), !0),
            this._runtime.UpdateRender())
        }
    },
    SetFullscreenQuality(a) {
        const b = this._runtime.GetCanvasManager();
        b && "off" !== b.GetCurrentFullscreenMode() && (b.SetFullscreenScalingQuality(0 !== a ? "high" : "low"),
        b.SetSize(b.GetLastWidth(), b.GetLastHeight(), !0))
    },
    SaveState(a) {
        this._runtime.SaveToSlot(a)
    },
    LoadState(a) {
        this._runtime.LoadFromSlot(a)
    },
    LoadStateJSON(a) {
        this._runtime.LoadFromJsonString(a)
    },
    SetHalfFramerateMode(a) {},
    ResetPersisted() {
        for (const a of this._runtime.GetLayoutManager().GetAllLayouts())
            a.ResetPersistData()
    },
    SetPixelRounding(a) {
        this._runtime.SetPixelRoundingEnabled(0 !== a)
    },
    SetMinimumFramerate(a) {
        this._runtime.SetMinimumFramerate(a)
    },
    SortZOrderByInstVar(a, b) {
        if (a) {
            var d = a.GetCurrentSol().GetInstances()
              , c = this._runtime.GetCurrentLayout()
              , e = a.IsFamily();
            a = a.GetFamilyIndex();
            for (let k = 0, l = d.length; k < l; ++k) {
                var g = d[k];
                const n = g.GetWorldInfo();
                if (!n)
                    continue;
                let p;
                p = e ? g.GetInstanceVariableValue(b + g.GetObjectClass().GetFamilyInstanceVariableOffset(a)) : g.GetInstanceVariableValue(b);
                tempZOrderList$jscomp$1.push([n.GetLayer().GetIndex(), n.GetZIndex()]);
                tempInstValues.push([g, p])
            }
            if (tempZOrderList$jscomp$1.length) {
                tempZOrderList$jscomp$1.sort(SortZOrderList$jscomp$1);
                tempInstValues.sort(SortInstancesByValue);
                b = !1;
                for (let k = 0, l = tempZOrderList$jscomp$1.length; k < l; ++k)
                    d = tempInstValues[k][0],
                    e = c.GetLayerByIndex(tempZOrderList$jscomp$1[k][0]),
                    a = tempZOrderList$jscomp$1[k][1],
                    g = e._GetInstances(),
                    g[a] !== d && (g[a] = d,
                    d.GetWorldInfo()._SetLayer(e, !0),
                    e.SetZIndicesChanged(),
                    b = !0);
                b && this._runtime.UpdateRender();
                C3$jscomp$178.clearArray(tempZOrderList$jscomp$1);
                C3$jscomp$178.clearArray(tempInstValues)
            }
        }
    },
    GoToLayout(a) {
        if (!this._runtime.IsLoading()) {
            var b = this._runtime.GetLayoutManager();
            b.IsPendingChangeMainLayout() || b.ChangeMainLayout(a)
        }
    },
    GoToLayoutByName(a) {
        if (!this._runtime.IsLoading()) {
            var b = this._runtime.GetLayoutManager();
            b.IsPendingChangeMainLayout() || (a = b.GetLayoutByName(a)) && b.ChangeMainLayout(a)
        }
    },
    NextPrevLayout(a) {
        if (!this._runtime.IsLoading()) {
            var b = this._runtime.GetLayoutManager();
            if (!b.IsPendingChangeMainLayout()) {
                var d = b.GetAllLayouts()
                  , c = d.indexOf(b.GetMainRunningLayout());
                a && 0 === c || (a || c !== d.length - 1) && b.ChangeMainLayout(d[c + (a ? -1 : 1)])
            }
        }
    },
    RestartLayout() {
        if (!this._runtime.IsLoading()) {
            var a = this._runtime.GetLayoutManager();
            a.IsPendingChangeMainLayout() || (a.ChangeMainLayout(a.GetMainRunningLayout()),
            this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation())
        }
    },
    SetLayerVisible(a, b) {
        a && a.SetVisible(b)
    },
    SetLayerInteractive(a, b) {
        a && a.SetInteractive(b)
    },
    SetLayerOpacity(a, b) {
        a && a.SetOpacity(b / 100)
    },
    SetLayerScale(a, b) {
        a && a.SetOwnScale(b)
    },
    SetLayerScaleRate(a, b) {
        a && a.SetScaleRate(b)
    },
    SetLayerAngle(a, b) {
        a && a.SetAngle(C3$jscomp$178.toRadians(+b))
    },
    SetLayerScroll(a, b, d) {
        a && (a.SetOwnScrollPositionEnabled(!0),
        a.SetScrollX(b),
        a.SetScrollY(d))
    },
    RestoreLayerScroll(a) {
        a && a.SetOwnScrollPositionEnabled(!1)
    },
    SetLayerParallax(a, b, d) {
        a && a.SetParallax(b / 100, d / 100)
    },
    SetLayerZElevation(a, b) {
        a && a.SetZElevation(+b)
    },
    SetLayerBackground(a, b) {
        a && (tempColor$jscomp$7.setFromRgbValue(b),
        tempColor$jscomp$7.clamp(),
        a = a.GetBackgroundColor(),
        a.equalsIgnoringAlpha(tempColor$jscomp$7) || (a.copyRgb(tempColor$jscomp$7),
        this.UpdateRender()))
    },
    SetLayerTransparent(a, b) {
        a && a.SetTransparent(b)
    },
    SetLayerBlendMode(a, b) {
        a && a.SetBlendMode(b)
    },
    SetLayerEffectEnabled(a, b, d) {
        a && (d = a.GetEffectList().GetEffectTypeByName(d)) && (b = 1 === b,
        d.IsActive() !== b && (d.SetActive(b),
        a.UpdateActiveEffects(),
        this._runtime.UpdateRender()))
    },
    SetLayerEffectParam(a, b, d, c) {
        if (a && (a = a.GetEffectList(),
        b = a.GetEffectTypeByName(b))) {
            d = Math.floor(d);
            var e = b.GetShaderProgram().GetParameterType(d);
            e && ("color" === e ? (tempColor$jscomp$7.setFromRgbValue(c),
            c = tempColor$jscomp$7) : "percent" === e && (c /= 100),
            a.SetEffectParameter(b.GetIndex(), d, c) && b.IsActive() && this._runtime.UpdateRender())
        }
    },
    SetLayerForceOwnTexture(a, b) {
        a && a.SetForceOwnTexture(b)
    },
    SetLayoutScale(a) {
        this._runtime.GetCurrentLayout().SetScale(+a)
    },
    SetLayoutAngle(a) {
        this._runtime.GetCurrentLayout().SetAngle(C3$jscomp$178.toRadians(+a))
    },
    SetLayoutEffectEnabled(a, b) {
        const d = this._runtime.GetCurrentLayout();
        if (b = d.GetEffectList().GetEffectTypeByName(b))
            a = 1 === a,
            b.IsActive() !== a && (b.SetActive(a),
            d.UpdateActiveEffects(),
            this._runtime.UpdateRender())
    },
    SetLayoutEffectParam(a, b, d) {
        const c = this._runtime.GetCurrentLayout().GetEffectList();
        if (a = c.GetEffectTypeByName(a)) {
            b = Math.floor(b);
            var e = a.GetShaderProgram().GetParameterType(b);
            e && ("color" === e ? (tempColor$jscomp$7.setFromRgbValue(d),
            d = tempColor$jscomp$7) : "percent" === e && (d /= 100),
            c.SetEffectParameter(a.GetIndex(), b, d) && a.IsActive() && this._runtime.UpdateRender())
        }
    },
    SetLayoutVanishingPoint(a, b) {
        this._runtime.GetCurrentLayout().SetVanishingPointXY(a / 100, b / 100)
    },
    SetLayoutProjection(a) {
        const b = this._runtime.GetCurrentLayout();
        0 === a ? b.SetPerspectiveProjection() : b.SetOrthographicProjection()
    },
    ScrollX(a) {
        this._runtime.GetCurrentLayout().SetScrollX(a)
    },
    ScrollY(a) {
        this._runtime.GetCurrentLayout().SetScrollY(a)
    },
    Scroll(a, b) {
        const d = this._runtime.GetCurrentLayout();
        d.SetScrollX(a);
        d.SetScrollY(b)
    },
    ScrollToObject(a) {
        if (a && (a = a.GetFirstPicked()) && (a = a.GetWorldInfo())) {
            var b = this._runtime.GetCurrentLayout();
            b.SetScrollX(a.GetX());
            b.SetScrollY(a.GetY())
        }
    },
    async LoadObjectTextures(a) {
        const b = this._runtime.GetMainRunningLayout();
        b && a && !this._runtime.IsLoading() && (a = a.IsFamily() ? a.GetFamilyMembers() : [a],
        await this._LoadTexturesForObjectClasses(b, a))
    },
    async LoadObjectTexturesByName(a) {
        await C3$jscomp$178.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(a))
    },
    UnloadObjectTextures(a) {
        const b = this._runtime.GetMainRunningLayout();
        b && a && (a = a.IsFamily() ? a.GetFamilyMembers() : [a],
        this._UnloadTexturesForObjectClasses(b, a))
    },
    UnloadObjectTexturesByName(a) {
        C3$jscomp$178.Plugins.System.Acts.UnloadObjectTextures.call(this, this._runtime.GetObjectClassByName(a))
    },
    UnloadUnusedTextures() {
        const a = this._runtime.GetMainRunningLayout();
        if (a) {
            var b = a._GetTextureLoadedObjectTypes();
            this._UnloadTexturesForObjectClasses(a, b)
        }
    },
    async LoadLayoutTextures(a) {
        const b = this._runtime.GetMainRunningLayout();
        a && b && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(b, a._GetInitialObjectClasses())
    },
    async LoadLayoutTexturesByName(a) {
        const b = this._runtime.GetMainRunningLayout();
        (a = this._runtime.GetLayoutManager().GetLayoutByName(a)) && b && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(b, a._GetInitialObjectClasses())
    },
    SetFunctionReturnValue(a) {
        const b = this._eventStack.GetCurrentExpFuncStackFrame();
        if (b)
            switch (b.GetFunctionReturnType()) {
            case 1:
                "number" === typeof a && b.SetFunctionReturnValue(a);
                break;
            case 2:
                "string" === typeof a && b.SetFunctionReturnValue(a);
                break;
            case 3:
                b.SetFunctionReturnValue(a)
            }
    },
    MapFunction(a, b, d) {
        var c = this._GetFunctionMap(a.toLowerCase(), !0);
        const e = c.strMap
          , g = b.toLowerCase();
        e.has(g) && console.warn(`[Construct] Function map '${a}' string '${b}' already in map; overwriting entry`);
        if (c = C3$jscomp$178.first(e.values()) || c.defaultFunc) {
            c = 0 !== c.GetReturnType();
            const k = 0 !== d.GetReturnType();
            if (c !== k) {
                console.error(`[Construct] Function map '${a}' string '${b}' function return type not compatible with other functions in the map; entry ignored`);
                return
            }
        }
        e.set(g, d)
    },
    MapFunctionDefault(a, b) {
        const d = this._GetFunctionMap(a.toLowerCase(), !0);
        d.defaultFunc && console.warn(`[Construct] Function map '${a}' already has a default; overwriting entry`);
        var c = C3$jscomp$178.first(d.strMap.values()) || d.defaultFunc;
        if (c) {
            c = 0 !== c.GetReturnType();
            const e = 0 !== b.GetReturnType();
            if (c !== e) {
                console.error(`[Construct] Function map '${a}' default: function return type not compatible with other functions in the map; entry ignored`);
                return
            }
        }
        d.defaultFunc = b
    },
    CallMappedFunction(a, b, d) {
        d = Math.floor(d);
        var c = this._GetFunctionMap(a.toLowerCase(), !1);
        if (c) {
            var e = c.strMap.get(b.toLowerCase());
            if (!e)
                if (c.defaultFunc)
                    e = c.defaultFunc,
                    d = 0;
                else {
                    console.warn(`[Construct] Call mapped function: no function associated with map '${a}' string '${b}'; call ignored (consider setting a default)`);
                    return
                }
            if (e.IsEnabled())
                if (0 !== e.GetReturnType())
                    console.warn(`[Construct] Call mapped function: map '${a}' string '${b}' has a return type so cannot be called`);
                else {
                    a = this._runtime;
                    b = a.GetEventSheetManager();
                    var g = b.GetCurrentEvent();
                    c = g.GetSolModifiersIncludingParents();
                    var k = 0 < c.length;
                    k && (e.IsCopyPicked() ? b.PushCopySol(c) : b.PushCleanSol(c));
                    var l = [];
                    if (g = b.FindFirstFunctionBlockParent(g)) {
                        g = g.GetFunctionParameters();
                        for (let n = d, p = g.length; n < p; ++n)
                            l.push(g[n].GetValue())
                    }
                    d = e.GetFunctionParameters();
                    for (let n = l.length, p = d.length; n < p; ++n)
                        l.push(d[n].GetInitialValue());
                    return a.IsDebugging() ? this._DebugDoCallMappedFunction(b, e, l, k, c) : this._DoCallMappedFunction(b, e, l, k, c)
                }
        } else
            console.warn(`[Construct] Call mapped function: map name '${a}' not found; call ignored`)
    }
};
const C3$jscomp$179 = self.C3;
C3$jscomp$179.Plugins.System.Exps = {
    int: function(a) {
        "string" === typeof a && (a = parseInt(a, 10),
        isNaN(a) && (a = 0));
        return Math.floor(a)
    },
    float: function(a) {
        "string" === typeof a && (a = parseFloat(a),
        isNaN(a) && (a = 0));
        return a
    },
    str(a) {
        return a.toString()
    },
    len(a) {
        return "string" === typeof a ? a.length : 0
    },
    random(a, b) {
        return "undefined" === typeof b ? this._runtime.Random() * a : this._runtime.Random() * (b - a) + a
    },
    choose(...a) {
        const b = Math.floor(this._runtime.Random() * a.length);
        return a[b]
    },
    chooseindex(a, ...b) {
        "number" !== typeof a && (a = 0);
        a = C3$jscomp$179.clamp(Math.floor(a), 0, b.length - 1);
        return b[a]
    },
    pi() {
        return Math.PI
    },
    infinity() {
        return Infinity
    },
    sqrt(a) {
        return Math.sqrt(a)
    },
    abs(a) {
        return Math.abs(a)
    },
    round(a) {
        return Math.round(a)
    },
    roundtodp(a, b) {
        b = Math.max(Math.floor(b), 0);
        b = Math.pow(10, b);
        return Math.round((a + Number.EPSILON) * b) / b
    },
    floor(a) {
        return Math.floor(a)
    },
    ceil(a) {
        return Math.ceil(a)
    },
    sign(a) {
        return Math.sign(a)
    },
    sin(a) {
        return Math.sin(C3$jscomp$179.toRadians(a))
    },
    cos(a) {
        return Math.cos(C3$jscomp$179.toRadians(a))
    },
    tan(a) {
        return Math.tan(C3$jscomp$179.toRadians(a))
    },
    asin(a) {
        return C3$jscomp$179.toDegrees(Math.asin(a))
    },
    acos(a) {
        return C3$jscomp$179.toDegrees(Math.acos(a))
    },
    atan(a) {
        return C3$jscomp$179.toDegrees(Math.atan(a))
    },
    exp(a) {
        return Math.exp(a)
    },
    ln(a) {
        return Math.log(a)
    },
    log10(a) {
        return Math.log(a) / Math.LN10
    },
    max(...a) {
        let b = a[0];
        "number" !== typeof b && (b = 0);
        for (let d = 1, c = a.length; d < c; ++d) {
            let e = a[d];
            "number" === typeof e && b < e && (b = e)
        }
        return b
    },
    min(...a) {
        let b = a[0];
        "number" !== typeof b && (b = 0);
        for (let d = 1, c = a.length; d < c; ++d) {
            let e = a[d];
            "number" === typeof e && b > e && (b = e)
        }
        return b
    },
    clamp(a, b, d) {
        return C3$jscomp$179.clamp(a, b, d)
    },
    distance(a, b, d, c) {
        return C3$jscomp$179.distanceTo(a, b, d, c)
    },
    angle(a, b, d, c) {
        return C3$jscomp$179.toDegrees(C3$jscomp$179.angleTo(a, b, d, c))
    },
    lerp(a, b, d) {
        return C3$jscomp$179.lerp(a, b, d)
    },
    unlerp(a, b, d) {
        return C3$jscomp$179.unlerp(a, b, d)
    },
    qarp(a, b, d, c) {
        return C3$jscomp$179.qarp(a, b, d, c)
    },
    cubic(a, b, d, c, e) {
        return C3$jscomp$179.cubic(a, b, d, c, e)
    },
    cosp(a, b, d) {
        return C3$jscomp$179.cosp(a, b, d)
    },
    anglediff(a, b) {
        return C3$jscomp$179.toDegrees(C3$jscomp$179.angleDiff(C3$jscomp$179.toRadians(a), C3$jscomp$179.toRadians(b)))
    },
    anglelerp(a, b, d) {
        return C3$jscomp$179.toDegrees(C3$jscomp$179.angleLerp(C3$jscomp$179.toRadians(a), C3$jscomp$179.toRadians(b), d))
    },
    anglerotate(a, b, d) {
        return C3$jscomp$179.toDegrees(C3$jscomp$179.angleRotate(C3$jscomp$179.toRadians(a), C3$jscomp$179.toRadians(b), C3$jscomp$179.toRadians(d)))
    },
    setbit(a, b, d) {
        b |= 0;
        return (a | 0) & ~(1 << b) | (0 !== d ? 1 : 0) << b
    },
    togglebit(a, b) {
        return (a | 0) ^ 1 << (b | 0)
    },
    getbit(a, b) {
        return (a | 0) & 1 << (b | 0) ? 1 : 0
    },
    newline() {
        return "\n"
    },
    uppercase(a) {
        return "string" === typeof a ? a.toUpperCase() : ""
    },
    lowercase(a) {
        return "string" === typeof a ? a.toLowerCase() : ""
    },
    left(a, b) {
        return "string" === typeof a ? a.substr(0, b) : ""
    },
    mid(a, b, d) {
        return "string" !== typeof a ? "" : 0 > d ? a.substr(b) : a.substr(b, d)
    },
    right(a, b) {
        return "string" === typeof a ? a.substr(Math.max(a.length - b, 0)) : ""
    },
    trim(a) {
        return "string" === typeof a ? a.trim() : ""
    },
    tokenat(a, b, d) {
        if ("string" !== typeof a || "string" !== typeof d)
            return "";
        a = a.split(d);
        b = Math.floor(b);
        return 0 > b || b >= a.length ? "" : a[b]
    },
    tokencount(a, b) {
        return "string" === typeof a && "string" === typeof b && a.length ? a.split(b).length : 0
    },
    find(a, b) {
        return "string" === typeof a && "string" === typeof b ? a.search(new RegExp(C3$jscomp$179.EscapeRegex(b),"i")) : -1
    },
    findcase(a, b) {
        return "string" === typeof a && "string" === typeof b ? a.search(new RegExp(C3$jscomp$179.EscapeRegex(b),"")) : -1
    },
    replace(a, b, d) {
        return "string" === typeof a && "string" === typeof b && "string" === typeof d ? a.replace(new RegExp(C3$jscomp$179.EscapeRegex(b),"gi"), d) : "string" === typeof a ? a : ""
    },
    regexsearch(a, b, d) {
        b = this.GetRegex(b, d);
        return a ? a.search(b) : -1
    },
    regexreplace(a, b, d, c) {
        b = this.GetRegex(b, d);
        return a ? a.replace(b, c) : ""
    },
    regexmatchcount(a, b, d) {
        return (a = this.GetRegexMatches(a.toString(), b, d)) ? a.length : 0
    },
    regexmatchat(a, b, d, c) {
        c = Math.floor(c);
        a = this.GetRegexMatches(a.toString(), b, d);
        return !a || 0 > c || c >= a.length ? "" : a[c]
    },
    zeropad(a, b) {
        let d = 0 > a ? "-" : "";
        0 > a && (a = -a);
        d += "0".repeat(Math.max(b - a.toString().length, 0));
        return d + a.toString()
    },
    urlencode(a) {
        return encodeURIComponent(a)
    },
    urldecode(a) {
        return decodeURIComponent(a)
    },
    dt() {
        return this._runtime._GetDtFast()
    },
    timescale() {
        return this._runtime.GetTimeScale()
    },
    wallclocktime() {
        return (Date.now() - this._runtime.GetStartTime()) / 1E3
    },
    unixtime() {
        return Date.now()
    },
    time() {
        return this._runtime.GetGameTime()
    },
    tickcount() {
        return this._runtime.GetTickCount()
    },
    objectcount() {
        return this._runtime.GetObjectCount()
    },
    fps() {
        return this._runtime.GetFPS()
    },
    cpuutilisation() {
        return this._runtime.GetMainThreadTime()
    },
    gpuutilisation() {
        return this._runtime.GetGPUUtilisation()
    },
    windowwidth() {
        return this._runtime.GetCanvasManager().GetDeviceWidth()
    },
    windowheight() {
        return this._runtime.GetCanvasManager().GetDeviceHeight()
    },
    originalwindowwidth() {
        return this._runtime.GetOriginalViewportWidth()
    },
    originalwindowheight() {
        return this._runtime.GetOriginalViewportHeight()
    },
    originalviewportwidth() {
        return this._runtime.GetOriginalViewportWidth()
    },
    originalviewportheight() {
        return this._runtime.GetOriginalViewportHeight()
    },
    scrollx() {
        return this._runtime.GetCurrentLayout().GetScrollX()
    },
    scrolly() {
        return this._runtime.GetCurrentLayout().GetScrollY()
    },
    layoutname() {
        return this._runtime.GetCurrentLayout().GetName()
    },
    layoutscale() {
        return this._runtime.GetCurrentLayout().GetScale()
    },
    layoutangle() {
        return C3$jscomp$179.toDegrees(this._runtime.GetCurrentLayout().GetAngle())
    },
    layoutwidth() {
        return this._runtime.GetCurrentLayout().GetWidth()
    },
    layoutheight() {
        return this._runtime.GetCurrentLayout().GetHeight()
    },
    vanishingpointx() {
        return 100 * this._runtime.GetCurrentLayout().GetVanishingPointX()
    },
    vanishingpointy() {
        return 100 * this._runtime.GetCurrentLayout().GetVanishingPointY()
    },
    viewportleft(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getLeft() : 0
    },
    viewporttop(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getTop() : 0
    },
    viewportright(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getRight() : 0
    },
    viewportbottom(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getBottom() : 0
    },
    viewportwidth(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().width() : 0
    },
    viewportheight(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().height() : 0
    },
    viewportmidx(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? (a = a.GetViewport3D(),
        (a.getLeft() + a.getRight()) / 2) : 0
    },
    viewportmidy(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? (a = a.GetViewport3D(),
        (a.getTop() + a.getBottom()) / 2) : 0
    },
    canvastolayerx(a, b, d) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.CanvasCssToLayer(b, d)[0] : 0
    },
    canvastolayery(a, b, d) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.CanvasCssToLayer(b, d)[1] : 0
    },
    layertocanvasx(a, b, d) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.LayerToCanvasCss(b, d)[0] : 0
    },
    layertocanvasy(a, b, d) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.LayerToCanvasCss(b, d)[1] : 0
    },
    layertolayerx(a, b, d, c) {
        const e = this._runtime.GetCurrentLayout();
        a = e.GetLayer(a);
        b = e.GetLayer(b);
        if (!a || !b || a === b)
            return d;
        const [g,k] = a.LayerToCanvasCss(d, c);
        return b.CanvasCssToLayer(g, k)[0]
    },
    layertolayery(a, b, d, c) {
        const e = this._runtime.GetCurrentLayout();
        a = e.GetLayer(a);
        b = e.GetLayer(b);
        if (!a || !b || a === b)
            return c;
        const [g,k] = a.LayerToCanvasCss(d, c);
        return b.CanvasCssToLayer(g, k)[1]
    },
    layerscale(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetOwnScale() : 0
    },
    layerangle(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? C3$jscomp$179.toDegrees(a.GetOwnAngle()) : 0
    },
    layeropacity(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? 100 * a.GetOpacity() : 0
    },
    layerscalerate(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScaleRate() : 0
    },
    layerscrollx(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScrollX() : 0
    },
    layerscrolly(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScrollY() : 0
    },
    layerparallaxx(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? 100 * a.GetParallaxX() : 0
    },
    layerparallaxy(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? 100 * a.GetParallaxY() : 0
    },
    layerzelevation(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetZElevation() : 0
    },
    layerindex(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetIndex() : -1
    },
    canvassnapshot() {
        const a = this._runtime.GetCanvasManager();
        return a ? a.GetCanvasSnapshotUrl() : ""
    },
    loopindex(a) {
        const b = this._loopStack;
        return b.IsInLoop() ? a ? (a = b.FindByName(a)) ? a.GetIndex() : 0 : b.GetCurrent().GetIndex() : 0
    },
    savestatejson() {
        return this._runtime.GetLastSaveJsonString()
    },
    callmapped(a, b, ...d) {
        var c = this._GetFunctionMap(a.toLowerCase(), !1);
        if (!c)
            return console.warn(`[Construct] Call mapped function: map name '${a}' not found; returning 0`),
            0;
        let e = c.strMap.get(b.toLowerCase());
        if (!e)
            if (c.defaultFunc)
                e = c.defaultFunc;
            else
                return console.warn(`[Construct] Call mapped function: no function associated with map '${a}' string '${b}'; returning 0 (consider setting a default)`),
                0;
        c = e.GetReturnType();
        const g = e.GetDefaultReturnValue();
        if (0 === c)
            return console.warn(`[Construct] Call mapped function: map '${a}' string '${b}' has no return type so cannot be called from an expression; returning 0`),
            0;
        if (!e.IsEnabled())
            return g;
        a = this._runtime.GetEventSheetManager();
        b = a.GetCurrentEvent().GetSolModifiersIncludingParents();
        const k = 0 < b.length;
        k && (e.IsCopyPicked() ? a.PushCopySol(b) : a.PushCleanSol(b));
        var l = e.GetFunctionParameters();
        for (let n = d.length, p = l.length; n < p; ++n)
            d.push(l[n].GetInitialValue());
        l = e.GetEventBlock();
        d = l.RunAsExpressionFunctionCall(l.GetSolModifiersIncludingParents(), e.IsCopyPicked(), c, g, ...d);
        k && a.PopSol(b);
        return d
    },
    loadingprogress() {
        return this._runtime.GetAssetManager().GetLoadProgress()
    },
    imageloadingprogress() {
        return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal
    },
    renderer() {
        return this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl"
    },
    rendererdetail() {
        return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetBasicAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
    },
    imagememoryusage() {
        let a = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();
        return Math.round(100 * a / 1048576) / 100
    },
    rgb(a, b, d) {
        return C3$jscomp$179.PackRGB(a, b, d)
    },
    rgbex(a, b, d) {
        return C3$jscomp$179.PackRGBEx(a / 100, b / 100, d / 100)
    },
    rgba(a, b, d, c) {
        return C3$jscomp$179.PackRGBAEx(a / 100, b / 100, d / 100, c / 100)
    },
    rgbex255(a, b, d) {
        return C3$jscomp$179.PackRGBEx(a / 255, b / 255, d / 255)
    },
    rgba255(a, b, d, c) {
        return C3$jscomp$179.PackRGBAEx(a / 255, b / 255, d / 255, c / 255)
    },
    projectname() {
        return this._runtime.GetProjectName()
    },
    projectversion() {
        return this._runtime.GetProjectVersion()
    },
    currenteventsheetname() {
        return this._runtime.GetCurrentEvent().GetEventSheet().GetName()
    },
    currenteventnumber() {
        return this._runtime.GetCurrentEvent().GetDisplayNumber()
    }
};
"use strict";
const C3$jscomp$180 = self.C3;
C3$jscomp$180.Plugins.Sprite = class extends C3$jscomp$180.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$181 = self.C3
  , spawnPickStack = [];
C3$jscomp$181.Plugins.Sprite.Type = class extends C3$jscomp$181.SDKTypeBase {
    constructor(a) {
        super(a);
        this._animations = a.GetAnimations()
    }
    Release() {
        C3$jscomp$181.clearArray(this._animations);
        super.Release()
    }
    OnCreate() {
        for (const a of this._animations)
            a.LoadAllAssets(this._runtime)
    }
    LoadTextures(a) {
        const b = {
            sampling: this._runtime.GetSampling()
        };
        return Promise.all(this._animations.map(d=>d.LoadAllTextures(a, b)))
    }
    ReleaseTextures() {
        for (const a of this._animations)
            a.ReleaseAllTextures()
    }
    OnDynamicTextureLoadComplete() {
        this._UpdateAllCurrentTexture()
    }
    _UpdateAllCurrentTexture() {
        for (const a of this._objectClass.instancesIncludingPendingCreate())
            a.GetSdkInstance()._UpdateCurrentTexture()
    }
    FinishCondition(a) {
        C3$jscomp$181.Plugins.Sprite.FinishCollisionCondition(this, a)
    }
    BeforeRunAction(a) {
        spawnPickStack.push({
            objectClass: null,
            createHierarchy: !1,
            instances: []
        })
    }
    _SpawnPickInstance(a, b, d) {
        const c = spawnPickStack.at(-1);
        c.objectClass = a;
        c.createHierarchy = d;
        c.instances.push(b)
    }
    AfterRunAction(a) {
        a = spawnPickStack.pop();
        const b = a.objectClass
          , d = a.createHierarchy;
        if (b) {
            var c = new Map;
            for (const e of a.instances)
                e.CollectInstancesToPick(c, b, d);
            for (const [e,g] of c)
                e.GetCurrentSol().SetSetPicked(g)
        }
    }
}
;
const C3$jscomp$182 = self.C3
  , C3X$jscomp$18 = self.C3X
  , tempRect$jscomp$10 = C3$jscomp$182.New(C3$jscomp$182.Rect)
  , tempQuad$jscomp$6 = C3$jscomp$182.New(C3$jscomp$182.Quad)
  , tempVec2$jscomp$1 = C3$jscomp$182.New(C3$jscomp$182.Vector2)
  , FLAG_PLAYING_FORWARDS = 1
  , FLAG_ANIMATION_PLAYING = 2
  , FLAG_ANIMATION_TRIGGER = 4;
C3$jscomp$182.Plugins.Sprite.Instance = class extends C3$jscomp$182.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        let d = !0
          , c = ""
          , e = 0
          , g = !0;
        b && (d = !!b[0],
        c = b[1],
        e = b[2],
        g = b[3]);
        this._currentAnimation = this._objectClass.GetAnimationByName(c) || this._objectClass.GetAnimations()[0];
        this._currentFrameIndex = C3$jscomp$182.clamp(e, 0, this._currentAnimation.GetFrameCount() - 1);
        this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        b = this._currentAnimationFrame.GetImageInfo();
        this._currentTexture = b.GetTexture();
        this._currentRcTex = b.GetTexRect();
        this._currentQuadTex = b.GetTexQuad();
        this.HandleRendererContextLoss();
        a.SetFlag(FLAG_ANIMATION_PLAYING, !0);
        a.SetFlag(FLAG_PLAYING_FORWARDS, 0 <= this._currentAnimation.GetSpeed());
        this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed());
        this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo();
        this._animationTimer = C3$jscomp$182.New(C3$jscomp$182.KahanSum);
        this._animationRepeats = this._frameStartTime = 0;
        this._animTriggerName = "";
        this._changeAnimFrameIndex = -1;
        this._changeAnimationName = "";
        this._changeAnimationFrom = 0;
        a = this.GetWorldInfo();
        this._bquadRef = a.GetBoundingQuad();
        a.SetVisible(d);
        a.SetCollisionEnabled(g);
        a.SetOriginX(this._currentAnimationFrame.GetOriginX());
        a.SetOriginY(this._currentAnimationFrame.GetOriginY());
        a.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly());
        a.SetBboxChanged();
        1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking()
    }
    Release() {
        this._animationTimer = this._currentTexture = this._currentAnimationFrame = this._currentAnimation = null;
        super.Release()
    }
    GetCurrentImageInfo() {
        return this._currentAnimationFrame.GetImageInfo()
    }
    IsOriginalSizeKnown() {
        return !0
    }
    OnRendererContextLost() {
        this._currentTexture = null
    }
    OnRendererContextRestored() {
        this._UpdateCurrentTexture()
    }
    Draw(a) {
        var b = this._currentTexture;
        null !== b && (a.SetTexture(b),
        b = this.GetWorldInfo(),
        b.HasMesh() ? this._DrawMesh(b, a) : this._DrawStandard(b, a))
    }
    _DrawStandard(a, b) {
        let d = this._bquadRef;
        this._runtime.IsPixelRoundingEnabled() && (d = a.PixelRoundQuad(d));
        b.Quad4(d, this._currentQuadTex)
    }
    _DrawMesh(a, b) {
        const d = a.GetTransformedMesh();
        if (a.IsMeshChanged()) {
            a.CalculateBbox(tempRect$jscomp$10, tempQuad$jscomp$6, !1);
            let c = tempQuad$jscomp$6;
            this._runtime.IsPixelRoundingEnabled() && (c = a.PixelRoundQuad(c));
            d.CalculateTransformedMesh(a.GetSourceMesh(), c, this._currentQuadTex);
            a.SetMeshChanged(!1)
        }
        d.Draw(b)
    }
    GetAnimationTime() {
        return this._animationTimer.Get()
    }
    IsAnimationPlaying() {
        return this._inst.GetFlag(FLAG_ANIMATION_PLAYING)
    }
    SetAnimationPlaying(a) {
        this._inst.SetFlag(FLAG_ANIMATION_PLAYING, a)
    }
    IsPlayingForwards() {
        return this._inst.GetFlag(FLAG_PLAYING_FORWARDS)
    }
    SetPlayingForwards(a) {
        this._inst.SetFlag(FLAG_PLAYING_FORWARDS, a)
    }
    IsInAnimationTrigger() {
        return this._inst.GetFlag(FLAG_ANIMATION_TRIGGER)
    }
    SetInAnimationTrigger(a) {
        this._inst.SetFlag(FLAG_ANIMATION_TRIGGER, a)
    }
    Tick() {
        this._changeAnimationName && this._DoChangeAnimation();
        0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame();
        const a = this._currentAnimationSpeed;
        if (this.IsAnimationPlaying() && 0 !== a) {
            var b = this._runtime.GetDt(this._inst);
            this._animationTimer.Add(b);
            b = this.GetAnimationTime();
            var d = this._currentAnimationFrame
              , c = d.GetDuration() / a;
            if (!(b < this._frameStartTime + c)) {
                var e = this._currentAnimation
                  , g = this._currentAnimationRepeatTo
                  , k = e.GetFrameCount()
                  , l = e.GetRepeatCount()
                  , n = e.IsLooping()
                  , p = e.IsPingPong();
                this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--;
                this._frameStartTime += c;
                this._currentFrameIndex >= k && (p ? (this.SetPlayingForwards(!1),
                this._currentFrameIndex = k - 2) : n ? this._currentFrameIndex = g : (this._animationRepeats++,
                this._animationRepeats >= l ? this._FinishAnimation(!1) : this._currentFrameIndex = g));
                0 > this._currentFrameIndex && (p ? (this._currentFrameIndex = 1,
                this.SetPlayingForwards(!0),
                n || (this._animationRepeats++,
                this._animationRepeats >= l && this._FinishAnimation(!0))) : n ? this._currentFrameIndex = g : (this._animationRepeats++,
                this._animationRepeats >= l ? this._FinishAnimation(!0) : this._currentFrameIndex = g));
                this._currentFrameIndex = C3$jscomp$182.clamp(this._currentFrameIndex, 0, k - 1);
                c = e.GetFrameAt(this._currentFrameIndex);
                b > this._frameStartTime + c.GetDuration() / a && (this._frameStartTime = b);
                this._OnFrameChanged(d, c)
            }
        } else
            this._StopTicking()
    }
    _FinishAnimation(a) {
        this._currentFrameIndex = a ? 0 : this._currentAnimation.GetFrameCount() - 1;
        this.SetAnimationPlaying(!1);
        this._animTriggerName = this._currentAnimation.GetName();
        this.SetInAnimationTrigger(!0);
        this.DispatchScriptEvent("animationend", !1, {
            animationName: this._animTriggerName
        });
        this.Trigger(C3$jscomp$182.Plugins.Sprite.Cnds.OnAnyAnimFinished);
        this.Trigger(C3$jscomp$182.Plugins.Sprite.Cnds.OnAnimFinished);
        this.SetInAnimationTrigger(!1);
        this._animationRepeats = 0
    }
    _OnFrameChanged(a, b) {
        if (a !== b) {
            var d = this.GetWorldInfo()
              , c = a.GetImageInfo()
              , e = b.GetImageInfo()
              , g = c.GetWidth();
            c = c.GetHeight();
            var k = e.GetWidth()
              , l = e.GetHeight();
            g !== k && d.SetWidth(d.GetWidth() * (k / g));
            c !== l && d.SetHeight(d.GetHeight() * (l / c));
            d.SetOriginX(b.GetOriginX());
            d.SetOriginY(b.GetOriginY());
            d.SetSourceCollisionPoly(b.GetCollisionPoly());
            d.SetBboxChanged();
            this._currentAnimationFrame = b;
            this._currentTexture = e.GetTexture();
            this._currentRcTex = e.GetTexRect();
            this._currentQuadTex = e.GetTexQuad();
            d = this.GetInstance().GetBehaviorInstances();
            for (let n = 0, p = d.length; n < p; ++n)
                d[n].OnSpriteFrameChanged(a, b);
            this.DispatchScriptEvent("framechange", !1, {
                animationName: this._currentAnimation.GetName(),
                animationFrame: this._currentFrameIndex
            });
            this.Trigger(C3$jscomp$182.Plugins.Sprite.Cnds.OnFrameChanged);
            this._runtime.UpdateRender()
        }
    }
    _StartAnim(a) {
        this.SetAnimationPlaying(!0);
        this._frameStartTime = this.GetAnimationTime();
        1 === a && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0,
        this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
        this._StartTicking()
    }
    _SetAnim(a, b) {
        this._changeAnimationName = a;
        this._changeAnimationFrom = b;
        this._StartTicking();
        this.IsInAnimationTrigger() || this._DoChangeAnimation()
    }
    _GetCurrentAnimation() {
        return this._currentAnimation
    }
    _GetCurrentAnimationName() {
        return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName()
    }
    _SetAnimFrame(a) {
        isFinite(a) && (this._changeAnimFrameIndex = a,
        this.IsInAnimationTrigger() || this._DoChangeAnimFrame())
    }
    _GetAnimFrame() {
        return this._currentFrameIndex
    }
    _SetAnimSpeed(a) {
        this._currentAnimationSpeed = Math.abs(a);
        this.SetPlayingForwards(0 <= a);
        0 < this._currentAnimationSpeed && this._StartTicking()
    }
    _GetAnimSpeed() {
        return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed
    }
    _SetAnimRepeatToFrame(a) {
        this._currentAnimationRepeatTo = a = C3$jscomp$182.clamp(Math.floor(a), 0, this._currentAnimation.GetFrameCount() - 1)
    }
    _GetAnimRepeatToFrame() {
        return this._currentAnimationRepeatTo
    }
    _DoChangeAnimation() {
        const a = this._currentAnimationFrame;
        var b = this._objectClass.GetAnimationByName(this._changeAnimationName);
        this._changeAnimationName = "";
        !b || b === this._currentAnimation && this.IsAnimationPlaying() || (this._currentAnimation = b,
        this.SetPlayingForwards(0 <= b.GetSpeed()),
        this._currentAnimationSpeed = Math.abs(b.GetSpeed()),
        this._currentAnimationRepeatTo = b.GetRepeatTo(),
        this._currentFrameIndex = C3$jscomp$182.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1),
        1 === this._changeAnimationFrom && (this._currentFrameIndex = 0),
        this.SetAnimationPlaying(!0),
        this._frameStartTime = this.GetAnimationTime(),
        b = this._currentAnimation.GetFrameAt(this._currentFrameIndex),
        this._OnFrameChanged(a, b))
    }
    _DoChangeAnimFrame() {
        const a = this._currentAnimationFrame;
        var b = this._currentFrameIndex;
        this._currentFrameIndex = C3$jscomp$182.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1);
        this._changeAnimFrameIndex = -1;
        b !== this._currentFrameIndex && (b = this._currentAnimation.GetFrameAt(this._currentFrameIndex),
        this._OnFrameChanged(a, b),
        this._frameStartTime = this.GetAnimationTime())
    }
    _UpdateCurrentTexture() {
        const a = this._currentAnimationFrame.GetImageInfo();
        this._currentTexture = a.GetTexture();
        this._currentRcTex = a.GetTexRect();
        this._currentQuadTex = a.GetTexQuad();
        this.GetWorldInfo().SetMeshChanged(!0)
    }
    GetTexture() {
        return this._currentTexture
    }
    GetTexRect() {
        return this._currentRcTex
    }
    GetTexQuad() {
        return this._currentQuadTex
    }
    GetImagePointCount() {
        return this._currentAnimationFrame.GetImagePointCount()
    }
    GetImagePoint(a) {
        const b = this._currentAnimationFrame
          , d = this.GetWorldInfo();
        if ("string" === typeof a)
            a = b.GetImagePointByName(a);
        else if ("number" === typeof a)
            a = b.GetImagePointByIndex(a - 1);
        else
            throw new TypeError("expected string or number");
        if (!a)
            return [d.GetX(), d.GetY()];
        tempVec2$jscomp$1.copy(a.GetVec2());
        if (d.HasMesh()) {
            const [c,e] = d.GetSourceMesh().TransformPoint(tempVec2$jscomp$1.getX(), tempVec2$jscomp$1.getY());
            tempVec2$jscomp$1.set(c, e)
        }
        tempVec2$jscomp$1.offset(-b.GetOriginX(), -b.GetOriginY());
        tempVec2$jscomp$1.scale(d.GetWidth(), d.GetHeight());
        tempVec2$jscomp$1.rotate(d.GetAngle());
        tempVec2$jscomp$1.offset(d.GetX(), d.GetY());
        return [tempVec2$jscomp$1.getX(), tempVec2$jscomp$1.getY()]
    }
    GetCollisionPolyPointCount() {
        return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount()
    }
    GetCollisionPolyPoint(a) {
        a = Math.floor(a);
        const b = this.GetWorldInfo();
        var d = b.GetTransformedCollisionPoly();
        const c = d.pointCount();
        a === c && (a = 0);
        if (0 > a || a >= c)
            return [0, 0];
        d = d.pointsArr();
        return [d[2 * a] + b.GetX(), d[2 * a + 1] + b.GetY()]
    }
    GetDebuggerProperties() {
        const a = C3$jscomp$182.Plugins.Sprite.Acts;
        return [{
            title: "plugins.sprite.debugger.animation-properties.title",
            properties: [{
                name: "plugins.sprite.debugger.animation-properties.current-animation",
                value: this._currentAnimation.GetName(),
                onedit: b=>this.CallAction(a.SetAnim, b, 0)
            }, {
                name: "plugins.sprite.debugger.animation-properties.current-frame",
                value: this._currentFrameIndex,
                onedit: b=>this.CallAction(a.SetAnimFrame, b)
            }, {
                name: "plugins.sprite.debugger.animation-properties.is-playing",
                value: this.IsAnimationPlaying(),
                onedit: b=>b ? this.CallAction(a.StartAnim, 0) : this.CallAction(a.StopAnim)
            }, {
                name: "plugins.sprite.debugger.animation-properties.speed",
                value: this._currentAnimationSpeed,
                onedit: b=>this.CallAction(a.SetAnimSpeed, b)
            }, {
                name: "plugins.sprite.debugger.animation-properties.repeats",
                value: this._animationRepeats,
                onedit: b=>this._animationRepeats = b
            }]
        }]
    }
    SaveToJson() {
        const a = {
            a: this._currentAnimation.GetSID()
        };
        0 !== this._frameStartTime && (a.fs = this._frameStartTime);
        var b = this.GetAnimationTime();
        0 !== b && (a.at = b);
        0 !== this._currentFrameIndex && (a.f = this._currentFrameIndex);
        0 !== this._currentAnimationSpeed && (a.cas = this._currentAnimationSpeed);
        1 !== this._animationRepeats && (a.ar = this._animationRepeats);
        0 !== this._currentAnimationRepeatTo && (a.rt = this._currentAnimationRepeatTo);
        this.IsAnimationPlaying() || (a.ap = this.IsAnimationPlaying());
        this.IsPlayingForwards() || (a.af = this.IsPlayingForwards());
        b = this.GetWorldInfo();
        b.IsCollisionEnabled() && (a.ce = b.IsCollisionEnabled());
        return a
    }
    LoadFromJson(a) {
        var b = this.GetObjectClass().GetAnimationBySID(a.a);
        b && (this._currentAnimation = b);
        this._frameStartTime = a.hasOwnProperty("fs") ? a.fs : 0;
        this._animationTimer.Set(a.hasOwnProperty("at") ? a.at : 0);
        b = a.hasOwnProperty("f") ? a.f : 0;
        this._currentFrameIndex = C3$jscomp$182.clamp(b, 0, this._currentAnimation.GetFrameCount() - 1);
        this._currentAnimationSpeed = a.hasOwnProperty("cas") ? a.cas : 0;
        this._animationRepeats = a.hasOwnProperty("ar") ? a.ar : 1;
        b = a.hasOwnProperty("rt") ? a.rt : 0;
        this._currentAnimationRepeatTo = C3$jscomp$182.clamp(b, 0, this._currentAnimation.GetFrameCount() - 1);
        this.SetAnimationPlaying(a.hasOwnProperty("ap") ? !!a.ap : !0);
        this.SetPlayingForwards(a.hasOwnProperty("af") ? !!a.af : !0);
        this._currentAnimationFrame = b = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        this._UpdateCurrentTexture();
        const d = this.GetWorldInfo();
        d.SetOriginX(b.GetOriginX());
        d.SetOriginY(b.GetOriginY());
        d.SetSourceCollisionPoly(b.GetCollisionPoly());
        d.SetCollisionEnabled(!!a.ce);
        this.IsAnimationPlaying() && this._StartTicking()
    }
    GetPropertyValueByIndex(a) {
        const b = this.GetWorldInfo();
        switch (a) {
        case 3:
            return b.IsCollisionEnabled();
        case 2:
            return C3$jscomp$182.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1);
        case 1:
            return this._currentAnimation.GetName()
        }
    }
    SetPropertyValueByIndex(a, b) {
        var d = this.GetWorldInfo();
        switch (a) {
        case 3:
            d.SetCollisionEnabled(!!b);
            break;
        case 2:
            this.SetAnimationPlaying(!1);
            a = this._currentAnimation.GetFrameCount() - 1;
            d = b = C3$jscomp$182.clamp(b, 0, a);
            b = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            const c = this._currentAnimation.GetFrameAt(d);
            this._OnFrameChanged(b, c);
            this._currentFrameIndex = C3$jscomp$182.clamp(d, 0, a);
            break;
        case 1:
            this._changeAnimationName = b,
            this._DoChangeAnimation()
        }
    }
    GetScriptInterfaceClass() {
        return self.ISpriteInstance
    }
}
;
const map$jscomp$19 = new WeakMap
  , ANIM_FROM_MODES = new Map([["current-frame", 0], ["beginning", 1]]);
self.ISpriteInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$19.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    getImagePointCount() {
        return map$jscomp$19.get(this).GetImagePointCount()
    }
    getImagePointX(a) {
        if ("string" !== typeof a && "number" !== typeof a)
            throw new TypeError("expected string or number");
        return map$jscomp$19.get(this).GetImagePoint(a)[0]
    }
    getImagePointY(a) {
        if ("string" !== typeof a && "number" !== typeof a)
            throw new TypeError("expected string or number");
        return map$jscomp$19.get(this).GetImagePoint(a)[1]
    }
    getImagePoint(a) {
        if ("string" !== typeof a && "number" !== typeof a)
            throw new TypeError("expected string or number");
        return map$jscomp$19.get(this).GetImagePoint(a)
    }
    getPolyPointCount() {
        return map$jscomp$19.get(this).GetCollisionPolyPointCount()
    }
    getPolyPointX(a) {
        C3X$jscomp$18.RequireFiniteNumber(a);
        return map$jscomp$19.get(this).GetCollisionPolyPoint(a)[0]
    }
    getPolyPointY(a) {
        C3X$jscomp$18.RequireFiniteNumber(a);
        return map$jscomp$19.get(this).GetCollisionPolyPoint(a)[1]
    }
    getPolyPoint(a) {
        C3X$jscomp$18.RequireFiniteNumber(a);
        return map$jscomp$19.get(this).GetCollisionPolyPoint(a)
    }
    stopAnimation() {
        map$jscomp$19.get(this).SetAnimationPlaying(!1)
    }
    startAnimation(a="current-frame") {
        C3X$jscomp$18.RequireString(a);
        a = ANIM_FROM_MODES.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$19.get(this)._StartAnim(a)
    }
    setAnimation(a, b="beginning") {
        C3X$jscomp$18.RequireString(a);
        C3X$jscomp$18.RequireString(b);
        b = ANIM_FROM_MODES.get(b);
        if ("undefined" === typeof b)
            throw Error("invalid mode");
        const d = map$jscomp$19.get(this);
        if (!d.GetObjectClass().GetAnimationByName(a))
            throw Error(`animation name "${a}" does not exist`);
        d._SetAnim(a, b)
    }
    getAnimation(a) {
        C3X$jscomp$18.RequireString(a);
        return (a = map$jscomp$19.get(this).GetObjectClass().GetAnimationByName(a)) ? a.GetIAnimation() : null
    }
    get animation() {
        return map$jscomp$19.get(this)._GetCurrentAnimation().GetIAnimation()
    }
    get animationName() {
        return map$jscomp$19.get(this)._GetCurrentAnimationName()
    }
    set animationFrame(a) {
        C3X$jscomp$18.RequireFiniteNumber(a);
        map$jscomp$19.get(this)._SetAnimFrame(a)
    }
    get animationFrame() {
        return map$jscomp$19.get(this)._GetAnimFrame()
    }
    set animationSpeed(a) {
        C3X$jscomp$18.RequireFiniteNumber(a);
        map$jscomp$19.get(this)._SetAnimSpeed(a)
    }
    get animationSpeed() {
        return map$jscomp$19.get(this)._GetAnimSpeed()
    }
    set animationRepeatToFrame(a) {
        C3X$jscomp$18.RequireFiniteNumber(a);
        map$jscomp$19.get(this)._SetAnimRepeatToFrame(a)
    }
    get animationRepeatToFrame() {
        return map$jscomp$19.get(this)._GetAnimRepeatToFrame()
    }
    get imageWidth() {
        return map$jscomp$19.get(this).GetCurrentImageInfo().GetWidth()
    }
    get imageHeight() {
        return map$jscomp$19.get(this).GetCurrentImageInfo().GetHeight()
    }
    getImageSize() {
        const a = map$jscomp$19.get(this).GetCurrentImageInfo();
        return [a.GetWidth(), a.GetHeight()]
    }
    setSolidCollisionFilter(a, b) {
        C3X$jscomp$18.RequireString(b);
        map$jscomp$19.get(this).GetWorldInfo().SetSolidCollisionFilter(!!a, b)
    }
}
;
const C3$jscomp$183 = self.C3;
C3$jscomp$183.Plugins.Sprite.Cnds = {
    IsAnimPlaying(a) {
        return C3$jscomp$183.equalsNoCase(this._GetCurrentAnimationName(), a)
    },
    CompareFrame(a, b) {
        return C3$jscomp$183.compare(this._currentFrameIndex, a, b)
    },
    CompareAnimSpeed(a, b) {
        return C3$jscomp$183.compare(this._GetAnimSpeed(), a, b)
    },
    OnAnimFinished(a) {
        return C3$jscomp$183.equalsNoCase(this._animTriggerName, a)
    },
    OnAnyAnimFinished() {
        return !0
    },
    OnFrameChanged() {
        return !0
    },
    IsMirrored() {
        return 0 > this.GetWorldInfo().GetWidth()
    },
    IsFlipped() {
        return 0 > this.GetWorldInfo().GetHeight()
    },
    OnURLLoaded() {
        return !0
    },
    OnURLFailed() {
        return !0
    },
    IsCollisionEnabled() {
        return this.GetWorldInfo().IsCollisionEnabled()
    }
};
const C3$jscomp$184 = self.C3;
C3$jscomp$184.Plugins.Sprite.Acts = {
    Spawn(a, b, d, c) {
        if (a && b) {
            var [e,g] = this.GetImagePoint(d);
            if (d = this._runtime.CreateInstance(a, b, e, g, c))
                c && b.SortAndAddInstancesByZIndex(d),
                a.GetPlugin().IsRotatable() && (b = d.GetWorldInfo(),
                b.SetAngle(this.GetWorldInfo().GetAngle()),
                b.SetBboxChanged()),
                b = this._runtime.GetEventSheetManager(),
                b.BlockFlushingInstances(!0),
                d._TriggerOnCreatedOnSelfAndRelated(),
                b.BlockFlushingInstances(!1),
                a !== this.GetObjectClass() && this._sdkType._SpawnPickInstance(a, d, c)
        }
    },
    StopAnim() {
        this.SetAnimationPlaying(!1)
    },
    StartAnim(a) {
        this._StartAnim(a)
    },
    SetAnim(a, b) {
        this._SetAnim(a, b)
    },
    SetAnimFrame(a) {
        this._SetAnimFrame(a)
    },
    SetAnimSpeed(a) {
        this._SetAnimSpeed(a)
    },
    SetAnimRepeatToFrame(a) {
        this._SetAnimRepeatToFrame(a)
    },
    SetMirrored(a) {
        const b = this.GetWorldInfo()
          , d = b.GetWidth();
        a = Math.abs(d) * (0 === a ? -1 : 1);
        d !== a && (b.SetWidth(a),
        b.SetBboxChanged())
    },
    SetFlipped(a) {
        const b = this.GetWorldInfo()
          , d = b.GetHeight();
        a = Math.abs(d) * (0 === a ? -1 : 1);
        d !== a && (b.SetHeight(a),
        b.SetBboxChanged())
    },
    SetScale(a) {
        const b = this._currentAnimationFrame.GetImageInfo()
          , d = this.GetWorldInfo();
        var c = 0 > d.GetWidth() ? -1 : 1;
        const e = 0 > d.GetHeight() ? -1 : 1;
        c *= b.GetWidth() * a;
        a = b.GetHeight() * a * e;
        if (d.GetWidth() !== c || d.GetHeight() !== a)
            d.SetSize(c, a),
            d.SetBboxChanged()
    },
    async LoadURL(a, b, d) {
        d = this._currentAnimationFrame.GetImageInfo();
        const c = this.GetWorldInfo()
          , e = this._runtime
          , g = this._sdkType;
        if (d.GetURL() === a)
            0 === b && (c.SetSize(d.GetWidth(), d.GetHeight()),
            c.SetBboxChanged()),
            this.Trigger(C3$jscomp$184.Plugins.Sprite.Cnds.OnURLLoaded);
        else {
            var k = C3$jscomp$184.New(C3$jscomp$184.ImageInfo);
            try {
                await k.LoadDynamicAsset(e, a);
                if (!k.IsLoaded())
                    throw Error("image failed to load");
                if (this.WasReleased()) {
                    k.Release();
                    return
                }
                await k.LoadStaticTexture(e.GetRenderer(), {
                    sampling: e.GetSampling()
                })
            } catch (l) {
                console.error("Load image from URL failed: ", l);
                this.WasReleased() || this.Trigger(C3$jscomp$184.Plugins.Sprite.Cnds.OnURLFailed);
                return
            }
            this.WasReleased() ? k.Release() : (d.ReplaceWith(k),
            g._UpdateAllCurrentTexture(),
            e.UpdateRender(),
            0 === b && (c.SetSize(d.GetWidth(), d.GetHeight()),
            c.SetBboxChanged()),
            await this.TriggerAsync(C3$jscomp$184.Plugins.Sprite.Cnds.OnURLLoaded))
        }
    },
    SetCollisions(a) {
        this.GetWorldInfo().SetCollisionEnabled(a)
    },
    SetSolidCollisionFilter(a, b) {
        this.GetWorldInfo().SetSolidCollisionFilter(0 === a, b)
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    }
};
self.C3.Plugins.Sprite.Exps = {
    AnimationFrame() {
        return this._currentFrameIndex
    },
    AnimationFrameCount() {
        return this._currentAnimation.GetFrameCount()
    },
    AnimationName() {
        return this._currentAnimation.GetName()
    },
    AnimationSpeed() {
        return this._GetAnimSpeed()
    },
    OriginalAnimationSpeed() {
        return this._currentAnimation.GetSpeed()
    },
    ImagePointX(a) {
        return this.GetImagePoint(a)[0]
    },
    ImagePointY(a) {
        return this.GetImagePoint(a)[1]
    },
    ImagePointCount() {
        return this.GetImagePointCount()
    },
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    },
    PolyPointXAt(a) {
        return this.GetCollisionPolyPoint(a)[0]
    },
    PolyPointYAt(a) {
        return this.GetCollisionPolyPoint(a)[1]
    },
    PolyPointCount() {
        return this.GetCollisionPolyPointCount()
    }
};
"use strict";
const C3$jscomp$186 = self.C3;
C3$jscomp$186.Plugins.Text = class extends C3$jscomp$186.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$187 = self.C3;
C3$jscomp$187.Plugins.Text.Type = class extends C3$jscomp$187.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    LoadTextures(a) {}
    ReleaseTextures() {}
}
;
const C3$jscomp$188 = self.C3
  , C3X$jscomp$19 = self.C3X
  , TEMP_COLOR_ARRAY$jscomp$1 = [0, 0, 0]
  , HORIZONTAL_ALIGNMENTS = ["left", "center", "right"]
  , VERTICAL_ALIGNMENTS = ["top", "center", "bottom"]
  , tempRect$jscomp$11 = new C3$jscomp$188.Rect
  , tempQuad$jscomp$7 = new C3$jscomp$188.Quad
  , tempColor$jscomp$8 = new C3$jscomp$188.Color;
C3$jscomp$188.Plugins.Text.Instance = class extends C3$jscomp$188.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this._text = "";
        this._enableBBcode = !0;
        this._faceName = "Arial";
        this._ptSize = 12;
        this._lineHeightOffset = 0;
        this._isItalic = this._isBold = !1;
        this._color = C3$jscomp$188.New(C3$jscomp$188.Color);
        this._verticalAlign = this._horizontalAlign = 0;
        this._wrapByWord = !0;
        this._readAloud = !1;
        this._screenReaderText = null;
        this._typewriterEndTime = this._typewriterStartTime = -1;
        this._typewriterLength = 0;
        this._rendererText = C3$jscomp$188.New(C3$jscomp$188.Gfx.RendererText, this._runtime.GetRenderer(), {
            timeout: 5
        });
        this._rendererText.ontextureupdate = ()=>this._runtime.UpdateRender();
        this._rendererText.SetIsAsync(!1);
        b && (this._text = b[0],
        this._enableBBcode = !!b[1],
        this._faceName = b[2],
        this._ptSize = b[3],
        this._lineHeightOffset = b[4],
        this._isBold = !!b[5],
        this._isItalic = !!b[6],
        this._horizontalAlign = b[8],
        this._verticalAlign = b[9],
        this._wrapByWord = 0 === b[10],
        a = b[7],
        this._color.setRgb(a[0], a[1], a[2]),
        this.GetWorldInfo().SetVisible(b[11]),
        this._readAloud = !!b[13]);
        this._UpdateTextSettings();
        this._UpdateScreenReaderText()
    }
    Release() {
        this._CancelTypewriter();
        this._screenReaderText && (this._screenReaderText.Release(),
        this._screenReaderText = null);
        this._rendererText.Release();
        this._rendererText = null;
        super.Release()
    }
    _UpdateTextSettings() {
        const a = this._rendererText;
        a.SetText(this._text);
        a.SetBBCodeEnabled(this._enableBBcode);
        a.SetFontName(this._faceName);
        a.SetLineHeight(this._lineHeightOffset);
        a.SetBold(this._isBold);
        a.SetItalic(this._isItalic);
        a.SetColor(this._color);
        a.SetHorizontalAlignment(HORIZONTAL_ALIGNMENTS[this._horizontalAlign]);
        a.SetVerticalAlignment(VERTICAL_ALIGNMENTS[this._verticalAlign]);
        a.SetWordWrapMode(this._wrapByWord ? "word" : "character")
    }
    _UpdateTextSize() {
        const a = this.GetWorldInfo();
        this._rendererText.SetFontSize(this._ptSize);
        this._rendererText.SetFontSizeScale(a.GetSceneGraphScale());
        var b = a.GetLayer();
        b = b.GetRenderScale() * b.Get2DScaleFactorToZ(a.GetTotalZElevation());
        this._rendererText.SetSize(a.GetWidth(), a.GetHeight(), b)
    }
    _UpdateScreenReaderText() {
        if (this._readAloud) {
            let a = this._text;
            this._enableBBcode && (a = C3$jscomp$188.BBString.StripAnyTags(a));
            this._screenReaderText ? this._screenReaderText.SetText(a) : this._screenReaderText = C3$jscomp$188.New(C3$jscomp$188.ScreenReaderText, this._runtime, a)
        } else
            this._screenReaderText && (this._screenReaderText.Release(),
            this._screenReaderText = null)
    }
    Draw(a) {
        var b = this.GetWorldInfo();
        this._UpdateTextSize();
        const d = this._rendererText.GetTexture();
        if (d) {
            var c = b.GetLayer();
            if (0 === b.GetAngle() && 0 === c.GetAngle() && 0 === b.GetTotalZElevation() && !b.HasMesh() && c.RendersIn2DMode()) {
                b = b.GetBoundingQuad();
                const [e,g] = c.LayerToDrawSurface(b.getTlx(), b.getTly())
                  , [k,l] = c.LayerToDrawSurface(b.getBrx(), b.getBry());
                b = e - Math.round(e);
                const n = g - Math.round(g);
                tempRect$jscomp$11.set(e, g, k, l);
                tempRect$jscomp$11.offset(-b, -n);
                tempQuad$jscomp$7.setFromRect(tempRect$jscomp$11);
                const [p,t] = a.GetRenderTargetSize(a.GetRenderTarget());
                this._runtime.GetCanvasManager().SetDeviceTransform(a, p, t);
                a.SetTexture(d);
                a.Quad3(tempQuad$jscomp$7, this._rendererText.GetTexRect());
                c._SetTransform(a)
            } else
                a.SetTexture(d),
                b.HasMesh() ? this._DrawMesh(b, a) : this._DrawStandard(b, a)
        }
    }
    _DrawStandard(a, b) {
        a = a.GetBoundingQuad();
        this._runtime.IsPixelRoundingEnabled() && (a = this._PixelRoundQuad(a));
        b.Quad3(a, this._rendererText.GetTexRect())
    }
    _DrawMesh(a, b) {
        const d = a.GetTransformedMesh();
        if (a.IsMeshChanged()) {
            a.CalculateBbox(tempRect$jscomp$11, tempQuad$jscomp$7, !1);
            let c = tempQuad$jscomp$7;
            this._runtime.IsPixelRoundingEnabled() && (c = this._PixelRoundQuad(c));
            d.CalculateTransformedMesh(a.GetSourceMesh(), c, this._rendererText.GetTexRect());
            a.SetMeshChanged(!1)
        }
        d.Draw(b)
    }
    _PixelRoundQuad(a) {
        const b = a.getTlx() - Math.round(a.getTlx())
          , d = a.getTly() - Math.round(a.getTly());
        if (0 === b && 0 === d)
            return a;
        tempQuad$jscomp$7.copy(a);
        tempQuad$jscomp$7.offset(-b, -d);
        return tempQuad$jscomp$7
    }
    GetCurrentSurfaceSize() {
        const a = this._rendererText.GetTexture();
        return a ? [a.GetWidth(), a.GetHeight()] : [100, 100]
    }
    GetCurrentTexRect() {
        return this._rendererText.GetTexRect()
    }
    IsCurrentTexRotated() {
        return !1
    }
    SaveToJson() {
        const a = {
            t: this._text,
            c: this._color.toJSON(),
            fn: this._faceName,
            ps: this._ptSize
        };
        this._enableBBcode && (a.bbc = this._enableBBcode);
        0 !== this._horizontalAlign && (a.ha = this._horizontalAlign);
        0 !== this._verticalAlign && (a.va = this._verticalAlign);
        this._wrapByWord || (a.wr = this._wrapByWord);
        0 !== this._lineHeightOffset && (a.lho = this._lineHeightOffset);
        this._isBold && (a.b = this._isBold);
        this._isItalic && (a.i = this._isItalic);
        -1 !== this._typewriterEndTime && (a.tw = {
            st: this._typewriterStartTime,
            en: this._typewriterEndTime,
            l: this._typewriterLength
        });
        return a
    }
    LoadFromJson(a) {
        this._CancelTypewriter();
        this._text = a.t;
        this._color.setFromJSON(a.c);
        this._faceName = a.fn;
        this._ptSize = a.ps;
        this._enableBBcode = a.hasOwnProperty("bbc") ? a.bbc : !1;
        this._horizontalAlign = a.hasOwnProperty("ha") ? a.ha : 0;
        this._verticalAlign = a.hasOwnProperty("va") ? a.va : 0;
        this._wrapByWord = a.hasOwnProperty("wr") ? a.wr : !0;
        this._lineHeightOffset = a.hasOwnProperty("lho") ? a.lho : 0;
        this._isBold = a.hasOwnProperty("b") ? a.b : !1;
        this._isItalic = a.hasOwnProperty("i") ? a.i : !1;
        a.hasOwnProperty("tw") && (a = a.tw,
        this._typewriterStartTime = a.st,
        this._typewriterEndTime = a.en,
        this._typewriterLength = a.l);
        this._UpdateTextSettings();
        this._UpdateScreenReaderText();
        -1 !== this._typewriterEndTime && this._StartTicking()
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this.GetText();
        case 1:
            return this._enableBBcode;
        case 2:
            return this._GetFontFace();
        case 3:
            return this._GetFontSize();
        case 4:
            return this._GetLineHeight();
        case 5:
            return this._IsBold();
        case 6:
            return this._IsItalic();
        case 7:
            return TEMP_COLOR_ARRAY$jscomp$1[0] = this._color.getR(),
            TEMP_COLOR_ARRAY$jscomp$1[1] = this._color.getG(),
            TEMP_COLOR_ARRAY$jscomp$1[2] = this._color.getB(),
            TEMP_COLOR_ARRAY$jscomp$1;
        case 8:
            return this._GetHAlign();
        case 9:
            return this._GetVAlign();
        case 10:
            return this._IsWrapByWord() ? 1 : 0;
        case 13:
            return this._IsReadAloud()
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetText(b);
            break;
        case 1:
            if (this._enableBBcode === !!b)
                break;
            this._enableBBcode = !!b;
            this._UpdateTextSettings();
            break;
        case 2:
            this._SetFontFace(b);
            break;
        case 3:
            this._SetFontSize(b);
            break;
        case 4:
            this._SetLineHeight(b);
            break;
        case 5:
            this._SetBold(b);
            break;
        case 6:
            this._SetItalic(b);
            break;
        case 7:
            a = this._color;
            if (a.getR() === b[0] && a.getG() === b[1] && a.getB() === b[2])
                break;
            this._color.setRgb(b[0], b[1], b[2]);
            this._UpdateTextSettings();
            break;
        case 8:
            this._SetHAlign(b);
            break;
        case 9:
            this._SetVAlign(b);
            break;
        case 10:
            this._SetWrapByWord(0 === b)
        }
    }
    SetPropertyColorOffsetValueByIndex(a, b, d, c) {
        if (0 !== b || 0 !== d || 0 !== c)
            switch (a) {
            case 7:
                this._color.addRgb(b, d, c),
                this._UpdateTextSettings()
            }
    }
    _SetText(a) {
        this._text !== a && (this._text = a,
        this._rendererText.SetText(a),
        this._UpdateScreenReaderText(),
        this._runtime.UpdateRender())
    }
    GetText() {
        return this._text
    }
    _StartTypewriter(a, b) {
        this._SetText(a);
        this._typewriterStartTime = this._runtime.GetWallTime();
        this._typewriterEndTime = this._typewriterStartTime + b / this.GetInstance().GetActiveTimeScale();
        this._typewriterLength = C3$jscomp$188.CountGraphemes(C3$jscomp$188.BBString.StripAnyTags(a));
        this._rendererText.SetDrawMaxCharacterCount(0);
        this._StartTicking()
    }
    _CancelTypewriter() {
        this._typewriterEndTime = this._typewriterStartTime = -1;
        this._typewriterLength = 0;
        this._rendererText.SetDrawMaxCharacterCount(-1);
        this._StopTicking()
    }
    _FinishTypewriter() {
        -1 !== this._typewriterEndTime && (this._CancelTypewriter(),
        this.Trigger(C3$jscomp$188.Plugins.Text.Cnds.OnTypewriterTextFinished),
        this._runtime.UpdateRender())
    }
    _SetFontFace(a) {
        this._faceName !== a && (this._faceName = a,
        this._rendererText.SetFontName(a),
        this._runtime.UpdateRender())
    }
    _GetFontFace() {
        return this._faceName
    }
    _SetBold(a) {
        a = !!a;
        this._isBold !== a && (this._isBold = a,
        this._rendererText.SetBold(a),
        this._runtime.UpdateRender())
    }
    _IsBold() {
        return this._isBold
    }
    _SetItalic(a) {
        a = !!a;
        this._isItalic !== a && (this._isItalic = a,
        this._rendererText.SetItalic(a),
        this._runtime.UpdateRender())
    }
    _IsItalic() {
        return this._isItalic
    }
    _SetFontSize(a) {
        this._ptSize !== a && (this._ptSize = a,
        this._runtime.UpdateRender())
    }
    _GetFontSize() {
        return this._ptSize
    }
    _SetFontColor(a) {
        this._color.equalsIgnoringAlpha(a) || (this._color.copyRgb(a),
        this._rendererText.SetColor(this._color),
        this._runtime.UpdateRender())
    }
    _GetFontColor() {
        return this._color
    }
    _SetLineHeight(a) {
        this._lineHeightOffset !== a && (this._lineHeightOffset = a,
        this._UpdateTextSettings(),
        this._runtime.UpdateRender())
    }
    _GetLineHeight() {
        return this._lineHeightOffset
    }
    _SetHAlign(a) {
        this._horizontalAlign !== a && (this._horizontalAlign = a,
        this._UpdateTextSettings(),
        this._runtime.UpdateRender())
    }
    _GetHAlign() {
        return this._horizontalAlign
    }
    _SetVAlign(a) {
        this._verticalAlign !== a && (this._verticalAlign = a,
        this._UpdateTextSettings(),
        this._runtime.UpdateRender())
    }
    _GetVAlign() {
        return this._verticalAlign
    }
    _SetWrapByWord(a) {
        a = !!a;
        this._wrapByWord !== a && (this._wrapByWord = a,
        this._UpdateTextSettings(),
        this._runtime.UpdateRender())
    }
    _IsWrapByWord() {
        return this._wrapByWord
    }
    _SetReadAloud(a) {
        this._readAloud = !!a;
        this._UpdateScreenReaderText()
    }
    _IsReadAloud() {
        return this._readAloud
    }
    _GetTextWidth() {
        this._UpdateTextSize();
        return this._rendererText.GetTextWidth()
    }
    _GetTextHeight() {
        this._UpdateTextSize();
        return this._rendererText.GetTextHeight()
    }
    Tick() {
        var a = this._runtime.GetWallTime();
        a >= this._typewriterEndTime ? (this._CancelTypewriter(),
        this.Trigger(C3$jscomp$188.Plugins.Text.Cnds.OnTypewriterTextFinished),
        this._runtime.UpdateRender()) : (a = C3$jscomp$188.relerp(this._typewriterStartTime, this._typewriterEndTime, a, 0, this._typewriterLength),
        a = Math.floor(a),
        a !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(a),
        this._runtime.UpdateRender()))
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.text.name",
            properties: [{
                name: "plugins.text.properties.text.name",
                value: this.GetText(),
                onedit: a=>this._SetText(a)
            }, {
                name: "plugins.text.properties.font.name",
                value: this._GetFontFace(),
                onedit: a=>this._SetFontFace(a)
            }, {
                name: "plugins.text.properties.size.name",
                value: this._GetFontSize(),
                onedit: a=>this._SetFontSize(a)
            }, {
                name: "plugins.text.properties.line-height.name",
                value: this._GetLineHeight(),
                onedit: a=>this._SetLineHeight(a)
            }, {
                name: "plugins.text.properties.bold.name",
                value: this._IsBold(),
                onedit: a=>this._SetBold(a)
            }, {
                name: "plugins.text.properties.italic.name",
                value: this._IsItalic(),
                onedit: a=>this._SetItalic(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ITextInstance
    }
}
;
const map$jscomp$20 = new WeakMap
  , SCRIPT_HORIZONTAL_ALIGNMENTS = new Map([["left", 0], ["center", 1], ["right", 2]])
  , SCRIPT_VERTICAL_ALIGNMENTS = new Map([["top", 0], ["center", 1], ["bottom", 2]])
  , SCRIPT_WRAP_MODES = new Map([["word", !0], ["character", !1]]);
self.ITextInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$20.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    get text() {
        return map$jscomp$20.get(this).GetText()
    }
    set text(a) {
        C3X$jscomp$19.RequireString(a);
        const b = map$jscomp$20.get(this);
        b._CancelTypewriter();
        b._SetText(a)
    }
    typewriterText(a, b) {
        C3X$jscomp$19.RequireString(a);
        C3X$jscomp$19.RequireFiniteNumber(b);
        const d = map$jscomp$20.get(this);
        d._CancelTypewriter();
        d._StartTypewriter(a, b)
    }
    typewriterFinish() {
        map$jscomp$20.get(this)._FinishTypewriter()
    }
    set fontFace(a) {
        C3X$jscomp$19.RequireString(a);
        map$jscomp$20.get(this)._SetFontFace(a)
    }
    get fontFace() {
        return map$jscomp$20.get(this)._GetFontFace()
    }
    set isBold(a) {
        map$jscomp$20.get(this)._SetBold(a)
    }
    get isBold() {
        return map$jscomp$20.get(this)._IsBold()
    }
    set isItalic(a) {
        map$jscomp$20.get(this)._SetItalic(a)
    }
    get isItalic() {
        return map$jscomp$20.get(this)._IsItalic()
    }
    set sizePt(a) {
        C3X$jscomp$19.RequireFiniteNumber(a);
        map$jscomp$20.get(this)._SetFontSize(a)
    }
    get sizePt() {
        return map$jscomp$20.get(this)._GetFontSize()
    }
    set fontColor(a) {
        C3X$jscomp$19.RequireArray(a);
        if (3 > a.length)
            throw Error("expected 3 elements");
        tempColor$jscomp$8.setRgb(a[0], a[1], a[2]);
        map$jscomp$20.get(this)._SetFontColor(tempColor$jscomp$8)
    }
    get fontColor() {
        const a = map$jscomp$20.get(this)._GetFontColor();
        return [a.getR(), a.getG(), a.getB()]
    }
    set lineHeight(a) {
        C3X$jscomp$19.RequireFiniteNumber(a);
        map$jscomp$20.get(this)._SetLineHeight(a)
    }
    get lineHeight() {
        return map$jscomp$20.get(this)._GetLineHeight()
    }
    set horizontalAlign(a) {
        C3X$jscomp$19.RequireString(a);
        a = SCRIPT_HORIZONTAL_ALIGNMENTS.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$20.get(this)._SetHAlign(a)
    }
    get horizontalAlign() {
        return HORIZONTAL_ALIGNMENTS[map$jscomp$20.get(this)._GetHAlign()]
    }
    set verticalAlign(a) {
        C3X$jscomp$19.RequireString(a);
        a = SCRIPT_VERTICAL_ALIGNMENTS.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$20.get(this)._SetVAlign(a)
    }
    get verticalAlign() {
        return VERTICAL_ALIGNMENTS[map$jscomp$20.get(this)._GetVAlign()]
    }
    set wordWrapMode(a) {
        C3X$jscomp$19.RequireString(a);
        a = SCRIPT_WRAP_MODES.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$20.get(this)._SetWrapByWord(a)
    }
    get wordWrapMode() {
        return map$jscomp$20.get(this)._IsWrapByWord() ? "word" : "character"
    }
    set readAloud(a) {
        map$jscomp$20.get(this)._SetReadAloud(!!a)
    }
    get readAloud() {
        return map$jscomp$20.get(this)._IsReadAloud()
    }
    get textWidth() {
        return map$jscomp$20.get(this)._GetTextWidth()
    }
    get textHeight() {
        return map$jscomp$20.get(this)._GetTextHeight()
    }
    getTextSize() {
        const a = map$jscomp$20.get(this);
        return [a._GetTextWidth(), a._GetTextHeight()]
    }
}
;
const C3$jscomp$189 = self.C3;
C3$jscomp$189.Plugins.Text.Cnds = {
    CompareText(a, b) {
        return b ? this._text === a : C3$jscomp$189.equalsNoCase(this._text, a)
    },
    IsRunningTypewriterText() {
        return -1 !== this._typewriterEndTime
    },
    OnTypewriterTextFinished() {
        return !0
    }
};
const C3$jscomp$190 = self.C3
  , tempColor$jscomp$9 = C3$jscomp$190.New(C3$jscomp$190.Color);
C3$jscomp$190.Plugins.Text.Acts = {
    SetText(a) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        this._SetText(a.toString())
    },
    AppendText(a) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        (a = a.toString()) && this._SetText(this._text + a)
    },
    TypewriterText(a, b) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        this._StartTypewriter(a.toString(), b)
    },
    SetFontFace(a, b) {
        let d = !1
          , c = !1;
        switch (b) {
        case 1:
            d = !0;
            break;
        case 2:
            c = !0;
            break;
        case 3:
            c = d = !0
        }
        if (a !== this._faceName || d !== this._isBold || c !== this._isItalic)
            this._SetFontFace(a),
            this._SetBold(d),
            this._SetItalic(c)
    },
    SetFontSize(a) {
        this._SetFontSize(a)
    },
    SetFontColor(a) {
        tempColor$jscomp$9.setFromRgbValue(a);
        tempColor$jscomp$9.clamp();
        this._SetFontColor(tempColor$jscomp$9)
    },
    SetWebFont(a, b) {
        console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect")
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    },
    TypewriterFinish() {
        this._FinishTypewriter()
    },
    SetLineHeight(a) {
        this._SetLineHeight(a)
    },
    SetHAlign(a) {
        this._SetHAlign(a)
    },
    SetVAlign(a) {
        this._SetVAlign(a)
    },
    SetWrapping(a) {
        this._SetWrapByWord(0 === a)
    },
    SetReadAloud(a) {
        this._SetReadAloud(a)
    }
};
const C3$jscomp$191 = self.C3;
C3$jscomp$191.Plugins.Text.Exps = {
    Text() {
        return this._text
    },
    PlainText() {
        return this._enableBBcode ? C3$jscomp$191.BBString.StripAnyTags(this._text) : this._text
    },
    FaceName() {
        return this._faceName
    },
    FaceSize() {
        return this._ptSize
    },
    TextWidth() {
        return this._GetTextWidth()
    },
    TextHeight() {
        return this._GetTextHeight()
    },
    LineHeight() {
        return this._lineHeightOffset
    }
};
"use strict";
const C3$jscomp$192 = self.C3;
C3$jscomp$192.Plugins.TiledBg = class extends C3$jscomp$192.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$193 = self.C3;
function WrapModeToStr(a) {
    switch (a) {
    case 0:
        return "clamp-to-edge";
    case 2:
        return "mirror-repeat"
    }
    return "repeat"
}
C3$jscomp$193.Plugins.TiledBg.Type = class extends C3$jscomp$193.SDKTypeBase {
    constructor(a, b) {
        super(a);
        this._wrapY = this._wrapX = "repeat";
        b && (this._wrapX = WrapModeToStr(b[0]),
        this._wrapY = WrapModeToStr(b[1]))
    }
    Release() {
        super.Release()
    }
    OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(a) {
        return this.GetImageInfo().LoadStaticTexture(a, {
            sampling: this._runtime.GetSampling(),
            wrapX: this._wrapX,
            wrapY: this._wrapY
        })
    }
    ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture()
    }
}
;
const C3$jscomp$194 = self.C3
  , C3X$jscomp$20 = self.C3X
  , tempRect$jscomp$12 = C3$jscomp$194.New(C3$jscomp$194.Rect)
  , tempQuad$jscomp$8 = C3$jscomp$194.New(C3$jscomp$194.Quad)
  , rcTex$jscomp$3 = C3$jscomp$194.New(C3$jscomp$194.Rect)
  , qTex = C3$jscomp$194.New(C3$jscomp$194.Quad);
C3$jscomp$194.Plugins.TiledBg.Instance = class extends C3$jscomp$194.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this._imageOffsetY = this._imageOffsetX = 0;
        this._imageScaleY = this._imageScaleX = 1;
        this._imageAngle = 0;
        this._enableTileRandomization = !1;
        this._tileBlendMarginY = this._tileBlendMarginX = this._tileAngleRandom = this._tileYRandom = this._tileXRandom = 0;
        this._ownImageInfo = null;
        b && (this.GetWorldInfo().SetVisible(!!b[0]),
        this._imageOffsetX = b[4],
        this._imageOffsetY = b[5],
        this._imageScaleX = b[6],
        this._imageScaleY = b[7],
        this._imageAngle = C3$jscomp$194.toRadians(b[8]),
        this._enableTileRandomization = !!b[9],
        this._tileXRandom = b[10],
        this._tileYRandom = b[11],
        this._tileAngleRandom = b[12],
        this._tileBlendMarginX = b[13],
        this._tileBlendMarginY = b[14])
    }
    Release() {
        this._ReleaseOwnImage();
        super.Release()
    }
    _ReleaseOwnImage() {
        this._ownImageInfo && (this._ownImageInfo.Release(),
        this._ownImageInfo = null)
    }
    CalculateTextureCoordsFor3DFace(a, b, d) {
        var c = this.GetCurrentImageInfo();
        const e = c.GetWidth();
        c = c.GetHeight();
        const g = this._imageOffsetX / e
          , k = this._imageOffsetY / c
          , l = this._imageAngle;
        rcTex$jscomp$3.set(0, 0, a / (e * this._imageScaleX), b / (c * this._imageScaleY));
        rcTex$jscomp$3.offset(-g, -k);
        0 === l ? d.setFromRect(rcTex$jscomp$3) : d.setFromRotatedRect(rcTex$jscomp$3, -l)
    }
    SetTilingShaderProgram(a) {
        if (this._enableTileRandomization) {
            const b = this.GetCurrentImageInfo();
            a.SetTileRandomizationMode();
            a.SetTileRandomizationInfo(b.GetWidth() * this._imageScaleX, b.GetHeight() * this._imageScaleY, this._tileXRandom, this._tileYRandom, this._tileAngleRandom, this._tileBlendMarginX, this._tileBlendMarginY)
        } else
            a.SetTextureFillMode()
    }
    Draw(a) {
        var b = this.GetCurrentImageInfo()
          , d = b.GetTexture();
        if (null !== d) {
            this.SetTilingShaderProgram(a);
            a.SetTexture(d);
            d = b.GetWidth();
            b = b.GetHeight();
            var c = this._imageOffsetX / d
              , e = this._imageOffsetY / b
              , g = this.GetWorldInfo();
            rcTex$jscomp$3.set(0, 0, g.GetWidth() / (d * this._imageScaleX), g.GetHeight() / (b * this._imageScaleY));
            rcTex$jscomp$3.offset(-c, -e);
            g.HasMesh() ? this._DrawMesh(g, a) : this._DrawStandard(g, a)
        }
    }
    _DrawStandard(a, b) {
        let d = a.GetBoundingQuad();
        this._runtime.IsPixelRoundingEnabled() && (d = a.PixelRoundQuad(d));
        0 === this._imageAngle ? b.Quad3(d, rcTex$jscomp$3) : (qTex.setFromRotatedRect(rcTex$jscomp$3, -this._imageAngle),
        b.Quad4(d, qTex))
    }
    _DrawMesh(a, b) {
        const d = a.GetTransformedMesh();
        if (a.IsMeshChanged()) {
            a.CalculateBbox(tempRect$jscomp$12, tempQuad$jscomp$8, !1);
            let c = tempQuad$jscomp$8;
            this._runtime.IsPixelRoundingEnabled() && (c = a.PixelRoundQuad(c));
            let e = rcTex$jscomp$3;
            0 !== this._imageAngle && (qTex.setFromRotatedRect(rcTex$jscomp$3, -this._imageAngle),
            e = qTex);
            d.CalculateTransformedMesh(a.GetSourceMesh(), c, e);
            a.SetMeshChanged(!1)
        }
        d.Draw(b)
    }
    GetCurrentImageInfo() {
        return this._ownImageInfo || this._objectClass.GetImageInfo()
    }
    IsOriginalSizeKnown() {
        return !0
    }
    GetTexture() {
        return this.GetCurrentImageInfo().GetTexture()
    }
    _SetMeshChanged() {
        this.GetWorldInfo().SetMeshChanged(!0)
    }
    _SetImageOffsetX(a) {
        this._imageOffsetX !== a && (this._imageOffsetX = a,
        this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageOffsetX() {
        return this._imageOffsetX
    }
    _SetImageOffsetY(a) {
        this._imageOffsetY !== a && (this._imageOffsetY = a,
        this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageOffsetY() {
        return this._imageOffsetY
    }
    _SetImageScaleX(a) {
        this._imageScaleX !== a && (this._imageScaleX = a,
        this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageScaleX() {
        return this._imageScaleX
    }
    _SetImageScaleY(a) {
        this._imageScaleY !== a && (this._imageScaleY = a,
        this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageScaleY() {
        return this._imageScaleY
    }
    _SetImageAngle(a) {
        this._imageAngle !== a && (this._imageAngle = a,
        this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageAngle() {
        return this._imageAngle
    }
    _SetTileRandomizationEnabled(a) {
        a = !!a;
        this._enableTileRandomization !== a && (this._enableTileRandomization = a,
        this._runtime.UpdateRender())
    }
    _IsTileRandomizationEnabled() {
        return this._enableTileRandomization
    }
    _SetTileXRandom(a) {
        this._tileXRandom !== a && (this._tileXRandom = a,
        this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileXRandom() {
        return this._tileXRandom
    }
    _SetTileYRandom(a) {
        this._tileYRandom !== a && (this._tileYRandom = a,
        this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileYRandom() {
        return this._tileYRandom
    }
    _SetTileAngleRandom(a) {
        this._tileAngleRandom !== a && (this._tileAngleRandom = a,
        this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileAngleRandom() {
        return this._tileAngleRandom
    }
    _SetTileBlendMarginX(a) {
        this._tileBlendMarginX !== a && (this._tileBlendMarginX = a,
        this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileBlendMarginX() {
        return this._tileBlendMarginX
    }
    _SetTileBlendMarginY(a) {
        this._tileBlendMarginY !== a && (this._tileBlendMarginY = a,
        this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileBlendMarginY() {
        return this._tileBlendMarginY
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.tiledbg.properties.image-transform.name",
            properties: [{
                name: "plugins.tiledbg.properties.image-offset-x.name",
                value: this._GetImageOffsetX(),
                onedit: a=>this._SetImageOffsetX(a)
            }, {
                name: "plugins.tiledbg.properties.image-offset-y.name",
                value: this._GetImageOffsetY(),
                onedit: a=>this._SetImageOffsetY(a)
            }, {
                name: "plugins.tiledbg.properties.image-scale-x.name",
                value: 100 * this._GetImageScaleX(),
                onedit: a=>this._SetImageScaleX(a / 100)
            }, {
                name: "plugins.tiledbg.properties.image-scale-y.name",
                value: 100 * this._GetImageScaleY(),
                onedit: a=>this._SetImageScaleY(a / 100)
            }, {
                name: "plugins.tiledbg.properties.image-angle.name",
                value: C3$jscomp$194.toDegrees(this._GetImageAngle()),
                onedit: a=>this._SetImageAngle(C3$jscomp$194.toRadians(a))
            }]
        }, {
            title: "plugins.tiledbg.properties.tile-randomization.name",
            properties: [{
                name: "plugins.tiledbg.properties.enable-tile-randomization.name",
                value: this._IsTileRandomizationEnabled(),
                onedit: a=>this._SetTileRandomizationEnabled(a)
            }, {
                name: "plugins.tiledbg.properties.x-random.name",
                value: 100 * this._GetTileXRandom(),
                onedit: a=>this._SetTileXRandom(a / 100)
            }, {
                name: "plugins.tiledbg.properties.y-random.name",
                value: 100 * this._GetTileYRandom(),
                onedit: a=>this._SetTileYRandom(a / 100)
            }, {
                name: "plugins.tiledbg.properties.angle-random.name",
                value: 100 * this._GetTileAngleRandom(),
                onedit: a=>this._SetTileAngleRandom(a / 100)
            }, {
                name: "plugins.tiledbg.properties.blend-margin-x.name",
                value: 100 * this._GetTileBlendMarginX(),
                onedit: a=>this._SetTileBlendMarginX(a / 100)
            }, {
                name: "plugins.tiledbg.properties.blend-margin-y.name",
                value: 100 * this._GetTileBlendMarginY(),
                onedit: a=>this._SetTileBlendMarginY(a / 100)
            }]
        }]
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 4:
            return this._GetImageOffsetX();
        case 5:
            return this._GetImageOffsetY();
        case 6:
            return this._GetImageScaleX();
        case 7:
            return this._GetImageScaleY();
        case 8:
            return this._GetImageAngle();
        case 9:
            return this._IsTileRandomizationEnabled();
        case 10:
            return this._GetTileXRandom();
        case 11:
            return this._GetTileYRandom();
        case 12:
            return this._GetTileAngleRandom();
        case 13:
            return this._GetTileBlendMarginX();
        case 14:
            return this._GetTileBlendMarginY()
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 4:
            this._SetImageOffsetX(b);
            break;
        case 5:
            this._SetImageOffsetY(b);
            break;
        case 6:
            this._SetImageScaleX(b);
            break;
        case 7:
            this._SetImageScaleY(b);
            break;
        case 8:
            this._SetImageAngle(b);
            break;
        case 9:
            this._SetTileRandomizationEnabled(!!b);
            break;
        case 10:
            this._SetTileXRandom(b);
            break;
        case 11:
            this._SetTileYRandom(b);
            break;
        case 12:
            this._SetTileAngleRandom(b);
            break;
        case 13:
            this._SetTileBlendMarginX(b);
            break;
        case 14:
            this._SetTileBlendMarginY(b)
        }
    }
    GetScriptInterfaceClass() {
        return self.ITiledBackgroundInstance
    }
}
;
const map$jscomp$21 = new WeakMap;
self.ITiledBackgroundInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$21.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    set imageOffsetX(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetImageOffsetX(a)
    }
    get imageOffsetX() {
        return map$jscomp$21.get(this)._GetImageOffsetX()
    }
    set imageOffsetY(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetImageOffsetY(a)
    }
    get imageOffsetY() {
        return map$jscomp$21.get(this)._GetImageOffsetY()
    }
    setImageOffset(a, b) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        C3X$jscomp$20.RequireFiniteNumber(b);
        const d = map$jscomp$21.get(this);
        d._SetImageOffsetX(a);
        d._SetImageOffsetY(b)
    }
    getImageOffset() {
        const a = map$jscomp$21.get(this);
        return [a._GetImageOffsetX(), a._GetImageOffsetY()]
    }
    set imageScaleX(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetImageScaleX(a)
    }
    get imageScaleX() {
        return map$jscomp$21.get(this)._GetImageScaleX()
    }
    set imageScaleY(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetImageScaleY(a)
    }
    get imageScaleY() {
        return map$jscomp$21.get(this)._GetImageScaleY()
    }
    setImageScale(a, b) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        C3X$jscomp$20.RequireFiniteNumber(b);
        const d = map$jscomp$21.get(this);
        d._SetImageScaleX(a);
        d._SetImageScaleY(b)
    }
    getImageScale() {
        const a = map$jscomp$21.get(this);
        return [a._GetImageScaleX(), a._GetImageScaleY()]
    }
    set imageAngle(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetImageAngle(a)
    }
    get imageAngle() {
        return map$jscomp$21.get(this)._GetImageAngle()
    }
    set imageAngleDegrees(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetImageAngle(C3$jscomp$194.toRadians(a))
    }
    get imageAngleDegrees() {
        return C3$jscomp$194.toDegrees(map$jscomp$21.get(this)._GetImageAngle())
    }
    get imageWidth() {
        return map$jscomp$21.get(this).GetCurrentImageInfo().GetWidth()
    }
    get imageHeight() {
        return map$jscomp$21.get(this).GetCurrentImageInfo().GetHeight()
    }
    getImageSize() {
        const a = map$jscomp$21.get(this).GetCurrentImageInfo();
        return [a.GetWidth(), a.GetHeight()]
    }
    set enableTileRandomization(a) {
        map$jscomp$21.get(this)._SetTileRandomizationEnabled(!!a)
    }
    get enableTileRandomization() {
        return map$jscomp$21.get(this)._IsTileRandomizationEnabled()
    }
    set tileXRandom(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetTileXRandom(a)
    }
    get tileXRandom() {
        return map$jscomp$21.get(this)._GetTileXRandom()
    }
    set tileYRandom(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetTileYRandom(a)
    }
    get tileYRandom() {
        return map$jscomp$21.get(this)._GetTileYRandom()
    }
    setTileRandom(a, b) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        C3X$jscomp$20.RequireFiniteNumber(b);
        const d = map$jscomp$21.get(this);
        d._SetTileXRandom(a);
        d._SetTileYRandom(b)
    }
    getTileRandom() {
        const a = map$jscomp$21.get(this);
        return [a._GetTileXRandom(), a._GetTileYRandom()]
    }
    set tileAngleRandom(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetTileAngleRandom(a)
    }
    get tileAngleRandom() {
        return map$jscomp$21.get(this)._GetTileAngleRandom()
    }
    set tileBlendMarginX(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetTileBlendMarginX(a)
    }
    get tileBlendMarginX() {
        return map$jscomp$21.get(this)._GetTileBlendMarginX()
    }
    set tileBlendMarginY(a) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        map$jscomp$21.get(this)._SetTileBlendMarginY(a)
    }
    get tileBlendMarginY() {
        return map$jscomp$21.get(this)._GetTileBlendMarginY()
    }
    setTileBlendMargin(a, b) {
        C3X$jscomp$20.RequireFiniteNumber(a);
        C3X$jscomp$20.RequireFiniteNumber(b);
        const d = map$jscomp$21.get(this);
        d._SetTileBlendMarginX(a);
        d._SetTileBlendMarginY(b)
    }
    getTileBlendMargin() {
        const a = map$jscomp$21.get(this);
        return [a._GetTileBlendMarginX(), a._GetTileBlendMarginY()]
    }
}
;
self.C3.Plugins.TiledBg.Cnds = {
    OnURLLoaded() {
        return !0
    },
    OnURLFailed() {
        return !0
    },
    IsTileRandomizationEnabled() {
        return this._IsTileRandomizationEnabled()
    }
};
const C3$jscomp$196 = self.C3;
C3$jscomp$196.Plugins.TiledBg.Acts = {
    SetImageOffsetX(a) {
        this._SetImageOffsetX(a)
    },
    SetImageOffsetY(a) {
        this._SetImageOffsetY(a)
    },
    SetImageScaleX(a) {
        this._SetImageScaleX(a / 100)
    },
    SetImageScaleY(a) {
        this._SetImageScaleY(a / 100)
    },
    SetImageAngle(a) {
        this._SetImageAngle(C3$jscomp$196.toRadians(a))
    },
    SetTileRandomizationEnabled(a) {
        this._SetTileRandomizationEnabled(a)
    },
    SetTilePosRandom(a, b) {
        this._SetTileXRandom(a / 100);
        this._SetTileYRandom(b / 100)
    },
    SetTileAngleRandom(a) {
        this._SetTileAngleRandom(a / 100)
    },
    SetTileBlendMargin(a, b) {
        this._SetTileBlendMarginX(a / 100);
        this._SetTileBlendMarginY(b / 100)
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    },
    async LoadURL(a, b) {
        if (!this._ownImageInfo || this._ownImageInfo.GetURL() !== a) {
            b = this._runtime;
            var d = C3$jscomp$196.New(C3$jscomp$196.ImageInfo);
            try {
                await d.LoadDynamicAsset(b, a);
                if (!d.IsLoaded())
                    throw Error("image failed to load");
                if (this.WasReleased())
                    return d.Release(),
                    null;
                if (!await d.LoadStaticTexture(b.GetRenderer(), {
                    sampling: b.GetSampling(),
                    wrapX: "repeat",
                    wrapY: "repeat"
                }))
                    return
            } catch (c) {
                console.error("Load image from URL failed: ", c);
                this.WasReleased() || this.Trigger(C3$jscomp$196.Plugins.TiledBg.Cnds.OnURLFailed);
                return
            }
            this.WasReleased() ? d.Release() : (this._ReleaseOwnImage(),
            this._ownImageInfo = d,
            b.UpdateRender(),
            await this.TriggerAsync(C3$jscomp$196.Plugins.TiledBg.Cnds.OnURLLoaded))
        }
    }
};
const C3$jscomp$197 = self.C3;
C3$jscomp$197.Plugins.TiledBg.Exps = {
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    },
    ImageOffsetX() {
        return this._imageOffsetX
    },
    ImageOffsetY() {
        return this._imageOffsetY
    },
    ImageScaleX() {
        return 100 * this._imageScaleX
    },
    ImageScaleY() {
        return 100 * this._imageScaleY
    },
    ImageAngle() {
        return C3$jscomp$197.toDegrees(this._imageAngle)
    },
    TileXRandom() {
        return 100 * this._GetTileXRandom()
    },
    TileYRandom() {
        return 100 * this._GetTileYRandom()
    },
    TileAngleRandom() {
        return 100 * this._GetTileAngleRandom()
    },
    TileBlendMarginX() {
        return 100 * this._GetTileBlendMarginX()
    },
    TileBlendMarginY() {
        return 100 * this._GetTileBlendMarginY()
    }
};
"use strict";
const C3$jscomp$198 = self.C3;
C3$jscomp$198.Plugins.Spritefont2 = class extends C3$jscomp$198.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$199 = self.C3;
C3$jscomp$199.Plugins.Spritefont2.Type = class extends C3$jscomp$199.SDKTypeBase {
    constructor(a) {
        super(a);
        this._spriteFont = C3$jscomp$199.New(self.SpriteFont)
    }
    Release() {
        super.Release()
    }
    OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(a) {
        return this.GetImageInfo().LoadStaticTexture(a, {
            sampling: this._runtime.GetSampling()
        })
    }
    ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture()
    }
    GetSpriteFont() {
        return this._spriteFont
    }
    UpdateSettings(a, b, d, c) {
        const e = this.GetImageInfo()
          , g = this._spriteFont;
        g.SetWidth(e.GetWidth());
        g.SetHeight(e.GetHeight());
        g.SetCharacterWidth(a);
        g.SetCharacterHeight(b);
        g.SetCharacterSet(d);
        g.SetSpacingData(c);
        g.UpdateCharacterMap()
    }
}
;
const C3$jscomp$200 = self.C3
  , C3X$jscomp$21 = self.C3X
  , HORIZONTAL_ALIGNMENTS$jscomp$1 = ["left", "center", "right"]
  , VERTICAL_ALIGNMENTS$jscomp$1 = ["top", "center", "bottom"];
C3$jscomp$200.Plugins.Spritefont2.Instance = class extends C3$jscomp$200.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this._text = "";
        this._enableBBcode = !0;
        this._characterHeight = this._characterWidth = 16;
        this._characterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#\"'&()[]|`\\/@\u00b0+=*$\u00a3\u20ac<>";
        a = "";
        this._characterScale = 1;
        this._verticalAlign = this._horizontalAlign = this._lineHeight = this._characterSpacing = 0;
        this._wrapByWord = !0;
        this._readAloud = !1;
        this._spriteFontText = this._screenReaderText = null;
        this._typewriterEndTime = this._typewriterStartTime = -1;
        this._typewriterLength = 0;
        b && (this._text = b[0],
        this._enableBBcode = b[1],
        this._characterWidth = b[2],
        this._characterHeight = b[3],
        this._characterSet = b[4],
        a = b[5],
        this._characterScale = b[6],
        this._characterSpacing = b[7],
        this._lineHeight = b[8],
        this._horizontalAlign = b[9],
        this._verticalAlign = b[10],
        this._wrapByWord = 0 === b[11],
        this.GetWorldInfo().SetVisible(b[12]),
        this._readAloud = !!b[14]);
        this._sdkType.UpdateSettings(this._characterWidth, this._characterHeight, this._characterSet, a);
        this._spriteFontText = C3$jscomp$200.New(self.SpriteFontText, this._sdkType.GetSpriteFont());
        b = this.GetWorldInfo();
        this._spriteFontText.SetSize(b.GetWidth(), b.GetHeight());
        this._UpdateSettings();
        this._UpdateScreenReaderText();
        this._inst.SetMustMitigateZFighting()
    }
    Release() {
        this._CancelTypewriter();
        this._screenReaderText && (this._screenReaderText.Release(),
        this._screenReaderText = null);
        this._spriteFontText.Release();
        this._spriteFontText = null;
        super.Release()
    }
    _UpdateSettings() {
        const a = this._spriteFontText;
        a && (a.SetBBCodeEnabled(this._enableBBcode),
        a.SetText(this._text),
        a.SetWordWrapMode(this._wrapByWord ? "word" : "character"),
        a.SetHorizontalAlign(HORIZONTAL_ALIGNMENTS$jscomp$1[this._horizontalAlign]),
        a.SetVerticalAlign(VERTICAL_ALIGNMENTS$jscomp$1[this._verticalAlign]),
        a.SetSpacing(this._characterSpacing),
        a.SetLineHeight(this._lineHeight))
    }
    _UpdateScreenReaderText() {
        if (this._readAloud) {
            let a = this._text;
            this._enableBBcode && (a = C3$jscomp$200.BBString.StripAnyTags(a));
            this._screenReaderText ? this._screenReaderText.SetText(a) : this._screenReaderText = C3$jscomp$200.New(C3$jscomp$200.ScreenReaderText, this._runtime, a)
        } else
            this._screenReaderText && (this._screenReaderText.Release(),
            this._screenReaderText = null)
    }
    Draw(a) {
        const b = this._objectClass.GetImageInfo();
        var d = b.GetTexture();
        if (d) {
            a.SetTexture(d);
            d = this.GetWorldInfo();
            var c = d.GetBoundingQuad()
              , e = this._spriteFontText;
            e.SetScale(this._characterScale);
            e.SetSceneGraphScale(d.GetSceneGraphScale());
            this._runtime.IsPixelRoundingEnabled() && (c = d.PixelRoundQuad(c));
            e.SetSize(d.GetWidth(), d.GetHeight());
            e.GetSpriteFont().SetTexRect(b.GetTexRect());
            e.SetColor(d.GetUnpremultipliedColor());
            e.Draw(a, c.getTlx(), c.getTly(), d.GetAngle())
        }
    }
    SaveToJson() {
        const a = {
            t: this._text,
            ebbc: this._enableBBcode,
            csc: this._characterScale,
            csp: this._characterSpacing,
            lh: this._lineHeight,
            ha: this._horizontalAlign,
            va: this._verticalAlign,
            w: this._wrapByWord,
            cw: this._sdkType.GetSpriteFont().GetCharacterWidth(),
            ch: this._sdkType.GetSpriteFont().GetCharacterHeight(),
            cs: this._sdkType.GetSpriteFont().GetCharacterSet(),
            sd: this._sdkType.GetSpriteFont().GetSpacingData()
        };
        -1 !== this._typewriterEndTime && (a.tw = {
            st: this._typewriterStartTime,
            en: this._typewriterEndTime,
            l: this._typewriterLength
        });
        return a
    }
    LoadFromJson(a) {
        this._CancelTypewriter();
        this._text = a.t;
        this._enableBBcode = a.ebbc;
        this._characterScale = a.csc;
        this._characterSpacing = a.csp;
        this._lineHeight = a.lh;
        this._horizontalAlign = a.ha;
        this._verticalAlign = a.va;
        this._wrapByWord = a.w;
        if (a.hasOwnProperty("tw")) {
            var b = a.tw;
            this._typewriterStartTime = b.st;
            this._typewriterEndTime = b.en;
            this._typewriterLength = a.l
        }
        b = this._sdkType.GetSpriteFont();
        b.SetCharacterWidth(a.cw);
        b.SetCharacterHeight(a.ch);
        b.SetCharacterSet(a.cs);
        b.SetSpacingData(a.sd);
        this._UpdateSettings();
        this._UpdateScreenReaderText();
        -1 !== this._typewriterEndTime && this._StartTicking()
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this.GetText();
        case 1:
            return this._enableBBcode;
        case 2:
            return this._sdkType.GetSpriteFont().GetCharacterWidth();
        case 3:
            return this._sdkType.GetSpriteFont().GetCharacterHeight();
        case 4:
            return this._sdkType.GetSpriteFont().GetCharacterSet();
        case 5:
            return this._sdkType.GetSpriteFont().GetSpacingData();
        case 6:
            return this._GetScale();
        case 7:
            return this._GetCharacterSpacing();
        case 8:
            return this._GetLineHeight();
        case 9:
            return this._GetHAlign();
        case 10:
            return this._GetVAlign();
        case 11:
            return this._IsWrapByWord() ? 1 : 0
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetText(b);
            break;
        case 1:
            if (this._enableBBcode === !!b)
                break;
            this._enableBBcode = !!b;
            this._UpdateSettings();
            break;
        case 2:
            this._sdkType.GetSpriteFont().SetCharacterWidth(b);
            break;
        case 3:
            this._sdkType.GetSpriteFont().SetCharacterHeight(b);
            break;
        case 4:
            this._sdkType.GetSpriteFont().SetCharacterSet(b);
            break;
        case 5:
            this._sdkType.GetSpriteFont().SetSpacingData(b);
            break;
        case 6:
            this._SetScale(b);
            break;
        case 7:
            this._SetCharacterSpacing(b);
            break;
        case 8:
            this._SetLineHeight(b);
            break;
        case 9:
            this._SetHAlign(b);
            break;
        case 10:
            this._SetVAlign(b);
            break;
        case 11:
            this._SetWrapByWord(0 === b)
        }
    }
    _SetText(a) {
        this._text !== a && (this._text = a,
        this._spriteFontText.SetText(a),
        this._UpdateScreenReaderText(),
        this._runtime.UpdateRender())
    }
    GetText() {
        return this._text
    }
    _StartTypewriter(a, b) {
        this._SetText(a);
        this._typewriterStartTime = this._runtime.GetWallTime();
        this._typewriterEndTime = this._typewriterStartTime + b / this.GetInstance().GetActiveTimeScale();
        this._typewriterLength = C3$jscomp$200.CountGraphemes(C3$jscomp$200.BBString.StripAnyTags(a));
        this._spriteFontText.SetDrawMaxCharacterCount(0);
        this._StartTicking()
    }
    _CancelTypewriter() {
        this._typewriterEndTime = this._typewriterStartTime = -1;
        this._typewriterLength = 0;
        this._spriteFontText.SetDrawMaxCharacterCount(-1);
        this._StopTicking()
    }
    _FinishTypewriter() {
        -1 !== this._typewriterEndTime && (this._CancelTypewriter(),
        this.Trigger(C3$jscomp$200.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished),
        this._runtime.UpdateRender())
    }
    _SetScale(a) {
        this._characterScale !== a && (this._characterScale = a,
        this._spriteFontText.SetScale(this._characterScale),
        this._runtime.UpdateRender())
    }
    _GetScale() {
        return this._characterScale
    }
    _SetCharacterSpacing(a) {
        this._characterSpacing !== a && (this._characterSpacing = a,
        this._spriteFontText.SetSpacing(this._characterSpacing),
        this._runtime.UpdateRender())
    }
    _GetCharacterSpacing() {
        return this._characterSpacing
    }
    _SetLineHeight(a) {
        this._lineHeight !== a && (this._lineHeight = a,
        this._spriteFontText.SetLineHeight(this._lineHeight),
        this._runtime.UpdateRender())
    }
    _GetLineHeight() {
        return this._lineHeight
    }
    _SetHAlign(a) {
        this._horizontalAlign !== a && (this._horizontalAlign = a,
        this._UpdateSettings(),
        this._runtime.UpdateRender())
    }
    _GetHAlign() {
        return this._horizontalAlign
    }
    _SetVAlign(a) {
        this._verticalAlign !== a && (this._verticalAlign = a,
        this._UpdateSettings(),
        this._runtime.UpdateRender())
    }
    _GetVAlign() {
        return this._verticalAlign
    }
    _SetWrapByWord(a) {
        a = !!a;
        this._wrapByWord !== a && (this._wrapByWord = a,
        this._UpdateSettings(),
        this._runtime.UpdateRender())
    }
    _IsWrapByWord() {
        return this._wrapByWord
    }
    _SetReadAloud(a) {
        this._readAloud = !!a;
        this._UpdateScreenReaderText()
    }
    _IsReadAloud() {
        return this._readAloud
    }
    _GetTextWidth() {
        const a = this.GetWorldInfo();
        this._spriteFontText.SetSize(a.GetWidth(), a.GetHeight());
        this._spriteFontText.SetScale(this._characterScale);
        return this._spriteFontText.GetTextWidth()
    }
    _GetTextHeight() {
        const a = this.GetWorldInfo();
        this._spriteFontText.SetSize(a.GetWidth(), a.GetHeight());
        this._spriteFontText.SetScale(this._characterScale);
        return this._spriteFontText.GetTextHeight()
    }
    Tick() {
        var a = this._runtime.GetWallTime();
        a >= this._typewriterEndTime ? (this._CancelTypewriter(),
        this.Trigger(C3$jscomp$200.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished),
        this._runtime.UpdateRender()) : (a = C3$jscomp$200.relerp(this._typewriterStartTime, this._typewriterEndTime, a, 0, this._typewriterLength),
        a = Math.floor(a),
        a !== this._spriteFontText.GetDrawMaxCharacterCount() && (this._spriteFontText.SetDrawMaxCharacterCount(a),
        this._runtime.UpdateRender()))
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.spritefont2.name",
            properties: [{
                name: "plugins.spritefont2.properties.text.name",
                value: this.GetText(),
                onedit: a=>this._SetText(a)
            }, {
                name: "plugins.spritefont2.properties.scale.name",
                value: this._GetScale(),
                onedit: a=>this._SetScale(a)
            }, {
                name: "plugins.spritefont2.properties.character-spacing.name",
                value: this._GetCharacterSpacing(),
                onedit: a=>this._SetCharacterSpacing(a)
            }, {
                name: "plugins.spritefont2.properties.line-height.name",
                value: this._GetLineHeight(),
                onedit: a=>this._SetLineHeight(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ISpriteFontInstance
    }
}
;
const map$jscomp$22 = new WeakMap
  , SCRIPT_HORIZONTAL_ALIGNMENTS$jscomp$1 = new Map([["left", 0], ["center", 1], ["right", 2]])
  , SCRIPT_VERTICAL_ALIGNMENTS$jscomp$1 = new Map([["top", 0], ["center", 1], ["bottom", 2]])
  , SCRIPT_WRAP_MODES$jscomp$1 = new Map([["word", !0], ["character", !1]]);
self.ISpriteFontInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$22.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    get text() {
        return map$jscomp$22.get(this).GetText()
    }
    set text(a) {
        C3X$jscomp$21.RequireString(a);
        const b = map$jscomp$22.get(this);
        b._CancelTypewriter();
        b._SetText(a)
    }
    typewriterText(a, b) {
        C3X$jscomp$21.RequireString(a);
        C3X$jscomp$21.RequireFiniteNumber(b);
        const d = map$jscomp$22.get(this);
        d._CancelTypewriter();
        d._StartTypewriter(a, b)
    }
    typewriterFinish() {
        map$jscomp$22.get(this)._FinishTypewriter()
    }
    set characterScale(a) {
        C3X$jscomp$21.RequireFiniteNumber(a);
        map$jscomp$22.get(this)._SetScale(a)
    }
    get characterScale() {
        return map$jscomp$22.get(this)._GetScale()
    }
    set characterSpacing(a) {
        C3X$jscomp$21.RequireFiniteNumber(a);
        map$jscomp$22.get(this)._SetCharacterSpacing(a)
    }
    get characterSpacing() {
        return map$jscomp$22.get(this)._GetCharacterSpacing()
    }
    set lineHeight(a) {
        C3X$jscomp$21.RequireFiniteNumber(a);
        map$jscomp$22.get(this)._SetLineHeight(a)
    }
    get lineHeight() {
        return map$jscomp$22.get(this)._GetLineHeight()
    }
    set horizontalAlign(a) {
        C3X$jscomp$21.RequireString(a);
        a = SCRIPT_HORIZONTAL_ALIGNMENTS$jscomp$1.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$22.get(this)._SetHAlign(a)
    }
    get horizontalAlign() {
        return HORIZONTAL_ALIGNMENTS$jscomp$1[map$jscomp$22.get(this)._GetHAlign()]
    }
    set verticalAlign(a) {
        C3X$jscomp$21.RequireString(a);
        a = SCRIPT_VERTICAL_ALIGNMENTS$jscomp$1.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$22.get(this)._SetVAlign(a)
    }
    get verticalAlign() {
        return VERTICAL_ALIGNMENTS$jscomp$1[map$jscomp$22.get(this)._GetVAlign()]
    }
    set wordWrapMode(a) {
        C3X$jscomp$21.RequireString(a);
        a = SCRIPT_WRAP_MODES$jscomp$1.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$22.get(this)._SetWrapByWord(a)
    }
    get wordWrapMode() {
        return map$jscomp$22.get(this)._IsWrapByWord() ? "word" : "character"
    }
    set readAloud(a) {
        map$jscomp$22.get(this)._SetReadAloud(!!a)
    }
    get readAloud() {
        return map$jscomp$22.get(this)._IsReadAloud()
    }
    get textWidth() {
        return map$jscomp$22.get(this)._GetTextWidth()
    }
    get textHeight() {
        return map$jscomp$22.get(this)._GetTextHeight()
    }
    getTextSize() {
        const a = map$jscomp$22.get(this);
        return [a._GetTextWidth(), a._GetTextHeight()]
    }
}
;
const C3$jscomp$201 = self.C3;
C3$jscomp$201.Plugins.Spritefont2.Cnds = {
    CompareText(a, b) {
        return b ? this._text === a : C3$jscomp$201.equalsNoCase(this._text, a)
    },
    IsRunningTypewriterText() {
        return -1 !== this._typewriterEndTime
    },
    OnTypewriterTextFinished() {
        return !0
    }
};
self.C3.Plugins.Spritefont2.Acts = {
    SetText(a) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        this._SetText(a.toString())
    },
    AppendText(a) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        (a = a.toString()) && this._SetText(this._text + a)
    },
    TypewriterText(a, b) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        this._StartTypewriter(a.toString(), b)
    },
    TypewriterFinish() {
        this._FinishTypewriter()
    },
    SetScale(a) {
        this._SetScale(a)
    },
    SetCharacterSpacing(a) {
        this._SetCharacterSpacing(a)
    },
    SetLineHeight(a) {
        this._SetLineHeight(a)
    },
    SetCharacterWidth(a, b) {
        let d = !1;
        const c = this._sdkType.GetSpriteFont();
        for (const e of a)
            if (" " === e)
                c.SetSpaceWidth(b),
                d = !0;
            else if (a = c.GetCharacter(e))
                a.SetDisplayWidth(b),
                d = !0;
        d && c.SetCharacterWidthsChanged();
        this._runtime.UpdateRender()
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    },
    SetHAlign(a) {
        this._SetHAlign(a)
    },
    SetVAlign(a) {
        this._SetVAlign(a)
    },
    SetWrapping(a) {
        this._SetWrapByWord(0 === a)
    },
    SetReadAloud(a) {
        this._SetReadAloud(a)
    }
};
const C3$jscomp$203 = self.C3;
C3$jscomp$203.Plugins.Spritefont2.Exps = {
    CharacterWidth(a) {
        return (a = this._sdkType.GetSpriteFont().GetCharacter(a)) ? a.GetDisplayWidth() : this._sdkType.GetSpriteFont().GetCharacterWidth()
    },
    CharacterHeight() {
        return this._characterHeight
    },
    CharacterScale() {
        return this._characterScale
    },
    CharacterSpacing() {
        return this._characterSpacing
    },
    LineHeight() {
        return this._lineHeight
    },
    Text() {
        return this._text
    },
    PlainText() {
        return this._enableBBcode ? C3$jscomp$203.BBString.StripAnyTags(this._text) : this._text
    },
    TextWidth() {
        return this._GetTextWidth()
    },
    TextHeight() {
        return this._GetTextHeight()
    }
};
"use strict";
const C3$jscomp$204 = self.C3;
self.SpriteFontCharacter = class {
    constructor(a, b, d, c) {
        let e = a.GetCharacterWidth()
          , g = a.GetCharacterHeight();
        this._spriteFont = a;
        this._char = b;
        this._pxRect = new C3$jscomp$204.Rect(d,c,d + e,c + g);
        this._texRect = new C3$jscomp$204.Rect;
        this._displayWidth = -1;
        this._UpdateTexRect()
    }
    Release() {
        this._texRect = this._pxRect = this._spriteFont = null
    }
    _UpdateTexRect() {
        let a = this._spriteFont.GetWidth()
          , b = this._spriteFont.GetHeight();
        this._texRect.copy(this._pxRect);
        this._texRect.divide(a, b);
        this._texRect.lerpInto(this._spriteFont.GetTexRect())
    }
    GetSpriteFont() {
        return this._spriteFont
    }
    GetChar() {
        return this._char
    }
    GetTexRect() {
        return this._texRect
    }
    SetDisplayWidth(a) {
        this._displayWidth = a
    }
    GetDisplayWidth() {
        return 0 > this._displayWidth ? this._spriteFont.GetCharacterWidth() : this._displayWidth
    }
}
;
"use strict";
const C3$jscomp$205 = self.C3
  , tmpRect$jscomp$3 = new C3$jscomp$205.Rect
  , tmpQuad$jscomp$3 = new C3$jscomp$205.Quad
  , tmpColor = new C3$jscomp$205.Color
  , VALID_HORIZ_ALIGNMENTS$jscomp$1 = new Set(["left", "center", "right"])
  , VALID_VERT_ALIGNMENTS$jscomp$1 = new Set(["top", "center", "bottom"])
  , VALID_WORD_WRAP_MODES$jscomp$1 = new Set(["word", "character"]);
self.SpriteFontText = class {
    constructor(a) {
        this._spriteFont = a;
        this._cssHeight = this._cssWidth = 0;
        this._text = "";
        this._isBBcodeEnabled = !1;
        this._bbString = null;
        this._wrappedText = C3$jscomp$205.New(C3$jscomp$205.WordWrap);
        this._wrapMode = "word";
        this._wrapChanged = !1;
        this._horizontalAlign = "left";
        this._verticalAlign = "top";
        this._sceneGraphScale = this._scale = 1;
        this._lineHeight = this._spacing = 0;
        this._color = C3$jscomp$205.New(C3$jscomp$205.Color);
        this._drawMaxCharCount = -1;
        this._drawCharCount = 0;
        this._measureTextCallback = (b,d)=>this._MeasureText(b, d);
        this._spriteFont._AddSpriteFontText(this)
    }
    Release() {
        this._spriteFont._RemoveSpriteFontText(this);
        this._measureTextCallback = this._color = null;
        this._wrappedText.Clear();
        this._bbString = this._spriteFont = this._wrappedText = null
    }
    _MeasureText(a, b) {
        var d = this._GetStyleTag(b, "scale")
          , c = (d ? parseFloat(d.param) : this._scale) * this._sceneGraphScale;
        d = this._GetStyleTag(b, "scalex");
        d = (d ? parseFloat(d.param) : 1) * c;
        b = this._GetStyleTag(b, "scaley");
        b = (b ? parseFloat(b.param) : 1) * c;
        b = this._spriteFont.GetCharacterHeight() * b + this._lineHeight;
        const e = this.GetSpriteFont();
        c = e.GetCharacterWidth() * d;
        const g = this.GetSpacing();
        if (e.HasAnyCustomWidths()) {
            let l = 0
              , n = 0;
            for (var k of a) {
                a = c;
                const p = e.GetCharacter(k);
                p ? a = p.GetDisplayWidth() * d : " " === k && (a = e.GetSpaceWidth() * d);
                n += a;
                ++l
            }
            return {
                width: n + l * g,
                height: b
            }
        }
        k = a.length;
        return {
            width: c * k + Math.max(k, 0) * g,
            height: b
        }
    }
    _SetWrapChanged() {
        this._wrapChanged = !0;
        this._wrappedText.Clear()
    }
    SetSize(a, b) {
        0 >= a || 0 >= b || this._cssWidth === a && this._cssHeight === b || (this._cssWidth !== a && this._SetWrapChanged(),
        this._cssWidth = a,
        this._cssHeight = b)
    }
    SetDrawMaxCharacterCount(a) {
        this._drawMaxCharCount = Math.floor(a)
    }
    GetDrawMaxCharacterCount() {
        return this._drawMaxCharCount
    }
    _GetStyleTag(a, b) {
        for (let d = a.length - 1; 0 <= d; --d) {
            const c = a[d];
            if (c.tag === b)
                return c
        }
        return null
    }
    _HasStyleTag(a, b) {
        return !!this._GetStyleTag(a, b)
    }
    _MaybeWrapText() {
        if (this._wrapChanged) {
            !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C3$jscomp$205.BBString(this._text,{
                noEscape: !0
            }));
            var a = -this.GetSpacing();
            this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, a);
            this._wrapChanged = !1
        }
    }
    Draw(a, b, d, c) {
        this._MaybeWrapText();
        let e = this._drawCharCount = 0;
        const g = this._lineHeight
          , k = C3$jscomp$205.cloneArray(this._wrappedText.GetLines())
          , l = Math.sin(c);
        c = Math.cos(c);
        var n = k.reduce((p,t)=>p + t.height, 0) - g;
        "center" === this._verticalAlign ? e = Math.max(Math.floor(this._cssHeight / 2 - n / 2), 0) : "bottom" === this._verticalAlign && (e = Math.floor(this._cssHeight - n));
        for (let p = 0, t = k.length; p < t; ++p) {
            n = k[p];
            const w = n.height;
            if (0 < p && e > this._cssHeight - (w - g))
                break;
            0 <= e && this._DrawLine(a, n, b, d, e, l, c);
            e += w
        }
    }
    _DrawLine(a, b, d, c, e, g, k) {
        const l = b.height;
        let n = 0;
        "center" === this._horizontalAlign ? n = Math.max(Math.floor((this._cssWidth - b.width) / 2), 0) : "right" === this._horizontalAlign && (n = Math.max(Math.floor(this._cssWidth - b.width), 0));
        for (const p of b.fragments)
            this._DrawFragment(a, p, d, c, n, e, g, k, l),
            n += p.width
    }
    _DrawFragment(a, b, d, c, e, g, k, l, n) {
        var p = b.chArr
          , t = b.width
          , w = b.styles;
        if (-1 !== this._drawMaxCharCount) {
            if (this._drawCharCount >= this._drawMaxCharCount)
                return;
            this._drawCharCount + p.length > this._drawMaxCharCount && (p = p.slice(0, this._drawMaxCharCount - this._drawCharCount),
            t = this._MeasureText(p, w).width);
            this._drawCharCount += p.length
        }
        var z = this._GetStyleTag(w, "background");
        if (!(C3$jscomp$205.IsCharArrayAllWhitespace(p) && !z || this._HasStyleTag(w, "hide"))) {
            b = this._GetStyleTag(w, "scale");
            var B = (b ? parseFloat(b.param) : this._scale) * this._sceneGraphScale;
            b = this._GetStyleTag(w, "scalex");
            b = (b ? parseFloat(b.param) : 1) * B;
            var C = this._GetStyleTag(w, "scaley");
            B *= C ? parseFloat(C.param) : 1;
            B *= this._spriteFont.GetCharacterHeight();
            g += n - this._lineHeight - B;
            n = this._GetStyleTag(w, "offsetx");
            e += n ? parseFloat(n.param) : 0;
            n = this._GetStyleTag(w, "offsety");
            g += n ? parseFloat(n.param) : 0;
            z && (a.SetColorFillMode(),
            tmpColor.parseString(z.param),
            tmpColor.setA(1),
            a.SetColor(tmpColor),
            tmpRect$jscomp$3.set(e, g, e + t, g + B),
            tmpRect$jscomp$3.getRight() > this._cssWidth && tmpRect$jscomp$3.setRight(this._cssWidth),
            tmpQuad$jscomp$3.setFromRotatedRectPrecalc(tmpRect$jscomp$3, k, l),
            tmpQuad$jscomp$3.offset(d, c),
            a.Quad(tmpQuad$jscomp$3),
            a.SetTextureFillMode());
            (t = this._GetStyleTag(w, "color")) ? (tmpColor.parseString(t.param),
            tmpColor.setA(this._color.getA())) : tmpColor.copy(this._color);
            (t = this._GetStyleTag(w, "opacity")) && tmpColor.setA(tmpColor.getA() * parseFloat(t.param) / 100);
            tmpColor.premultiply();
            a.SetColor(tmpColor);
            t = this._spriteFont.GetCharacterWidth() * b;
            w = Math.abs(this.GetSpacing());
            for (const E of p)
                if (p = this._spriteFont.GetCharacter(E)) {
                    z = p.GetDisplayWidth() * b;
                    if (e + z > this._cssWidth + w + 1E-5)
                        break;
                    tmpRect$jscomp$3.set(e, g, e + t, g + B);
                    tmpQuad$jscomp$3.setFromRotatedRectPrecalc(tmpRect$jscomp$3, k, l);
                    tmpQuad$jscomp$3.offset(d, c);
                    a.Quad3(tmpQuad$jscomp$3, p.GetTexRect());
                    e += z + this._spacing
                } else
                    e += this._spriteFont.GetSpaceWidth() * b + this._spacing
        }
    }
    GetSpriteFont() {
        return this._spriteFont
    }
    SetBBCodeEnabled(a) {
        a = !!a;
        this._isBBcodeEnabled !== a && (this._isBBcodeEnabled = a,
        this._SetWrapChanged())
    }
    IsBBCodeEnabled() {
        return this._isBBcodeEnabled
    }
    SetText(a) {
        this._text !== a && (this._text = a,
        this._SetWrapChanged())
    }
    SetWordWrapMode(a) {
        if (!VALID_WORD_WRAP_MODES$jscomp$1.has(a))
            throw Error("invalid word wrap mode");
        this._wrapMode !== a && (this._wrapMode = a,
        this._SetWrapChanged())
    }
    SetHorizontalAlign(a) {
        if (!VALID_HORIZ_ALIGNMENTS$jscomp$1.has(a))
            throw Error("invalid alignment");
        this._horizontalAlign = a
    }
    SetVerticalAlign(a) {
        if (!VALID_VERT_ALIGNMENTS$jscomp$1.has(a))
            throw Error("invalid alignment");
        this._verticalAlign = a
    }
    SetScale(a) {
        this._scale !== a && (this._scale = a,
        this._SetWrapChanged())
    }
    GetScale() {
        return this._scale
    }
    SetSceneGraphScale(a) {
        this._sceneGraphScale !== a && (this._sceneGraphScale = a,
        this._SetWrapChanged())
    }
    GetSceneGraphScale() {
        return this._sceneGraphScale
    }
    SetSpacing(a) {
        this._spacing !== a && (this._spacing = a,
        this._SetWrapChanged())
    }
    GetSpacing() {
        return this._spacing
    }
    SetLineHeight(a) {
        this._lineHeight = a;
        this._SetWrapChanged()
    }
    GetLineHeight() {
        return this._lineHeight
    }
    SetOpacity(a) {
        a = C3$jscomp$205.clamp(a, 0, 1);
        this._color.a = a
    }
    SetColor(a) {
        this._color.equals(a) || this._color.copy(a)
    }
    GetColor() {
        return this._color
    }
    GetTextWidth() {
        this._MaybeWrapText();
        return this._wrappedText.GetMaxLineWidth()
    }
    GetTextHeight() {
        this._MaybeWrapText();
        var a = this._spriteFont.GetCharacterHeight() * this._scale;
        const b = this._lineHeight;
        a += b;
        return this._wrappedText.GetLineCount() * a - b
    }
}
;
"use strict";
const C3$jscomp$206 = self.C3
  , DEFAULT_SPRITEFONT_OPTS = {
    width: 256,
    height: 256,
    characterWidth: 16,
    characterHeight: 16,
    characterSet: ""
};
self.SpriteFont = class {
    constructor(a) {
        a = Object.assign({}, DEFAULT_SPRITEFONT_OPTS, a);
        if (0 >= a.width || 0 >= a.height || 0 >= a.characterWidth || 0 >= a.characterHeight)
            throw Error("invalid size");
        this._width = a.width;
        this._height = a.height;
        this._characterWidth = a.characterWidth;
        this._characterHeight = a.characterHeight;
        this._characterSet = a.characterSet;
        this._spacingData = "";
        this._spacingParsed = null;
        this._hasAnyCustomWidths = !1;
        this._spaceWidth = -1;
        this._texRect = new C3$jscomp$206.Rect(0,0,1,1);
        this._characterMap = new Map;
        this._mapChanged = !0;
        this._allTexts = new Set
    }
    Release() {
        this._texRect = null;
        this._ReleaseCharacters();
        this._characterMap = null;
        this._allTexts && this._allTexts.clear();
        this._allTexts = null
    }
    _ReleaseCharacters() {
        for (let a of this._characterMap.values())
            a.Release();
        this._characterMap.clear()
    }
    _AddSpriteFontText(a) {
        this._allTexts.add(a)
    }
    _RemoveSpriteFontText(a) {
        this._allTexts.delete(a)
    }
    UpdateCharacterMap() {
        if (this._mapChanged) {
            this._ReleaseCharacters();
            var a = C3$jscomp$206.SplitGraphemes(this._characterSet)
              , b = Math.floor(this._width / this._characterWidth)
              , d = b * Math.floor(this._height / this._characterHeight);
            for (let c = 0, e = a.length; c < e && !(c >= d); ++c) {
                let g = a[c];
                this._characterMap.has(g) || this._characterMap.set(g, C3$jscomp$206.New(self.SpriteFontCharacter, this, g, c % b * this._characterWidth, Math.floor(c / b) * this._characterHeight))
            }
            this._hasAnyCustomWidths = !1;
            this._spaceWidth = -1;
            if (Array.isArray(this._spacingParsed))
                for (let c of this._spacingParsed)
                    if (Array.isArray(c) && 2 === c.length && (a = c[0],
                    b = c[1],
                    "number" === typeof a && isFinite(a) && "string" === typeof b && a !== this._characterWidth))
                        for (let e of b)
                            (b = this._characterMap.get(e)) ? (b.SetDisplayWidth(a),
                            this._hasAnyCustomWidths = !0) : " " === e && (this._spaceWidth = a,
                            this._hasAnyCustomWidths = !0);
            this._mapChanged = !1;
            for (let c of this._allTexts)
                c._SetWrapChanged()
        }
    }
    SetCharacterWidthsChanged() {
        this._hasAnyCustomWidths = !0;
        for (const a of this._allTexts)
            a._SetWrapChanged()
    }
    GetCharacter(a) {
        this.UpdateCharacterMap();
        return this._characterMap.get(a) || null
    }
    HasAnyCustomWidths() {
        return this._hasAnyCustomWidths
    }
    SetWidth(a) {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._width !== a && (this._width = a,
        this._mapChanged = !0)
    }
    GetWidth() {
        return this._width
    }
    SetHeight(a) {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._height !== a && (this._height = a,
        this._mapChanged = !0)
    }
    GetHeight() {
        return this._height
    }
    SetTexRect(a) {
        if (!this._texRect.equals(a)) {
            this._texRect.copy(a);
            for (const b of this._characterMap.values())
                b._UpdateTexRect()
        }
    }
    GetTexRect() {
        return this._texRect
    }
    SetCharacterWidth(a) {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._characterWidth !== a && (this._characterWidth = a,
        this._mapChanged = !0)
    }
    GetCharacterWidth() {
        return this._characterWidth
    }
    SetCharacterHeight(a) {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._characterHeight !== a && (this._characterHeight = a,
        this._mapChanged = !0)
    }
    GetCharacterHeight() {
        return this._characterHeight
    }
    SetCharacterSet(a) {
        this._characterSet !== a && (this._characterSet = a,
        this._mapChanged = !0)
    }
    GetCharacterSet() {
        return this._characterSet
    }
    SetSpacingData(a) {
        if (this._spacingData !== a && (this._spacingData = a,
        this._mapChanged = !0,
        this._spacingParsed = null,
        this._spacingData.length))
            try {
                this._spacingParsed = JSON.parse(this._spacingData)
            } catch (b) {
                this._spacingParsed = null
            }
    }
    GetSpacingData() {
        return this._spacingData
    }
    SetSpaceWidth(a) {
        0 > a && (a = -1);
        this._spaceWidth !== a && (this._spaceWidth = a,
        0 <= this._spaceWidth && (this._hasAnyCustomWidths = !0))
    }
    GetSpaceWidth() {
        return 0 > this._spaceWidth ? this._characterWidth : this._spaceWidth
    }
}
;
"use strict";
const C3$jscomp$207 = self.C3;
C3$jscomp$207.Plugins.Arr = class extends C3$jscomp$207.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$208 = self.C3;
C3$jscomp$208.Plugins.Arr.Type = class extends C3$jscomp$208.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$209 = self.C3
  , C3X$jscomp$22 = self.C3X
  , IInstance$jscomp$3 = self.IInstance;
function ResizeArray(a, b, d) {
    if (b < a.length)
        C3$jscomp$209.truncateArray(a, b);
    else if (b > a.length)
        if ("function" === typeof d)
            for (var c = a.length; c < b; ++c)
                a.push(d());
        else
            for (c = a.length; c < b; ++c)
                a.push(d)
}
C3$jscomp$209.Plugins.Arr.Instance = class extends C3$jscomp$209.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._cx = 10;
        this._cz = this._cy = 1;
        this._arr = null;
        this._forX = [];
        this._forY = [];
        this._forZ = [];
        this._forDepth = -1;
        b && (this._cx = b[0],
        this._cy = b[1],
        this._cz = b[2]);
        this._arr = C3$jscomp$209.MakeFilledArray(this._cx, ()=>C3$jscomp$209.MakeFilledArray(this._cy, ()=>C3$jscomp$209.MakeFilledArray(this._cz, 0)))
    }
    Release() {
        this._arr = null;
        super.Release()
    }
    At(a, b, d) {
        a = Math.floor(a);
        b = Math.floor(b);
        d = Math.floor(d);
        return 0 <= a && a < this._cx && 0 <= b && b < this._cy && 0 <= d && d < this._cz ? this._arr[a][b][d] : 0
    }
    Set(a, b, d, c) {
        a = Math.floor(a);
        b = Math.floor(b);
        d = Math.floor(d);
        0 <= a && a < this._cx && 0 <= b && b < this._cy && 0 <= d && d < this._cz && (this._arr[a][b][d] = c)
    }
    SetSize(a, b, d) {
        a = Math.floor(a);
        b = Math.floor(b);
        d = Math.floor(d);
        0 > a && (a = 0);
        0 > b && (b = 0);
        0 > d && (d = 0);
        if (this._cx !== a || this._cy !== b || this._cz !== d) {
            this._cx = a;
            this._cy = b;
            this._cz = d;
            var c = this._arr;
            ResizeArray(c, a, ()=>C3$jscomp$209.MakeFilledArray(b, ()=>C3$jscomp$209.MakeFilledArray(d, 0)));
            for (let e = 0; e < a; ++e) {
                ResizeArray(c[e], b, ()=>C3$jscomp$209.MakeFilledArray(d, 0));
                for (let g = 0; g < b; ++g)
                    ResizeArray(c[e][g], d, 0)
            }
        }
    }
    GetWidth() {
        return this._cx
    }
    GetHeight() {
        return this._cy
    }
    GetDepth() {
        return this._cz
    }
    _ShuffleHelper(a, b, d, c, e) {
        for (; 0 < b; ) {
            const l = Math.floor(this._runtime.Random() * b);
            --b;
            if (0 === a) {
                var g = this.At(b, c, e)
                  , k = this.At(l, c, e);
                this.Set(b, c, e, k);
                this.Set(l, c, e, g)
            } else
                1 === a ? (g = this.At(d, b, e),
                k = this.At(d, l, e),
                this.Set(d, b, e, k),
                this.Set(d, l, e, g)) : 2 === a && (g = this.At(d, c, b),
                k = this.At(d, c, l),
                this.Set(d, c, b, k),
                this.Set(d, c, l, g))
        }
    }
    GetDebuggerProperties() {
        const a = [{
            title: "plugins.arr.debugger.array-properties.title",
            properties: [{
                name: "plugins.arr.properties.width.name",
                value: this._cx,
                onedit: d=>this.SetSize(d, this._cy, this._cz)
            }, {
                name: "plugins.arr.properties.height.name",
                value: this._cy,
                onedit: d=>this.SetSize(this._cx, d, this._cz)
            }, {
                name: "plugins.arr.properties.depth.name",
                value: this._cz,
                onedit: d=>this.SetSize(this._cx, this._cy, d)
            }, {
                name: "plugins.arr.properties.elements.name",
                value: this._cx * this._cy * this._cz
            }]
        }]
          , b = [];
        if (1 === this._cy && 1 === this._cz)
            for (let d = 0; d < this._cx; ++d)
                b.push({
                    name: "$" + d,
                    value: this._arr[d][0][0],
                    onedit: c=>this._arr[d][0][0] = c
                });
        else
            for (let d = 0; d < this._cx; ++d)
                b.push({
                    name: "$" + d,
                    value: this._arr[d].toString()
                });
        b.length && a.push({
            title: "plugins.arr.debugger.array-data.title",
            properties: b
        });
        return a
    }
    GetAsJsonString() {
        return JSON.stringify({
            c2array: !0,
            size: [this._cx, this._cy, this._cz],
            data: this._arr
        })
    }
    SaveToJson() {
        return {
            size: [this._cx, this._cy, this._cz],
            data: this._arr
        }
    }
    LoadFromJson(a) {
        const b = a.size;
        this._cx = b[0];
        this._cy = b[1];
        this._cz = b[2];
        this._arr = a.data
    }
    _GetForX() {
        return 0 <= this._forDepth && this._forDepth < this._forX.length ? this._forX[this._forDepth] : 0
    }
    _GetForY() {
        return 0 <= this._forDepth && this._forDepth < this._forY.length ? this._forY[this._forDepth] : 0
    }
    _GetForZ() {
        return 0 <= this._forDepth && this._forDepth < this._forZ.length ? this._forZ[this._forDepth] : 0
    }
    GetScriptInterfaceClass() {
        return self.IArrayInstance
    }
}
;
const map$jscomp$23 = new WeakMap;
self.IArrayInstance = class extends IInstance$jscomp$3 {
    constructor() {
        super();
        map$jscomp$23.set(this, IInstance$jscomp$3._GetInitInst().GetSdkInstance())
    }
    get width() {
        return map$jscomp$23.get(this).GetWidth()
    }
    get height() {
        return map$jscomp$23.get(this).GetHeight()
    }
    get depth() {
        return map$jscomp$23.get(this).GetDepth()
    }
    setSize(a, b=1, d=1) {
        C3X$jscomp$22.RequireFiniteNumber(a);
        C3X$jscomp$22.RequireFiniteNumber(b);
        C3X$jscomp$22.RequireFiniteNumber(d);
        map$jscomp$23.get(this).SetSize(a, b, d)
    }
    getAt(a, b=0, d=0) {
        C3X$jscomp$22.RequireFiniteNumber(a);
        C3X$jscomp$22.RequireFiniteNumber(b);
        C3X$jscomp$22.RequireFiniteNumber(d);
        return map$jscomp$23.get(this).At(a, b, d)
    }
    setAt(a, b, d=0, c=0) {
        C3X$jscomp$22.RequireFiniteNumber(b);
        C3X$jscomp$22.RequireFiniteNumber(d);
        C3X$jscomp$22.RequireFiniteNumber(c);
        if ("number" !== typeof a && "string" !== typeof a)
            throw new TypeError("invalid type");
        map$jscomp$23.get(this).Set(b, d, c, a)
    }
}
;
const C3$jscomp$210 = self.C3;
function DoForEachTrigger(a, b, d, c, e) {
    a.PushCopySol(d);
    b.Retrigger(c, e);
    a.PopSol(d)
}
C3$jscomp$210.Plugins.Arr.Cnds = {
    CompareX(a, b, d) {
        return C3$jscomp$210.compare(this.At(a, 0, 0), b, d)
    },
    CompareXY(a, b, d, c) {
        return C3$jscomp$210.compare(this.At(a, b, 0), d, c)
    },
    CompareXYZ(a, b, d, c, e) {
        return C3$jscomp$210.compare(this.At(a, b, d), c, e)
    },
    ArrForEach(a) {
        const b = this._runtime
          , d = b.GetEventSheetManager()
          , c = b.GetCurrentEvent()
          , e = c.GetSolModifiers()
          , g = b.GetEventStack()
          , k = g.GetCurrentStackFrame()
          , l = g.Push(c)
          , n = ++this._forDepth
          , p = this._forX;
        var t = this._forY
          , w = this._forZ;
        const z = this._cx
          , B = this._cy;
        var C = this._cz;
        n === this._forX.length ? (p.push(0),
        t.push(0),
        w.push(0)) : (p[n] = 0,
        t[n] = 0,
        w[n] = 0);
        b.SetDebuggingEnabled(!1);
        if (0 === a)
            for (a = 0; a < z; ++a)
                for (let E = 0; E < B; ++E)
                    for (let F = 0; F < C; ++F)
                        p[n] = a,
                        t[n] = E,
                        w[n] = F,
                        DoForEachTrigger(d, c, e, k, l);
        else if (1 === a)
            for (w = 0; w < z; ++w)
                for (C = 0; C < B; ++C)
                    p[n] = w,
                    t[n] = C,
                    DoForEachTrigger(d, c, e, k, l);
        else
            for (t = 0; t < z; ++t)
                p[n] = t,
                DoForEachTrigger(d, c, e, k, l);
        b.SetDebuggingEnabled(!0);
        this._forDepth--;
        g.Pop();
        return !1
    },
    CompareCurrent(a, b) {
        return C3$jscomp$210.compare(this.At(this._GetForX(), this._GetForY(), this._GetForZ()), a, b)
    },
    Contains(a) {
        const b = this._cx
          , d = this._cy
          , c = this._cz
          , e = this._arr;
        for (let g = 0; g < b; ++g)
            for (let k = 0; k < d; ++k)
                for (let l = 0; l < c; ++l)
                    if (e[g][k][l] === a)
                        return !0;
        return !1
    },
    IsEmpty() {
        return 0 === this._cx || 0 === this._cy || 0 === this._cz
    },
    CompareSize(a, b, d) {
        let c = 0;
        switch (a) {
        case 0:
            c = this._cx;
            break;
        case 1:
            c = this._cy;
            break;
        case 2:
            c = this._cz
        }
        return C3$jscomp$210.compare(c, b, d)
    }
};
const C3$jscomp$211 = self.C3;
function CompareValues(a, b) {
    if ("number" === typeof a && "number" === typeof b)
        return a - b;
    a = a.toString();
    b = b.toString();
    return a < b ? -1 : a > b ? 1 : 0
}
C3$jscomp$211.Plugins.Arr.Acts = {
    Clear(a) {
        const b = this._cx
          , d = this._cy
          , c = this._cz
          , e = this._arr;
        for (let g = 0; g < b; ++g)
            for (let k = 0; k < d; ++k)
                for (let l = 0; l < c; ++l)
                    e[g][k][l] = a
    },
    SetSize(a, b, d) {
        this.SetSize(a, b, d)
    },
    SetX(a, b) {
        this.Set(a, 0, 0, b)
    },
    SetXY(a, b, d) {
        this.Set(a, b, 0, d)
    },
    SetXYZ(a, b, d, c) {
        this.Set(a, b, d, c)
    },
    Push(a, b, d) {
        var c = this._cx
          , e = this._cy;
        const g = this._cz
          , k = this._arr;
        if (0 === d)
            c = C3$jscomp$211.MakeFilledArray(e, ()=>C3$jscomp$211.MakeFilledArray(g, b)),
            0 === a ? k.push(c) : k.unshift(c),
            this._cx++;
        else if (1 === d) {
            for (e = 0; e < c; ++e)
                d = C3$jscomp$211.MakeFilledArray(g, b),
                0 === a ? k[e].push(d) : k[e].unshift(d);
            this._cy++
        } else {
            for (d = 0; d < c; ++d)
                for (let l = 0; l < e; ++l)
                    0 === a ? k[d][l].push(b) : k[d][l].unshift(b);
            this._cz++
        }
    },
    Pop(a, b) {
        const d = this._cx;
        var c = this._cy
          , e = this._cz;
        const g = this._arr;
        if (0 === b)
            0 !== d && (0 === a ? g.pop() : g.shift(),
            this._cx--);
        else if (1 === b) {
            if (0 !== c) {
                for (c = 0; c < d; ++c)
                    0 === a ? g[c].pop() : g[c].shift();
                this._cy--
            }
        } else if (0 !== e) {
            for (b = 0; b < d; ++b)
                for (e = 0; e < c; ++e)
                    0 === a ? g[b][e].pop() : g[b][e].shift();
            this._cz--
        }
    },
    Reverse(a) {
        const b = this._cx;
        var d = this._cy
          , c = this._cz;
        const e = this._arr;
        if (0 !== b && 0 !== d && 0 !== c)
            if (0 === a)
                e.reverse();
            else if (1 === a)
                for (d = 0; d < b; ++d)
                    e[d].reverse();
            else
                for (a = 0; a < b; ++a)
                    for (c = 0; c < d; ++c)
                        e[a][c].reverse()
    },
    Sort(a) {
        const b = this._cx;
        var d = this._cy
          , c = this._cz;
        const e = this._arr;
        if (0 !== b && 0 !== d && 0 !== c)
            if (0 === a)
                e.sort((g,k)=>CompareValues(g[0][0], k[0][0]));
            else if (1 === a)
                for (d = 0; d < b; ++d)
                    e[d].sort((g,k)=>CompareValues(g[0], k[0]));
            else
                for (a = 0; a < b; ++a)
                    for (c = 0; c < d; ++c)
                        e[a][c].sort(CompareValues)
    },
    Shuffle(a) {
        const b = this._cx
          , d = this._cy
          , c = this._cz;
        if (0 !== b && 0 !== d && 0 !== c)
            if (0 === a)
                for (var e = 0; e < d; ++e)
                    for (var g = 0; g < c; ++g)
                        this._ShuffleHelper(a, b, 0, e, g);
            else if (1 === a)
                for (e = 0; e < b; ++e)
                    for (g = 0; g < c; ++g)
                        this._ShuffleHelper(a, d, e, 0, g);
            else
                for (e = 0; e < b; ++e)
                    for (g = 0; g < d; ++g)
                        this._ShuffleHelper(a, c, e, g, 0)
    },
    Delete(a, b) {
        a = Math.floor(a);
        if (!(0 > a)) {
            var d = this._cx
              , c = this._cy
              , e = this._cz
              , g = this._arr;
            if (0 === b)
                a >= d || (g.splice(a, 1),
                this._cx--);
            else if (1 === b) {
                if (!(a >= c)) {
                    for (c = 0; c < d; ++c)
                        g[c].splice(a, 1);
                    this._cy--
                }
            } else if (!(a >= e)) {
                for (b = 0; b < d; ++b)
                    for (e = 0; e < c; ++e)
                        g[b][e].splice(a, 1);
                this._cz--
            }
        }
    },
    Insert(a, b, d) {
        b = Math.floor(b);
        if (!(0 > b)) {
            var c = this._cx
              , e = this._cy
              , g = this._cz
              , k = this._arr;
            if (0 === d)
                b > c || (k.splice(b, 0, C3$jscomp$211.MakeFilledArray(e, ()=>C3$jscomp$211.MakeFilledArray(g, a))),
                this._cx++);
            else if (1 === d) {
                if (!(b > e)) {
                    for (e = 0; e < c; ++e)
                        k[e].splice(b, 0, C3$jscomp$211.MakeFilledArray(g, a));
                    this._cy++
                }
            } else if (!(b > g)) {
                for (d = 0; d < c; ++d)
                    for (let l = 0; l < e; ++l)
                        k[d][l].splice(b, 0, a);
                this._cz++
            }
        }
    },
    SplitString(a, b, d) {
        a = a.split(b);
        this.SetSize(a.length, 1, 1);
        for (let c = 0, e = a.length; c < e; ++c)
            b = a[c],
            0 === d ? String(Number(b)) === b && (b = Number(b)) : 2 === d && (b = Number(b)),
            this.Set(c, 0, 0, b)
    },
    JSONLoad(a) {
        let b = null;
        try {
            b = JSON.parse(a)
        } catch (d) {
            console.error("[Construct] Failed to parse JSON: ", d);
            return
        }
        b.c2array && (a = b.size,
        this._cx = a[0],
        this._cy = a[1],
        this._cz = a[2],
        this._arr = b.data)
    },
    JSONDownload(a) {
        const b = URL.createObjectURL(new Blob([this.GetAsJsonString()],{
            type: "application/json"
        }));
        this._runtime.InvokeDownload(b, a)
    }
};
self.C3.Plugins.Arr.Exps = {
    At(a, b, d) {
        return this.At(a, b || 0, d || 0)
    },
    Width() {
        return this._cx
    },
    Height() {
        return this._cy
    },
    Depth() {
        return this._cz
    },
    CurX() {
        return this._GetForX()
    },
    CurY() {
        return this._GetForY()
    },
    CurZ() {
        return this._GetForZ()
    },
    CurValue() {
        return this.At(this._GetForX(), this._GetForY(), this._GetForZ())
    },
    Front() {
        return this.At(0, 0, 0)
    },
    Back() {
        return this.At(this._cx - 1, 0, 0)
    },
    IndexOf(a) {
        const b = this._arr;
        for (let d = 0, c = this._cx; d < c; ++d)
            if (b[d][0][0] === a)
                return d;
        return -1
    },
    LastIndexOf(a) {
        const b = this._arr;
        for (let d = this._cx - 1; 0 <= d; --d)
            if (b[d][0][0] === a)
                return d;
        return -1
    },
    JoinString(a) {
        let b = [];
        for (let d = 0; d < this._cx; ++d)
            b.push(this.At(d, 0, 0));
        return b.join(a)
    },
    AsJSON() {
        return this.GetAsJsonString()
    }
};
"use strict";
const C3$jscomp$213 = self.C3;
C3$jscomp$213.Plugins.Dictionary = class extends C3$jscomp$213.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$214 = self.C3;
C3$jscomp$214.Plugins.Dictionary.Type = class extends C3$jscomp$214.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$215 = self.C3
  , IInstance$jscomp$4 = self.IInstance;
C3$jscomp$215.Plugins.Dictionary.Instance = class extends C3$jscomp$215.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._data = new Map;
        this._curKey = ""
    }
    Release() {
        this._data.clear();
        super.Release()
    }
    GetAsJsonString() {
        return JSON.stringify({
            c2dictionary: !0,
            data: C3$jscomp$215.MapToObject(this._data)
        })
    }
    GetDataMap() {
        return this._data
    }
    SaveToJson() {
        return C3$jscomp$215.MapToObject(this._data)
    }
    LoadFromJson(a) {
        C3$jscomp$215.ObjectToMap(a, this._data)
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.dictionary.name",
            properties: [{
                name: "plugins.dictionary.debugger.key-count",
                value: this._data.size
            }, ...[...this._data].map(a=>({
                name: "$" + a[0],
                value: a[1],
                onedit: b=>this._data.set(a[0], b)
            }))]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IDictionaryInstance
    }
}
;
const map$jscomp$24 = new WeakMap;
self.IDictionaryInstance = class extends IInstance$jscomp$4 {
    constructor() {
        super();
        map$jscomp$24.set(this, IInstance$jscomp$4._GetInitInst().GetSdkInstance())
    }
    getDataMap() {
        return map$jscomp$24.get(this).GetDataMap()
    }
}
;
const C3$jscomp$216 = self.C3;
C3$jscomp$216.Plugins.Dictionary.Cnds = {
    CompareValue(a, b, d) {
        a = this._data.get(a);
        return "undefined" === typeof a ? !1 : C3$jscomp$216.compare(a, b, d)
    },
    ForEachKey() {
        const a = this._runtime
          , b = a.GetEventSheetManager()
          , d = a.GetCurrentEvent()
          , c = d.GetSolModifiers()
          , e = a.GetEventStack()
          , g = e.GetCurrentStackFrame()
          , k = e.Push(d);
        a.SetDebuggingEnabled(!1);
        for (const l of this._data.keys())
            this._curKey = l,
            b.PushCopySol(c),
            d.Retrigger(g, k),
            b.PopSol(c);
        a.SetDebuggingEnabled(!0);
        this._curKey = "";
        e.Pop();
        return !1
    },
    CompareCurrentValue(a, b) {
        const d = this._data.get(this._curKey);
        return "undefined" === typeof d ? !1 : C3$jscomp$216.compare(d, a, b)
    },
    HasKey(a) {
        return this._data.has(a)
    },
    IsEmpty() {
        return 0 === this._data.size
    }
};
const C3$jscomp$217 = self.C3;
C3$jscomp$217.Plugins.Dictionary.Acts = {
    AddKey(a, b) {
        this._data.set(a, b)
    },
    SetKey(a, b) {
        this._data.has(a) && this._data.set(a, b)
    },
    DeleteKey(a) {
        this._data.delete(a)
    },
    Clear() {
        this._data.clear()
    },
    JSONLoad(a) {
        let b = null;
        try {
            b = JSON.parse(a)
        } catch (d) {
            console.error("[Construct] Error parsing JSON: ", d);
            return
        }
        b.c2dictionary && C3$jscomp$217.ObjectToMap(b.data, this._data)
    },
    JSONDownload(a) {
        const b = URL.createObjectURL(new Blob([this.GetAsJsonString()],{
            type: "application/json"
        }));
        this._runtime.InvokeDownload(b, a)
    }
};
self.C3.Plugins.Dictionary.Exps = {
    Get(a) {
        a = this._data.get(a);
        return "undefined" === typeof a ? 0 : a
    },
    GetDefault(a, b) {
        a = this._data.get(a);
        return "undefined" === typeof a ? b : a
    },
    KeyCount() {
        return this._data.size
    },
    CurrentKey() {
        return this._curKey
    },
    CurrentValue() {
        return this._data.get(this._curKey) || 0
    },
    AsJSON() {
        return this.GetAsJsonString()
    }
};
"use strict";
const C3$jscomp$219 = self.C3;
C3$jscomp$219.Plugins.TextBox = class extends C3$jscomp$219.SDKDOMPluginBase {
    constructor(a) {
        super(a, "text-input");
        this.AddElementMessageHandler("click", (b,d)=>b._OnClick(d));
        this.AddElementMessageHandler("dblclick", (b,d)=>b._OnDoubleClick(d));
        this.AddElementMessageHandler("change", (b,d)=>b._OnChange(d))
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$220 = self.C3;
C3$jscomp$220.Plugins.TextBox.Type = class extends C3$jscomp$220.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$221 = self.C3
  , C3X$jscomp$24 = self.C3X
  , elemTypes = "text password email number tel url textarea search".split(" ");
C3$jscomp$221.Plugins.TextBox.Instance = class extends C3$jscomp$221.SDKDOMInstanceBase {
    constructor(a, b) {
        super(a, "text-input");
        this._title = this._placeholder = this._text = "";
        this._isEnabled = !0;
        this._spellCheck = this._isReadOnly = !1;
        this._type = "text";
        this._autoFontSize = !0;
        this._maxLength = -1;
        this._className = this._id = "";
        b && (this._text = b[0],
        this._placeholder = b[1],
        this._title = b[2],
        this.GetWorldInfo().SetVisible(b[3]),
        this._isEnabled = b[4],
        this._isReadOnly = b[5],
        this._spellCheck = b[6],
        this._type = elemTypes[b[7]],
        this._autoFontSize = b[8],
        this._id = b[9],
        this._className = b[10]);
        this.CreateElement({
            type: this._type,
            id: this._id,
            className: this._className
        })
    }
    Release() {
        super.Release()
    }
    GetElementState() {
        return {
            text: this._text,
            placeholder: this._placeholder,
            title: this._title,
            isEnabled: this._isEnabled,
            isReadOnly: this._isReadOnly,
            spellCheck: this._spellCheck,
            maxLength: this._maxLength
        }
    }
    async _OnClick(a) {
        this.DispatchScriptEvent("click", !0);
        await this.TriggerAsync(C3$jscomp$221.Plugins.TextBox.Cnds.OnClicked)
    }
    async _OnDoubleClick(a) {
        this.DispatchScriptEvent("dblclick", !0);
        await this.TriggerAsync(C3$jscomp$221.Plugins.TextBox.Cnds.OnDoubleClicked)
    }
    async _OnChange(a) {
        this._text = a.text;
        this.DispatchScriptEvent("change", !0);
        await this.TriggerAsync(C3$jscomp$221.Plugins.TextBox.Cnds.OnTextChanged)
    }
    _SetText(a) {
        this._text !== a && (this._text = a,
        this.UpdateElementState())
    }
    _GetText() {
        return this._text
    }
    _SetPlaceholder(a) {
        this._placeholder !== a && (this._placeholder = a,
        this.UpdateElementState())
    }
    _GetPlaceholder() {
        return this._placeholder
    }
    _SetTooltip(a) {
        this._title !== a && (this._title = a,
        this.UpdateElementState())
    }
    _GetTooltip() {
        return this._title
    }
    _SetEnabled(a) {
        a = !!a;
        this._isEnabled !== a && (this._isEnabled = a,
        this.UpdateElementState())
    }
    _IsEnabled() {
        return this._isEnabled
    }
    _SetReadOnly(a) {
        a = !!a;
        this._isReadOnly !== a && (this._isReadOnly = a,
        this.UpdateElementState())
    }
    _IsReadOnly() {
        return this._isReadOnly
    }
    _SetMaxLength(a) {
        a = Math.max(+a, -1);
        this._maxLength !== a && (this._maxLength = a,
        this.UpdateElementState())
    }
    _GetMaxLength() {
        return this._maxLength
    }
    _ScrollToBottom() {
        Promise.resolve().then(()=>this.PostToDOMElement("scroll-to-bottom"))
    }
    Draw(a) {}
    SaveToJson() {
        return {
            t: this._text,
            p: this._placeholder,
            ti: this._title,
            e: this._isEnabled,
            r: this._isReadOnly,
            sp: this._spellCheck,
            ml: this._maxLength,
            type: this._type,
            id: this._id
        }
    }
    LoadFromJson(a) {
        this._text = a.t;
        this._placeholder = a.p;
        this._title = a.ti;
        this._isEnabled = a.e;
        this._isReadOnly = a.r;
        this._spellCheck = a.sp;
        this._maxLength = a.hasOwnProperty("ml") ? a.ml : -1;
        this._type = a.type;
        this._id = a.id;
        this.UpdateElementState()
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._text;
        case 1:
            return this._placeholder;
        case 2:
            return this._title;
        case 4:
            return this._isEnabled;
        case 5:
            return this._isReadOnly;
        case 6:
            return this._spellCheck;
        case 8:
            return this._autoFontSize
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            if (this._text === b)
                break;
            this._text = b;
            this.UpdateElementState();
            break;
        case 1:
            if (this._placeholder === b)
                break;
            this._placeholder = b;
            this.UpdateElementState();
            break;
        case 2:
            if (this._title === b)
                break;
            this._title = b;
            this.UpdateElementState();
            break;
        case 4:
            if (this._isEnabled === !!b)
                break;
            this._isEnabled = !!b;
            this.UpdateElementState();
            break;
        case 5:
            if (this._isReadOnly === !!b)
                break;
            this._isReadOnly = !!b;
            this.UpdateElementState();
            break;
        case 6:
            if (this._spellCheck === !!b)
                break;
            this._spellCheck = !!b;
            this.UpdateElementState();
            break;
        case 8:
            this._autoFontSize = !!b
        }
    }
    GetDebuggerProperties() {
        const a = C3$jscomp$221.Plugins.TextBox.Acts;
        return [{
            title: "plugins.textbox.name",
            properties: [{
                name: "plugins.textbox.properties.text.name",
                value: this._text,
                onedit: b=>this.CallAction(a.SetText, b)
            }, {
                name: "plugins.textbox.properties.enabled.name",
                value: this._isEnabled,
                onedit: b=>this.CallAction(a.SetEnabled, b)
            }, {
                name: "plugins.textbox.properties.read-only.name",
                value: this._isReadOnly,
                onedit: b=>this.CallAction(a.SetReadOnly, b)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ITextInputInstance
    }
}
;
const map$jscomp$25 = new WeakMap;
self.ITextInputInstance = class extends self.IDOMInstance {
    constructor() {
        super();
        map$jscomp$25.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    set text(a) {
        C3X$jscomp$24.RequireString(a);
        map$jscomp$25.get(this)._SetText(a)
    }
    get text() {
        return map$jscomp$25.get(this)._GetText()
    }
    set placeholder(a) {
        C3X$jscomp$24.RequireString(a);
        map$jscomp$25.get(this)._SetPlaceholder(a)
    }
    get placeholder() {
        return map$jscomp$25.get(this)._GetPlaceholder()
    }
    set tooltip(a) {
        C3X$jscomp$24.RequireString(a);
        map$jscomp$25.get(this)._SetTooltip(a)
    }
    get tooltip() {
        return map$jscomp$25.get(this)._GetTooltip()
    }
    set isEnabled(a) {
        map$jscomp$25.get(this)._SetEnabled(a)
    }
    get isEnabled() {
        return map$jscomp$25.get(this)._IsEnabled()
    }
    set isReadOnly(a) {
        map$jscomp$25.get(this)._SetReadOnly(a)
    }
    get isReadOnly() {
        return map$jscomp$25.get(this)._IsReadOnly()
    }
    set maxLength(a) {
        C3X$jscomp$24.RequireFiniteNumber(a);
        map$jscomp$25.get(this)._SetMaxLength(a)
    }
    get maxLength() {
        return map$jscomp$25.get(this)._GetMaxLength()
    }
    scrollToBottom() {
        map$jscomp$25.get(this)._ScrollToBottom()
    }
}
;
const C3$jscomp$222 = self.C3;
C3$jscomp$222.Plugins.TextBox.Cnds = {
    CompareText(a, b) {
        return 0 === b ? C3$jscomp$222.equalsNoCase(this._text, a) : this._text === a
    },
    OnTextChanged() {
        return !0
    },
    OnClicked() {
        return !0
    },
    OnDoubleClicked() {
        return !0
    }
};
self.C3.Plugins.TextBox.Acts = {
    SetText(a) {
        this._SetText(a.toString())
    },
    AppendText(a) {
        "" !== a && this._SetText(this._GetText() + a)
    },
    SetPlaceholder(a) {
        this._SetPlaceholder(a)
    },
    SetTooltip(a) {
        this._SetTooltip(a)
    },
    SetReadOnly(a) {
        this._SetReadOnly(0 === a)
    },
    ScrollToBottom() {
        this._ScrollToBottom()
    },
    SetMaxLength(a) {
        this._SetMaxLength(a)
    }
};
self.C3.Plugins.TextBox.Exps = {
    Text() {
        return this._GetText()
    },
    MaxLength() {
        return this._GetMaxLength()
    }
};
"use strict";
const C3$jscomp$225 = self.C3;
C3$jscomp$225.Plugins.sliderbar = class extends C3$jscomp$225.SDKDOMPluginBase {
    constructor(a) {
        super(a, "sliderbar");
        this.AddElementMessageHandler("click", (b,d)=>b._OnClick(d));
        this.AddElementMessageHandler("change", (b,d)=>b._OnChange(d));
        this.AddElementMessageHandler("input", (b,d)=>b._OnInput(d))
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$226 = self.C3;
C3$jscomp$226.Plugins.sliderbar.Type = class extends C3$jscomp$226.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$227 = self.C3
  , C3X$jscomp$25 = self.C3X;
C3$jscomp$227.Plugins.sliderbar.Instance = class extends C3$jscomp$227.SDKDOMInstanceBase {
    constructor(a, b) {
        super(a, "sliderbar");
        this._min = this._value = 0;
        this._max = 100;
        this._step = 1;
        this._title = "";
        this._isEnabled = !0;
        this._className = this._id = "";
        b && (this._value = b[0],
        this._min = b[1],
        this._max = b[2],
        this._step = b[3],
        this._title = b[4],
        this.GetWorldInfo().SetVisible(b[5]),
        this._isEnabled = b[6],
        this._id = b[7],
        this._className = b[8]);
        this.CreateElement({
            id: this._id,
            className: this._className
        })
    }
    Release() {
        super.Release()
    }
    GetElementState() {
        return {
            value: this._value,
            min: this._min,
            max: this._max,
            step: this._step,
            title: this._title,
            isEnabled: this._isEnabled
        }
    }
    async _OnClick(a) {
        this.DispatchScriptEvent("click", !0);
        await this.TriggerAsync(C3$jscomp$227.Plugins.sliderbar.Cnds.OnClicked)
    }
    async _OnChange(a) {
        this._value = a.value;
        this.DispatchScriptEvent("change", !0);
        await this.TriggerAsync(C3$jscomp$227.Plugins.sliderbar.Cnds.OnChanged)
    }
    async _OnInput(a) {
        this._value = a.value;
        this.DispatchScriptEvent("input", !0);
        await this.TriggerAsync(C3$jscomp$227.Plugins.sliderbar.Cnds.OnChanging)
    }
    Draw(a) {}
    _SetValue(a) {
        this._value !== a && (this._value = a,
        this.UpdateElementState())
    }
    _GetValue() {
        return this._value
    }
    _SetMaximum(a) {
        this._max !== a && (this._max = a,
        this.UpdateElementState())
    }
    _GetMaximum() {
        return this._max
    }
    _SetMinimum(a) {
        this._min !== a && (this._min = a,
        this.UpdateElementState())
    }
    _GetMinimum() {
        return this._min
    }
    _SetTooltip(a) {
        this._title !== a && (this._title = a,
        this.UpdateElementState())
    }
    _GetTooltip() {
        return this._title
    }
    _SetStep(a) {
        this._step !== a && (this._step = a,
        this.UpdateElementState())
    }
    _GetStep() {
        return this._step
    }
    _SetEnabled(a) {
        a = !!a;
        this._isEnabled !== a && (this._isEnabled = a,
        this.UpdateElementState())
    }
    _IsEnabled() {
        return this._isEnabled
    }
    SaveToJson() {
        return {
            v: this._value,
            min: this._min,
            max: this._max,
            s: this._step,
            t: this._title,
            e: this._isEnabled,
            id: this._id
        }
    }
    LoadFromJson(a) {
        this._value = a.v;
        this._min = a.min;
        this._max = a.max;
        this._step = a.s;
        this._title = a.t;
        this._isEnabled = a.e;
        this._id = a.id;
        this.UpdateElementState()
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._GetValue();
        case 1:
            return this._GetMinimum();
        case 2:
            return this._GetMaximum();
        case 3:
            return this._GetStep();
        case 4:
            return this._GetTooltip();
        case 6:
            return this._IsEnbled()
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetValue(b);
            break;
        case 1:
            this._SetMinimum(b);
            break;
        case 2:
            this._SetMaximum(b);
            break;
        case 3:
            this._SetStep(b);
            break;
        case 4:
            this._SetTooltip(b);
            break;
        case 6:
            this._SetEnabled(b)
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.sliderbar.name",
            properties: [{
                name: "plugins.sliderbar.properties.value.name",
                value: this._GetValue(),
                onedit: a=>this._SetValue(a)
            }, {
                name: "plugins.sliderbar.properties.minimum.name",
                value: this._GetMinimum(),
                onedit: a=>this._SetMinimum(a)
            }, {
                name: "plugins.sliderbar.properties.maximum.name",
                value: this._GetMaximum(),
                onedit: a=>this._SetMaximum(a)
            }, {
                name: "plugins.sliderbar.properties.step.name",
                value: this._GetStep(),
                onedit: a=>this._SetStep(a)
            }, {
                name: "plugins.sliderbar.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a=>this._SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ISliderBarInstance
    }
}
;
const map$jscomp$26 = new WeakMap;
self.ISliderBarInstance = class extends self.IDOMInstance {
    constructor() {
        super();
        map$jscomp$26.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    set value(a) {
        C3X$jscomp$25.RequireFiniteNumber(a);
        map$jscomp$26.get(this)._SetValue(a)
    }
    get value() {
        return map$jscomp$26.get(this)._GetValue()
    }
    set maximum(a) {
        C3X$jscomp$25.RequireFiniteNumber(a);
        map$jscomp$26.get(this)._SetMaximum(a)
    }
    get maximum() {
        return map$jscomp$26.get(this)._GetMaximum()
    }
    set minimum(a) {
        C3X$jscomp$25.RequireFiniteNumber(a);
        map$jscomp$26.get(this)._SetMinimum(a)
    }
    get minimum() {
        return map$jscomp$26.get(this)._GetMinimum()
    }
    set step(a) {
        C3X$jscomp$25.RequireFiniteNumber(a);
        map$jscomp$26.get(this)._SetStep(a)
    }
    get step() {
        return map$jscomp$26.get(this)._GetStep()
    }
    set tooltip(a) {
        C3X$jscomp$25.RequireString(a);
        map$jscomp$26.get(this)._SetTooltip(a)
    }
    get tooltip() {
        return map$jscomp$26.get(this)._GetTooltip()
    }
    set isEnabled(a) {
        map$jscomp$26.get(this)._SetEnabled(a)
    }
    get isEnabled() {
        return map$jscomp$26.get(this)._IsEnabled()
    }
}
;
const C3$jscomp$228 = self.C3;
C3$jscomp$228.Plugins.sliderbar.Cnds = {
    OnClicked() {
        return !0
    },
    OnChanged() {
        return !0
    },
    OnChanging() {
        return !0
    },
    CompareValue(a, b) {
        return C3$jscomp$228.compare(this._GetValue(), a, b)
    }
};
self.C3.Plugins.sliderbar.Acts = {
    SetTooltip(a) {
        this._SetTooltip(a)
    },
    SetValue(a) {
        this._SetValue(a)
    },
    SetMaximum(a) {
        this._SetMaximum(a)
    },
    SetMinimum(a) {
        this._SetMinimum(a)
    },
    SetStep(a) {
        this._SetStep(a)
    }
};
self.C3.Plugins.sliderbar.Exps = {
    Value() {
        return this._GetValue()
    },
    Maximum() {
        return this._GetMaximum()
    },
    Minimum() {
        return this._GetMinimum()
    },
    Step() {
        return this._GetStep()
    }
};
"use strict";
const C3$jscomp$231 = self.C3;
C3$jscomp$231.Plugins.AJAX = class extends C3$jscomp$231.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$232 = self.C3;
C3$jscomp$232.Plugins.AJAX.Type = class extends C3$jscomp$232.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$233 = self.C3;
C3$jscomp$233.Plugins.AJAX.Instance = class extends C3$jscomp$233.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._lastData = "";
        this._lastStatusCode = 0;
        this._curTag = "";
        this._progress = 0;
        this._timeout = -1;
        this._nextRequestHeaders = new Map;
        this._nextReponseBinaryData = null;
        this._nextRequestOverrideMimeType = "";
        this._nwjsAppFolder = this._nwjsPath = this._nwjsFs = null;
        if (this._isNWjs = "nwjs" === this._runtime.GetExportType())
            this._nwjsFs = require("fs"),
            this._nwjsPath = require("path"),
            this._nwjsAppFolder = this._nwjsPath.dirname((self.process || nw.process).execPath) + "\\"
    }
    Release() {
        super.Release()
    }
    async _TriggerError(a, b, d) {
        console.error(`[Construct] AJAX request to '${b}' (tag '${a}') failed: `, d);
        this._curTag = a;
        await this.TriggerAsync(C3$jscomp$233.Plugins.AJAX.Cnds.OnAnyError);
        this._curTag = a;
        await this.TriggerAsync(C3$jscomp$233.Plugins.AJAX.Cnds.OnError)
    }
    async _TriggerComplete(a) {
        this._curTag = a;
        await this.TriggerAsync(C3$jscomp$233.Plugins.AJAX.Cnds.OnAnyComplete);
        this._curTag = a;
        await this.TriggerAsync(C3$jscomp$233.Plugins.AJAX.Cnds.OnComplete)
    }
    async _OnProgress(a, b) {
        b.lengthComputable && (this._progress = b.loaded / b.total,
        this._curTag = a,
        await this.TriggerAsync(C3$jscomp$233.Plugins.AJAX.Cnds.OnProgress))
    }
    _OnError(a, b, d) {
        if (this._isNWjs) {
            var c = this._nwjsFs
              , e = this._nwjsAppFolder + b;
            c.existsSync(e) ? c.readFile(e, {
                encoding: "utf8"
            }, (g,k)=>{
                g ? this._TriggerError(a, b, g) : (this._lastData = k.replace(/\r\n/g, "\n"),
                this._TriggerComplete(a))
            }
            ) : this._TriggerError(a, b, d)
        } else
            this._TriggerError(a, b, d)
    }
    async _DoCordovaRequest(a, b) {
        const d = this._runtime.GetAssetManager()
          , c = this._nextReponseBinaryData;
        this._nextReponseBinaryData = null;
        try {
            if (c) {
                const e = await d.CordovaFetchLocalFileAsArrayBuffer(b);
                c.SetArrayBufferTransfer(e);
                this._lastData = ""
            } else
                this._lastData = (await d.CordovaFetchLocalFileAsText(b)).replace(/\r\n/g, "\n");
            this._lastStatusCode = 0;
            this._TriggerComplete(a)
        } catch (e) {
            this._TriggerError(a, b, e)
        }
    }
    _DoRequest(a, b, d, c) {
        return new Promise(e=>{
            const g = l=>{
                this._OnError(a, b, l);
                e()
            }
              , k = this._nextReponseBinaryData;
            this._nextReponseBinaryData = null;
            try {
                const l = new XMLHttpRequest;
                l.onreadystatechange = ()=>{
                    if (4 === l.readyState) {
                        this._lastData = k ? "" : (l.responseText || "").replace(/\r\n/g, "\n");
                        this._lastStatusCode = l.status;
                        if (400 <= l.status)
                            this._TriggerError(a, b, l.status + l.statusText);
                        else {
                            const n = this._lastData.length || k && l.response instanceof ArrayBuffer;
                            this._isNWjs && !n || !this._isNWjs && 0 === l.status && !n || (k && k.SetArrayBufferTransfer(l.response),
                            this._TriggerComplete(a))
                        }
                        e()
                    }
                }
                ;
                l.onerror = g;
                l.ontimeout = g;
                l.onabort = g;
                l.onprogress = n=>this._OnProgress(a, n);
                l.open(d, b);
                0 <= this._timeout && "undefined" !== typeof l.timeout && (l.timeout = this._timeout);
                l.responseType = k ? "arraybuffer" : "text";
                c && !this._nextRequestHeaders.has("Content-Type") && ("string" !== typeof c ? l.setRequestHeader("Content-Type", "application/octet-stream") : l.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"));
                for (const [n,p] of this._nextRequestHeaders)
                    try {
                        l.setRequestHeader(n, p)
                    } catch (t) {
                        console.error(`[Construct] AJAX: Failed to set header '${n}: ${p}': `, t)
                    }
                this._nextRequestHeaders.clear();
                if (this._nextRequestOverrideMimeType) {
                    try {
                        l.overrideMimeType(this._nextRequestOverrideMimeType)
                    } catch (n) {
                        console.error("[Construct] AJAX: failed to override MIME type: ", n)
                    }
                    this._nextRequestOverrideMimeType = ""
                }
                c ? l.send(c) : l.send()
            } catch (l) {
                g(l)
            }
        }
        )
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.ajax.debugger.title",
            properties: [{
                name: "plugins.ajax.debugger.last-status-code",
                value: this._lastStatusCode
            }, {
                name: "plugins.ajax.debugger.last-data",
                value: this._lastData
            }]
        }]
    }
    SaveToJson() {
        return {
            lastData: this._lastData,
            lastStatusCode: this._lastStatusCode
        }
    }
    LoadFromJson(a) {
        this._lastData = a.lastData;
        this._lastStatusCode = a.hasOwnProperty("lastStatusCode") ? a.lastStatusCode : 0;
        this._curTag = "";
        this._progress = 0
    }
}
;
const C3$jscomp$234 = self.C3;
C3$jscomp$234.Plugins.AJAX.Cnds = {
    OnComplete(a) {
        return C3$jscomp$234.equalsNoCase(this._curTag, a)
    },
    OnAnyComplete() {
        return !0
    },
    OnError(a) {
        return C3$jscomp$234.equalsNoCase(this._curTag, a)
    },
    OnAnyError() {
        return !0
    },
    OnProgress(a) {
        return C3$jscomp$234.equalsNoCase(this._curTag, a)
    }
};
const C3$jscomp$235 = self.C3;
C3$jscomp$235.Plugins.AJAX.Acts = {
    async Request(a, b) {
        this._runtime.IsCordova() && C3$jscomp$235.IsRelativeURL(b) && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(a, b) : this._runtime.IsPreview() && C3$jscomp$235.IsRelativeURL(b) ? (b = this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(b),
        await this._DoRequest(a, b, "GET", null)) : await this._DoRequest(a, b, "GET", null)
    },
    async RequestFile(a, b) {
        this._runtime.IsCordova() && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(a, b) : await this._DoRequest(a, this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(b), "GET", null)
    },
    async Post(a, b, d, c) {
        await this._DoRequest(a, b, c, d)
    },
    async PostBinary(a, b, d, c) {
        d && (d = d.GetFirstPicked(this._inst)) && (d = d.GetSdkInstance().GetArrayBufferReadOnly(),
        await this._DoRequest(a, b, c, d))
    },
    SetTimeout(a) {
        this._timeout = 1E3 * a
    },
    SetHeader(a, b) {
        this._nextRequestHeaders.set(a, b)
    },
    SetResponseBinary(a) {
        a && (a = a.GetFirstPicked(this._inst)) && (this._nextReponseBinaryData = a.GetSdkInstance())
    },
    OverrideMIMEType(a) {
        this._nextRequestOverrideMimeType = a
    }
};
self.C3.Plugins.AJAX.Exps = {
    LastData() {
        return this._lastData
    },
    LastStatusCode() {
        return this._lastStatusCode
    },
    Progress() {
        return this._progress
    },
    Tag() {
        return this._curTag
    }
};
"use strict";
const C3$jscomp$237 = self.C3
  , actionPromises = [];
C3$jscomp$237.Plugins.Audio = class extends C3$jscomp$237.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    _AddActionPromise(a) {
        actionPromises.push(a)
    }
    static async WaitForAllActionPromises() {
        await Promise.all(actionPromises);
        C3$jscomp$237.clearArray(actionPromises)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$238 = self.C3;
C3$jscomp$238.Plugins.Audio.Type = class extends C3$jscomp$238.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.IAudioObjectType
    }
}
;
function GetAudioDOMInterface() {
    if (self.C3Audio_DOMInterface)
        return self.C3Audio_DOMInterface;
    throw Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
}
self.IAudioObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a)
    }
    get audioContext() {
        return GetAudioDOMInterface().GetAudioContext()
    }
    get destinationNode() {
        return GetAudioDOMInterface().GetDestinationNode()
    }
}
;
const C3$jscomp$239 = self.C3
  , LATENCY_HINTS = ["interactive", "balanced", "playback"];
C3$jscomp$239.Plugins.Audio.Instance = class extends C3$jscomp$239.SDKInstanceBase {
    constructor(a, b) {
        super(a, "audio");
        this._nextPlayTime = 0;
        this._triggerTags = [];
        this._enableMultiTags = !0;
        this._saveLoadMode = this._timeScaleMode = 0;
        this._playInBackground = !1;
        this._distanceModel = this._panningModel = 1;
        this._listenerPos = [this._runtime.GetViewportWidth() / 2, this._runtime.GetViewportHeight() / 2, 600];
        this._listenerForwardVec = [0, 0, -1];
        this._listenerUpVec = [0, 1, 0];
        this._referenceDistance = 600;
        this._maxDistance = 1E4;
        this._rolloffFactor = 1;
        this._listenerInst = null;
        this._loadListenerUid = -1;
        this._masterVolume = 1;
        this._isSilent = !1;
        this._sampleRate = 0;
        this._audioContextState = "suspended";
        this._outputLatency = 0;
        this._effectCount = new Map;
        this._preloadCount = this._preloadTotal = 0;
        this._bufferMetadata = new Map;
        this._remoteUrls = new Map;
        a = "interactive";
        b && (this._timeScaleMode = b[0],
        this._saveLoadMode = b[1],
        this._playInBackground = b[2],
        a = LATENCY_HINTS[b[3]],
        this._enableMultiTags = b[4],
        this._panningModel = b[5],
        this._distanceModel = b[6],
        this._listenerPos[2] = b[7],
        this._referenceDistance = b[8],
        this._maxDistance = b[9],
        this._rolloffFactor = b[10]);
        this._lastAIState = [];
        this._lastFxState = [];
        this._lastAnalysersData = [];
        this.AddDOMMessageHandlers([["state", d=>this._OnUpdateState(d)], ["audiocontext-state", d=>this._OnAudioContextStateChanged(d)], ["fxstate", d=>this._OnUpdateFxState(d)], ["trigger", d=>this._OnTrigger(d)], ["buffer-metadata", d=>this._OnBufferMetadata(d)]]);
        b = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$239.CompositeDisposable(C3$jscomp$239.Disposable.From(b, "instancedestroy", d=>this._OnInstanceDestroyed(d.instance)),C3$jscomp$239.Disposable.From(b, "afterload", ()=>this._OnAfterLoad()),C3$jscomp$239.Disposable.From(b, "suspend", ()=>this._OnSuspend()),C3$jscomp$239.Disposable.From(b, "resume", ()=>this._OnResume()));
        this._runtime.AddLoadPromise(this.PostToDOMAsync("create-audio-context", {
            preloadList: this._runtime.GetAssetManager().GetAudioToPreload().map(d=>({
                originalUrl: d.originalUrl,
                url: d.url,
                type: d.type,
                fileSize: d.fileSize
            })),
            isiOSCordova: this._runtime.IsiOSCordova(),
            isSafari: "Safari" === C3$jscomp$239.Platform.Browser,
            timeScaleMode: this._timeScaleMode,
            latencyHint: a,
            panningModel: this._panningModel,
            distanceModel: this._distanceModel,
            refDistance: this._referenceDistance,
            maxDistance: this._maxDistance,
            rolloffFactor: this._rolloffFactor,
            listenerPos: this._listenerPos
        }).then(d=>{
            this._sampleRate = d.sampleRate;
            this._audioContextState = d.audioContextState;
            this._outputLatency = d.outputLatency
        }
        ));
        this._StartTicking()
    }
    Release() {
        this._listenerInst = null;
        super.Release()
    }
    _SplitTags(a) {
        return this._enableMultiTags ? a.split(" ").filter(b=>!!b) : a ? [a] : []
    }
    _MatchTagLists(a, b) {
        for (const d of b) {
            b = !1;
            for (const c of a)
                if (C3$jscomp$239.equalsNoCase(c, d)) {
                    b = !0;
                    break
                }
            if (!b)
                return !1
        }
        return !0
    }
    _MatchTagListToStr(a, b) {
        return this._MatchTagLists(a, this._SplitTags(b))
    }
    _AddActionPromise(a) {
        this.GetPlugin()._AddActionPromise(a)
    }
    _OnInstanceDestroyed(a) {
        this._listenerInst === a && (this._listenerInst = null)
    }
    DbToLinearNoCap(a) {
        return Math.pow(10, a / 20)
    }
    DbToLinear(a) {
        a = this.DbToLinearNoCap(a);
        return isFinite(a) ? Math.max(Math.min(a, 1), 0) : 0
    }
    LinearToDbNoCap(a) {
        return Math.log(a) / Math.log(10) * 20
    }
    LinearToDb(a) {
        return this.LinearToDbNoCap(Math.max(Math.min(a, 1), 0))
    }
    _OnSuspend() {
        this._playInBackground || this.PostToDOM("set-suspended", {
            isSuspended: !0
        })
    }
    _OnResume() {
        this._playInBackground || this.PostToDOM("set-suspended", {
            isSuspended: !1
        })
    }
    _OnUpdateState(a) {
        const b = a.tickCount;
        this._outputLatency = a.outputLatency;
        const d = this._lastAIState.filter(c=>c.hasOwnProperty("placeholder") && (c.placeholder > b || -1 === c.placeholder));
        this._lastAIState = a.audioInstances;
        this._lastAnalysersData = a.analysers;
        0 < d.length && C3$jscomp$239.appendArray(this._lastAIState, d)
    }
    _OnBufferMetadata(a) {
        this._bufferMetadata.set(a.originalUrl, {
            duration: a.duration
        })
    }
    _OnAudioContextStateChanged(a) {
        this._audioContextState = a.audioContextState
    }
    GetAudioContextState() {
        return this._runtime.IsExportToVideo() ? "running" : this._audioContextState
    }
    _OnUpdateFxState(a) {
        this._lastFxState = a.fxstate
    }
    _GetFirstAudioStateByTags(a) {
        a = this._SplitTags(a);
        for (const b of this._lastAIState)
            if (this._MatchTagLists(b.tags, a))
                return b;
        return null
    }
    _IsTagPlaying(a) {
        const b = this._SplitTags(a);
        return this._lastAIState.some(d=>this._MatchTagLists(d.tags, b) && d.isPlaying)
    }
    _MaybeMarkAsPlaying(a, b, d, c, e) {
        if (this._IsTagPlaying(b))
            return null;
        const g = this._bufferMetadata.get(a);
        a = {
            tags: this._SplitTags(b),
            duration: g ? g.duration : 0,
            volume: e,
            isPlaying: !0,
            playbackTime: 0,
            playbackRate: 1,
            uid: -1,
            bufferOriginalUrl: a,
            bufferUrl: "",
            bufferType: "",
            isMusic: d,
            isLooping: c,
            isMuted: !1,
            resumePosition: 0,
            pan: null,
            placeholder: -1
        };
        this._lastAIState.push(a);
        return a
    }
    async _OnTrigger(a) {
        const b = a.type;
        this._triggerTags = a.tags;
        a = a.aiid;
        if ("ended" === b) {
            for (const d of this._lastAIState)
                if (d.aiid === a) {
                    d.isPlaying = !1;
                    break
                }
            await this.TriggerAsync(C3$jscomp$239.Plugins.Audio.Cnds.OnEnded)
        } else
            "fade-ended" === b && await this.TriggerAsync(C3$jscomp$239.Plugins.Audio.Cnds.OnFadeEnded)
    }
    _MatchTriggerTag(a) {
        return this._MatchTagListToStr(this._triggerTags, a)
    }
    Tick() {
        const a = {
            timeScale: this._runtime.GetTimeScale(),
            gameTime: this._runtime.GetGameTimeRaw(),
            instPans: this.GetInstancePans(),
            tickCount: this._runtime.GetTickCountNoSave()
        };
        if (this._listenerInst) {
            const b = this._listenerInst.GetWorldInfo();
            this._listenerPos[0] = b.GetX();
            this._listenerPos[1] = b.GetY();
            a.listenerPos = this._listenerPos;
            a.listenerOrientation = [...this._listenerForwardVec, ...this._listenerUpVec]
        }
        this.PostToDOM("tick", a)
    }
    rotatePtAround(a, b, d, c, e) {
        if (0 === d)
            return [a, b];
        const g = Math.sin(d);
        d = Math.cos(d);
        a -= c;
        b -= e;
        const k = a * g;
        a = a * d - b * g;
        return [a + c, b * d + k + e]
    }
    GetInstancePans() {
        return this._lastAIState.filter(a=>-1 !== a.uid).map(a=>this._runtime.GetInstanceByUID(a.uid)).filter(a=>a).map(a=>{
            const b = a.GetWorldInfo()
              , d = b.GetLayer().GetAngle()
              , [c,e] = this.rotatePtAround(b.GetX(), b.GetY(), -d, this._listenerPos[0], this._listenerPos[1]);
            return {
                uid: a.GetUID(),
                x: c,
                y: e,
                z: b.GetTotalZElevation(),
                angle: b.GetAngle() - d
            }
        }
        )
    }
    GetAnalyserData(a, b) {
        for (const d of this._lastAnalysersData)
            if (d.index === b && C3$jscomp$239.equalsNoCase(d.tag, a))
                return d;
        return null
    }
    _IncrementEffectCount(a) {
        for (const b of this._SplitTags(a))
            a = b.toLowerCase(),
            this._effectCount.set(a, (this._effectCount.get(a) || 0) + 1)
    }
    _ShouldSave(a) {
        return a.hasOwnProperty("placeholder") || 3 === this._saveLoadMode ? !1 : a.isMusic && 1 === this._saveLoadMode ? !1 : a.isMusic || 2 !== this._saveLoadMode ? !0 : !1
    }
    SaveToJson() {
        return {
            isSilent: this._isSilent,
            masterVolume: this._masterVolume,
            listenerZ: this._listenerPos[2],
            listenerForwardVec: this._listenerForwardVec,
            listenerUpVec: this._listenerUpVec,
            listenerUid: this._listenerInst ? this._listenerInst.GetUID() : -1,
            remoteUrls: [...this._remoteUrls.entries()],
            playing: this._lastAIState.filter(a=>this._ShouldSave(a)),
            effects: this._lastFxState,
            analysers: this._lastAnalysersData
        }
    }
    LoadFromJson(a) {
        this._isSilent = a.isSilent;
        this._masterVolume = a.masterVolume;
        this._listenerPos[2] = a.listenerZ;
        this._listenerInst = null;
        this._loadListenerUid = a.listenerUid;
        a.hasOwnProperty("listenerForwardVec") ? this._listenerForwardVec = a.listenerForwardVec : this._listenerForwardVec = [0, 0, -1];
        a.hasOwnProperty("listenerUpVec") ? this._listenerUpVec = a.listenerUpVec : this._listenerUpVec = [0, 1, 0];
        this._remoteUrls.clear();
        if (a.remoteUrls)
            for (const [b,d] of a.remoteUrls)
                this._remoteUrls.set(b, d);
        this._lastAIState = a.playing;
        for (const b of this._lastAIState)
            b.hasOwnProperty("tag") && !b.hasOwnProperty("tags") && (b.tags = [b.tag].filter(d=>!!d));
        this._lastFxState = a.effects;
        this._lastAnalysersData = a.analysers
    }
    _OnAfterLoad() {
        if (-1 !== this._loadListenerUid && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid),
        this._loadListenerUid = -1,
        this._listenerInst)) {
            var a = this._listenerInst.GetWorldInfo();
            this._listenerPos[0] = a.GetX();
            this._listenerPos[1] = a.GetY()
        }
        for (var b of this._lastAIState)
            (a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b.bufferOriginalUrl)) ? (b.bufferUrl = a.url,
            b.bufferType = a.type) : b.bufferUrl = null;
        for (const d of Object.values(this._lastFxState))
            for (const c of d)
                c.hasOwnProperty("bufferOriginalUrl") && (b = this._runtime.GetAssetManager().GetProjectAudioFileUrl(c.bufferOriginalUrl)) && (c.bufferUrl = b.url,
                c.bufferType = b.type);
        this.PostToDOM("load-state", {
            saveLoadMode: this._saveLoadMode,
            timeScale: this._runtime.GetTimeScale(),
            gameTime: this._runtime.GetGameTimeRaw(),
            listenerPos: this._listenerPos,
            listenerOrientation: [...this._listenerForwardVec, ...this._listenerUpVec],
            isSilent: this._isSilent,
            masterVolume: this._masterVolume,
            playing: this._lastAIState.filter(d=>null !== d.bufferUrl),
            effects: this._lastFxState
        })
    }
    GetDebuggerProperties() {
        const a = [];
        for (const [b,d] of Object.entries(this._lastFxState))
            a.push({
                name: "$" + b,
                value: d.map(c=>c.type).join(", ")
            });
        return [{
            title: "plugins.audio.debugger.tag-effects",
            properties: a
        }, {
            title: "plugins.audio.debugger.currently-playing",
            properties: [{
                name: "plugins.audio.debugger.currently-playing-count",
                value: this._lastAIState.length
            }, ...this._lastAIState.map((b,d)=>({
                name: "$#" + d,
                value: `${b.bufferOriginalUrl} ("${b.tags}") ${Math.round(10 * b.playbackTime) / 10} / ${Math.round(10 * b.duration) / 10}`
            }))]
        }]
    }
}
;
self.C3.Plugins.Audio.Cnds = {
    OnEnded(a) {
        return this._MatchTriggerTag(a)
    },
    OnFadeEnded(a) {
        return this._MatchTriggerTag(a)
    },
    PreloadsComplete() {
        return this._preloadCount === this._preloadTotal
    },
    AdvancedAudioSupported() {
        return !0
    },
    IsSilent() {
        return this._isSilent
    },
    IsAnyPlaying() {
        for (const a of this._lastAIState)
            if (a.isPlaying)
                return !0;
        return !1
    },
    IsTagPlaying(a) {
        return this._IsTagPlaying(a)
    }
};
const C3$jscomp$241 = self.C3
  , FILTER_TYPES = "lowpass highpass bandpass lowshelf highshelf peaking notch allpass".split(" ");
C3$jscomp$241.Plugins.Audio.Acts = {
    Play(a, b, d, c, e) {
        a = C3$jscomp$241.Plugins.Audio.Acts._DoPlay.call(this, a, b, d, c, e);
        this._AddActionPromise(a);
        return a
    },
    PlayFromTimeline(a, b, d, c) {
        C3$jscomp$241.Plugins.Audio.Acts._DoPlay.call(this, a, 0, b, 0, d, c)
    },
    async _DoPlay(a, b, d, c, e, g) {
        if (!this._isSilent) {
            var k = a[1]
              , l = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            if (l) {
                var n = this._nextPlayTime;
                this._nextPlayTime = 0;
                var p = this._MaybeMarkAsPlaying(a[0], e, k, 0 !== b, this.DbToLinear(d));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: a[0],
                        url: l.url,
                        type: l.type,
                        isMusic: k,
                        tags: this._SplitTags(e),
                        isLooping: 0 !== b,
                        vol: this.DbToLinear(d),
                        stereoPan: C3$jscomp$241.clamp(c / 100, -1, 1),
                        pos: g || 0,
                        off: n,
                        trueClock: !!self.C3_GetAudioContextCurrentTime
                    })
                } finally {
                    p && (p.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtPosition(a, b, d, c, e, g, k, l, n, p, t) {
        if (!this._isSilent) {
            var w = a[1]
              , z = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            if (z) {
                var B = this._nextPlayTime;
                this._nextPlayTime = 0;
                var C = this._MaybeMarkAsPlaying(a[0], t, w, 0 !== b, this.DbToLinear(d));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: a[0],
                        url: z.url,
                        type: z.type,
                        isMusic: w,
                        tags: this._SplitTags(t),
                        isLooping: 0 !== b,
                        vol: this.DbToLinear(d),
                        pos: 0,
                        off: B,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: c,
                            y: e,
                            z: g,
                            angle: C3$jscomp$241.toRadians(k),
                            innerAngle: C3$jscomp$241.toRadians(l),
                            outerAngle: C3$jscomp$241.toRadians(n),
                            outerGain: this.DbToLinear(p)
                        }
                    })
                } finally {
                    C && (C.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtObject(a, b, d, c, e, g, k, l) {
        if (!this._isSilent && c && (c = c.GetFirstPicked()) && c.GetWorldInfo()) {
            var n = c.GetWorldInfo()
              , p = n.GetLayer().GetAngle()
              , [t,w] = this.rotatePtAround(n.GetX(), n.GetY(), -p, this._listenerPos[0], this._listenerPos[1])
              , z = a[1]
              , B = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            if (B) {
                var C = this._nextPlayTime;
                this._nextPlayTime = 0;
                var E = this._MaybeMarkAsPlaying(a[0], l, z, 0 !== b, this.DbToLinear(d));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: a[0],
                        url: B.url,
                        type: B.type,
                        isMusic: z,
                        tags: this._SplitTags(l),
                        isLooping: 0 !== b,
                        vol: this.DbToLinear(d),
                        pos: 0,
                        off: C,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: t,
                            y: w,
                            z: n.GetTotalZElevation(),
                            angle: n.GetAngle() - p,
                            innerAngle: C3$jscomp$241.toRadians(e),
                            outerAngle: C3$jscomp$241.toRadians(g),
                            outerGain: this.DbToLinear(k),
                            uid: c.GetUID()
                        }
                    })
                } finally {
                    E && (E.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayByName(a, b, d, c, e, g) {
        if (!this._isSilent) {
            a = 1 === a;
            var k = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
            if (k) {
                var l = this._nextPlayTime;
                this._nextPlayTime = 0;
                var n = this._MaybeMarkAsPlaying(b, g, a, 0 !== d, this.DbToLinear(c));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: b,
                        url: k.url,
                        type: k.type,
                        isMusic: a,
                        tags: this._SplitTags(g),
                        isLooping: 0 !== d,
                        vol: this.DbToLinear(c),
                        stereoPan: C3$jscomp$241.clamp(e / 100, -1, 1),
                        pos: 0,
                        off: l,
                        trueClock: !!self.C3_GetAudioContextCurrentTime
                    })
                } finally {
                    n && (n.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtPositionByName(a, b, d, c, e, g, k, l, n, p, t, w) {
        if (!this._isSilent) {
            a = 1 === a;
            var z = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
            if (z) {
                var B = this._nextPlayTime;
                this._nextPlayTime = 0;
                var C = this._MaybeMarkAsPlaying(b, w, a, 0 !== d, this.DbToLinear(c));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: b,
                        url: z.url,
                        type: z.type,
                        isMusic: a,
                        tags: this._SplitTags(w),
                        isLooping: 0 !== d,
                        vol: this.DbToLinear(c),
                        pos: 0,
                        off: B,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: e,
                            y: g,
                            z: k,
                            angle: C3$jscomp$241.toRadians(l),
                            innerAngle: C3$jscomp$241.toRadians(n),
                            outerAngle: C3$jscomp$241.toRadians(p),
                            outerGain: this.DbToLinear(t)
                        }
                    })
                } finally {
                    C && (C.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtObjectByName(a, b, d, c, e, g, k, l, n) {
        if (!this._isSilent && !this._isSilent && e && (e = e.GetFirstPicked()) && e.GetWorldInfo()) {
            var p = e.GetWorldInfo()
              , t = p.GetLayer().GetAngle()
              , [w,z] = this.rotatePtAround(p.GetX(), p.GetY(), -t, this._listenerPos[0], this._listenerPos[1]);
            a = 1 === a;
            var B = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
            if (B) {
                var C = this._nextPlayTime;
                this._nextPlayTime = 0;
                var E = this._MaybeMarkAsPlaying(b, n, a, 0 !== d, this.DbToLinear(c));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: b,
                        url: B.url,
                        type: B.type,
                        isMusic: a,
                        tags: this._SplitTags(n),
                        isLooping: 0 !== d,
                        vol: this.DbToLinear(c),
                        pos: 0,
                        off: C,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: w,
                            y: z,
                            z: p.GetTotalZElevation(),
                            angle: p.GetAngle() - t,
                            innerAngle: C3$jscomp$241.toRadians(g),
                            outerAngle: C3$jscomp$241.toRadians(k),
                            outerGain: this.DbToLinear(l),
                            uid: e.GetUID()
                        }
                    })
                } finally {
                    E && (E.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    SetLooping(a, b) {
        this.PostToDOM("set-looping", {
            tags: this._SplitTags(a),
            isLooping: 0 === b
        })
    },
    SetMuted(a, b) {
        this.PostToDOM("set-muted", {
            tags: this._SplitTags(a),
            isMuted: 0 === b
        })
    },
    SetVolume(a, b) {
        this.PostToDOM("set-volume", {
            tags: this._SplitTags(a),
            vol: this.DbToLinear(b)
        })
    },
    FadeVolume(a, b, d, c) {
        this.PostToDOM("fade-volume", {
            tags: this._SplitTags(a),
            vol: this.DbToLinear(b),
            duration: d,
            stopOnEnd: 0 === c
        })
    },
    SetStereoPan(a, b) {
        this.PostToDOM("set-stereo-pan", {
            tags: this._SplitTags(a),
            p: C3$jscomp$241.clamp(b / 100, -1, 1)
        })
    },
    async Preload(a) {
        const b = a[1]
          , d = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
        d && (this._preloadTotal++,
        await this.PostToDOMAsync("preload", {
            originalUrl: a[0],
            url: d.url,
            type: d.type,
            isMusic: b
        }),
        this._preloadCount++)
    },
    async PreloadByName(a, b) {
        a = 1 === a;
        const d = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
        d && (this._preloadTotal++,
        await this.PostToDOMAsync("preload", {
            originalUrl: b,
            url: d.url,
            type: d.type,
            isMusic: a
        }),
        this._preloadCount++)
    },
    SetPlaybackRate(a, b) {
        this.PostToDOM("set-playback-rate", {
            tags: this._SplitTags(a),
            rate: Math.max(b, 0)
        })
    },
    Stop(a) {
        this.PostToDOM("stop", {
            tags: this._SplitTags(a)
        })
    },
    StopAll() {
        this.PostToDOM("stop-all")
    },
    SetPaused(a, b) {
        this.PostToDOM("set-paused", {
            tags: this._SplitTags(a),
            paused: 0 === b
        })
    },
    Seek(a, b) {
        this.PostToDOM("seek", {
            tags: this._SplitTags(a),
            pos: b
        })
    },
    SetSilent(a) {
        2 === a && (a = this._isSilent ? 1 : 0);
        a = 0 === a;
        this._isSilent !== a && (this._isSilent = a,
        this.PostToDOM("set-silent", {
            isSilent: a
        }))
    },
    SetMasterVolume(a) {
        a = this.DbToLinear(a);
        this._masterVolume !== a && (this._masterVolume = a,
        this.PostToDOM("set-master-volume", {
            vol: a
        }))
    },
    AddFilterEffect(a, b, d, c, e, g, k) {
        b = FILTER_TYPES[b];
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "filter",
            tags: this._SplitTags(a),
            params: [b, d, c, e, g, C3$jscomp$241.clamp(k / 100, 0, 1)]
        })
    },
    AddDelayEffect(a, b, d, c) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "delay",
            tags: this._SplitTags(a),
            params: [b, this.DbToLinear(d), C3$jscomp$241.clamp(c / 100, 0, 1)]
        })
    },
    AddFlangerEffect(a, b, d, c, e, g) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "flanger",
            tags: this._SplitTags(a),
            params: [b / 1E3, d / 1E3, c, e / 100, C3$jscomp$241.clamp(g / 100, 0, 1)]
        })
    },
    AddPhaserEffect(a, b, d, c, e, g, k) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "phaser",
            tags: this._SplitTags(a),
            params: [b, d, c, e, g, C3$jscomp$241.clamp(k / 100, 0, 1)]
        })
    },
    AddConvolutionEffect(a, b, d, c) {
        const e = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b[0]);
        e && (this._IncrementEffectCount(a),
        this.PostToDOM("add-effect", {
            type: "convolution",
            tags: this._SplitTags(a),
            bufferOriginalUrl: b[0],
            bufferUrl: e.url,
            bufferType: e.type,
            params: [0 === d, C3$jscomp$241.clamp(c / 100, 0, 1)]
        }))
    },
    AddGainEffect(a, b) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "gain",
            tags: this._SplitTags(a),
            params: [this.DbToLinear(b)]
        })
    },
    AddStereoPanEffect(a, b) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "stereopan",
            tags: this._SplitTags(a),
            params: [C3$jscomp$241.clamp(b / 100, -1, 1)]
        })
    },
    AddMuteEffect(a) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "gain",
            tags: this._SplitTags(a),
            params: [0]
        })
    },
    AddTremoloEffect(a, b, d) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "tremolo",
            tags: this._SplitTags(a),
            params: [b, C3$jscomp$241.clamp(d / 100, 0, 1)]
        })
    },
    AddRingModEffect(a, b, d) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "ringmod",
            tags: this._SplitTags(a),
            params: [b, C3$jscomp$241.clamp(d / 100, 0, 1)]
        })
    },
    AddDistortionEffect(a, b, d, c, e, g) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "distortion",
            tags: this._SplitTags(a),
            params: [this.DbToLinearNoCap(b), this.DbToLinearNoCap(d), c, this.DbToLinearNoCap(e), C3$jscomp$241.clamp(g / 100, 0, 1)]
        })
    },
    AddCompressorEffect(a, b, d, c, e, g) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "compressor",
            tags: this._SplitTags(a),
            params: [b, d, c, e / 1E3, g / 1E3]
        })
    },
    AddAnalyserEffect(a, b, d) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "analyser",
            tags: this._SplitTags(a),
            params: [b, d]
        })
    },
    RemoveEffects(a) {
        a = this._SplitTags(a);
        for (const b of a)
            this._effectCount.set(b.toLowerCase(), 0);
        this.PostToDOM("remove-effects", {
            tags: a
        });
        this._lastFxState = {}
    },
    SetEffectParameter(a, b, d, c, e, g) {
        this.PostToDOM("set-effect-param", {
            tags: this._SplitTags(a),
            index: Math.floor(b),
            param: d,
            value: c,
            ramp: e,
            time: g
        })
    },
    SetListenerObject(a) {
        a && (a = a.GetFirstPicked()) && a.GetWorldInfo() && (this._listenerInst = a)
    },
    SetListenerZ(a) {
        this._listenerPos[2] = a
    },
    SetListenerOrientation(a, b, d, c, e, g) {
        this._listenerForwardVec[0] = a;
        this._listenerForwardVec[1] = b;
        this._listenerForwardVec[2] = -d;
        this._listenerUpVec[0] = c;
        this._listenerUpVec[1] = e;
        this._listenerUpVec[2] = -g
    },
    ScheduleNextPlay(a) {
        this._nextPlayTime = Math.max(a, 0)
    },
    UnloadAudio(a) {
        const b = a[1];
        (a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])) && this.PostToDOM("unload", {
            url: a.url,
            type: a.type,
            isMusic: b
        })
    },
    UnloadAudioByName(a, b) {
        a = 1 === a;
        (b = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase())) && this.PostToDOM("unload", {
            url: b.url,
            type: b.type,
            isMusic: a
        })
    },
    UnloadAll() {
        this.PostToDOM("unload-all")
    },
    AddRemoteURL(a, b, d) {
        this._remoteUrls.set(d.toLowerCase(), {
            url: a,
            type: b
        })
    }
};
self.C3.Plugins.Audio.Exps = {
    Duration(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? a.duration : 0
    },
    PlaybackTime(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? a.playbackTime : 0
    },
    PlaybackRate(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? a.playbackRate : 0
    },
    Volume(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? this.LinearToDb(a.volume) : 0
    },
    MasterVolume() {
        return this.LinearToDb(this._masterVolume)
    },
    EffectCount(a) {
        return this._effectCount.get(a.toLowerCase()) || 0
    },
    AnalyserFreqBinCount(a, b) {
        return (a = this.GetAnalyserData(a, Math.floor(b))) ? a.binCount : 0
    },
    AnalyserFreqBinAt(a, b, d) {
        a = this.GetAnalyserData(a, Math.floor(b));
        if (!a)
            return 0;
        d = Math.floor(d);
        return 0 > d || d >= a.binCount ? 0 : a.freqBins[d]
    },
    AnalyserPeakLevel(a, b) {
        return (a = this.GetAnalyserData(a, Math.floor(b))) ? a.peak : 0
    },
    AnalyserRMSLevel(a, b) {
        return (a = this.GetAnalyserData(a, Math.floor(b))) ? a.rms : 0
    },
    SampleRate() {
        return this._sampleRate
    },
    CurrentTime() {
        return self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() / 1E3
    },
    OutputLatency() {
        return this._outputLatency
    }
};
"use strict";
const C3$jscomp$243 = self.C3;
C3$jscomp$243.Plugins.Browser = class extends C3$jscomp$243.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$244 = self.C3;
C3$jscomp$244.Plugins.Browser.Type = class extends C3$jscomp$244.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$245 = self.C3;
C3$jscomp$245.Plugins.Browser.Instance = class extends C3$jscomp$245.SDKInstanceBase {
    constructor(a, b) {
        super(a, "browser");
        this._initLocationStr = "";
        this._isOnline = !1;
        this._docTitle = this._referrer = "";
        this._isCookieEnabled = !1;
        this._windowOuterHeight = this._windowOuterWidth = this._screenHeight = this._screenWidth = 0;
        this._isConstructArcade = !1;
        this._cssStyleMap = new Map;
        this.AddDOMMessageHandlers([["online-state", d=>this._OnOnlineStateChanged(d)], ["backbutton", ()=>this._OnBackButton()], ["sw-message", d=>this._OnSWMessage(d)], ["hashchange", d=>this._OnHashChange(d)]]);
        a = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$245.CompositeDisposable(C3$jscomp$245.Disposable.From(a, "afterfirstlayoutstart", ()=>this._OnAfterFirstLayoutStart()),C3$jscomp$245.Disposable.From(a, "window-resize", ()=>this._OnWindowResize()),C3$jscomp$245.Disposable.From(a, "suspend", ()=>this._OnSuspend()),C3$jscomp$245.Disposable.From(a, "resume", ()=>this._OnResume()));
        this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state", {
            exportType: this._runtime.GetExportType()
        }).then(d=>{
            this._initLocationStr = d.location;
            this._isOnline = d.isOnline;
            this._referrer = d.referrer;
            this._docTitle = d.title;
            this._isCookieEnabled = d.isCookieEnabled;
            this._screenWidth = d.screenWidth;
            this._screenHeight = d.screenHeight;
            this._windowOuterWidth = d.windowOuterWidth;
            this._windowOuterHeight = d.windowOuterHeight;
            this._isConstructArcade = d.isConstructArcade
        }
        ))
    }
    Release() {
        super.Release()
    }
    _OnAfterFirstLayoutStart() {
        this.PostToDOM("ready-for-sw-messages")
    }
    async _OnOnlineStateChanged(a) {
        a = !!a.isOnline;
        this._isOnline !== a && ((this._isOnline = a) ? await this.TriggerAsync(C3$jscomp$245.Plugins.Browser.Cnds.OnOnline) : await this.TriggerAsync(C3$jscomp$245.Plugins.Browser.Cnds.OnOffline))
    }
    async _OnWindowResize() {
        await this.TriggerAsync(C3$jscomp$245.Plugins.Browser.Cnds.OnResize)
    }
    _OnSuspend() {
        this.Trigger(C3$jscomp$245.Plugins.Browser.Cnds.OnPageHidden)
    }
    _OnResume() {
        this.Trigger(C3$jscomp$245.Plugins.Browser.Cnds.OnPageVisible)
    }
    async _OnBackButton() {
        await this.TriggerAsync(C3$jscomp$245.Plugins.Browser.Cnds.OnBackButton)
    }
    _OnSWMessage(a) {
        a = a.type;
        "downloading-update" === a ? this.Trigger(C3$jscomp$245.Plugins.Browser.Cnds.OnUpdateFound) : "update-ready" === a || "update-pending" === a ? this.Trigger(C3$jscomp$245.Plugins.Browser.Cnds.OnUpdateReady) : "offline-ready" === a && this.Trigger(C3$jscomp$245.Plugins.Browser.Cnds.OnOfflineReady)
    }
    _OnHashChange(a) {
        this._initLocationStr = a.location;
        this.Trigger(C3$jscomp$245.Plugins.Browser.Cnds.OnHashChange)
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.browser.name",
            properties: [{
                name: "plugins.browser.debugger.user-agent",
                value: navigator.userAgent
            }, {
                name: "plugins.browser.debugger.is-online",
                value: this._isOnline
            }, {
                name: "plugins.browser.debugger.is-fullscreen",
                value: this._runtime.GetCanvasManager().IsDocumentFullscreen()
            }]
        }]
    }
}
;
self.C3.Plugins.Browser.Cnds = {
    IsOnline() {
        return this._isOnline
    },
    OnOnline() {
        return !0
    },
    OnOffline() {
        return !0
    },
    OnResize() {
        return !0
    },
    CookiesEnabled() {
        return this._isCookieEnabled
    },
    IsFullscreen() {
        return this._runtime.GetCanvasManager().IsDocumentFullscreen()
    },
    OnBackButton() {
        return !0
    },
    IsPortraitLandscape(a) {
        const b = this._runtime.GetCanvasManager().GetLastWidth()
          , d = this._runtime.GetCanvasManager().GetLastHeight();
        return (b <= d ? 0 : 1) === a
    },
    OnUpdateFound() {
        return !0
    },
    OnUpdateReady() {
        return !0
    },
    OnOfflineReady() {
        return !0
    },
    OnHashChange() {
        return !0
    },
    PageVisible() {
        return !this._runtime.IsSuspended()
    },
    OnPageHidden() {
        return !0
    },
    OnPageVisible() {
        return !0
    },
    HasJava() {
        return !1
    },
    IsDownloadingUpdate() {
        return !1
    },
    OnMenuButton() {
        return !1
    },
    OnSearchButton() {
        return !1
    },
    IsMetered() {
        return !1
    },
    IsCharging() {
        return !0
    },
    SupportsFullscreen() {
        return !0
    }
};
const C3$jscomp$247 = self.C3
  , ORIENTATIONS = "portrait landscape portrait-primary portrait-secondary landscape-primary landscape-secondary".split(" ");
C3$jscomp$247.Plugins.Browser.Acts = {
    Alert(a) {
        this.PostToDOM("alert", {
            message: a.toString()
        })
    },
    Close() {
        this._isConstructArcade || (this._runtime.IsDebug() ? self.C3Debugger.CloseWindow() : this.PostToDOM("close"))
    },
    Focus() {
        this.PostToDOM("set-focus", {
            isFocus: !0
        })
    },
    Blur() {
        this.PostToDOM("set-focus", {
            isFocus: !1
        })
    },
    GoBack() {
        this._isConstructArcade || this.PostToDOM("navigate", {
            type: "back"
        })
    },
    GoForward() {
        this._isConstructArcade || this.PostToDOM("navigate", {
            type: "forward"
        })
    },
    GoHome() {},
    Reload() {
        this._isConstructArcade || (this._runtime.IsDebug() ? this._runtime.PostToDebugger({
            type: "reload"
        }) : this.PostToDOM("navigate", {
            type: "reload"
        }))
    },
    GoToURL(a, b) {
        this._PostToDOMMaybeSync("navigate", {
            type: "url",
            url: a,
            target: b,
            exportType: this._runtime.GetExportType()
        })
    },
    GoToURLWindow(a, b) {
        this._PostToDOMMaybeSync("navigate", {
            type: "new-window",
            url: a,
            tag: b,
            exportType: this._runtime.GetExportType()
        })
    },
    RequestFullScreen(a, b) {
        2 <= a && (a += 1);
        6 === a && (a = 2);
        1 === a && (a = 0);
        a = C3$jscomp$247.CanvasManager._FullscreenModeNumberToString(a);
        this._runtime.GetCanvasManager().SetDocumentFullscreenMode(a);
        this._PostToDOMMaybeSync("request-fullscreen", {
            navUI: b
        })
    },
    CancelFullScreen() {
        this._PostToDOMMaybeSync("exit-fullscreen")
    },
    Vibrate(a) {
        a = a.split(",");
        for (let b = 0, d = a.length; b < d; ++b)
            a[b] = parseInt(a[b], 10);
        this._PostToDOMMaybeSync("vibrate", {
            pattern: a
        })
    },
    async InvokeDownload(a, b) {
        a && b && (a = await this._runtime.GetAssetManager().GetProjectFileUrl(a),
        this._runtime.InvokeDownload(a, b))
    },
    InvokeDownloadString(a, b, d) {
        d && (a = `data:${b},${encodeURIComponent(a)}`,
        this._runtime.InvokeDownload(a, d))
    },
    ConsoleLog(a, b) {
        b = b.toString();
        0 === a ? console.log(b) : 1 === a ? console.warn(b) : 2 === a && console.error(b)
    },
    ConsoleGroup(a) {
        console.group(a)
    },
    ConsoleGroupEnd() {
        console.groupEnd()
    },
    ExecJs(a) {
        try {
            eval(a)
        } catch (b) {
            console.error("Error executing JavaScript: ", b)
        }
    },
    LockOrientation(a) {
        a = Math.floor(a);
        0 > a || a >= ORIENTATIONS.length || this._PostToDOMMaybeSync("lock-orientation", {
            orientation: ORIENTATIONS[a]
        })
    },
    UnlockOrientation() {
        this._PostToDOMMaybeSync("unlock-orientation")
    },
    LoadStyleSheet(a) {
        this._runtime.GetAssetManager().LoadStyleSheet(a)
    },
    async SetDocumentCSSStyle(a, b, d, c) {
        await this.PostToDOMAsync("set-document-css-style", {
            prop: C3$jscomp$247.CSSToCamelCase(a),
            value: b,
            selector: d,
            "is-all": 0 !== c
        })
    },
    async GetDocumentCSSStyle(a, b, d) {
        a = await this.PostToDOMAsync("get-document-css-style", {
            prop: a,
            selector: b
        });
        a.isOk && this._cssStyleMap.set(d.toLowerCase(), a.result.trim())
    },
    SetHash(a) {
        this.PostToDOM("set-hash", {
            hash: a
        })
    }
};
self.C3.Plugins.Browser.Exps = {
    URL() {
        return this._runtime.IsInWorker() ? this._initLocationStr : location.toString()
    },
    Protocol() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).protocol : location.protocol
    },
    Domain() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).hostname : location.hostname
    },
    Port() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).port : location.port
    },
    PathName() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).pathname : location.pathname
    },
    Hash() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).hash : location.hash
    },
    QueryString() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).search : location.search
    },
    QueryParam(a) {
        const b = this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).search : location.search;
        return (a = RegExp("[?&]" + a + "=([^&]*)").exec(b)) ? decodeURIComponent(a[1].replace(/\+/g, " ")) : ""
    },
    Referrer() {
        return this._referrer
    },
    Title() {
        return this._docTitle
    },
    Language() {
        return navigator.language
    },
    Platform() {
        return navigator.platform
    },
    UserAgent() {
        return navigator.userAgent
    },
    ExecJS(a) {
        let b = 0;
        try {
            b = eval(a)
        } catch (d) {
            console.error("Error executing JavaScript: ", d)
        }
        return "number" === typeof b || "string" === typeof b ? b : "boolean" === typeof b ? b ? 1 : 0 : 0
    },
    CSSStyleValue(a) {
        return this._cssStyleMap.get(a) || ""
    },
    Name() {
        return navigator.appName
    },
    Version() {
        return navigator.appVersion
    },
    Product() {
        return navigator.product
    },
    Vendor() {
        return navigator.vendor
    },
    BatteryLevel() {
        return 1
    },
    BatteryTimeLeft() {
        return Infinity
    },
    Bandwidth() {
        const a = navigator.connection;
        return a ? a.downlink || a.downlinkMax || a.bandwidth || Infinity : Infinity
    },
    ConnectionType() {
        const a = navigator.connection;
        return a ? a.type || "unknown" : "unknown"
    },
    DevicePixelRatio() {
        return self.devicePixelRatio
    },
    ScreenWidth() {
        return this._screenWidth
    },
    ScreenHeight() {
        return this._screenHeight
    },
    WindowInnerWidth() {
        return this._runtime.GetCanvasManager().GetLastWidth()
    },
    WindowInnerHeight() {
        return this._runtime.GetCanvasManager().GetLastHeight()
    },
    WindowOuterWidth() {
        return this._windowOuterWidth
    },
    WindowOuterHeight() {
        return this._windowOuterWidth
    }
};
"use strict";
const C3$jscomp$249 = self.C3;
C3$jscomp$249.Plugins.Keyboard = class extends C3$jscomp$249.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$250 = self.C3;
C3$jscomp$250.Plugins.Keyboard.Type = class extends C3$jscomp$250.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.IKeyboardObjectType
    }
}
;
let keyboardObjectType = null;
function GetKeyboardSdkInstance() {
    return keyboardObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
self.IKeyboardObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a);
        keyboardObjectType = a;
        a.GetRuntime()._GetCommonScriptInterfaces().keyboard = this
    }
    isKeyDown(a) {
        const b = GetKeyboardSdkInstance();
        if ("string" === typeof a)
            return b.IsKeyDown(a);
        if ("number" === typeof a)
            return b.IsKeyCodeDown(a);
        throw new TypeError("expected string or number");
    }
}
;
const C3$jscomp$251 = self.C3;
C3$jscomp$251.Plugins.Keyboard.Instance = class extends C3$jscomp$251.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._keysDownByString = new Set;
        this._keysDownByWhich = new Set;
        this._triggerWhich = 0;
        this._triggerTypedKey = this._triggerString = "";
        a = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$251.CompositeDisposable(C3$jscomp$251.Disposable.From(a, "keydown", d=>this._OnKeyDown(d.data)),C3$jscomp$251.Disposable.From(a, "keyup", d=>this._OnKeyUp(d.data)),C3$jscomp$251.Disposable.From(a, "window-blur", ()=>this._OnWindowOrKeyboardBlur()),C3$jscomp$251.Disposable.From(a, "keyboard-blur", ()=>this._OnWindowOrKeyboardBlur()))
    }
    Release() {
        super.Release()
    }
    _OnKeyDown(a) {
        const b = a.which
          , d = a.code || b.toString();
        a = a.key;
        this._keysDownByString.has(d) || (this._keysDownByString.add(d),
        this._keysDownByWhich.add(b),
        this._triggerString = d,
        this._triggerWhich = b,
        this._triggerTypedKey = a,
        this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnAnyKey),
        this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnKey),
        this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed),
        this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnKeyCode))
    }
    _OnKeyUp(a) {
        const b = a.which
          , d = a.code || b.toString();
        a = a.key;
        this._keysDownByString.delete(d);
        this._keysDownByWhich.delete(b);
        this._triggerString = d;
        this._triggerWhich = b;
        this._triggerTypedKey = a;
        this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnAnyKeyReleased);
        this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnKeyReleased);
        this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased);
        this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnKeyCodeReleased)
    }
    _OnWindowOrKeyboardBlur() {
        for (const a of this._keysDownByWhich)
            this._keysDownByWhich.delete(a),
            this._triggerWhich = a,
            this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnAnyKeyReleased),
            this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnKeyReleased),
            this.Trigger(C3$jscomp$251.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
        this._keysDownByString.clear()
    }
    IsKeyDown(a) {
        return this._keysDownByString.has(a)
    }
    IsKeyCodeDown(a) {
        return this._keysDownByWhich.has(a)
    }
    SaveToJson() {
        return {
            tk: this._triggerWhich,
            tkk: this._triggerTypedKey
        }
    }
    LoadFromJson(a) {
        this._triggerWhich = a.tk;
        a.hasOwnProperty("tkk") && (this._triggerTypedKey = a.tkk)
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.keyboard.name",
            properties: [{
                name: "plugins.keyboard.debugger.last-key-code",
                value: this._triggerWhich
            }, {
                name: "plugins.keyboard.debugger.last-key-string",
                value: C3$jscomp$251.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich)
            }, {
                name: "plugins.keyboard.debugger.last-typed-key",
                value: this._triggerTypedKey
            }]
        }]
    }
}
;
const LEFTRIGHT_KEY_STRINGS = "ShiftLeft ShiftRight ControlLeft ControlRight AltLeft AltRight MetaLeft MetaRight".split(" ");
self.C3.Plugins.Keyboard.Cnds = {
    IsKeyDown(a) {
        return this._keysDownByWhich.has(a)
    },
    OnKey(a) {
        return this._triggerWhich === a
    },
    OnAnyKey() {
        return !0
    },
    OnAnyKeyReleased() {
        return !0
    },
    OnKeyReleased(a) {
        return this._triggerWhich === a
    },
    IsKeyCodeDown(a) {
        a = Math.floor(a);
        return this._keysDownByWhich.has(a)
    },
    OnKeyCode(a) {
        return this._triggerWhich === a
    },
    OnKeyCodeReleased(a) {
        return this._triggerWhich === a
    },
    OnLeftRightKeyPressed(a) {
        return this._triggerString === LEFTRIGHT_KEY_STRINGS[a]
    },
    OnLeftRightKeyReleased(a) {
        return this._triggerString === LEFTRIGHT_KEY_STRINGS[a]
    },
    IsLeftRightKeyDown(a) {
        return this._keysDownByString.has(LEFTRIGHT_KEY_STRINGS[a])
    }
};
self.C3.Plugins.Keyboard.Acts = {};
function StringFromCharCode(a) {
    a = Math.floor(a);
    switch (a) {
    case 8:
        return "backspace";
    case 9:
        return "tab";
    case 13:
        return "enter";
    case 16:
        return "shift";
    case 17:
        return "control";
    case 18:
        return "alt";
    case 19:
        return "pause";
    case 20:
        return "capslock";
    case 27:
        return "esc";
    case 33:
        return "pageup";
    case 34:
        return "pagedown";
    case 35:
        return "end";
    case 36:
        return "home";
    case 37:
        return "\u2190";
    case 38:
        return "\u2191";
    case 39:
        return "\u2192";
    case 40:
        return "\u2193";
    case 45:
        return "insert";
    case 46:
        return "del";
    case 91:
        return "left window key";
    case 92:
        return "right window key";
    case 93:
        return "select";
    case 96:
        return "numpad 0";
    case 97:
        return "numpad 1";
    case 98:
        return "numpad 2";
    case 99:
        return "numpad 3";
    case 100:
        return "numpad 4";
    case 101:
        return "numpad 5";
    case 102:
        return "numpad 6";
    case 103:
        return "numpad 7";
    case 104:
        return "numpad 8";
    case 105:
        return "numpad 9";
    case 106:
        return "numpad *";
    case 107:
        return "numpad +";
    case 109:
        return "numpad -";
    case 110:
        return "numpad .";
    case 111:
        return "numpad /";
    case 112:
        return "F1";
    case 113:
        return "F2";
    case 114:
        return "F3";
    case 115:
        return "F4";
    case 116:
        return "F5";
    case 117:
        return "F6";
    case 118:
        return "F7";
    case 119:
        return "F8";
    case 120:
        return "F9";
    case 121:
        return "F10";
    case 122:
        return "F11";
    case 123:
        return "F12";
    case 144:
        return "numlock";
    case 145:
        return "scroll lock";
    case 186:
        return ";";
    case 187:
        return "=";
    case 188:
        return ",";
    case 189:
        return "-";
    case 190:
        return ".";
    case 191:
        return "/";
    case 192:
        return "'";
    case 219:
        return "[";
    case 220:
        return "\\";
    case 221:
        return "]";
    case 222:
        return "#";
    case 223:
        return "`";
    default:
        return String.fromCharCode(a)
    }
}
self.C3.Plugins.Keyboard.Exps = {
    LastKeyCode() {
        return this._triggerWhich
    },
    StringFromKeyCode(a) {
        return StringFromCharCode(a)
    },
    TypedKey() {
        return this._triggerTypedKey
    }
};
"use strict";
const C3$jscomp$255 = self.C3;
C3$jscomp$255.Plugins.Mouse = class extends C3$jscomp$255.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$256 = self.C3
  , C3X$jscomp$28 = self.C3X;
C3$jscomp$256.Plugins.Mouse.Type = class extends C3$jscomp$256.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.IMouseObjectType
    }
}
;
let mouseObjectType = null;
function GetMouseSdkInstance() {
    return mouseObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
self.IMouseObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a);
        mouseObjectType = a;
        a.GetRuntime()._GetCommonScriptInterfaces().mouse = this
    }
    getMouseX(a) {
        return GetMouseSdkInstance().GetMousePositionForLayer(a)[0]
    }
    getMouseY(a) {
        return GetMouseSdkInstance().GetMousePositionForLayer(a)[1]
    }
    getMousePosition(a) {
        return GetMouseSdkInstance().GetMousePositionForLayer(a)
    }
    isMouseButtonDown(a) {
        return GetMouseSdkInstance().IsMouseButtonDown(a)
    }
    setCursorStyle(a) {
        C3X$jscomp$28.RequireString(a);
        GetMouseSdkInstance().SetCursorStyle(a)
    }
    setCursorObjectClass(a) {
        const b = GetMouseSdkInstance();
        a = b.GetRuntime()._UnwrapIObjectClass(a);
        b.SetCursorObjectClass(a)
    }
}
;
const C3$jscomp$257 = self.C3;
let lastSetCursor = null;
C3$jscomp$257.Plugins.Mouse.Instance = class extends C3$jscomp$257.SDKInstanceBase {
    constructor(a, b) {
        super(a, "mouse");
        this._buttonMap = [!1, !1, !1];
        this._wheelDeltaZ = this._wheelDeltaY = this._wheelDeltaX = this._triggerDir = this._triggerType = this._triggerButton = this._mouseYcanvas = this._mouseXcanvas = 0;
        this._hasPointerLock = !1;
        this._movementY = this._movementX = 0;
        this.AddDOMMessageHandlers([["pointer-lock-change", d=>this._OnPointerLockChange(d)], ["pointer-lock-error", d=>this._OnPointerLockError(d)]]);
        a = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$257.CompositeDisposable(C3$jscomp$257.Disposable.From(a, "pointermove", d=>this._OnPointerMove(d.data)),C3$jscomp$257.Disposable.From(a, "pointerdown", d=>this._OnPointerDown(d.data)),C3$jscomp$257.Disposable.From(a, "pointerup", d=>this._OnPointerUp(d.data)),C3$jscomp$257.Disposable.From(a, "dblclick", d=>this._OnDoubleClick(d.data)),C3$jscomp$257.Disposable.From(a, "wheel", d=>this._OnMouseWheel(d.data)),C3$jscomp$257.Disposable.From(a, "window-blur", ()=>this._OnWindowBlur()))
    }
    Release() {
        super.Release()
    }
    _OnPointerDown(a) {
        "mouse" === a.pointerType && (this._mouseXcanvas = a.pageX - this._runtime.GetCanvasClientX(),
        this._mouseYcanvas = a.pageY - this._runtime.GetCanvasClientY(),
        this._CheckButtonChanges(a.lastButtons, a.buttons))
    }
    _OnPointerMove(a) {
        this._movementX = a.movementX;
        this._movementY = a.movementY;
        this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnMovement);
        this._movementY = this._movementX = 0;
        "mouse" === a.pointerType && (this._mouseXcanvas = a.pageX - this._runtime.GetCanvasClientX(),
        this._mouseYcanvas = a.pageY - this._runtime.GetCanvasClientY(),
        this._CheckButtonChanges(a.lastButtons, a.buttons))
    }
    _OnPointerUp(a) {
        "mouse" === a.pointerType && this._CheckButtonChanges(a.lastButtons, a.buttons)
    }
    _CheckButtonChanges(a, b) {
        this._CheckButtonChange(a, b, 1, 0);
        this._CheckButtonChange(a, b, 4, 1);
        this._CheckButtonChange(a, b, 2, 2)
    }
    _CheckButtonChange(a, b, d, c) {
        !(a & d) && b & d ? this._OnMouseDown(c) : a & d && !(b & d) && this._OnMouseUp(c)
    }
    _OnMouseDown(a) {
        this._buttonMap[a] = !0;
        this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnAnyClick);
        this._triggerButton = a;
        this._triggerType = 0;
        this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnClick);
        this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnObjectClicked)
    }
    _OnMouseUp(a) {
        this._buttonMap[a] && (this._buttonMap[a] = !1,
        this._triggerButton = a,
        this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnRelease))
    }
    _OnDoubleClick(a) {
        this._triggerButton = a.button;
        this._triggerType = 1;
        this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnClick);
        this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnObjectClicked)
    }
    _OnMouseWheel(a) {
        this._triggerDir = 0 > a.deltaY ? 1 : 0;
        this._wheelDeltaX = a.deltaX;
        this._wheelDeltaY = a.deltaY;
        this._wheelDeltaZ = a.deltaZ;
        this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnWheel)
    }
    _OnWindowBlur() {
        for (let a = 0, b = this._buttonMap.length; a < b && this._buttonMap[a]; ++a)
            this._buttonMap[a] = !1,
            this._triggerButton = a,
            this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnRelease)
    }
    GetMousePositionForLayer(a) {
        const b = this._runtime.GetMainRunningLayout()
          , d = this._mouseXcanvas
          , c = this._mouseYcanvas;
        return "undefined" === typeof a ? b.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(d, c) : (a = b.GetLayer(a)) ? a.CanvasCssToLayer(d, c) : [0, 0]
    }
    IsMouseButtonDown(a) {
        a = Math.floor(a);
        return !!this._buttonMap[a]
    }
    _IsMouseOverCanvas() {
        return 0 <= this._mouseXcanvas && 0 <= this._mouseYcanvas && this._mouseXcanvas < this._runtime.GetCanvasCssWidth() && this._mouseYcanvas < this._runtime.GetCanvasCssHeight()
    }
    SetCursorStyle(a) {
        lastSetCursor !== a && (lastSetCursor = a,
        this.PostToDOM("cursor", a))
    }
    async SetCursorObjectClass(a) {
        if (!C3$jscomp$257.Platform.IsMobile && a) {
            var b = a.GetFirstPicked();
            b && (a = b.GetWorldInfo(),
            b = b.GetCurrentImageInfo(),
            a && b && lastSetCursor !== b && (lastSetCursor = b,
            a = `url(${await b.ExtractImageToBlobURL()}) ${Math.round(a.GetOriginX() * b.GetWidth())} ${Math.round(a.GetOriginY() * b.GetHeight())}, auto`,
            this.PostToDOM("cursor", a)))
        }
    }
    _OnPointerLockChange(a) {
        this._UpdatePointerLockState(a["has-pointer-lock"])
    }
    _OnPointerLockError(a) {
        this._UpdatePointerLockState(a["has-pointer-lock"]);
        this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnPointerLockError)
    }
    _UpdatePointerLockState(a) {
        this._hasPointerLock !== a && ((this._hasPointerLock = a) ? this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnPointerLocked) : this.Trigger(C3$jscomp$257.Plugins.Mouse.Cnds.OnPointerUnlocked))
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.mouse.name",
            properties: [{
                name: "plugins.mouse.debugger.absolute-position",
                value: this._mouseXcanvas + "," + this._mouseYcanvas
            }, {
                name: "plugins.mouse.debugger.left-button",
                value: this._buttonMap[0]
            }, {
                name: "plugins.mouse.debugger.middle-button",
                value: this._buttonMap[1]
            }, {
                name: "plugins.mouse.debugger.right-button",
                value: this._buttonMap[2]
            }]
        }, {
            title: "plugins.mouse.debugger.position-on-each-layer",
            properties: this._runtime.GetMainRunningLayout().GetLayers().map(a=>({
                name: "$" + a.GetName(),
                value: a.CanvasCssToLayer(this._mouseXcanvas, this._mouseYcanvas).join(", ")
            }))
        }]
    }
}
;
const C3$jscomp$258 = self.C3;
C3$jscomp$258.Plugins.Mouse.Cnds = {
    OnClick(a, b) {
        return this._triggerButton === a && this._triggerType === b
    },
    OnAnyClick() {
        return !0
    },
    IsButtonDown(a) {
        return this._buttonMap[a]
    },
    OnRelease(a) {
        return this._triggerButton === a
    },
    IsOverObject(a) {
        if (!this._IsMouseOverCanvas())
            return !1;
        const b = this._runtime.GetCurrentCondition().IsInverted()
          , d = this._mouseXcanvas
          , c = this._mouseYcanvas;
        return C3$jscomp$258.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, d, c, b), b)
    },
    OnObjectClicked(a, b, d) {
        if (a !== this._triggerButton || b !== this._triggerType || !this._IsMouseOverCanvas())
            return !1;
        a = this._mouseXcanvas;
        b = this._mouseYcanvas;
        return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(d, a, b, !1)
    },
    OnWheel(a) {
        return 2 === a || this._triggerDir === a
    },
    OnPointerLocked() {
        return !0
    },
    OnPointerUnlocked() {
        return !0
    },
    OnPointerLockError() {
        return !0
    },
    HasPointerLock() {
        return this._hasPointerLock
    },
    OnMovement() {
        return !0
    }
};
const CURSOR_STYLES = "auto pointer text crosshair move help wait none".split(" ");
self.C3.Plugins.Mouse.Acts = {
    SetCursor(a) {
        this.SetCursorStyle(CURSOR_STYLES[a])
    },
    SetCursorSprite(a) {
        this.SetCursorObjectClass(a)
    },
    RequestPointerLock() {
        this._PostToDOMMaybeSync("request-pointer-lock")
    },
    ReleasePointerLock() {
        this.PostToDOM("release-pointer-lock")
    }
};
self.C3.Plugins.Mouse.Exps = {
    X(a) {
        return this.GetMousePositionForLayer(a)[0]
    },
    Y(a) {
        return this.GetMousePositionForLayer(a)[1]
    },
    AbsoluteX() {
        return this._mouseXcanvas
    },
    AbsoluteY() {
        return this._mouseYcanvas
    },
    MovementX() {
        return this._movementX
    },
    MovementY() {
        return this._movementY
    },
    WheelDeltaX() {
        return this._wheelDeltaX
    },
    WheelDeltaY() {
        return this._wheelDeltaY
    },
    WheelDeltaZ() {
        return this._wheelDeltaZ
    }
};
"use strict";
const C3$jscomp$261 = self.C3;
C3$jscomp$261.Plugins.Touch = class extends C3$jscomp$261.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$262 = self.C3
  , C3X$jscomp$29 = self.C3X;
C3$jscomp$262.Plugins.Touch.Type = class extends C3$jscomp$262.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
        return self.ITouchObjectType
    }
}
;
let touchObjectType = null;
function GetTouchSdkInstance() {
    return touchObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
self.ITouchObjectType = class extends self.IObjectClass {
    constructor(a) {
        super(a);
        touchObjectType = a;
        a.GetRuntime()._GetCommonScriptInterfaces().touch = this
    }
    requestPermission(a) {
        C3X$jscomp$29.RequireString(a);
        const b = GetTouchSdkInstance();
        if ("orientation" === a)
            return b._RequestPermission(0);
        if ("motion" === a)
            return b._RequestPermission(1);
        throw Error("invalid type");
    }
}
;
const C3$jscomp$263 = self.C3;
C3$jscomp$263.Plugins.Touch.Instance = class extends C3$jscomp$263.SDKInstanceBase {
    constructor(a, b) {
        super(a, "touch");
        this._touches = new Map;
        this._isMouseDown = this._useMouseInput = !1;
        this._getTouchIndex = this._curTouchY = this._curTouchX = this._triggerPermission = this._triggerId = this._triggerIndex = this._accWithGZ = this._accWithGY = this._accWithGX = this._accZ = this._accY = this._accX = this._orientGamma = this._orientBeta = this._orientAlpha = this._orientCompassHeading = 0;
        this._permissionPromises = [];
        b && (this._useMouseInput = b[0]);
        this.AddDOMMessageHandler("permission-result", d=>this._OnPermissionResult(d));
        a = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$263.CompositeDisposable(C3$jscomp$263.Disposable.From(a, "pointerdown", d=>this._OnPointerDown(d.data)),C3$jscomp$263.Disposable.From(a, "pointermove", d=>this._OnPointerMove(d.data)),C3$jscomp$263.Disposable.From(a, "pointerup", d=>this._OnPointerUp(d.data, !1)),C3$jscomp$263.Disposable.From(a, "pointercancel", d=>this._OnPointerUp(d.data, !0)),C3$jscomp$263.Disposable.From(a, "deviceorientation", d=>this._OnDeviceOrientation(d.data)),C3$jscomp$263.Disposable.From(a, "deviceorientationabsolute", d=>this._OnDeviceOrientationAbsolute(d.data)),C3$jscomp$263.Disposable.From(a, "devicemotion", d=>this._OnDeviceMotion(d.data)),C3$jscomp$263.Disposable.From(a, "tick2", d=>this._OnTick2()))
    }
    Release() {
        this._touches.clear();
        super.Release()
    }
    _OnPointerDown(a) {
        if ("mouse" === a.pointerType)
            if (this._useMouseInput)
                this._isMouseDown = !0;
            else
                return;
        const b = a.pointerId;
        if (!this._touches.has(b)) {
            var d = a.pageX - this._runtime.GetCanvasClientX();
            a = a.pageY - this._runtime.GetCanvasClientY();
            var c = performance.now()
              , e = this._touches.size;
            this._triggerIndex = e;
            this._triggerId = b;
            var g = C3$jscomp$263.New(C3$jscomp$263.Plugins.Touch.TouchInfo);
            g.Init(c, d, a, b, e);
            this._touches.set(b, g);
            this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnNthTouchStart);
            this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnTouchStart);
            this._curTouchX = d;
            this._curTouchY = a;
            this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnTouchObject)
        }
    }
    _OnPointerMove(a) {
        if ("mouse" !== a.pointerType || this._isMouseDown) {
            var b = this._touches.get(a.pointerId);
            if (b) {
                var d = performance.now();
                if (!(2 > d - b.GetTime())) {
                    var c = a.pageX - this._runtime.GetCanvasClientX()
                      , e = a.pageY - this._runtime.GetCanvasClientY();
                    b.Update(d, c, e, a.width, a.height, a.pressure)
                }
            }
        }
    }
    _OnPointerUp(a, b) {
        if ("mouse" === a.pointerType)
            if (this._isMouseDown)
                this._isMouseDown = !1;
            else
                return;
        const d = performance.now();
        a = a.pointerId;
        const c = this._touches.get(a);
        c && (this._triggerIndex = c.GetStartIndex(),
        this._triggerId = c.GetId(),
        this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnNthTouchEnd),
        this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnTouchEnd),
        b || (b = c.ShouldTriggerTap(d),
        "single-tap" === b ? (this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnTapGesture),
        this._curTouchX = c.GetX(),
        this._curTouchY = c.GetY(),
        this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnTapGestureObject)) : "double-tap" === b && (this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnDoubleTapGesture),
        this._curTouchX = c.GetX(),
        this._curTouchY = c.GetY(),
        this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnDoubleTapGestureObject))),
        c.Release(),
        this._touches.delete(a))
    }
    _RequestPermission(a) {
        this._PostToDOMMaybeSync("request-permission", {
            type: a
        });
        return new Promise((b,d)=>{
            this._permissionPromises.push({
                type: a,
                resolve: b,
                reject: d
            })
        }
        )
    }
    _OnPermissionResult(a) {
        const b = a.result
          , d = a.type;
        this._triggerPermission = d;
        a = this._permissionPromises.filter(c=>c.type === d);
        for (const c of a)
            c.resolve(b ? "granted" : "denied");
        this._permissionPromises = this._permissionPromises.filter(c=>c.type !== d);
        b ? (this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnPermissionGranted),
        0 === d ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnPermissionDenied)
    }
    _OnDeviceOrientation(a) {
        "number" === typeof a.webkitCompassHeading ? this._orientCompassHeading = a.webkitCompassHeading : a.absolute && (this._orientCompassHeading = a.alpha);
        this._orientAlpha = a.alpha;
        this._orientBeta = a.beta;
        this._orientGamma = a.gamma
    }
    _OnDeviceOrientationAbsolute(a) {
        this._orientCompassHeading = a.alpha
    }
    _OnDeviceMotion(a) {
        const b = a.acceleration;
        b && (this._accX = b.x,
        this._accY = b.y,
        this._accZ = b.z);
        if (a = a.accelerationIncludingGravity)
            this._accWithGX = a.x,
            this._accWithGY = a.y,
            this._accWithGZ = a.z
    }
    _OnTick2() {
        const a = performance.now();
        let b = 0;
        for (const d of this._touches.values())
            d.GetTime() <= a - 50 && d._SetLastTime(a),
            d.ShouldTriggerHold(a) && (this._triggerIndex = d.GetStartIndex(),
            this._triggerId = d.GetId(),
            this._getTouchIndex = b,
            this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnHoldGesture),
            this._curTouchX = d.GetX(),
            this._curTouchY = d.GetY(),
            this.Trigger(C3$jscomp$263.Plugins.Touch.Cnds.OnHoldGestureObject),
            this._getTouchIndex = 0),
            ++b
    }
    _GetTouchByIndex(a) {
        a = Math.floor(a);
        for (const b of this._touches.values()) {
            if (0 === a)
                return b;
            --a
        }
        return null
    }
    _IsClientPosOnCanvas(a, b) {
        return 0 <= a && 0 <= b && a < this._runtime.GetCanvasCssWidth() && b < this._runtime.GetCanvasCssHeight()
    }
    GetDebuggerProperties() {
        return [{
            title: "plugins.touch.debugger.touches",
            properties: [...this._touches.values()].map(a=>({
                name: "$" + a.GetId(),
                value: a.GetX() + ", " + a.GetY()
            }))
        }]
    }
}
;
const C3$jscomp$264 = self.C3
  , tempArr = [];
C3$jscomp$264.Plugins.Touch.Cnds = {
    OnTouchStart() {
        return !0
    },
    OnTouchEnd() {
        return !0
    },
    IsInTouch() {
        return 0 < this._touches.size
    },
    OnTouchObject(a) {
        return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
    },
    IsTouchingObject(a) {
        if (!a)
            return !1;
        const b = new Map
          , d = a.GetCurrentSol();
        var c = d.GetInstances();
        for (const e of c) {
            const g = e.GetWorldInfo()
              , k = g.GetLayer();
            c = k;
            let l = b.get(c);
            "undefined" === typeof l && (l = c.IsSelfAndParentsInteractive(),
            b.set(c, l));
            if (l && g.IsInViewport2())
                for (const n of this._touches.values()) {
                    if (!this._IsClientPosOnCanvas(n.GetX(), n.GetY()))
                        continue;
                    const [p,t] = k.CanvasCssToLayer(n.GetX(), n.GetY(), g.GetTotalZElevation());
                    if (g.ContainsPoint(p, t)) {
                        tempArr.push(e);
                        break
                    }
                }
        }
        b.clear();
        return tempArr.length ? (d.SetArrayPicked(tempArr),
        a.ApplySolToContainer(),
        C3$jscomp$264.clearArray(tempArr),
        !0) : !1
    },
    CompareTouchSpeed(a, b, d) {
        return (a = this._GetTouchByIndex(a)) ? C3$jscomp$264.compare(a.GetSpeed(), b, d) : !1
    },
    OrientationSupported() {
        return !0
    },
    MotionSupported() {
        return !0
    },
    CompareOrientation(a, b, d) {
        this._runtime.RequestDeviceOrientationEvent();
        return C3$jscomp$264.compare(0 === a ? this._orientAlpha : 1 === a ? this._orientBeta : this._orientGamma, b, d)
    },
    CompareAcceleration(a, b, d) {
        this._runtime.RequestDeviceMotionEvent();
        return C3$jscomp$264.compare(0 === a ? this._accWithGX : 1 === a ? this._accWithGY : 2 === a ? this._accWithGZ : 3 === a ? this._accX : 4 === a ? this._accY : this._accZ, b, d)
    },
    OnNthTouchStart(a) {
        a = Math.floor(a);
        return a === this._triggerIndex
    },
    OnNthTouchEnd(a) {
        a = Math.floor(a);
        return a === this._triggerIndex
    },
    HasNthTouch(a) {
        a = Math.floor(a);
        return this._touches.size >= a + 1
    },
    OnHoldGesture() {
        return !0
    },
    OnTapGesture() {
        return !0
    },
    OnDoubleTapGesture() {
        return !0
    },
    OnHoldGestureObject(a) {
        return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
    },
    OnTapGestureObject(a) {
        return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
    },
    OnDoubleTapGestureObject(a) {
        return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
    },
    OnPermissionGranted(a) {
        return this._triggerPermission === a
    },
    OnPermissionDenied(a) {
        return this._triggerPermission === a
    }
};
self.C3.Plugins.Touch.Acts = {
    RequestPermission(a) {
        this._RequestPermission(a)
    }
};
const C3$jscomp$266 = self.C3;
C3$jscomp$266.Plugins.Touch.Exps = {
    TouchCount() {
        return this._touches.size
    },
    X(a) {
        const b = this._GetTouchByIndex(this._getTouchIndex);
        return b ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0) : 0
    },
    Y(a) {
        const b = this._GetTouchByIndex(this._getTouchIndex);
        return b ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1) : 0
    },
    XAt(a, b) {
        return (a = this._GetTouchByIndex(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0) : 0
    },
    YAt(a, b) {
        return (a = this._GetTouchByIndex(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !1) : 0
    },
    XForID(a, b) {
        return (a = this._touches.get(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0) : 0
    },
    YForID(a, b) {
        return (a = this._touches.get(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !1) : 0
    },
    AbsoluteX() {
        const a = this._GetTouchByIndex(0);
        return a ? a.GetX() : 0
    },
    AbsoluteY() {
        const a = this._GetTouchByIndex(0);
        return a ? a.GetY() : 0
    },
    AbsoluteXAt(a) {
        return (a = this._GetTouchByIndex(a)) ? a.GetX() : 0
    },
    AbsoluteYAt(a) {
        return (a = this._GetTouchByIndex(a)) ? a.GetY() : 0
    },
    AbsoluteXForID(a) {
        return (a = this._touches.get(a)) ? a.GetX() : 0
    },
    AbsoluteYForID(a) {
        return (a = this._touches.get(a)) ? a.GetY() : 0
    },
    SpeedAt(a) {
        return (a = this._GetTouchByIndex(a)) ? a.GetSpeed() : 0
    },
    SpeedForID(a) {
        return (a = this._touches.get(a)) ? a.GetSpeed() : 0
    },
    AngleAt(a) {
        return (a = this._GetTouchByIndex(a)) ? C3$jscomp$266.toDegrees(a.GetAngle()) : 0
    },
    AngleForID(a) {
        return (a = this._touches.get(a)) ? C3$jscomp$266.toDegrees(a.GetAngle()) : 0
    },
    CompassHeading() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientCompassHeading
    },
    Alpha() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientAlpha
    },
    Beta() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientBeta
    },
    Gamma() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientGamma
    },
    AccelerationXWithG() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accWithGX
    },
    AccelerationYWithG() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accWithGY
    },
    AccelerationZWithG() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accWithGZ
    },
    AccelerationX() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accX
    },
    AccelerationY() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accY
    },
    AccelerationZ() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accZ
    },
    TouchIndex() {
        return this._triggerIndex
    },
    TouchID() {
        return this._triggerId
    },
    WidthForID(a) {
        return (a = this._touches.get(a)) ? a.GetWidth() : 0
    },
    HeightForID(a) {
        return (a = this._touches.get(a)) ? a.GetHeight() : 0
    },
    PressureForID(a) {
        return (a = this._touches.get(a)) ? a.GetPressure() : 0
    }
};
"use strict";
const C3$jscomp$267 = self.C3;
let lastTapX = -1E3
  , lastTapY = -1E3
  , lastTapTime = -1E4;
C3$jscomp$267.Plugins.Touch.TouchInfo = class extends C3$jscomp$267.DefendedBase {
    constructor() {
        super();
        this._pressure = this._height = this._width = this._lastY = this._lastX = this._y = this._x = this._startY = this._startX = this._lastTime = this._time = this._startTime = this._startIndex = this._pointerId = 0;
        this._isTooFarForHold = this._hasTriggeredHold = !1
    }
    Release() {}
    Init(a, b, d, c, e) {
        this._pointerId = c;
        this._startIndex = e;
        this._startTime = this._lastTime = this._time = a;
        this._startX = b;
        this._startY = d;
        this._x = b;
        this._y = d;
        this._lastX = b;
        this._lastY = d
    }
    Update(a, b, d, c, e, g) {
        this._lastTime = this._time;
        this._time = a;
        this._lastX = this._x;
        this._lastY = this._y;
        this._x = b;
        this._y = d;
        this._width = c;
        this._height = e;
        this._pressure = g;
        !this._isTooFarForHold && 15 <= C3$jscomp$267.distanceTo(this._startX, this._startY, this._x, this._y) && (this._isTooFarForHold = !0)
    }
    GetId() {
        return this._pointerId
    }
    GetStartIndex() {
        return this._startIndex
    }
    GetTime() {
        return this._time
    }
    _SetLastTime(a) {
        this._lastTime = a
    }
    GetX() {
        return this._x
    }
    GetY() {
        return this._y
    }
    GetSpeed() {
        const a = C3$jscomp$267.distanceTo(this._x, this._y, this._lastX, this._lastY)
          , b = (this._time - this._lastTime) / 1E3;
        return 0 < b ? a / b : 0
    }
    GetAngle() {
        return C3$jscomp$267.angleTo(this._lastX, this._lastY, this._x, this._y)
    }
    GetWidth() {
        return this._width
    }
    GetHeight() {
        return this._height
    }
    GetPressure() {
        return this._pressure
    }
    ShouldTriggerHold(a) {
        return this._hasTriggeredHold ? !1 : 500 <= a - this._startTime && !this._isTooFarForHold && 15 > C3$jscomp$267.distanceTo(this._startX, this._startY, this._x, this._y) ? this._hasTriggeredHold = !0 : !1
    }
    ShouldTriggerTap(a) {
        if (this._hasTriggeredHold)
            return "";
        if (333 >= a - this._startTime && !this._isTooFarForHold && 15 > C3$jscomp$267.distanceTo(this._startX, this._startY, this._x, this._y)) {
            if (666 >= a - lastTapTime && 25 > C3$jscomp$267.distanceTo(lastTapX, lastTapY, this._x, this._y))
                return lastTapY = lastTapX = -1E3,
                lastTapTime = -1E4,
                "double-tap";
            lastTapX = this._x;
            lastTapY = this._y;
            lastTapTime = a;
            return "single-tap"
        }
        return ""
    }
    GetPositionForLayer(a, b, d) {
        return "undefined" === typeof b ? a.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(this._x, this._y)[d ? 0 : 1] : (a = a.GetLayer(b)) ? a.CanvasCssToLayer(this._x, this._y)[d ? 0 : 1] : 0
    }
}
;
"use strict";
C3.Plugins.NhutCorp_SlotGenPHP = class extends C3.SDKPluginBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
"use strict";
C3.Plugins.NhutCorp_SlotGenPHP.Type = class extends C3.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
"use strict";
C3.Plugins.NhutCorp_SlotGenPHP.Instance = class extends C3.SDKInstanceBase {
    constructor(a, b) {
        super(a);
        this._defKey = this._apiURL = "";
        this._isLog = !1;
        this._apiFramework = "";
        b && (this._apiURL = b[0],
        this._defKey = b[1],
        this._isLog = b[2],
        this._player = b[3],
        this._apiFramework = b[4]);
        switch (this._apiFramework) {
        case 0:
            this.apiFramework = "laravel";
            break;
        case 1:
            this.apiFramework = "simple-php";
            break;
        case 2:
            this.apiFramework = "static-json"
        }
        a = this.getLaunchIdByUrl();
        this.nRt = this.runtime;
        this.apiURL = this._apiURL;
        this.isLog = this._isLog;
        this.gameId = a ? a : this._defKey;
        this.errorMsgs = [];
        this.UserName = "Guest";
        this.CreditPerLine = this.JackpotSum = this.BetAmount = this.LineNumberNew = this.LineNumber = this.ScatterAmount = this.JackpotAmount = this.WinAmount = this.FreeSpin = this.Credit = 0;
        this.GameTitle = "";
        this.LuckyWheelWin = 0;
        this.LuckyWheelName = "";
        this.DropLineCount = this.HasFreeCredit = this.HasLuckyWheel = this.FreeCreditWin = 0;
        this.DropLineData = [];
        this.Slots = [];
        this.Actives = [];
        this.LineActives = [];
        this.PriceData = [];
        this.IconData = {};
        this.FeatureData = {};
        this.LogData = {};
        this.BuyFeature = this.LogDisplayTotal = this.LogCurrentPage = this.LogPerPage = this.LogTotalPage = this.LogTotalRecord = 0;
        this.WildColumnIcon = "";
        this.BetSize = this.BetLevel = this.BuyLimit = this.BuyFeature = 0;
        this.DropLogData = [];
        this.PreviousSession = null;
        this.WinOnDrop = this.TotalWay = this.Multiply = this.HasSession = 0;
        this.LogHistoryListData = this.LogHistoryListTemplate = this.LogHtmlDetail = this.LogHtmlList = "";
        this.LogEnableLoadMore = this.LogTotalProfit = this.LogTotalBet = 0;
        this.LogHistoryDetailId = this.LogHistoryDetailTemplate = this.LogGameInfoTemplate = "";
        this.LogHistorySlideTotal = 1;
        this.LogHistorySlideTo = 0;
        this.LogHistoryDetailResult = [];
        this.LogHistoryDetailTitle = "";
        this.PendingLoadImgs = [];
        this.PendingCssContent = [];
        this.FreeSpinMode = this.FreeSpinMultiply = this.FreeSpinAmount = 0;
        this.MultiplyList = [];
        this.FreeTotal = 0;
        this.CurrencyDecimal = this.CurrencyThousand = this.CurrencySuffix = this.CurrencyPrefix = "";
        this.BetSizeList = [];
        this.BetSizeTotal = 0;
        var d = this;
        window.addEventListener("beforeunload", c=>{
            c.preventDefault();
            0 < d.FreeSpin && d.GetRuntime()._SaveToJsonString().then(e=>{
                d.remoteData("save_session", function(g, k) {}, {
                    data: e
                })
            }
            );
            c.returnValue = ""
        }
        , !1);
        (window.attachEvent || window.addEventListener)(window.attachEvent ? "onbeforeunload" : "beforeunload", function(c) {
            return (c || window.event).returnValue = "Are you sure to leave the page?"
        })
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {}
    }
    LoadFromJson(a) {}
    remoteData(a, b, d={}) {
        var c = this
          , e = c.apiURL;
        if ("simple-php" == c.apiFramework) {
            var g = "";
            switch (a) {
            case "load_session":
                c.gameId = (new URLSearchParams(window.location.search)).get('token');
                g = "session";
                break;
            case "game_spin":
                g = "spin";
                break;
            case "buy_feature":
                g = "buy";
                break;
            case "load_icon":
                g = "icons";
                break;
            case "load_logs":
                g = "logs";
                break;
            case "save_session":
                g = "save";
                break;
            case "history_list":
                g = "histories"
            }
            var k = d ? d : {};
            k.action = g;
            c.npost(e, k, function(l) {
                console.log("~remoteData " + a, l);
                if (l.success)
                    return b(null, l.data);
                c.ErrorMsg = l.message;
                c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onErrorOccurred);
                return b(l.message, null)
            })
        } else {
            switch (a) {
            case "load_session":
                c.gameId = (new URLSearchParams(window.location.search)).get('token');
                 e = e + "/" + c.gameId + "/session";
                break;
            case "login":
                e += "/signin";
                break;
            case "logout":
                e += "/logout";
                break;
            case "game_spin":
                e = e + "/" + c.gameId + "/spin";
                break;
            case "buy_feature":
                e = e + "/" + c.gameId + "/buy";
                break;
            case "load_icon":
                e = e + "/" + c.gameId + "/icons";
                break;
            case "load_logs":
                e = e + "/" + c.gameId + "/logs";
                break;
            case "check_lucky":
                e += "/checklucky";
                break;
            case "lucky_wheel":
                e += "/luckywheel";
                break;
            case "check_free":
                e += "/checkfree";
                break;
            case "load_pricing":
                e += "/pricing";
                break;
            case "free_credit":
                e += "/freecredit";
                break;
            case "save_session":
                e = e + "/" + c.gameId + "/save";
                break;
            case "history_list":
                e = e + "/" + c.gameId + "/histories";
                break;
            case "history_detail":
                e = e + "/history/" + c.LogHistoryDetailId;
                break;
            case "collect_money":
                e = e + "/" + c.gameId + "/collect";
                break;
            case "bonus_gamble":
                e = e + "/" + c.gameId + "/gamble";
                break;
            case "change_line":
                e = e + "/" + c.gameId + "/linenum";
                break;
            case "change_free":
                e = e + "/" + c.gameId + "/freenum"
            }
            g = null;
            null != d && (g = Object.keys(d).map(function(l) {
                return encodeURIComponent(l) + "=" + encodeURIComponent(d[l])
            }).join("&"));
            c.l("remoteData", e + "?" + g);
            c.njax(e, g, function(l, n, p) {
                if (0 == p)
                    return b("Connection has problem!", null);
                if (null !== l)
                    return b(l, null);
                try {
                    var t = JSON.parse(n);
                    c.l("JSON result", t);
                    if (t.success)
                        return b(null, t.data);
                    if (t.message)
                        return console.log("d.message", t.message),
                        c.errorMsgs = t.message,
                        c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onErrorOccurred),
                        b(t.message, null);
                    c.errorMsgs = t.data ? t.data.message : "Unknow error!";
                    c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onErrorOccurred);
                    return b("JSON data got FAILD status", null)
                } catch (w) {
                    return console.log("e", w),
                    c.errorMsgs = "Can not phrase json for content, please see log",
                    c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onErrorOccurred),
                    c.l("JSON error", n),
                    b("Can not phrase json for content", null)
                }
            })
        }
    }
    njax(a, b, d) {
        var c = this
          , e = window
          , g = (g = e.ActiveXObject) ? new g("Microsoft.XMLHTTP") : (g = e.XMLHttpRequest) ? new g : 0;
        if (g)
            g.onreadystatechange = function() {
                if (4 == g.readyState && d) {
                    if (200 === g.status)
                        return d(null, g.responseText);
                    if (401 === g.status)
                        return localStorage.getItem("token") && localStorage.removeItem("token"),
                        c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onLoginRequire),
                        d("Unauthenticated", null);
                    console.log("njax Error", g.statusText);
                    return d("Ajax error", null)
                }
            }
            ,
            b ? (g.open("POST", a, !0),
            g.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")) : g.open("GET", a, !0),
            a = this._player,
            e = this.getUrlParams(),
            e.token && "" != e.token && (a = e.token),
            a && g.setRequestHeader("X-Ncash-token", a),
            g.setRequestHeader("Accept", "application/json"),
            g.send(b);
        else
            return d("HTTP requests are not supported", null)
    }
    getUrlParams() {
        const a = new URLSearchParams(window.location.search);
        return Object.fromEntries(a.entries())
    }
    getParameterByName(a, b) {
        b || (b = window.location.href);
        a = a.replace(/[\[\]]/g, "\\$&");
        return (a = (new RegExp("[?&]" + a + "(=([^&#]*)|&|#|$)")).exec(b)) ? a[2] ? decodeURIComponent(a[2].replace(/\+/g, " ")) : "" : null
    }
    getLaunchIdByUrl() {
        var a = window.location.pathname.split("/")
          , b = !1;
        if (0 < a.length)
            for (var d = a.length - 1; 0 <= d; d--) {
                var c = a[d];
                /^(?=[a-f\d]{24}$)(\d+[a-f]|[a-f]+\d)/i.test(c) && (b = c)
            }
        return b
    }
    addLog(a, b) {
        "undefined" === typeof this.LogData[a] && (this.LogData[a] = []);
        this.LogData[a].push(b)
    }
    addDropLog(a, b, d) {
        "undefined" === typeof this.DropLogData[a] && (this.DropLogData[a] = []);
        "undefined" === typeof this.DropLogData[a][b] && (this.DropLogData[a][b] = []);
        this.DropLogData[a][b].push(d)
    }
    queueDownloadImgs(a) {
        const b = this;
        var d = b.GetRuntime();
        if ("undefined" !== typeof b.PendingCssContent[a] && "undefined" !== typeof b.PendingLoadImgs[a])
            if (0 < b.PendingLoadImgs[a].length) {
                const g = b.PendingLoadImgs[a].pop();
                d.GetAssetManager().LoadProjectFileUrl(g).then(k=>{
                    fetch(k).then(l=>l.blob()).then(l=>{
                        l = URL.createObjectURL(l);
                        b.PendingCssContent[a] = b.PendingCssContent[a].replace(g, l);
                        b.queueDownloadImgs(a)
                    }
                    ).catch(l=>{
                        alert(`Load image ${g} error!`);
                        console.log(l)
                    }
                    )
                }
                )
            } else {
                d = b.PendingCssContent[a];
                var c = document.head || document.getElementsByTagName("head")[0]
                  , e = document.createElement("style");
                c.appendChild(e);
                e.styleSheet ? e.styleSheet.cssText = d : e.appendChild(document.createTextNode(d));
                C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onGameCssOpen
            }
    }
    l(a, b) {
        this.isLog && console.log(a, b)
    }
    npost(a, b, d) {
        var c = new XMLHttpRequest;
        c.open("POST", a, !0);
        c.setRequestHeader("Content-Type", "application/json");
        c.setRequestHeader("Accept", "application/json");
        a = this._sessionKey;
        var e = this.getUrlParams();
        e.token && "" != e.token && (a = e.token);
        a && c.setRequestHeader("X-Ncash-token", a);
        c.onreadystatechange = function() {
            if (4 === c.readyState && 200 === c.status) {
                var g = JSON.parse(c.responseText);
                d(g)
            }
        }
        ;
        b = JSON.stringify(b);
        c.send(b)
    }
}
;
"use strict";
C3.Plugins.NhutCorp_SlotGenPHP.Cnds = {
    onGameLoaded() {
        return !0
    },
    onIconLoaded() {
        return !0
    },
    onLogLoaded() {
        return !0
    },
    onInfoLoaded() {
        return !0
    },
    onCreditChange() {
        return !0
    },
    onSpinSuccess() {
        return !0
    },
    onLoginSuccess() {
        return !0
    },
    onLoginRequire() {
        return !0
    },
    onLogoutSuccess() {
        return !0
    },
    onWinScatter() {
        return !0
    },
    onWinJackpot() {
        return !0
    },
    onHasFreeCredit() {
        return !0
    },
    onFreeCredit() {
        return !0
    },
    onHasLuckyWheel() {
        return !0
    },
    onLuckyWheel() {
        return !0
    },
    onFreespinOn() {
        return !0
    },
    onErrorOccurred() {
        return !0
    },
    onHistoryListOpen() {
        return !0
    },
    onEnableLoadMore() {
        return !0
    },
    onGameInfoOpen() {
        return !0
    },
    onGamePayoutOpen() {
        return !0
    },
    onHistoryDetailOpen() {
        return !0
    },
    onHistoryEnablePrev() {
        return !0
    },
    onHistoryEnableNext() {
        return !0
    },
    onHistorySlideMove() {
        return !0
    },
    onBonusWin() {
        return !0
    },
    onBonusFinish() {
        return !0
    },
    onSpinWin() {
        return !0
    },
    onCollectFinish() {
        return !0
    },
    onLineNumChange() {
        return !0
    },
    onFreeSpinChange() {
        return !0
    },
    onGameCssOpen() {
        return !0
    }
};
"use strict";
C3.Plugins.NhutCorp_SlotGenPHP.Acts = {
    LoadGame() {
        var a = this;
        a.remoteData("load_session", function(b, d) {
            null === b && (a.UserName = d.user_name,
            a.Credit = d.credit,
            a.FreeSpin = d.free_num,
            a.Multiply = d.multipy ? d.multipy : 0,
            a.FreeSpinAmount = d.free_amount ? d.free_amount : 0,
            a.FreeSpinMultiply = d.free_multi ? d.free_multi : 0,
            a.FreeSpinMode = d.freespin_mode ? d.freespin_mode : 0,
            a.MultiplyList = d.multiple_list ? d.multiple_list : [],
            a.FreeTotal = d.free_total ? d.free_total : 0,
            a.LineNumber = d.num_line,
            a.BetAmount = d.bet_amount,
            a.CreditPerLine = d.credit_line,
            a.BetLevel = d.credit_line,
            a.BetSize = d.bet_amount,
            a.BuyFeature = d.buy_feature,
            a.BuyLimit = d.buy_max,
            a.Slots = d.icon_data,
            a.Actives = d.active_icons,
            a.LineActives = d.active_lines,
            a.FeatureData = d.feature,
            a.TotalWay = d.total_way,
            a.PreviousState = d.game_state ? d.game_state : null,
            a.HasSession = d.previous_session ? 1 : 0,
            a.LineNumberNew = d.line_num,
            a.CurrencyPrefix = d.currency_prefix ? d.currency_prefix : "",
            a.CurrencySuffix = d.currency_suffix ? d.currency_suffix : "",
            a.CurrencyThousand = d.currency_thousand ? d.currency_thousand : "",
            a.CurrencyDecimal = d.currency_decimal ? d.currency_decimal : "",
            a.BetSizeList = d.bet_size_list ? d.bet_size_list : [],
            a.BetSizeTotal = a.BetSizeList.length,
            a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onCreditChange),
            a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onGameLoaded))
        })
    },
    LoadIcon() {
        var a = this;
        a.remoteData("load_icon", function(b, d) {
            null === b && (d.forEach(function(c) {
                a.IconData[c.icon_name] = c
            }),
            a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onIconLoaded))
        })
    },
    LoadLogs() {
        var a = this;
        a.remoteData("load_logs", function(b, d) {
            null === b && (a.LogData = {},
            d.forEach(function(c) {
                var e = c.free_num && 0 < c.free_num ? 1 : 0
                  , g = c.feature_in && 0 < c.feature_in ? 1 : 0
                  , k = c.active_lines ? c.active_lines : []
                  , l = k ? k.length : 0;
                a.addLog("Time", c.spin_date);
                a.addLog("Transaction", c.transaction);
                a.addLog("Bet", c.bet_amount);
                a.addLog("TotalBet", c.total_bet);
                a.addLog("Win", c.win_amount);
                a.addLog("CPL", c.credit_line);
                a.addLog("Profit", c.profit);
                a.addLog("Balance", c.balance);
                a.addLog("FreeSpin", e);
                a.addLog("HasFeature", g);
                a.addLog("Multipy", c.multipy);
                a.addLog("icon_data", c.icon_data);
                a.addLog("TotalLine", l);
                a.addLog("line_data", k);
                a.addLog("BetSize", c.bet_amount);
                a.addLog("BetLevel", c.credit_line);
                a.addLog("TotalWay", c.total_way);
                c = c.drop_line ? c.drop_line : [];
                e = c.length;
                g = [];
                for (k = 0; k < e; k++) {
                    l = c[k];
                    var n = l.ActiveLines ? l.ActiveLines : [];
                    g.push({
                        TotalLine: n.length,
                        line_data: n,
                        icon_data: l.SlotIcons ? l.SlotIcons : []
                    })
                }
                a.addLog("drop_data", g);
                a.addLog("TotalDrop", e)
            }),
            a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onLogLoaded))
        })
    },
    LoadInfo() {
        var a = this;
        a.remoteData("load_info", function(b, d) {
            null === b && (a.JackpotSum = d.jackpot_sum,
            a.CreditPerLine = d.credit_line,
            a.GameTitle = d.title,
            a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onInfoLoaded))
        })
    },
    SpinGame(a, b, d) {
        var c = this;
        a = {
            betamount: a,
            numline: b,
            cpl: d
        };
        c.WinAmount = 0;
        c.JackpotAmount = 0;
        c.ScatterAmount = 0;
        c.WildColumnIcon = "";
        c.Slots = [];
        c.Actives = [];
        c.remoteData("game_spin", function(e, g) {
            null === e && (c.Credit = g.credit,
            c.FreeSpin = g.free_num,
            c.LineNumber = g.num_line,
            c.BetAmount = g.bet_amount,
            c.JackpotAmount = g.jackpot,
            c.ScatterAmount = g.scaler,
            c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onCreditChange),
            g.jackpot && 0 < g.jackpot && c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onWinJackpot),
            e = g.pull,
            c.WinAmount = e.WinAmount,
            c.WinOnDrop = e.WinOnDrop,
            c.Slots = e.SlotIcons,
            c.Actives = e.ActiveIcons,
            c.LineActives = e.ActiveLines,
            c.WildColumnIcon = e.WildColumIcon,
            c.TotalWay = e.TotalWay,
            "undefined" !== typeof e.DropLine && "undefined" !== typeof e.DropLineData && (c.DropLineCount = e.DropLine,
            c.DropLineData = e.DropLineData),
            c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onSpinSuccess),
            1 == g.free_spin && c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onFreespinOn),
            e.HasScatter && c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onWinScatter),
            0 < e.WinAmount && c.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onSpinWin),
            c.PreviousSession = null,
            c.HasSession = 0)
        }, a)
    },
    LoginAPI(a, b) {
        var d = this;
        d.remoteData("login", function(c, e) {
            null === c && (d.Credit = e.credit,
            d.FreeSpin = e.free_num,
            d.LineNumber = e.num_line,
            d.BetAmount = e.bet_amount,
            localStorage.setItem("token", e.session_id),
            d.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onCreditChange),
            d.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onLoginSuccess))
        }, {
            u: a,
            p: b
        })
    },
    LogoutAPI() {
        localStorage.removeItem("token");
        this.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onLogoutSuccess)
    },
    CheckLucky() {
        var a = this;
        a.remoteData("check_lucky", function(b, d) {
            null === b && (a.HasLuckyWheel = parseInt(d),
            a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onHasLuckyWheel))
        })
    },
    LuckyWheel() {
        var a = this;
        a.remoteData("lucky_wheel", function(b, d) {
            null === b && (a.Credit = d.credit,
            0 < d.credit && a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onCreditChange),
            a.LuckyWheelWin = d.win_amount,
            a.LuckyWheelName = d.name,
            a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onLuckyWheel))
        }, {
            post: ""
        })
    },
    CheckFree() {
        var a = this;
        a.remoteData("check_free", function(b, d) {
            null === b && (a.HasFreeCredit = parseInt(d),
            a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onHasFreeCredit))
        })
    },
    FreeCredit() {
        var a = this;
        a.remoteData("free_credit", function(b, d) {
            null === b && (a.Credit = d.credit,
            0 < d.credit && a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onCreditChange),
            a.FreeCreditWin = d.win_amount,
            a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onFreeCredit))
        }, {
            post: ""
        })
    },
    LoadDropLine(a) {
        a = 0 < a ? a - 1 : 0;
        "undefined" !== typeof this.DropLineData[a] && (a = this.DropLineData[a],
        this.Slots = a.SlotIcons,
        this.Actives = a.ActiveIcons,
        this.LineActives = a.ActiveLines,
        this.WinOnDrop = a.WinOnDrop,
        this.TotalWay = a.TotalWay)
    },
    BuyFeature(a, b) {
        var d = this;
        a = {
            betamount: a,
            cpl: b
        };
        d.WinAmount = 0;
        d.JackpotAmount = 0;
        d.ScatterAmount = 0;
        d.WildColumnIcon = "";
        d.Slots = [];
        d.Actives = [];
        d.remoteData("buy_feature", function(c, e) {
            null === c && (d.Credit = e.credit,
            d.FreeSpin = e.free_num,
            d.LineNumber = e.num_line,
            d.BetAmount = e.bet_amount,
            d.JackpotAmount = e.jackpot,
            d.ScatterAmount = e.scaler,
            d.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onCreditChange),
            c = e.pull,
            d.WinAmount = c.WinAmount,
            d.Slots = c.SlotIcons,
            d.Actives = c.ActiveIcons,
            d.LineActives = c.ActiveLines,
            d.WildColumnIcon = c.WildColumIcon,
            "undefined" !== typeof c.DropLine && "undefined" !== typeof c.DropLineData && (d.DropLineCount = c.DropLine,
            d.DropLineData = c.DropLineData),
            d.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onSpinSuccess),
            1 == e.free_spin && d.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onFreespinOn),
            c.HasScatter && d.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onWinScatter))
        }, a)
    },
    LoadGameState() {
        var a = this;
        1 == a.HasSession && null != a.PreviousState ? a.GetRuntime()._DoLoadFromJsonString(a.PreviousState).then(()=>{
            a.l("LoadGameState success", "ok");
            a.PreviousState = null;
            a.HasSession = 0
        }
        ) : a.l("LoadGameState failed", "Session not found")
    },
    LoadHistories(a, b, d, c) {
        var e = this;
        const g = e.LogHistoryListTemplate;
        e.remoteData("history_list", function(k, l) {
            if (null === k) {
                e.LogData = [];
                e.LogTotalRecord = l.totalRecord;
                e.LogPerPage = l.perPage;
                e.LogCurrentPage = l.currentPage;
                e.LogDisplayTotal = l.displayTotal;
                e.LogTotalPage = l.totalPage;
                e.LogTotalBet = l.totalBet;
                e.LogTotalProfit = l.totalProfit;
                e.LogEnableLoadMore = 1 >= l.totalPage || l.currentPage == l.totalPage ? 0 : 1;
                const z = l.items
                  , B = RegExp("\x3c!---START_FEATURE----\x3e(.|\n|s|S)*?\x3c!---END_FEATURE----\x3e", "i")
                  , C = RegExp("\x3c!---START_WINCOUNT----\x3e(.|\n|s|S)*?\x3c!---END_WINCOUNT----\x3e", "i");
                k = "";
                for (l = 0; l < z.length; l++) {
                    var n = z[l]
                      , p = JSON.parse(JSON.stringify(g));
                    p = p.replace("{BGCOLOR}", 0 == l % 2 ? "rgb(52, 52, 63)" : "rgb(48, 48, 60)");
                    p = p.replace("{ID}", n.id);
                    p = p.replace("{Date}", n.spin_date);
                    p = p.replace("{Time}", n.spin_hour);
                    p = p.replace("{Transaction}", n.transaction);
                    p = p.replace("{TotalBet}", n.total_bet);
                    p = p.replace("{Win}", n.win_amount);
                    p = p.replace("{BetSize}", n.credit_line);
                    p = p.replace("{BetLevel}", n.bet_amount);
                    p = p.replace("{Profit}", n.profit);
                    p = p.replace("{Balance}", n.balance);
                    p = p.replace("{FreeSpin}", n.free_num);
                    p = p.replace("{Multipy}", n.multipy);
                    var t = 0 < n.free_num
                      , w = 0 < n.drop_feature || 0 < n.drop_normal;
                    p.match(B) && !t && (p = p.replace(B, ""));
                    if (t = p.match(C))
                        w ? (n = 0 < n.drop_feature ? `${n.drop_normal}+${n.drop_feature}` : `${n.drop_normal}`,
                        w = JSON.parse(JSON.stringify(t[0])),
                        w = w.replace("{WinNote}", n),
                        p = p.replace(C, w)) : p = p.replace(C, "");
                    k += p
                }
                e.LogHistoryListData = k;
                e.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onLogLoaded);
                1 == e.LogEnableLoadMore && e.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onEnableLoadMore)
            }
        }, {
            page: a,
            type: b,
            from: d,
            to: c
        })
    },
    OpenHistoryList(a) {
        var b = this;
        b.GetRuntime().GetAssetManager().LoadProjectFileUrl(a).then(d=>{
            fetch(d).then(c=>c.text()).then(c=>{
                const e = RegExp("\x3c!---START_ITEMS----\x3e(.|\n|s|S)*?\x3c!---END_ITEMS----\x3e", "i")
                  , g = c.match(e);
                g ? (c = c.replace(e, ""),
                b.LogHtmlList = c,
                b.LogHistoryListTemplate = g[0],
                b.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryListOpen)) : (alert(`Load template ${a} failed!`),
                console.log(e))
            }
            ).catch(c=>{
                alert(`Load template ${a} error!`);
                console.log(c)
            }
            )
        }
        )
    },
    OpenGameInfo(a, b) {
        var d = this;
        d.GetRuntime().GetAssetManager().LoadProjectFileUrl(a).then(c=>{
            fetch(c).then(e=>e.text()).then(e=>{
                d.LogGameInfoTemplate = e;
                1 == b ? d.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onGamePayoutOpen) : d.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onGameInfoOpen)
            }
            ).catch(e=>{
                alert(`Load template ${a} error!`);
                console.log(e)
            }
            )
        }
        )
    },
    OpenHistoryDetail(a, b) {
        var d = this
          , c = d.GetRuntime();
        d.LogHistoryDetailId = a;
        d.LogHistorySlideTo = 0;
        d.remoteData("history_detail", function(e, g) {
            d.LogHistoryDetailResult = g.result_data;
            d.LogHistorySlideTotal = g.result_data.length;
            c.GetAssetManager().LoadProjectFileUrl(b).then(k=>{
                fetch(k).then(l=>l.text()).then(l=>{
                    var n = g.result_data[0];
                    d.LogHistoryDetailTitle = n.spin_title;
                    l = l.replace("{LOG_TITLE}", n.spin_title);
                    l = l.replace("{Date}", g.spin_date);
                    l = l.replace("{Time}", g.spin_hour);
                    n = RegExp("\x3c!---START_SAMBLE_BLOCK----\x3e(.|\n|s|S)*?\x3c!---END_SAMBLE_BLOCK----\x3e", "ig");
                    const p = RegExp("-x-(.*?)-xx-", "ig")
                      , t = /\x3c!--[\s\S]*?--\x3e/g
                      , w = RegExp("\x3c!---START_SLIDE_ITEM----\x3e(.|\n|s|S)*?\x3c!---END_SLIDE_ITEM----\x3e", "i")
                      , z = RegExp("\x3c!---START_TEMPLATE_TOP----\x3e(.|\n|s|S)*?\x3c!---END_TEMPLATE_TOP----\x3e", "i")
                      , B = RegExp("\x3c!---START_PLACEHOLDER_TOP----\x3e(.|\n|s|S)*?\x3c!---END_PLACEHOLDER_TOP----\x3e", "ig")
                      , C = RegExp("\x3c!---START_TEMPLATE_BODY----\x3e(.|\n|s|S)*?\x3c!---END_TEMPLATE_BODY----\x3e", "i")
                      , E = RegExp("\x3c!---START_PLACEHOLDER_BODY----\x3e(.|\n|s|S)*?\x3c!---END_PLACEHOLDER_BODY----\x3e", "ig")
                      , F = RegExp("\x3c!---START_FRAME_BODY----\x3e(.|\n|s|S)*?\x3c!---END_FRAME_BODY----\x3e", "i")
                      , J = RegExp("\x3c!---START_BODY_ITEM----\x3e(.|\n|s|S)*?\x3c!---END_BODY_ITEM----\x3e", "i")
                      , K = RegExp("\x3c!---START_PAYOUT_INFO----\x3e(.|\n|s|S)*?\x3c!---END_PAYOUT_INFO----\x3e", "i");
                    var M = l.match(w);
                    if (M) {
                        M = JSON.parse(JSON.stringify(M[0]));
                        M = M.replace(n, "");
                        for (var U = "", X = 0; X < g.result_data.length; X++) {
                            const ia = g.result_data[X];
                            var R = JSON.parse(JSON.stringify(M));
                            R = R.replace("{LEFT}", `${360 * X}px`);
                            R = R.replace("{Transaction}", ia.transaction);
                            R = R.replace("{TotalBet}", ia.total_bet);
                            R = R.replace("{Profit}", ia.profit);
                            R = R.replace("{Balance}", ia.balance);
                            const ja = ia.bet_level
                              , Ba = ia.bet_size;
                            R = R.replace("{LEVEL}", ja);
                            R = R.replace("{SIZE}", Ba);
                            var T = ""
                              , P = R.match(z);
                            if (P) {
                                if (ia.top_reel && 0 < ia.top_reel.length)
                                    for (var fa = 0; fa < ia.top_reel.length; fa++) {
                                        var ba = JSON.parse(JSON.stringify(P[0]));
                                        ba = ba.replace(n, "");
                                        ba = ba.replace(p, "");
                                        var ea = ia.top_reel[fa];
                                        if ("_blank" != ea) {
                                            var da = 3 < ea.length ? `ta-symbols-sprite ${ea}` : `ta-symbols-sprite l_ ${ea}`
                                              , ka = `ta-general-sprite sym_base-block_ ${ea}-block_1x1`;
                                            if ("scatter" == ea || "wild" == ea)
                                                da = `ta-dynamic-symbols-sprite s_ ${ea}`,
                                                ba = ba.replace(B, "");
                                            da = `${da}_1x1`;
                                            ba = ba.replace("{COLUMN}", fa);
                                            ba = ba.replace("{BLOCK-CSS}", ka);
                                            ba = ba.replace("{ICON-CSS}", da);
                                            ba = ba.replace(t, "");
                                            T += ba
                                        }
                                    }
                                T = T.replace(n, "");
                                R = R.replace(z, T)
                            }
                            T = "";
                            var Q = R.match(C);
                            if (Q) {
                                if (ia.reel_data && 0 < ia.reel_data.length)
                                    for (fa = 0; fa < ia.reel_data.length; fa++) {
                                        var xa = ia.reel_data[fa];
                                        ba = JSON.parse(JSON.stringify(Q[0]));
                                        ba = ba.replace(n, "");
                                        ba = ba.replace("{COLUMN}", fa);
                                        const ua = ba.match(J);
                                        if (ua) {
                                            P = "";
                                            for (ea = 0; ea < xa.length; ea++) {
                                                var ca = JSON.parse(JSON.stringify(ua[0]));
                                                ca = ca.replace(p, "");
                                                da = xa[ea];
                                                var ha = (ka = da.includes(":")) ? da.split(":") : []
                                                  , ra = ka ? ha[1] : 1
                                                  , qa = ka ? ha[2] : 0;
                                                const ta = ka ? ha[0] : da;
                                                ha = `ta-general-sprite sym_frame-${2 == qa ? "s_gold" : "s_silver"}_frame_1x ${ra}`;
                                                var ya = !1;
                                                if ("_skip" != ta) {
                                                    const Ca = 42 * ra;
                                                    var za = Ca - 42;
                                                    da = 3 < ta.length ? `ta-symbols-sprite ${ta}` : `ta-symbols-sprite l_ ${ta}`;
                                                    ka = `ta-general-sprite sym_base-block_ ${ta}-block_1x ${ra}`;
                                                    if ("scatter" == ta || "wild" == ta)
                                                        da = `ta-dynamic-symbols-sprite s_ ${ta}`,
                                                        ca = ca.replace(E, ""),
                                                        za = -8,
                                                        ya = !0;
                                                    0 == qa && (ca = ca.replace(F, ""));
                                                    da = ya ? `${da}_1x ${ra}` : `${da}_1x1`;
                                                    ra = `translateY(${za}px)`;
                                                    qa = `style="width: 50px; height: ${Ca}px; z-index: 0;"`;
                                                    ca = ca.replace("{BLOCK-CSS}", ka);
                                                    ca = ca.replace("{ICON-CSS}", da);
                                                    ca = ca.replace("{TRANSLATE}", ra);
                                                    ca = ca.replace("{SIZE-INFO}", qa);
                                                    ca = ca.replace("{FRAME-CSS}", ha);
                                                    ca = ca.replace(t, "");
                                                    P += ca
                                                }
                                            }
                                            ba = ba.replace(n, "");
                                            ba = ba.replace(J, P);
                                            T += ba
                                        }
                                    }
                                R = R.replace(C, T)
                            }
                            R = R.replace("{ROUND_INFO}", ` ${ia.round_name} `);
                            R = R.replace("{MULTIPLY_INFO}", 0 < ia.active_lines.length ? `Win Multiplier x ${ia.active_lines[0].multiply}` : "No Winning Combination");
                            ka = "";
                            if (ba = R.match(K)) {
                                for (fa = 0; fa < ia.active_lines.length; fa++)
                                    P = ia.active_lines[fa],
                                    T = JSON.parse(JSON.stringify(ba[0])),
                                    T = T.replace(p, ""),
                                    da = P.name,
                                    da = 3 < da.length ? `ta-symbols-sprite ${da}` : `ta-symbols-sprite l_ ${da}`,
                                    da = `${da}_1x1`,
                                    ea = `${P.combine} of a Kind`,
                                    ca = `${P.way_243} way(s)`,
                                    Q = d.CurrencyPrefix + "<i></i>" + P.win_amount.toString() + d.CurrencySuffix,
                                    xa = `${(P.payout * P.way_243 * ja * Ba).toFixed(2).replace(/\d(?=(\d{3})+\.)/g, "$&,")} x ${P.multiply}`,
                                    T = T.replace("{ICON-CSS}", da),
                                    T = T.replace("{SYMBOL_TITLE}", ea),
                                    T = T.replace("{SYMBOL_SUB}", ca),
                                    T = T.replace("{PAYOUT_TOTAL}", Q),
                                    T = T.replace("{PAYOUT_DESC}", xa),
                                    T = T.replace("{SIZE}", Ba),
                                    T = T.replace("{LEVEL}", ja),
                                    T = T.replace("{PAYOUT}", P.payout),
                                    T = T.replace("{WAY}", P.way_243),
                                    T = T.replace("{MULTIPLY}", P.multiply),
                                    T = T.replace(t, ""),
                                    ka += T;
                                R = R.replace(K, ka)
                            }
                            U += R
                        }
                        l = l.replace(w, U);
                        l = l.replace(t, "");
                        l = l.replace(n, "");
                        d.LogHistoryDetailTemplate = l;
                        d.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryDetailOpen);
                        1 < d.LogHistorySlideTotal && d.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryEnableNext)
                    } else
                        alert(`Load template ${b} failed!`),
                        console.log(w)
                }
                ).catch(l=>{
                    alert(`Load template ${b} error!`);
                    console.log(l)
                }
                )
            }
            )
        })
    },
    HistorySlideMove(a) {
        1 == a ? this.LogHistorySlideTo++ : 0 < this.LogHistorySlideTo && this.LogHistorySlideTo--;
        this.LogHistorySlideTo < this.LogHistorySlideTotal - 1 && this.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryEnableNext);
        0 < this.LogHistorySlideTo && this.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryEnablePrev);
        this.LogHistoryDetailTitle = this.LogHistoryDetailResult[this.LogHistorySlideTo].spin_title;
        this.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistorySlideMove)
    },
    CollectMoney() {
        var a = this;
        a.remoteData("collect_money", function(b, d) {
            null === b && (a.Credit = d.credit,
            a.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onCollectFinish))
        }, {
            post: ""
        })
    },
    BonusGamble(a) {
        var b = this;
        b.remoteData("bonus_gamble", function(d, c) {
            null === d && (b.WinAmount = c.win_amount,
            c.is_win && b.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onBonusWin),
            c.is_finish && b.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onBonusFinish))
        }, {
            card: a
        })
    },
    ChangeLineNum(a) {
        var b = this;
        b.remoteData("change_line", function(d, c) {
            null === d && (b.LineNumberNew = c.line_num,
            b.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onLineNumChange))
        }, {
            line: a
        })
    },
    ChangeFreeSpin(a) {
        var b = this;
        b.remoteData("change_free", function(d, c) {
            null === d && (b.FreeSpin = c.free_num,
            b.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onFreeSpinChange))
        }, {
            index: a
        })
    },
    OpenGameCss(a) {
        const b = this
          , d = /url\((['"])?(.*?)\1\)/gi;
        b.GetRuntime().GetAssetManager().LoadProjectFileUrl(a).then(c=>{
            fetch(c).then(e=>e.text()).then(e=>{
                b.PendingCssContent[a] = e;
                for (var g = d.exec(e); g; )
                    g = g[2],
                    "undefined" === typeof b.PendingLoadImgs[a] && (b.PendingLoadImgs[a] = []),
                    b.PendingLoadImgs[a].push(g),
                    g = d.exec(e);
                b.queueDownloadImgs(a)
            }
            ).catch(e=>{
                alert(`Load template ${a} error!`);
                console.log(e)
            }
            )
        }
        )
    },
    OpenHistoryNormal(a, b, d, c) {
        var e = this
          , g = e.GetRuntime();
        e.LogHistoryDetailId = a;
        e.LogHistorySlideTo = 0;
        e.remoteData("history_detail", function(k, l) {
            const n = "undefined" !== typeof l.special_symbols ? l.special_symbols : [];
            e.LogHistoryDetailResult = l.result_data;
            e.LogHistorySlideTotal = l.result_data.length;
            g.GetAssetManager().LoadProjectFileUrl(b).then(p=>{
                fetch(p).then(t=>t.text()).then(t=>{
                    var w = l.result_data[0];
                    e.LogHistoryDetailTitle = w.spin_title;
                    t = t.replace("{LOG_TITLE}", w.spin_title);
                    t = t.replace("{Date}", l.spin_date);
                    t = t.replace("{Time}", l.spin_hour);
                    w = RegExp("\x3c!---START_SAMBLE_BLOCK----\x3e(.|\n|s|S)*?\x3c!---END_SAMBLE_BLOCK----\x3e", "ig");
                    const z = RegExp("-x-ICON-CSS-(.*?)-xx-", "ig")
                      , B = RegExp("-x-(.*?)-xx-", "ig")
                      , C = /\x3c!--[\s\S]*?--\x3e/g
                      , E = RegExp("\x3c!---START_SLIDE_ITEM----\x3e(.|\n|s|S)*?\x3c!---END_SLIDE_ITEM----\x3e", "i")
                      , F = RegExp("\x3c!---START_TEMPLATE_BODY----\x3e(.|\n|s|S)*?\x3c!---END_TEMPLATE_BODY----\x3e", "i")
                      , J = RegExp("\x3c!---START_BODY_ITEM----\x3e(.|\n|s|S)*?\x3c!---END_BODY_ITEM----\x3e", "i")
                      , K = RegExp("\x3c!---START_PAYOUT_INFO----\x3e(.|\n|s|S)*?\x3c!---END_PAYOUT_INFO----\x3e", "i");
                    var M = t.match(E);
                    if (M) {
                        M = JSON.parse(JSON.stringify(M[0]));
                        M = M.replace(w, "");
                        for (var U = "", X = -1, R = 0; R < l.result_data.length; R++) {
                            const ja = l.result_data[R];
                            var T = ja.multi_list ? ja.multi_list : [1, 2, 3, 5]
                              , P = JSON.parse(JSON.stringify(M));
                            P = P.replace("{LEFT}", `${360 * R}px`);
                            P = P.replace("{Transaction}", ja.transaction);
                            P = P.replace("{TotalBet}", ja.total_bet);
                            P = P.replace("{Profit}", ja.profit);
                            P = P.replace("{Balance}", ja.balance);
                            const Ba = ja.bet_level
                              , ua = ja.bet_size;
                            P = P.replace("{LEVEL}", Ba);
                            P = P.replace("{SIZE}", ua);
                            var fa = ""
                              , ba = P.match(F);
                            if (ba) {
                                if (ja.reel_data && 0 < ja.reel_data.length)
                                    for (var ea = 0; ea < ja.reel_data.length; ea++) {
                                        var da = ea + 1
                                          , ka = ja.reel_data[ea]
                                          , Q = JSON.parse(JSON.stringify(ba[0]));
                                        Q = Q.replace(w, "");
                                        Q = Q.replace("{COLUMN}", ea);
                                        var xa = Q.match(J);
                                        if (xa) {
                                            for (var ca = "", ha = 0; ha < ka.length; ha++) {
                                                var ra = JSON.parse(JSON.stringify(xa[0]))
                                                  , qa = ka[ha]
                                                  , ya = qa.includes(":")
                                                  , za = ya ? qa.split(":") : []
                                                  , ia = ya ? za[1] : 1;
                                                qa = ya ? za[0] : qa;
                                                ya = 1 == (ya ? za[2] : 0) ? "bottom" : "top";
                                                za = -1 != n.indexOf(qa) ? c : d;
                                                ra = ra.replace(z, "_skip" == qa ? "" : `${za} s_ ${qa} l_ ${ia} f_ ${ya} r_ ${da}`);
                                                ca += ra
                                            }
                                            Q = Q.replace(w, "");
                                            Q = Q.replace(J, ca);
                                            fa += Q
                                        }
                                    }
                                P = P.replace(F, fa)
                            }
                            P = P.replace("{ROUND_INFO}", ` ${ja.round_name} `);
                            fa = 0 < ja.active_lines.length ? ja.active_lines[0].multiply : 0;
                            P = P.replace("{MULTIPLY_INFO}", 0 < fa ? `Win Multiplier x ${fa}` : "");
                            ea = !1;
                            for (Q = 0; Q < T.length; Q++)
                                ca = T[Q],
                                ha = 0 == Q && 0 == fa && -1 == X,
                                ra = ca == X && 0 == fa,
                                ba = ha || ra || fa == ca ? `cb2_number_sprite yellow_ ${ca}` : `cb2_number_sprite grey_ ${ca}`,
                                da = ha || ra || fa == ca ? "cb2_general_sprite red_highlight" : "",
                                ka = Q + 1,
                                P = P.replace(`{MULTIPLY_X_ ${ka}}`, ha || ra || fa == ca ? "cb2_number_sprite yellow_x" : "cb2_number_sprite grey_x"),
                                P = P.replace(`{MULTIPLY_NUMBER_ ${ka}}`, ba),
                                P = P.replace(`{MULTIPLY_HIGHLIGHT_ ${ka}}`, da),
                                fa == ca && (X = T[R >= T.length ? Q : Q + 1],
                                ea = !0);
                            ea || (X = -1);
                            P = P.replace(B, "");
                            T = "";
                            if (ca = P.match(K)) {
                                for (ea = 0; ea < ja.active_lines.length; ea++)
                                    ha = ja.active_lines[ea],
                                    Q = JSON.parse(JSON.stringify(ca[0])),
                                    ra = ha.index,
                                    ba = ha.name,
                                    da = `${-1 != n.indexOf(ba) ? c : d} s_ ${ba}`,
                                    ka = `${ha.combine} of a Kind`,
                                    xa = `${ha.way_243} way(s)`,
                                    ia = e.CurrencyPrefix + "<i></i>" + ha.win_amount.toString() + e.CurrencySuffix,
                                    qa = (ha.payout * ha.way_243 * Ba * ua).toFixed(2).replace(/\d(?=(\d{3})+\.)/g, "$&,"),
                                    qa = 0 < fa ? `${qa}` : `${qa} x ${ha.multiply}`,
                                    Q = Q.replace(z, da),
                                    Q = Q.replace(/{SYMBOL_INDEX}/g, ra),
                                    Q = Q.replace(/{SYMBOL_NAME}/g, ba),
                                    Q = Q.replace("{SYMBOL_TITLE}", ka),
                                    Q = Q.replace("{SYMBOL_SUB}", xa),
                                    Q = Q.replace("{PAYOUT_TOTAL}", ia),
                                    Q = Q.replace("{PAYOUT_DESC}", qa),
                                    Q = Q.replace("{SIZE}", ua),
                                    Q = Q.replace("{LEVEL}", Ba),
                                    Q = Q.replace("{PAYOUT}", ha.payout),
                                    Q = Q.replace("{WAY}", ha.way_243),
                                    Q = Q.replace("{MULTIPLY}", ha.multiply),
                                    Q = Q.replace(C, ""),
                                    T += Q;
                                P = P.replace(K, T)
                            }
                            U += P
                        }
                        t = t.replace(E, U);
                        t = t.replace(C, "");
                        t = t.replace(w, "");
                        e.LogHistoryDetailTemplate = t;
                        e.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryDetailOpen);
                        1 < e.LogHistorySlideTotal && e.Trigger(C3.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryEnableNext)
                    } else
                        alert(`Load template ${b} failed!`),
                        console.log(E)
                }
                ).catch(t=>{
                    alert(`Load template ${b} error!`);
                    console.log(t)
                }
                )
            }
            )
        })
    }
};
"use strict";
C3.Plugins.NhutCorp_SlotGenPHP.Exps = {
    FreeSpin() {
        return "undefined" !== typeof this.FreeSpin ? this.FreeSpin : -1
    },
    LineNumber() {
        return "undefined" !== typeof this.LineNumber ? this.LineNumber : -1
    },
    BetAmount() {
        return "undefined" !== typeof this.BetAmount ? this.BetAmount : -1
    },
    JackpotSum() {
        return "undefined" !== typeof this.JackpotSum ? this.JackpotSum : -1
    },
    CreditPerLine() {
        return "undefined" !== typeof this.CreditPerLine ? this.CreditPerLine : -1
    },
    GameTitle() {
        return "undefined" !== typeof this.GameTitle ? this.GameTitle : ""
    },
    UserName() {
        return "undefined" !== typeof this.UserName ? this.UserName : "Unknow"
    },
    ActiveAt(a) {
        var b = 0;
        if (-1 < a)
            for (var d = 0; d < this.Actives.length; d++)
                if (this.Actives[d] == a + 1) {
                    b = 1;
                    break
                }
        return b
    },
    ActiveByLine(a, b) {
        var d = 0;
        if (-1 < a && -1 < b && "undefined" !== typeof this.LineActives[a]) {
            a = this.LineActives[a].active_icon;
            for (var c = 0; c < a.length; c++)
                if (a[c] == b + 1) {
                    d = 1;
                    break
                }
        }
        return d
    },
    LineActiveAt(a) {
        var b = 0;
        if (0 < a)
            for (var d = 0; d < this.LineActives.length; d++)
                if (this.LineActives[d].index == a) {
                    b = 1;
                    break
                }
        return b
    },
    LineAmountAt(a) {
        var b = 0;
        -1 < a && "undefined" !== typeof this.LineActives[a] && (b = this.LineActives[a].win_amount);
        return b
    },
    LineActiveTotal() {
        return "undefined" !== typeof this.LineActives ? this.LineActives.length : -1
    },
    JackpotAmount() {
        return "undefined" !== typeof this.JackpotAmount ? this.JackpotAmount : -1
    },
    ScatterAmount() {
        return "undefined" !== typeof this.ScatterAmount ? this.ScatterAmount : -1
    },
    LuckyWheelWin() {
        return "undefined" !== typeof this.LuckyWheelWin ? this.LuckyWheelWin : 0
    },
    LuckyWheelName() {
        return "undefined" !== typeof this.LuckyWheelName ? this.LuckyWheelName : ""
    },
    FreeCreditWin() {
        return "undefined" !== typeof this.FreeCreditWin ? this.FreeCreditWin : 0
    },
    Credit() {
        return "undefined" !== typeof this.Credit ? this.Credit : -1
    },
    SlotAt(a) {
        var b = "";
        -1 < a && a < this.Slots.length && (b = this.Slots[a]);
        return b
    },
    WinAmount() {
        return "undefined" !== typeof this.WinAmount ? this.WinAmount : -1
    },
    WildColumnIcon() {
        return "undefined" !== typeof this.WildColumnIcon ? this.WildColumnIcon : ""
    },
    ErrorMsg() {
        return -1 !== this.errorMsgs.indexOf(";;;") ? this.errorMsgs.join(";;;") : this.errorMsgs
    },
    IconWinOf(a, b) {
        var d = -1;
        "undefined" !== typeof this.IconData[a] && "undefined" !== typeof this.IconData[a]["win_" + b] && (d = this.IconData[a]["win_" + b]);
        return d
    },
    IconWildCardOf(a) {
        var b = -1;
        "undefined" !== typeof this.IconData[a] && "undefined" !== typeof this.IconData[a].wild_card && (b = parseInt(this.IconData[a].wild_card));
        return b
    },
    IconFreeSpinOf(a) {
        var b = -1;
        "undefined" !== typeof this.IconData[a] && "undefined" !== typeof this.IconData[a].free_spin && (b = parseInt(this.IconData[a].free_spin));
        return b
    },
    IconFreeNumOf(a) {
        var b = -1;
        "undefined" !== typeof this.IconData[a] && "undefined" !== typeof this.IconData[a].free_num && (b = parseInt(this.IconData[a].free_num));
        return b
    },
    IconScatterSpinOf(a) {
        var b = -1;
        "undefined" !== typeof this.IconData[a] && "undefined" !== typeof this.IconData[a].scaler_spin && (b = parseInt(this.IconData[a].scaler_spin));
        return b
    },
    IconJackpotOf(a) {
        var b = -1;
        "undefined" !== typeof this.IconData[a] && "undefined" !== typeof this.IconData[a].jack_pot && (b = parseInt(this.IconData[a].jack_pot));
        return b
    },
    HistoryOf(a, b) {
        var d = "undefined";
        "undefined" !== typeof this.LogData[a] && "undefined" !== typeof this.LogData[a][b] && (d = this.LogData[a][b]);
        return d
    },
    HistoryIconOf(a, b) {
        var d = "undefined";
        "undefined" !== typeof this.LogData.icon_data && "undefined" !== typeof this.LogData.icon_data[a] && "undefined" !== typeof this.LogData.icon_data[a][b] && (d = this.LogData.icon_data[a][b]);
        return d
    },
    HistoryLineOf(a, b, d) {
        var c = "undefined";
        "undefined" !== typeof this.LogData.line_data && "undefined" !== typeof this.LogData.line_data[a] && "undefined" !== typeof this.LogData.line_data[a][b] && "undefined" !== typeof this.LogData.line_data[a][b][d] && (c = this.LogData.line_data[a][b][d]);
        return c
    },
    DropHistoryOf(a, b, d) {
        var c = "undefined";
        this.LogData.drop_data[b][d] && "undefined" !== typeof this.LogData.drop_data[b] && "undefined" !== typeof this.LogData.drop_data[b][d] && "undefined" !== typeof this.LogData.drop_data[b][d][a] && (c = this.LogData.drop_data[b][d][a]);
        return c
    },
    DropHistoryIconOf(a, b, d) {
        var c = "undefined";
        "undefined" !== typeof this.LogData.drop_data[a] && "undefined" !== typeof this.LogData.drop_data[a][d] && "undefined" !== typeof this.LogData.drop_data[a][d].icon_data && "undefined" !== typeof this.LogData.drop_data[a][d].icon_data[b] && (c = this.LogData.drop_data[a][d].icon_data[b]);
        return c
    },
    DropHistoryLineOf(a, b, d, c) {
        var e = "undefined";
        "undefined" !== typeof this.LogData.drop_data[a] && "undefined" !== typeof this.LogData.drop_data[a][c] && "undefined" !== typeof this.LogData.drop_data[a][c].line_data && "undefined" !== typeof this.LogData.drop_data[a][c].line_data[b] && "undefined" !== typeof this.LogData.drop_data[a][c].line_data[b][d] && (e = this.LogData.drop_data[a][c].line_data[b][d]);
        return e
    },
    GameFeature(a) {
        var b = "";
        "undefined" !== typeof this.FeatureData[a] && (b = this.FeatureData[a]);
        return b
    },
    GameFeatureOf(a, b) {
        var d = "";
        "undefined" !== typeof this.FeatureData[a] && "undefined" !== typeof this.FeatureData[a][b] && (d = this.FeatureData[a][b]);
        return d
    },
    GameFeature2D(a, b, d) {
        var c = "";
        "undefined" !== typeof this.FeatureData[a] && "undefined" !== typeof this.FeatureData[a][b] && "undefined" !== typeof this.FeatureData[a][b][d] && (c = this.FeatureData[a][b][d]);
        return c
    },
    DropLineTotal() {
        return "undefined" !== typeof this.DropLineCount ? this.DropLineCount : 0
    },
    BuyFeature() {
        return "undefined" !== typeof this.BuyFeature ? this.BuyFeature : 0
    },
    BuyLimit() {
        return "undefined" !== typeof this.BuyLimit ? this.BuyLimit : 0
    },
    BetLevel() {
        return "undefined" !== typeof this.BetLevel ? this.BetLevel : 0
    },
    BetSize() {
        return "undefined" !== typeof this.BetSize ? this.BetSize : 0
    },
    HasSession() {
        return "undefined" !== typeof this.HasSession ? this.HasSession : 0
    },
    Multiply() {
        return "undefined" !== typeof this.Multiply ? this.Multiply : 0
    },
    TotalWay() {
        return "undefined" !== typeof this.TotalWay ? this.TotalWay : 0
    },
    WinOnDrop() {
        return "undefined" !== typeof this.WinOnDrop ? this.WinOnDrop : 0
    },
    LogTotalRecord() {
        return "undefined" !== typeof this.LogTotalRecord ? this.LogTotalRecord : 0
    },
    LogPerPage() {
        return "undefined" !== typeof this.LogPerPage ? this.LogPerPage : 0
    },
    LogCurrentPage() {
        return "undefined" !== typeof this.LogCurrentPage ? this.LogCurrentPage : 0
    },
    LogDisplayTotal() {
        return "undefined" !== typeof this.LogDisplayTotal ? this.LogDisplayTotal : 0
    },
    LogTotalPage() {
        return "undefined" !== typeof this.LogTotalPage ? this.LogTotalPage : 0
    },
    LogHtmlList() {
        return "undefined" !== typeof this.LogHtmlList ? this.LogHtmlList : ""
    },
    LogHistoryListData() {
        return "undefined" !== typeof this.LogHistoryListData ? this.LogHistoryListData : ""
    },
    LogTotalBet() {
        return "undefined" !== typeof this.LogTotalBet ? this.LogTotalBet : 0
    },
    LogTotalProfit() {
        return "undefined" !== typeof this.LogTotalProfit ? this.LogTotalProfit : 0
    },
    LogEnableLoadMore() {
        return "undefined" !== typeof this.LogEnableLoadMore ? this.LogEnableLoadMore : 0
    },
    LogGameInfoTemplate() {
        return "undefined" !== typeof this.LogGameInfoTemplate ? this.LogGameInfoTemplate : ""
    },
    LogHistoryDetailTemplate() {
        return "undefined" !== typeof this.LogHistoryDetailTemplate ? this.LogHistoryDetailTemplate : ""
    },
    LogHistorySlideTo() {
        return "undefined" !== typeof this.LogHistorySlideTo ? this.LogHistorySlideTo : 0
    },
    LogHistoryDetailTitle() {
        return "undefined" !== typeof this.LogHistoryDetailTitle ? this.LogHistoryDetailTitle : ""
    },
    LineNumberNew() {
        return "undefined" !== typeof this.LineNumberNew ? this.LineNumberNew : -1
    },
    FreeSpinAmount() {
        return "undefined" !== typeof this.FreeSpinAmount ? this.FreeSpinAmount : 0
    },
    FreeSpinMultiply() {
        return "undefined" !== typeof this.FreeSpinMultiply ? this.FreeSpinMultiply : 0
    },
    MultiplyListAt(a) {
        var b = "";
        "undefined" !== typeof this.MultiplyList[a] && (b = this.MultiplyList[a]);
        return b
    },
    FreeSpinMode() {
        return "undefined" !== typeof this.FreeSpinMode ? this.FreeSpinMode : 0
    },
    FreeTotal() {
        return "undefined" !== typeof this.FreeTotal ? this.FreeTotal : 0
    },
    CurrencyPrefix() {
        return "undefined" !== typeof this.CurrencyPrefix ? this.CurrencyPrefix : ""
    },
    CurrencySuffix() {
        return "undefined" !== typeof this.CurrencySuffix ? this.CurrencySuffix : ""
    },
    CurrencyThousand() {
        return "undefined" !== typeof this.CurrencyThousand ? this.CurrencyThousand : ""
    },
    CurrencyDecimal() {
        return "undefined" !== typeof this.CurrencyDecimal ? this.CurrencyDecimal : ""
    },
    BetSizeTotal() {
        return "undefined" !== typeof this.BetSizeTotal ? this.BetSizeTotal : 0
    },
    BetSizeListAt(a) {
        var b = "";
        "undefined" !== typeof this.BetSizeList[a] && (b = this.BetSizeList[a]);
        return b
    }
};
"use strict";
const C3$jscomp$268 = self.C3;
C3$jscomp$268.Plugins.HTMLElement = class extends C3$jscomp$268.SDKDOMPluginBase {
    constructor(a) {
        super(a, "html-element");
        this.AddElementMessageHandler("initial-content", (b,d)=>b._OnInitialContent(d));
        this.AddElementMessageHandler("click", (b,d)=>b._OnClick(d));
        this.AddElementMessageHandler("animationend", (b,d)=>b._OnAnimationEnd(d))
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$269 = self.C3;
C3$jscomp$269.Plugins.HTMLElement.Type = class extends C3$jscomp$269.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$270 = self.C3
  , C3X$jscomp$30 = self.C3X;
C3$jscomp$270.Plugins.HTMLElement.Instance = class extends C3$jscomp$270.SDKDOMInstanceBase {
    constructor(a, b) {
        super(a, "html-element");
        this._tag = "div";
        a = this._cssAnimationName = this._targetClass = this._targetId = this._className = this._id = this._textContent = this._htmlContent = "";
        this._initialType = "html";
        var d = !1;
        let c = 0
          , e = !1
          , g = C3$jscomp$270.New(C3$jscomp$270.Color)
          , k = !1
          , l = C3$jscomp$270.New(C3$jscomp$270.Color);
        this._autoFontSize = !0;
        this._autoFontSizeOffset = 0;
        let n = !1
          , p = "";
        b && (this._tag = b[0] || "div",
        a = b[1],
        d = b[2],
        1 === d ? a = C3$jscomp$270.New(C3$jscomp$270.BBString, a, {
            convertLineBreaks: !0
        }).toHTML() : 2 === d && (this._initialType = "text"),
        this.GetWorldInfo().SetVisible(b[3]),
        this._id = b[4],
        this._className = b[5],
        d = b[6],
        c = b[7],
        e = b[9],
        g.setFromJSON(b[10]),
        k = b[11],
        l.setFromJSON(b[12]),
        this._autoFontSize = b[13],
        n = b[14],
        p = b[15]);
        "html" === this._initialType ? this._htmlContent = a : this._textContent = a;
        this.CreateElement({
            tag: this._tag,
            str: a,
            type: this._initialType,
            id: this._id,
            className: this._className,
            "allow-context-menu": d,
            "stop-input-events-mode": c,
            "css-color": e ? g.getCssRgb() : "",
            "css-background-color": k ? l.getCssRgb() : "",
            "allow-text-selection": n,
            "style-attribute": p
        })
    }
    Release() {
        super.Release()
    }
    _GetStringContent(a, b) {
        let d = "html";
        "bbcode" === b ? a = C3$jscomp$270.New(C3$jscomp$270.BBString, a, {
            convertLineBreaks: !0
        }).toHTML() : "text" === b && (d = "text");
        return {
            contentType: d,
            str: a
        }
    }
    async _SetContent(a, b="html", d="", c=!1) {
        const {contentType: e, str: g} = this._GetStringContent(a, b);
        if (!d)
            if ("html" === e) {
                if ("html" === this._initialType && this._htmlContent === g)
                    return;
                this._htmlContent = g
            } else if ("text" === e) {
                if ("text" === this._initialType && this._textContent === g)
                    return;
                this._textContent = g
            }
        await this._SendHTMLUpdateMessage("set-content", {
            str: g,
            type: e,
            selector: d,
            "is-all": c
        })
    }
    async _InsertContent(a, b="html", d=!0, c="", e=!1) {
        if (a) {
            var {contentType: g, str: k} = this._GetStringContent(a, b);
            await this._SendHTMLUpdateMessage("insert-content", {
                str: k,
                type: g,
                "at-end": d,
                selector: c,
                "is-all": e
            })
        }
    }
    async _RemoveContent(a, b=!1, d=!1) {
        await this._SendHTMLUpdateMessage("remove-content", {
            selector: a,
            "is-clear": b,
            "is-all": d
        })
    }
    async _SetContentClass(a, b, d, c=!1) {
        await this._SendHTMLUpdateMessage("set-content-class", {
            mode: a,
            "class-array": b,
            selector: d,
            "is-all": c
        })
    }
    async _SetContentAttribute(a, b, d, c, e=!1) {
        await this._SendHTMLUpdateMessage("set-content-attribute", {
            mode: a,
            attribute: b,
            value: d,
            selector: c,
            "is-all": e
        })
    }
    async _SetContentCSSStyle(a, b, d, c=!1) {
        await this._SendHTMLUpdateMessage("set-content-css-style", {
            prop: C3$jscomp$270.CSSToCamelCase(a),
            value: b,
            selector: d,
            "is-all": c
        })
    }
    async _SendHTMLUpdateMessage(a, b) {
        a = await this.PostToDOMElementAsync(a, b);
        a.isOk && (this._htmlContent = a.html,
        this._textContent = a.text)
    }
    async _PositionObjectAtElement(a, b) {
        var d = await this.PostToDOMElementAsync("get-element-box", {
            selector: b
        });
        if (d.isOk) {
            var c = this._runtime.GetCanvasManager();
            b = d.left - c.GetCanvasClientX();
            var e = d.top - c.GetCanvasClientY()
              , g = d.right - c.GetCanvasClientX();
            d = d.bottom - c.GetCanvasClientY();
            for (const n of a) {
                a = n.GetWorldInfo();
                if (!a)
                    continue;
                c = a.GetLayer();
                const [p,t] = c.CanvasCssToLayer(b, e, a.GetZElevation())
                  , [w,z] = c.CanvasCssToLayer(g, d, a.GetZElevation());
                if (!(isFinite(p) && isFinite(t) && isFinite(w) && isFinite(z)))
                    continue;
                c = w - p;
                const B = z - t;
                var k = a.GetOriginX()
                  , l = a.GetOriginY();
                k = p + k * c;
                l = t + l * B;
                if (a.GetX() !== k || a.GetY() !== l || a.GetWidth() !== c || a.GetHeight() !== B)
                    a.SetXY(k, l),
                    a.SetSize(c, B),
                    a.SetBboxChanged()
            }
        }
    }
    async _CreateSpriteImgElement(a, b, d, c, e) {
        var g = a.GetWorldInfo();
        a = a.GetCurrentImageInfo();
        g && a && (g = await a.ExtractImageToBlobURL(),
        b = await this.PostToDOMElementAsync("insert-img-element", {
            blobUrl: g,
            width: a.GetWidth(),
            height: a.GetHeight(),
            selector: b,
            insertAt: d,
            id: c,
            "class": e
        }),
        b.isOk && (this._htmlContent = b.html,
        this._textContent = b.text))
    }
    async _SetElementScrollPosition(a, b, d) {
        await this.PostToDOMElementAsync("set-scroll-position", {
            selector: a,
            direction: b,
            position: d
        })
    }
    GetElementState() {
        return {
            html: this._htmlContent
        }
    }
    _OnInitialContent(a) {
        this._htmlContent = a.html;
        this._textContent = a.text
    }
    _GetHTMLContent() {
        return this._htmlContent
    }
    _GetTextContent() {
        return this._textContent
    }
    async _OnClick(a) {
        a = a.chain;
        for (var b of a)
            this._targetId = b.targetId,
            this._targetClass = b.targetClass,
            this.DispatchScriptEvent("click", !0, {
                targetId: this._targetId,
                targetClass: this._targetClass
            }),
            this._targetId && await this.TriggerAsync(C3$jscomp$270.Plugins.HTMLElement.Cnds.OnClickedID),
            this._targetClass && await this.TriggerAsync(C3$jscomp$270.Plugins.HTMLElement.Cnds.OnClickedClass);
        0 < a.length ? (b = a[0],
        this._targetId = b.targetId,
        this._targetClass = b.targetClass) : this._targetClass = this._targetId = "";
        await this.TriggerAsync(C3$jscomp$270.Plugins.HTMLElement.Cnds.OnClicked);
        this._targetClass = this._targetId = ""
    }
    async _OnAnimationEnd(a) {
        this._targetId = a.targetId;
        this._targetClass = a.targetClass;
        this._cssAnimationName = a.animationName;
        this.DispatchScriptEvent("animationend", !0, {
            targetId: this._targetId,
            targetClass: this._targetClass,
            animationName: this._cssAnimationName
        });
        await this.TriggerAsync(C3$jscomp$270.Plugins.HTMLElement.Cnds.OnCSSAnimationEnded);
        this._cssAnimationName = this._targetClass = this._targetId = ""
    }
    Draw(a) {}
    SaveToJson() {
        return {
            t: this._tag,
            h: this._htmlContent,
            id: this._id,
            c: this._className
        }
    }
    LoadFromJson(a) {
        this._tag = a.t;
        this._htmlContent = a.h;
        this._id = a.id;
        this._className = a.c;
        this.UpdateElementState()
    }
    GetPropertyValueByIndex(a) {}
    SetPropertyValueByIndex(a, b) {}
    GetDebuggerProperties() {
        return []
    }
    GetScriptInterfaceClass() {
        return self.IHTMLElementInstance
    }
}
;
const map$jscomp$27 = new WeakMap
  , VALID_CONTENT_TYPES = new Set(["html", "bbcode", "text"])
  , VALID_SET_CLASS_MODES = new Set(["add", "toggle", "remove"])
  , VALID_SET_ATTRIBUTE_MODES = new Set(["set", "remove"])
  , VALID_INSERT_AT = ["start", "end", "replace"]
  , VALID_SCROLL_DIRECTIONS = new Set(["left", "top"]);
self.IHTMLElementInstance = class extends self.IDOMInstance {
    constructor() {
        super();
        map$jscomp$27.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    setContent(a, b="html", d="", c=!1) {
        C3X$jscomp$30.RequireString(a);
        if (!VALID_CONTENT_TYPES.has(b))
            throw Error("invalid type");
        C3X$jscomp$30.RequireString(d);
        return map$jscomp$27.get(this)._SetContent(a, b, d, !!c)
    }
    insertContent(a, b="html", d=!0, c="", e=!1) {
        C3X$jscomp$30.RequireString(a);
        if (!VALID_CONTENT_TYPES.has(b))
            throw Error("invalid type");
        C3X$jscomp$30.RequireString(c);
        return map$jscomp$27.get(this)._InsertContent(a, b, !!d, c, !!e)
    }
    setContentClass(a, b, d, c=!1) {
        if (!VALID_SET_CLASS_MODES.has(a))
            throw Error("invalid mode");
        "string" === typeof b && (b = b.split(" "));
        C3X$jscomp$30.RequireArray(b);
        C3X$jscomp$30.RequireString(d);
        return map$jscomp$27.get(this)._SetContentClass(a, b, d, !!c)
    }
    setContentAttribute(a, b, d, c, e=!1) {
        if (!VALID_SET_ATTRIBUTE_MODES.has(a))
            throw Error("invalid type");
        C3X$jscomp$30.RequireString(b);
        d = d.toString();
        C3X$jscomp$30.RequireString(c);
        return map$jscomp$27.get(this)._SetContentAttribute(a, b, d, c, !!e)
    }
    setContentCssStyle(a, b, d, c) {
        C3X$jscomp$30.RequireString(a);
        b = b.toString();
        C3X$jscomp$30.RequireString(d);
        return map$jscomp$27.get(this)._SetContentCSSStyle(a, b, d, !!c)
    }
    positionInstanceAtElement(a, b) {
        C3X$jscomp$30.RequireInstanceOf(a, self.IWorldInstance);
        C3X$jscomp$30.RequireString(b);
        a = map$jscomp$27.get(this).GetRuntime()._UnwrapIWorldInstance(a);
        return map$jscomp$27.get(this)._PositionObjectAtElement([a], b)
    }
    createSpriteImgElement(a, b, d, c, e) {
        C3X$jscomp$30.RequireInstanceOf(a, self.ISpriteInstance);
        C3X$jscomp$30.RequireString(b);
        C3X$jscomp$30.RequireOptionalString(c);
        C3X$jscomp$30.RequireOptionalString(e);
        d = VALID_INSERT_AT.indexOf(d);
        if (0 > d)
            throw Error("invalid insert position");
        a = map$jscomp$27.get(this).GetRuntime()._UnwrapIWorldInstance(a);
        return map$jscomp$27.get(this)._CreateSpriteImgElement(a, b, d, c, e)
    }
    setScrollPosition(a, b, d) {
        C3X$jscomp$30.RequireString("selector");
        if (!VALID_SCROLL_DIRECTIONS.has(b))
            throw Error("invalid direction");
        C3X$jscomp$30.RequireNumber(d);
        return map$jscomp$27.get(this)._SetElementScrollPosition(a, b, d)
    }
    get htmlContent() {
        return map$jscomp$27.get(this)._GetHTMLContent()
    }
    set htmlContent(a) {
        map$jscomp$27.get(this)._SetContent(a, "html", "", !1)
    }
    get textContent() {
        return map$jscomp$27.get(this)._GetTextContent()
    }
    set textContent(a) {
        map$jscomp$27.get(this)._SetContent(a, "text", "", !1)
    }
}
;
const C3$jscomp$271 = self.C3;
C3$jscomp$271.Plugins.HTMLElement.Cnds = {
    OnClicked() {
        return !0
    },
    OnClickedID(a) {
        return C3$jscomp$271.equalsNoCase(this._targetId, a)
    },
    OnClickedClass(a) {
        const b = this._targetClass.toLowerCase().split(" ");
        return a.toLowerCase().split(" ").every(d=>b.includes(d))
    },
    OnCSSAnimationEnded(a) {
        return C3$jscomp$271.equalsNoCase(this._cssAnimationName, a)
    }
};
const CONTENT_TYPES = ["html", "bbcode", "text"]
  , SET_CLASS_MODES = ["add", "toggle", "remove"]
  , SET_ATTRIBUTE_MODES = ["set", "remove"];
self.C3.Plugins.HTMLElement.Acts = {
    SetContent(a, b, d, c) {
        return this._SetContent(b, CONTENT_TYPES[a], d, 0 !== c)
    },
    InsertContent(a, b, d, c, e) {
        return this._InsertContent(b, CONTENT_TYPES[a], 0 !== d, c, 0 !== e)
    },
    RemoveContent(a, b, d) {
        return this._RemoveContent(b, 0 !== a, 0 !== d)
    },
    SetContentClass(a, b, d, c) {
        return this._SetContentClass(SET_CLASS_MODES[a], b.split(" "), d, 0 !== c)
    },
    SetContentAttribute(a, b, d, c, e) {
        return this._SetContentAttribute(SET_ATTRIBUTE_MODES[a], b, d.toString(), c, 0 !== e)
    },
    SetContentCSSStyle(a, b, d, c) {
        return this._SetContentCSSStyle(a, b, d, 0 !== c)
    },
    PositionObjectAtElement(a, b) {
        if (a)
            return this._PositionObjectAtElement(a.GetCurrentSol().GetInstances(), b)
    },
    CreateSpriteImgElement(a, b, d, c, e) {
        if (a && (a = a.GetFirstPicked()))
            return this._CreateSpriteImgElement(a, b, d, c, e)
    },
    SetScrollPosition(a, b, d) {
        return this._SetElementScrollPosition(a, ["left", "top"][b], d)
    }
};
const C3$jscomp$273 = self.C3;
C3$jscomp$273.Plugins.HTMLElement.Exps = {
    HTMLContent() {
        return this._htmlContent
    },
    TextContent() {
        return this._textContent
    },
    TargetID() {
        return this._targetId
    },
    TargetClass() {
        return this._targetClass
    },
    EscapeHTML(a) {
        return C3$jscomp$273.EscapeHTML(a.toString())
    }
};
"use strict";
const C3$jscomp$274 = self.C3;
C3$jscomp$274.Plugins.Gritsenko_Spine = class extends C3$jscomp$274.SDKPluginBase {
    constructor(a) {
        super(a, "gritsenko-spine")
    }
    Release() {
        super.Release()
    }
}
;
"use strict";
const C3$jscomp$275 = self.C3;
C3$jscomp$275.Plugins.Gritsenko_Spine.Type = class extends C3$jscomp$275.SDKTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        console.warn("[Spine] type.Release", this.GetObjectClass().GetName(), this._runtime.GetTickCount());
        super.Release()
    }
    OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime);
        this._skeletonDataInitializing = this._skeletonDataInitialized = !1;
        this._assetTag = this._skeletonJson = null;
        this._skeletonInstances = {};
        this._rendered = !1;
        this._tickCount = -1;
        this._assetPaths = {};
        this._initFailed = !1;
        this._initOwner = -1;
        this._skeletonRenderQuality = 1
    }
    LoadTextures(a) {
        return this.GetImageInfo().LoadStaticTexture(a, {
            linearSampling: this._runtime.IsLinearSampling()
        })
    }
    ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture()
    }
}
;
"use strict";
const C3$jscomp$276 = self.C3
  , spineBatcher = globalThis.spineBatcher
  , spine$jscomp$1 = globalThis.spine;
C3$jscomp$276.Plugins.Gritsenko_Spine.Instance = class extends C3$jscomp$276.SDKWorldInstanceBase {
    constructor(a, b) {
        super(a);
        this.paletteNumber = 64;
        this.indexSize = 32;
        this.palette = null;
        this.data = {};
        this.currentKey = "";
        this.currentValue = 0;
        this.bgColor = this.canvas = null;
        this.isPlaying = !0;
        this.instance = a;
        this.gl = this.renderer = this.skeletonInfo = null;
        this.uid = this.GetInstance().GetUID();
        this.customSkins = {};
        this.slotColors = {};
        this.slotDarkColors = {};
        this.isLoaded = !1;
        this.animateOnce = 0;
        this.trackAnimations = {};
        this.skinNames = [];
        this.delayedTrackListeners = [];
        this.sdkType = this.GetSdkType();
        this.atlasPath = this.pngPath = this.jsonPath = "";
        this.objectName = this.GetInstance().GetObjectClass().GetName();
        b && (this.jsonPath = b[0],
        this.atlasPath = b[1],
        this.pngPath = b[2],
        this.skinName = b[3],
        this.animationName = b[4],
        this.skeletonName = b[5],
        this.skeletonScale = b[6],
        this.premultipliedAlpha = b[7],
        this.collisionsEnabled = b[8],
        this.defaultMix = b[9],
        this.skeletonRenderQuality = b[10],
        this.keepAspectRatio = b[11],
        this.debug = b[12],
        this.bboxOverride = b[13],
        this.bboxOffsetX = b[14],
        this.bboxOffsetY = b[15],
        this.bboxSizeX = b[16],
        this.bboxSizeY = b[17]);
        this.isMirrored = !1;
        this._elementTexture = null;
        this.pngURI = "";
        this.atlasURI = "*init-atlas-uri*";
        this.initOwnerId = this.uid + Math.random();
        this.debug && console.log("[Spine] instance constructor, uid", this.initOwnerId);
        this.jsonURI = "";
        this.c3renderer = null;
        this.runtime = a.GetRuntime();
        this.c3wgl = this.runtime.GetCanvasManager().GetWebGLRenderer();
        this.canvas = this.c3wgl._gl.canvas;
        this.spineFB = null;
        this.initSpineInProgress = !1;
        this.completeAnimationName = "";
        this.spineError = null;
        this.animationSpeed = 1;
        this.completeEventName = "";
        this.textureHeight = this.textureWidth = 0;
        this.completeEventData = {};
        this.GetWorldInfo().SetCollisionEnabled(this.collisionsEnabled);
        this._StartTicking();
        this.HandleWebGLContextLoss();
        this.OnWebGLContextRestored = function() {
            this.debug && console.warn("[Spine] Context restored.")
        }
        ;
        this.OnWebGLContextLost = function() {
            console.warn("[Spine] Context lost.");
            globalThis.spineBatcher.debugVariables.animationDisable = "enable";
            globalThis.spineBatcher.debugVariables.renderDisable = "enable";
            this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnWebGLContextLost)
        }
        ;
        this.OnWebGLContextRestored = function() {
            console.warn("[Spine] Context Restored.");
            globalThis.spineBatcher.debugVariables.animationDisable = "enable";
            globalThis.spineBatcher.debugVariables.renderDisable = "enable";
            this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnWebGLContextRestored)
        }
    }
    initInstance() {
        this.initSpineInProgress = !0;
        this.mvp = new spine$jscomp$1.Matrix4;
        this.mvp.ortho2d(0, 0, 0, 0);
        this.gl = this.runtime.GetWebGLRenderer()._gl;
        this.canvas = this.gl._canvas
    }
    async initTexturesBatcher() {
        this.sdkType._texturesBatcherInitializing = !0;
        spineBatcher.init(this.canvas, this.runtime);
        this.runtime.IsPreview() || this.runtime._assetManager._isCordova ? await this.loadSkeletonTextures() : this.loadSkeletonTextures()
    }
    resize() {
        var a = this.skeletonInfo.bounds
          , b = a.offset.x + a.size.x / 2
          , d = a.offset.y + a.size.y / 2
          , c = 1 / this.skeletonScale * Math.max(a.size.x / a.size.x, a.size.y / a.size.y);
        1 > c && (c = 1);
        var e = a.size.x * c;
        a = a.size.y * c;
        this.mvp.ortho2d(b - e / 2, d - a / 2, e, a)
    }
    async loadSkeletonTextures() {
        var a = new spine$jscomp$1.ManagedWebGLRenderingContext(this.gl);
        this.sdkType._assetManager = new spine$jscomp$1.AssetManager(a);
        a = this.sdkType._assetManager;
        this.debug && console.info(this.GetInstance().GetUID(), "[Spine] Loading skeleton, textures, json, atlas");
        spine$jscomp$1.GLTexture.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL = !0;
        this.runtime.IsPreview() || this.runtime._assetManager._isCordova ? (this.atlasURI = "*await-atlas-path*",
        this.atlasURI = await this.runtime._assetManager.GetProjectFileUrl(this.atlasPath),
        this.jsonURI = await this.runtime._assetManager.GetProjectFileUrl(this.jsonPath)) : (this.atlasURI = this.atlasPath,
        this.jsonURI = this.jsonPath,
        this.debug && console.info("[Spine] loadSkeletonTextures, atlasURI, not preview", this.atlasURI, this.atlasPath, this.uid, this.objectName, this.runtime.GetTickCount()));
        this.sdkType._assetPaths[this.atlasURI] = this.atlasURI;
        this.sdkType._assetPaths[this.atlasPath] = this.atlasURI;
        this.sdkType._assetPaths[this.jsonURI] = this.jsonURI;
        this.sdkType._assetPaths[this.jsonPath] = this.jsonURI;
        this.sdkType._jsonURI = this.jsonURI;
        a.loadText(this.jsonURI);
        let b = this.pngPath.split(",");
        for (let d = 0; d < b.length; d++)
            this.pngURI = await this.runtime._assetManager.GetProjectFileUrl(b[d]),
            !this.pngURI && this.debug && alert("[Spine] png path not found:" + b[d]),
            this.sdkType._assetPaths[b[d]] = this.pngURI;
        a.loadTextureAtlas(this.atlasURI, null, null, this.sdkType._assetPaths);
        a.loadText(this.atlasURI);
        this.sdkType._texturesBatcherInitialized = !0;
        this.sdkType._texturesBatcherInitializing = !1;
        this.debug && console.info("[Spine] loadSkeletonTextures, atlasURI", this.atlasURI, this.atlasPath, this.uid, this.objectName, this.runtime.GetTickCount())
    }
    loadSkeletonData() {
        this.debug && console.info("[Spine] loadSkeletonData, atlasURI", this.atlasURI, this.atlasPath, this.uid, this.objectName, this.sdkType._texturesBatcherInitialized, this.runtime.GetTickCount());
        const a = this.sdkType._assetManager
          , b = a.get(this.atlasURI);
        void 0 === b || null === b ? (console.warn("[Spine] loadSkeletonData, atlasURI not set", b, this.uid, this.atlasURI, a.isLoadingComplete(), this.atlasPath, this.runtime.GetTickCount()),
        console.warn("[Spine] objectclass", this.objectName, this.sdkType, this.uid, this.runtime.GetTickCount()),
        globalThis.Sentry && globalThis.Sentry.captureException("[Spine] loadSkeletonData, atlasURI not set, object:" + this.objectName),
        this.sdkType._initFailed = !0) : (this.sdkType._atlas = a.get(this.atlasURI),
        this.sdkType._skeletonJson = new spine$jscomp$1.SkeletonJson(new spine$jscomp$1.AtlasAttachmentLoader(this.sdkType._atlas)),
        this.sdkType._skeletonJson.scale = this.skeletonRenderQuality,
        this.sdkType._skeletonRenderQuality = this.skeletonRenderQuality,
        this.sdkType._skeletonData = this.sdkType._skeletonJson.readSkeletonData(a.get(this.jsonURI)),
        this.sdkType._skeletonDataInitialized = !0,
        this.sdkType._skeletonDataInitializing = !1)
    }
    loadSkeletons() {
        this.skeletonInfo = this.loadSkeleton(this.skeletonName, this.animationName);
        this.skeletonInfo.premultipliedAlpha = this.premultipliedAlpha;
        this.skinNames = this.skeletonInfo.skeleton.data.skins.map(a=>a.name);
        this.animationNames = this.skeletonInfo.skeleton.data.animations.map(a=>a.name);
        this.resize();
        spineBatcher.addInstance(this.skeletonInfo, this.skeletonScale, this.GetInstance().GetUID());
        this.spineBoneControl = new SpineBoneControl(this.debug)
    }
    loadSkeleton(a, b, d) {
        this.debug && console.info("[Spine] Reading skeleton data:", this.uid, this.sdkType.GetObjectClass().GetName(), b);
        a = new spine$jscomp$1.Skeleton(this.sdkType._skeletonData);
        this.skinName ? (d = a.data.findSkin(this.skinName),
        d || (d = a.data.defaultSkin)) : d = a.data.defaultSkin;
        a.setSkin(d);
        d = new spine$jscomp$1.AnimationStateData(this.sdkType._skeletonData);
        d.defaultMix = this.defaultMix;
        var c = new spine$jscomp$1.AnimationState(d);
        c.setAnimation(0, b, !0);
        this.trackAnimations[0] = this.animationName;
        c.tracks[0].listener = {
            complete: (k,l)=>{
                this.completeAnimationName = this.trackAnimations[0];
                this.completeTrackIndex = k.trackIndex;
                this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnAnimationFinished);
                this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnAnyAnimationFinished)
            }
            ,
            event: (k,l)=>{
                this.completeEventName = l.data.name;
                this.completeEventTrackIndex = k.trackIndex;
                this.completeEventData = {
                    "float": l.floatValue,
                    "int": l.intValue,
                    string: l.stringValue,
                    balance: l.balance,
                    volume: l.volume,
                    audiopath: l.data.audioPath,
                    event: l.data.name,
                    track: k.trackIndex
                };
                this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnEvent);
                this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnAnyEvent)
            }
        };
        c.apply(a);
        a.updateWorldTransform();
        b = new spine$jscomp$1.Vector2;
        var e = new spine$jscomp$1.Vector2;
        a.getBounds(b, e, []);
        var g = new spine$jscomp$1.SkeletonBounds;
        this.keepAspectRatio && (e = this.GetWorldInfo(),
        b = {
            x: b.x - e._w / 2,
            y: b.y
        },
        e = {
            x: e._w,
            y: e._h
        });
        this.bboxOverride && (e = this.sdkType._skeletonRenderQuality,
        b = {
            x: this.bboxOffsetX * e,
            y: this.bboxOffsetY * e
        },
        e = {
            x: this.bboxSizeX * e,
            y: this.bboxSizeY * e
        });
        return {
            atlas: this.sdkType._atlas,
            skeleton: a,
            state: c,
            playTime: 0,
            bounds: {
                offset: b,
                size: e
            },
            atlasLoader: this.sdkType._atlasLoader,
            skeletonBounds: g,
            stateData: d,
            palette: this.palette
        }
    }
    createInstanceTexture() {
        var a = this.runtime.GetWebGLRenderer();
        const b = this.gl;
        this.c3renderer = a;
        var d = this.skeletonInfo.bounds;
        this.textureWidth = d.size.x;
        this.textureHeight = d.size.y;
        d = {
            mipMap: !1,
            sampling: this.runtime.GetSampling()
        };
        this.debug && console.info("[Spine] CreateDynamicTexture x,y:", Math.round(this.textureWidth), Math.round(this.textureHeight), this.uid, this.runtime.GetTickCount());
        this._elementTexture = a.CreateDynamicTexture(this.textureWidth, this.textureHeight, d);
        a = b.getParameter(b.FRAMEBUFFER_BINDING);
        this.spineFB = b.createFramebuffer();
        b.bindFramebuffer(b.FRAMEBUFFER, this.spineFB);
        b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, this._elementTexture._texture, 0);
        b.bindFramebuffer(b.FRAMEBUFFER, a);
        spineBatcher.setInstanceFB(this.spineFB, this.GetInstance().GetUID())
    }
    updateCurrentSkin() {
        const a = this.skeletonInfo.skeleton;
        let b = [];
        if (-1 < this.skinName.indexOf(",")) {
            b = this.skinName.split(",");
            const d = new spine$jscomp$1.Skin("compound-skin");
            b.forEach(c=>{
                c = a.data.findSkin(c);
                d.addSkin(c)
            }
            );
            a.setSkin(d)
        } else
            b.push(this.skinName),
            a.setSkinByName(this.skinName);
        a.setSlotsToSetupPose()
    }
    updateBounds() {
        const a = this.skeletonInfo.skeleton;
        this.skeletonInfo.state.apply(a);
        a.updateWorldTransform();
        var b = new spine$jscomp$1.Vector2
          , d = new spine$jscomp$1.Vector2;
        a.getBounds(b, d, []);
        this.skeletonInfo.bounds = {
            offset: b,
            size: d
        }
    }
    updateCurrentAnimation(a, b, d, c) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton && this.animationNames)
            if (this.animationNames.includes(c))
                try {
                    const e = this.skeletonInfo.state
                      , g = e.tracks[d];
                    let k = 0
                      , l = 0;
                    g && (k = g.trackTime,
                    g.animationEnd != g.animationStart && g.animationEnd > g.animationStart && (l = (g.animationLast + g.trackTime - g.trackLast) / (g.animationEnd - g.animationStart)));
                    e.setAnimation(d, c, a);
                    switch (b) {
                    case 1:
                        e.tracks[d].trackTime = k;
                        break;
                    case 2:
                        e.tracks[d].trackTime = l * (e.tracks[d].animationEnd - e.tracks[d].animationStart)
                    }
                    this.trackAnimations[d] = this.animationName;
                    0 == b || 2 == b && 0 == l ? this.setTrackListeners(e, d) : this.delayedTrackListeners.push(d)
                } catch (e) {
                    this.debug && console.error("[Spine] setAnimation error", e, d, c),
                    this.spineError = "setAnimation error " + e,
                    this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnError)
                }
            else
                this.debug && console.warn("[Spine] updateCurrentAnimation, animation does not exist.", c, this.uid)
    }
    setTrackListeners(a, b) {
        a && a.tracks && a.tracks[b] ? a.tracks[b].listener = {
            complete: (d,c)=>{
                this.completeAnimationName = this.trackAnimations[d.trackIndex];
                this.completeTrackIndex = d.trackIndex;
                this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnAnimationFinished);
                this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnAnyAnimationFinished)
            }
            ,
            event: (d,c)=>{
                this.completeEventName = c.data.name;
                this.completeEventTrackIndex = d.trackIndex;
                this.completeEventData = {
                    "float": c.floatValue,
                    "int": c.intValue,
                    string: c.stringValue,
                    balance: c.balance,
                    volume: c.volume,
                    audiopath: c.data.audioPath,
                    event: c.data.name,
                    track: d.trackIndex
                };
                this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnEvent);
                this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnAnyEvent)
            }
        } : this.debug && console.warn("[Spine] setTrackListners invalid", a, b)
    }
    playAnimation() {
        this.isPlaying = !0
    }
    stopAnimation() {
        this.isPlaying = !1
    }
    async IsSpineReady() {
        if (this.sdkType._initFailed)
            return !1;
        if (null === this.sdkType || void 0 === this.sdkType)
            return this.debug && console.warn("[Spine] IsSpineReady, sdkType not defined", this.sdkType),
            globalThis.Sentry && globalThis.Sentry.captureException("[Spine] IsSpineReady, sdkType not defined:" + this.sdkType),
            this.sdkType._initFailed = !0,
            !1;
        if ("" === this.jsonPath)
            return !1;
        if (this.isLoaded)
            return !0;
        this.initInstanceInitialized || this.initInstance();
        -1 == this.sdkType._initOwner && (this.sdkType._initOwner = this.initOwnerId,
        this.debug && console.info("[Spine] IsSpineReady, initOwner", this.sdkType._initOwner, this.objectName, this.runtime.GetTickCount()));
        if (!this.sdkType._texturesBatcherInitialized)
            return this.sdkType._texturesBatcherInitializing || this.sdkType._initOwner != this.initOwnerId || (this.sdkType._texturesBatcherInitializing = !0,
            this.runtime.IsPreview() || this.runtime._assetManager._isCordova ? await this.initTexturesBatcher() : this.initTexturesBatcher()),
            !1;
        if (!this.sdkType._assetManager.isLoadingComplete() && this.sdkType._initOwner == this.initOwnerId)
            return !1;
        if (!this.sdkType._skeletonDataInitialized)
            return this.sdkType._skeletonDataInitializing || this.sdkType._initOwner != this.initOwnerId || (this.sdkType._skeletonDataInitializing = !0,
            this.loadSkeletonData()),
            !1;
        this.loadSkeletons();
        this.createInstanceTexture();
        this.palette = new globalThis.SpinePalette(this.indexSize,this.paletteNumber);
        this.palette.createPaletteTexture(this.c3renderer);
        for (let a = 0; a < this.paletteNumber; a++)
            this.palette.setDefaultColors(a, (this.paletteNumber - a) / this.paletteNumber, 1);
        spineBatcher.setInstancePalette(this.palette, this.uid);
        this.palette.uploadNeeded = !0;
        spineBatcher.setInstanceInitialized(this.GetInstance().GetUID());
        this.isLoaded = !0;
        this.Trigger(C3$jscomp$276.Plugins.Gritsenko_Spine.Cnds.OnSkeletonLoaded)
    }
    Release() {
        this.data = this.currentValue = this.currentKey = null;
        spineBatcher.removeInstance(this.GetInstance().GetUID());
        super.Release();
        this.c3renderer && this._elementTexture && this.c3renderer.DeleteTexture(this._elementTexture);
        this.sdkType = this.palette = this.indexSize = this.paletteNumber = this.spineBoneControl = this.slotDarkColors = this.slotColors = this.customSkins = this.uid = this.textureHeight = this.textureWidth = this.skeletonRenderQuality = this.completeEventData = this.completeEventName = this.animationSpeed = this.spineError = this.completeAnimationName = this.initSpineInProgress = this.spineFB = this.canvas = this.c3wgl = this.c3renderer = this.jsonURI = this.atlasURI = this.pngURI = this._elementTexture = this.isMirrored = this.defaultMix = this.collisionsEnabled = this.premultipliedAlpha = this.skeletonScale = this.skeletonName = this.animationName = this.skinName = this.pngPath = this.atlasPath = this.jsonPath = this.gl = this.renderer = this.skeletonInfo = this.isPlaying = this.bgColor = this.canvas = null
    }
    Tick() {
        this.IsSpineReady();
        if (this.isLoaded) {
            var a = this.runtime.GetDt() * this.animationSpeed
              , b = this.skeletonInfo
              , d = this.skeletonInfo.state
              , c = this.GetWorldInfo()
              , e = c.GetLayer().GetViewport();
            c = c.GetBoundingBox().intersectsRect(e);
            spineBatcher.setInstanceOnScreen(c, this.uid);
            var g = !0;
            d.tracks.forEach(k=>{
                !k || !k.loop && k.isComplete() || (g = !1)
            }
            );
            g = g || !this.isPlaying;
            spineBatcher.setInstanceTracksComplete(g, this.uid);
            c = this.isPlaying || 0 < this.animateOnce;
            e = 0 < this.animateOnce || !g && this.isPlaying;
            if (("enable" === spineBatcher.debugVariables.animationReduce ? e : c) && "enable" !== spineBatcher.debugVariables.animationDisable) {
                c = d.getCurrent(0).animation.duration;
                b.playTime += a;
                if (0 < c)
                    for (; b.playTime >= c; )
                        b.playTime -= c;
                d.update(a);
                d.apply(b.skeleton);
                if (0 < this.delayedTrackListeners.length) {
                    for (const k of this.delayedTrackListeners)
                        this.setTrackListeners(d, k);
                    this.delayedTrackListeners.splice(0, this.setTrackListeners.length)
                }
                this.spineBoneControl.applyBoneControl(b.skeleton);
                b.skeleton.updateWorldTransform();
                this.runtime.UpdateRender();
                0 < this.animateOnce && (this.animateOnce -= a,
                0 >= this.animateOnce && this.SetRenderOnce(0, !1, this.uid))
            }
        }
    }
    SetRenderOnce(a, b, d) {
        a > this.animateOnce && (this.animateOnce = a);
        spineBatcher.setInstanceRenderOnce(b, d)
    }
    Draw(a) {
        if (this.isLoaded) {
            var b = this.GetWorldInfo()
              , d = b.GetBoundingQuad();
            spineBatcher.tickCount != this.runtime.GetTickCount() && (spineBatcher.tickCount = this.runtime.GetTickCount(),
            spineBatcher.drawBatch());
            var c = 0
              , e = 1;
            this.isMirrored && (c = 1,
            e = 0);
            c = new C3$jscomp$276.Rect(c,1,e,0);
            a.SetTexture(this._elementTexture);
            if (this.runtime.IsPixelRoundingEnabled()) {
                e = new C3$jscomp$276.Quad;
                const g = Math.round(b.GetX()) - b.GetX();
                b = Math.round(b.GetY()) - b.GetY();
                e.copy(d);
                e.offset(g, b);
                a.Quad3(e, c)
            } else
                a.Quad3(d, c)
        }
    }
    SaveToJson() {
        return {}
    }
    LoadFromJson(a) {}
    GetDebuggerProperties() {
        return [{
            title: "Spine",
            properties: []
        }]
    }
    GetValuePath(a, b) {
        let d = this.data;
        for (const c of a)
            if ("object" === typeof d && null !== d)
                if (d.hasOwnProperty(c))
                    d = d[c];
                else if (b)
                    a = {},
                    d = d[c] = a;
                else {
                    d = null;
                    break
                }
        return d
    }
    SetValuePath(a, b) {
        let d = b.pop();
        if ("" === d || null === d)
            return !1;
        b = this.GetValuePath(b, !0);
        return "object" === typeof b && null !== b ? (b[d] = a,
        !0) : !1
    }
    GetScriptInterfaceClass() {
        return self.ISpineInstance
    }
    _getData() {
        return this.data
    }
    _setAnimation(a, b, d, c) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.animationName = a,
        this.updateCurrentAnimation(b, d, c, a),
        this.SetRenderOnce(1, !0, this.uid)) : this.debug && console.warn("[Spine] SetAnimation, no skeleton.", a, b, d, c, this.uid, this.runtime.GetTickCount())
    }
    _setAnimationTime(a, b, d) {
        if (this.skeletonInfo && this.skeletonInfo.state) {
            var c = this.skeletonInfo.state;
            if (c && c.tracks && (c = c.tracks[d])) {
                if (0 == a) {
                    if (b < c.animationStart || b > c.animationEnd) {
                        this.debug && console.warn("[Spine] SetAnimationTime time out of bounds:", a, b, d, this.uid, this.runtime.GetTickCount());
                        return
                    }
                    c.trackTime = b
                } else {
                    if (0 > b || 1 < b) {
                        this.debug && console.warn("[Spine] SetAnimationTime ratio out of bounds:", a, b, d, this.uid, this.runtime.GetTickCount());
                        return
                    }
                    c.trackTime = b * (c.animationEnd - c.animationStart)
                }
                this.SetRenderOnce(1, !0, this.uid)
            }
        } else
            this.debug && console.warn("[Spine] SetAninationTime, no state.", a, b, d, this.uid, this.runtime.GetTickCount())
    }
    _setAnimationSpeed(a) {
        this.animationSpeed = a
    }
    _currentAnimation(a) {
        if (!this.isLoaded)
            return "";
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.animation.name : "" : ""
    }
    _setAnimationMix(a, b, d) {
        if (this.skeletonInfo && this.skeletonInfo.stateData) {
            var c = this.skeletonInfo.stateData;
            try {
                c.setMix(a, b, d)
            } catch (e) {
                console.error("[Spine] SetAnimationMix:", e)
            }
        } else
            this.debug && console.warn("[Spine] SetAnimationMix, no stateData.", a, b, d, this.uid, this.runtime.GetTickCount())
    }
    _deleteAnimation(a, b) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var d = this.skeletonInfo.state;
            d && d.tracks && d.tracks[a] && (d.setEmptyAnimation(a, b),
            this.SetRenderOnce(1, !0, this.uid))
        } else
            this.debug && console.warn("[Spine] DeleteAnimation, no skelton.", a, b, this.uid, this.runtime.GetTickCount())
    }
    _addCustomSkinOutfit(a, b, d, c, e, g) {
        const k = globalThis.spine;
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var l = this.skeletonInfo.skeleton;
            this.customSkins[a] ? this.customSkins[a].clear() : this.customSkins[a] = new k.Skin(a);
            var n = {};
            d.forEach(p=>{
                let t = b[p];
                t?.override?.skinName && (t = t.override);
                if ("" != t.skinName) {
                    var w = l.findSlot(p);
                    if (w) {
                        var z = p + "/" + t.skinName
                          , B = l.data.findSkin(z);
                        if (B) {
                            n[p] = t.skinName;
                            this.customSkins[a].addSkin(B);
                            if (c[p])
                                for (const C of c[p])
                                    n[C] = t.skinName,
                                    z = C + "/" + t.skinName,
                                    (B = l.data.findSkin(z)) ? this.customSkins[a].addSkin(B) : this.debug && console.warn("[Spine] AddCustomSkin, add skin does not exist", a, z, this.uid, this.runtime.GetTickCount());
                            this.slotColors[p] = this._swap32(t.tintColor);
                            this.slotDarkColors[p] = this._swap32(t.tintDarkColor);
                            k.Color.rgba8888ToColor(w.color, t.tintColor);
                            k.Color.rgba8888ToColor(w.darkColor, t.tintDarkColor);
                            if (e[p])
                                for (const C of e[p])
                                    n[C] = t.skinName,
                                    p = l.findSlot(C),
                                    this.slotColors[C] = this._swap32(t.tintColor),
                                    this.slotDarkColors[C] = this._swap32(t.tintDarkColor),
                                    k.Color.rgba8888ToColor(p.color, t.tintColor),
                                    k.Color.rgba8888ToColor(p.darkColor, t.tintDarkColor)
                        } else
                            this.debug && console.warn("[Spine] AddCustomSkin, add skin does not exist", a, z, this.uid, this.runtime.GetTickCount())
                    }
                }
            }
            );
            d.forEach(p=>{
                if (g[p]) {
                    let t = b[p];
                    for (const w of g[p])
                        n[w] && "0" !== n[w] || (p = l.findSlot(w),
                        this.slotColors[w] = this._swap32(t.tintColor),
                        this.slotDarkColors[w] = this._swap32(t.tintDarkColor),
                        k.Color.rgba8888ToColor(p.color, t.tintColor),
                        k.Color.rgba8888ToColor(p.darkColor, t.tintDarkColor))
                }
            }
            );
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] AddCustomSkin, skeleton is not available", a, b, this.uid, this.runtime.GetTickCount())
    }
    _swap32(a) {
        return ((a & 255) << 24 | (a & 65280) << 8 | a >>> 8 & 65280 | a >>> 24 & 255) >>> 0
    }
    _hexToC3RGBAColorValue(a) {
        7 == a.length && (a += "ff");
        return this._swap32(parseInt(a.substr(1), 16))
    }
    _hexToRGBA(a) {
        return (a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a)) ? {
            r: parseInt(a[1], 16) / 255,
            g: parseInt(a[2], 16) / 255,
            b: parseInt(a[3], 16) / 255,
            a: parseInt(a[4], 16) / 255
        } : {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        }
    }
    _applySlotColors() {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var a = this.skeletonInfo.skeleton, b;
            for (b in this.slotColors) {
                var d = a.findSlot(b);
                if (null === d)
                    console.warn("[Spine] ApplySlotColors, slot not found: ", b, this.uid, this.runtime.GetTickCount());
                else {
                    var c = this.slotColors[b];
                    "string" == typeof c ? (7 == c.length && (c += "ff"),
                    c = this._hexToRGBA(c),
                    d.color.set(c.r, c.g, c.b, c.a)) : d.color.set(spineBatcher.getRValue(c), spineBatcher.getGValue(c), spineBatcher.getBValue(c), spineBatcher.getAValue(c))
                }
            }
            for (b in this.slotDarkColors)
                d = a.findSlot(b),
                null === d ? console.warn("[Spine] ApplySlotColors dark color, slot not found: ", b, this.uid, this.runtime.GetTickCount()) : d.darkColor && (c = this.slotDarkColors[b],
                "string" == typeof c ? (7 == c.length && (c += "ff"),
                c = this._hexToRGBA(c),
                d.darkColor.set(c.r, c.g, c.b, c.a)) : d.darkColor.set(spineBatcher.getRValue(c), spineBatcher.getGValue(c), spineBatcher.getBValue(c), spineBatcher.getAValue(c)));
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] ApplySlotColors, no skeleton.", this.uid, this.runtime.GetTickCount())
    }
    _animationEnd(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.animationEnd : 0 : 0
    }
    _animationStart(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.animationStart : 0 : 0
    }
    _animationLength(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.animationEnd - a.animationStart : 0 : 0
    }
    _addCustomSkin(a, b) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var d = this.skeletonInfo.skeleton;
            this.customSkins[a] ? (d = d.data.findSkin(b)) ? this.customSkins[a].addSkin(d) : this.debug && console.warn("[Spine] AddCustomSkin, add skin does not exist", a, b, this.uid, this.runtime.GetTickCount()) : this.debug && console.warn("[Spine] AddCustomSkin, custom skin does not exist", a, b, this.uid, this.runtime.GetTickCount());
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] AddCustomSkin, skeleton is not available", a, b, this.uid, this.runtime.GetTickCount())
    }
}
;
const map$jscomp$28 = new WeakMap;
self.ISpineInstance = class extends self.IWorldInstance {
    constructor() {
        super();
        map$jscomp$28.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    get data() {
        return map$jscomp$28.get(this)._getData()
    }
    setAnimation(a, b, d, c) {
        map$jscomp$28.get(this)._setAnimation(a, b, d, c)
    }
    setAnimationTime(a, b, d) {
        map$jscomp$28.get(this)._setAnimationTime(a, b, d)
    }
    setAnimationSpeed(a) {
        map$jscomp$28.get(this)._setAnimationSpeed(a)
    }
    currentAnimation(a) {
        return map$jscomp$28.get(this)._currentAnimation(a)
    }
    setAnimationMix(a, b, d) {
        map$jscomp$28.get(this)._setAnimationMix(a, b, d)
    }
    deleteAnimation(a, b) {
        map$jscomp$28.get(this)._deleteAnimation(a, b)
    }
    addCustomSkinOutfit(a, b, d, c, e, g) {
        map$jscomp$28.get(this)._addCustomSkinOutfit(a, b, d, c, e, g)
    }
    applySlotColors() {
        map$jscomp$28.get(this)._applySlotColors()
    }
    addCustomSkin(a, b) {
        map$jscomp$28.get(this)._addCustomSkin(a, b)
    }
    animationStart(a) {
        return map$jscomp$28.get(this)._animationStart(a)
    }
    animationEnd(a) {
        return map$jscomp$28.get(this)._animationEnd(a)
    }
    animationLength(a) {
        return map$jscomp$28.get(this)._animationLength(a)
    }
}
;
"use strict";
self.C3.Plugins.Gritsenko_Spine.Cnds = {
    OnWebGLContextLost() {
        return !0
    },
    OnWebGLContextRestored() {
        return !0
    },
    OnSkeletonLoaded() {
        return !0
    },
    IsSkeletonLoaded() {
        return this.isLoaded
    },
    OnAnimationFinished(a, b) {
        return this.completeAnimationName == a && this.completeTrackIndex == b
    },
    OnAnyAnimationFinished() {
        return !0
    },
    IsAnimationPlaying(a, b) {
        if (!this.isLoaded || !this.skeletonInfo || !this.skeletonInfo.skeleton)
            return !1;
        const d = this.skeletonInfo.state.tracks[b];
        return d ? d.animation.name === a && d.trackIndex === b : !1
    },
    OnError() {
        return !0
    },
    OnEvent(a, b) {
        return this.completeEventName === a && this.completeEventTrackIndex === b
    },
    OnAnyEvent(a) {
        return this.completeEventTrackIndex === a
    },
    IsBoneControlPropertyActive(a, b) {
        b = ["x", "y", "rotation", "scaleX", "scaleY"][b];
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty(b) ? !0 : !1
    },
    CompareValue(a, b, d) {
        if ("" === d)
            return !1;
        d = d.split(".");
        d = this.GetValuePath(d, !1);
        if ("object" === typeof d || null === d)
            return !1;
        switch (b) {
        case 0:
            return a === d;
        case 1:
            return a !== d;
        case 2:
            return a < d;
        case 3:
            return a <= d;
        case 4:
            return a > d;
        case 4:
            return a >= d;
        default:
            return !1
        }
    },
    ForEach(a) {
        if ("" === a)
            return !1;
        a = a.split(".");
        a = this.GetValuePath(a, !1);
        if ("object" !== typeof a || null === a)
            return !1;
        const b = this._runtime
          , d = b.GetEventSheetManager()
          , c = b.GetCurrentEvent()
          , e = c.GetSolModifiers()
          , g = b.GetEventStack()
          , k = g.GetCurrentStackFrame()
          , l = g.Push(c)
          , n = this.currentKey
          , p = this.currentValue;
        b.SetDebuggingEnabled(!1);
        for (const [t,w] of Object.entries(a))
            this.currentKey = t,
            this.currentValue = w,
            d.PushCopySol(e),
            c.Retrigger(k, l),
            d.PopSol(e);
        b.SetDebuggingEnabled(!0);
        this.currentKey = n;
        this.currentValue = p;
        g.Pop();
        return !1
    }
};
"use strict";
const spineBatcher$jscomp$1 = globalThis.spineBatcher;
self.C3.Plugins.Gritsenko_Spine.Acts = {
    SetSkin(a) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.skinName = a,
        this.updateCurrentSkin(),
        this.SetRenderOnce(1, !0, this.uid)) : this.debug && console.warn("[Spine] SetSkin, no skeleton.", a, this.uid, this.runtime.GetTickCount())
    },
    Flip(a) {
        this.isMirrored = a;
        this.SetRenderOnce(1, !0, this.uid)
    },
    SetAnimation(a, b, d, c) {
        this._setAnimation(a, b, d, c)
    },
    SetAlpha(a, b) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var d = this.skeletonInfo.state;
            d && d.tracks && (b = d.tracks[b]) && (b.alpha = Math.max(0, Math.min(1, a)),
            this.SetRenderOnce(1, !0, this.uid))
        } else
            this.debug && console.warn("[Spine] SetAlpha, no state.", a, b, this.uid, this.runtime.GetTickCount())
    },
    DeleteAnimation(a, b) {
        this._deleteAnimation(a, b)
    },
    Play() {
        this.playAnimation();
        this.SetRenderOnce(1, !0, this.uid)
    },
    Stop() {
        this.stopAnimation();
        this.SetRenderOnce(0, !1, this.uid)
    },
    UpdateBounds() {
        this.updateBounds()
    },
    SetAnimationSpeed(a) {
        this._setAnimationSpeed(a)
    },
    SetRegion(a, b, d) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var c = this.skeletonInfo.skeleton
              , e = this.skeletonInfo.atlas.findRegion(d);
            if (null == e)
                throw Error("Region not found in atlas: " + d + " " + this.uid);
            a = c.data.findSlot(a).index;
            b = c.getAttachment(a, b);
            e.renderObject = e;
            b.setRegion(e);
            b.updateOffset();
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] SetRegion, no skeleton.", a, b, d, this.uid, this.runtime.GetTickCount())
    },
    SetAttachment(a, b) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.skeletonInfo.skeleton.setAttachment(a, b),
        this.SetRenderOnce(1, !0, this.uid)) : this.debug && console.warn("[Spine] SetAttachment, no skeleton.", a, b, this.uid, this.runtime.GetTickCount())
    },
    CreateCustomSkin(a) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? this.customSkins[a] ? this.customSkins[a].clear() : this.customSkins[a] = new spine.Skin(a) : this.debug && console.warn("[Spine] CreateCustomSkin, no skeleton.", a, this.uid)
    },
    AddCustomSkin(a, b) {
        this._addCustomSkin(a, b)
    },
    SetCustomSkin(a) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.skinName = a,
        a = this.skeletonInfo.skeleton,
        a.setSkin(this.customSkins[this.skinName]),
        a.setSlotsToSetupPose(),
        this.SetRenderOnce(1, !0, this.uid)) : this.debug && console.warn("[Spine] SetCustomSkin, no skeleton", a, this.uid, this.runtime.GetTickCount())
    },
    SetCustomAttachmentColor(a, b, d, c) {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var e = this.skeletonInfo.skeleton
              , g = this.customSkins[a]
              , k = e.data.findSlot(b).index;
            e.findSlot(b);
            b = g.getAttachment(k, d).copy();
            c = new spine.Color(spineBatcher$jscomp$1.getRValue(c),spineBatcher$jscomp$1.getGValue(c),spineBatcher$jscomp$1.getBValue(c),spineBatcher$jscomp$1.getAValue(c));
            b.color = c;
            g.setAttachment(k, d, b);
            e.setSkin(this.customSkins[a]);
            e.setSlotsToSetupPose();
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] SetCustomAttachmentColor, no skeleton", a, b, d, c, this.uid, this.runtime.GetTickCount())
    },
    SetSlotColor(a, b) {
        this.slotColors[a] = b;
        this.SetRenderOnce(1, !0, this.uid)
    },
    SetSlotDarkColor(a, b) {
        this.slotDarkColors[a] = b;
        this.SetRenderOnce(1, !0, this.uid)
    },
    ApplySlotColors() {
        this._applySlotColors()
    },
    ResetSlotColors() {
        if (this.skeletonInfo && this.skeletonInfo.skeleton) {
            var a = this.skeletonInfo.skeleton;
            this.slotColors = {};
            this.slotDarkColors = {};
            a.setSlotsToSetupPose();
            this.SetRenderOnce(1, !0, this.uid)
        } else
            this.debug && console.warn("[Spine] ResetSlotColors, no skeleton.", this.uid, this.runtime.GetTickCount())
    },
    SetAnimationTime(a, b, d) {
        this._setAnimationTime(a, b, d)
    },
    UpdateBBoxes() {
        this.skeletonInfo.skeletonBounds.update(this.skeletonInfo.skeleton, !0)
    },
    SetAnimationMix(a, b, d) {
        this._setAnimationMix(a, b, d)
    },
    SetObjectRenderRate(a) {
        globalThis.spineBatcher ? globalThis.spineBatcher.renderRate = a : this.debug && console.warn("[Spine] SetObjectRenderRate, error no spineBatcher.", a, this.uid, this.runtime.GetTickCount())
    },
    SetDebug(a) {
        this.debug = a
    },
    SetDebugVariable(a, b) {
        spineBatcher$jscomp$1 ? (spineBatcher$jscomp$1.debugVariables[a] = b,
        this.debug && console.info("[Spine] SetDebugVariable", a, b, spineBatcher$jscomp$1.debugVariables)) : console.warn("[Spine] SetDebugVariable, no spineBatcher", a, b)
    },
    SetBoneControl(a, b, d) {
        this.spineBoneControl.setBoneControl(a, ["x", "y", "rotation", "scaleX", "scaleY"][b], d);
        this.SetRenderOnce(.017, !0, this.uid)
    },
    RemoveBoneControl(a, b) {
        this.spineBoneControl.removeBoneControl(a, ["x", "y", "rotation", "scaleX", "scaleY"][b]);
        this.SetRenderOnce(.017, !0, this.uid)
    },
    RemoveAllBoneControl(a) {
        this.spineBoneControl.removeAllBoneControl(a);
        this.SetRenderOnce(.017, !0, this.uid)
    },
    SetSkeletondataRenderQuality(a) {
        this.sdkType._skeletonRenderQuality = a;
        const b = this._sdkType._assetManager;
        this._sdkType._skeletonJson.scale = a;
        this._sdkType._skeletonData = "" == this.skeletonName ? this._sdkType._skeletonJson.readSkeletonData(b.get(this._sdkType._jsonURI)) : this._sdkType._skeletonJson.readSkeletonData(b.get(this._sdkType._jsonURI)[this.skeletonName])
    },
    SetValue(a, b) {
        b = b.split(".");
        this.SetValuePath(a, b)
    },
    SetNull(a) {
        a = a.split(".");
        this.SetValuePath(null, a)
    },
    DeleteKey(a) {
        var b = a.split(".");
        a = b.pop();
        b = this.GetValuePath(b, !1);
        "object" === typeof b && null !== b && delete b[a]
    },
    SetJSON(a, b) {
        try {
            if ("" === b)
                this.data = JSON.parse(a);
            else {
                var d = b.split(".")
                  , c = d.pop()
                  , e = this.GetValuePath(d, !0);
                "object" === typeof e && (console.log("parse", JSON.parse(a)),
                e[c] = JSON.parse(a))
            }
        } catch (g) {
            return console.warn("[Spine] JSON parse error", g, a),
            !1
        }
    },
    EnablePaletteColor(a) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? this.palette.enable = 0 === a ? !0 : !1 : this.debug && console.warn("[Spine] EnablePaletteColor, no skeleton", this.uid, this.runtime.GetTickCount())
    },
    SetSlotPalette(a, b) {
        this.palette.setSlotPalette(a, b)
    },
    SetSlotPaletteOffset(a, b) {
        this.palette.setSlotPaletteOffset(a, b)
    },
    SetPaletteDefaultColors(a) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.palette.setDefaultColors(a, 1, 1),
        this.palette.entryUploadNeeded[a] = !0,
        this.palette.uploadNeeded = !0) : this.debug && console.warn("[Spine] SetPaletteDefaultColors, no skeleton", this.uid, this.runtime.GetTickCount())
    },
    SetPaletteColor(a, b, d) {
        this.skeletonInfo && this.skeletonInfo.skeleton ? (this.palette.setColor(a, b, d),
        this.palette.entryUploadNeeded[a] = !0,
        this.palette.uploadNeeded = !0) : this.debug && console.warn("[Spine] SetPaletteColor, no skeleton", this.uid, this.runtime.GetTickCount())
    },
    SetAllPaletteColors(a) {
        let b = a.length;
        b / 2 > this.palette.palette.length && console.warn("[Spine] SetAllPaletteColorsFromString string too long:", b);
        for (let d = 0; d < b; d += 2)
            this.palette.palette[d / 2] = parseInt(a.substring(d, d + 2), 16);
        this.palette.entryUploadNeeded.fill(!0);
        this.palette.uploadNeeded = !0
    },
    SetEntryPaletteColors(a, b) {
        let d = b.length
          , c = this.palette.indexSize;
        d > 8 * c && console.warn("[Spine] SetEntryPaletteColorsFromString string too long:", d);
        for (let e = 0; e < d; e += 2)
            this.palette.palette[c * a * 4 + e / 2] = parseInt(b.substring(e, e + 2), 16);
        this.palette.entryUploadNeeded[a] = !0;
        this.palette.uploadNeeded = !0
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this.runtime.UpdateRender()
    },
    LoadSpineFiles(a, b, d) {
        this.debug && console.log("[Spine] LoadSpineFiles", this.uid, this.runtime.GetTickCount(), a, b, d);
        "" === this.jsonPath && (this.jsonPath = a,
        this.atlasPath = b,
        this.pngPath = d,
        this.runtime.UpdateRender())
    }
};
"use strict";
self.C3.Plugins.Gritsenko_Spine.Exps = {
    Skins() {
        return this.isLoaded ? this.skinNames.join("\n") : ""
    },
    CurrentSkin() {
        return this.isLoaded ? this.skinName : ""
    },
    SkinsCount() {
        return this.isLoaded ? this.skinNames.length : 0
    },
    SkinName(a) {
        return !this.isLoaded || a >= this.skinNames.length || 0 > a ? "" : this.skinNames[a]
    },
    Animations() {
        return this.isLoaded ? this.animationNames.join("\n") : ""
    },
    CurrentAnimation(a) {
        return this._currentAnimation(a)
    },
    AnimationsCount() {
        return this.isLoaded ? this.animationNames.length : 0
    },
    AnimationName(a) {
        return !this.isLoaded || a >= this.animationNames.length || 0 > a ? "" : this.animationNames[a]
    },
    Error() {
        return this.spineError
    },
    TextureHeight() {
        return this.isLoaded ? this.textureHeight : 0
    },
    TextureWidth() {
        return this.isLoaded ? this.textureWidth : 0
    },
    AnimationStart(a) {
        return this._animationStart(a)
    },
    AnimationEnd(a) {
        return this._animationEnd(a)
    },
    AnimationLast(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.animationLast : 0 : 0
    },
    TrackTime(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.trackTime : 0 : 0
    },
    Alpha(a) {
        if (!this.isLoaded)
            return 0;
        const b = this.skeletonInfo.state;
        return b && b.tracks ? (a = b.tracks[a]) ? a.alpha : 0 : 0
    },
    SpineBBoxCenterX(a, b) {
        if (!this.isLoaded)
            return 0;
        a = this.skeletonInfo.skeleton.getAttachmentByName(a, b);
        if (!a)
            return 0;
        a = this.skeletonInfo.skeletonBounds.getPolygon(a);
        var d = 0;
        for (b = 0; b < a.length; b += 2)
            d += a[b];
        d = d / (a.length / 2) + this.skeletonInfo.bounds.offset.x + this.skeletonInfo.bounds.size.x;
        this.isMirrored && (d = this.skeletonInfo.bounds.size.x - d);
        b = this.GetInstance().GetWorldInfo();
        d = b.GetX() - b.GetWidth() / 2 + d / (this.textureWidth / b.GetWidth());
        if (0 == b.GetAngle())
            return d;
        let c = 0;
        for (let e = 1; e < a.length; e += 2)
            c += a[e];
        c = this.skeletonInfo.bounds.size.y - c / (a.length / 2) + this.skeletonInfo.bounds.offset.y;
        a = b.GetY() - b.GetHeight() / 2 + c / (this.textureHeight / b.GetHeight());
        return Math.cos(b.GetAngle()) * (d - b.GetX()) - Math.sin(b.GetAngle()) * (a - b.GetY()) + b.GetX()
    },
    SpineBBoxCenterY(a, b) {
        if (!this.isLoaded)
            return 0;
        a = this.skeletonInfo.skeleton.getAttachmentByName(a, b);
        if (!a)
            return 0;
        a = this.skeletonInfo.skeletonBounds.getPolygon(a);
        var d = 0;
        for (b = 1; b < a.length; b += 2)
            d += a[b];
        d = this.skeletonInfo.bounds.size.y - d / (a.length / 2) + this.skeletonInfo.bounds.offset.y;
        b = this.GetInstance().GetWorldInfo();
        d = b.GetY() - b.GetHeight() / 2 + d / (this.textureHeight / b.GetHeight());
        if (0 == b.GetAngle())
            return d;
        let c = 0;
        for (let e = 0; e < a.length; e += 2)
            c += a[e];
        c = c / (a.length / 2) + this.skeletonInfo.bounds.offset.x + this.skeletonInfo.bounds.size.x;
        this.isMirrored && (c = this.skeletonInfo.bounds.size.x - c);
        a = b.GetX() - b.GetWidth() / 2 + c / (this.textureWidth / b.GetWidth());
        return Math.sin(b.GetAngle()) * (a - b.GetX()) + Math.cos(b.GetAngle()) * (d - b.GetY()) + b.GetY()
    },
    SpineBBoxGetPoly(a, b) {
        if (!this.isLoaded)
            return JSON.stringify({});
        var d = this.skeletonInfo.skeleton.getAttachmentByName(a, b);
        if (!d)
            return JSON.stringify({});
        var c = this.GetInstance().GetWorldInfo();
        a = c.GetX();
        b = c.GetY();
        let e = c.GetHeight() / 2
          , g = c.GetWidth() / 2
          , k = c.GetAngle()
          , l = this.textureHeight / c.GetHeight();
        c = this.textureWidth / c.GetWidth();
        let n = this.skeletonInfo.bounds.size.y
          , p = this.skeletonInfo.bounds.offset.y
          , t = this.skeletonInfo.bounds.size.x
          , w = this.skeletonInfo.bounds.offset.x
          , z = 0
          , B = 0;
        0 != k && (z = Math.cos(k),
        B = Math.sin(k));
        d = Array.from(this.skeletonInfo.skeletonBounds.getPolygon(d));
        for (let E = 0; E < d.length; E += 2) {
            var C = d[E] + w + t;
            d[E] = this.isMirrored ? t - C : C;
            d[E] = a - g + d[E] / c;
            d[E + 1] = n - d[E + 1] + p;
            d[E + 1] = b - e + d[E + 1] / l;
            0 != k && (C = B * (d[E] - a) + z * (d[E + 1] - b) + b,
            d[E] = z * (d[E] - a) - B * (d[E + 1] - b) + a,
            d[E + 1] = C)
        }
        return JSON.stringify(d)
    },
    BoneX(a) {
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty("x") ? this.spineBoneControl.bones[a].x : 0
    },
    BoneY(a) {
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty("y") ? this.spineBoneControl.bones[a].y : 0
    },
    BoneRotation(a) {
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty("rotation") ? this.spineBoneControl.bones[a].rotation : 0
    },
    BoneScaleX(a) {
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty("scaleX") ? this.spineBoneControl.bones[a].scaleX : 0
    },
    BoneScaleY(a) {
        return this.spineBoneControl.bones.hasOwnProperty(a) && this.spineBoneControl.bones[a].hasOwnProperty("scaleY") ? this.spineBoneControl.bones[a].scaleY : 0
    },
    AllPaletteColorString() {
        if (!this.palette)
            return "";
        let a = "";
        for (let b = 0; b < this.palette.palette.length; b++) {
            const d = this.palette.palette[b].toString(16).padStart(2, "0");
            a += d
        }
        return a
    },
    EntryPaletteColorString(a) {
        if (!this.palette)
            return "";
        let b = "";
        a = this.palette.indexSize * a * 4;
        for (let d = 0; d < this.palette.paletteNumber; d++) {
            const c = this.palette.palette[a + d].toString(16).padStart(2, "0");
            b += c
        }
        return b
    },
    GetValue(a) {
        if ("" === a)
            return "";
        a = a.split(".");
        a = this.GetValuePath(a, !1);
        return "object" === typeof a || null === a ? "" : a
    },
    GetAsCompactString(a) {
        a = a.split(".");
        "" === a[0] && (a = []);
        a = this.GetValuePath(a, !1);
        return JSON.stringify(a)
    },
    CurrentKey() {
        return this.currentKey
    },
    CurrentValue() {
        return this.currentValue
    },
    BboxOffsetX() {
        return this.bboxOffsetX
    },
    BboxOffsetY() {
        return this.bboxOffsetY
    },
    BboxSizeX() {
        return this.bboxSizeX
    },
    BboxSizeY() {
        return this.bboxSizeY
    },
    SkeletonScale() {
        return this.skeletonScale
    },
    GetEventData(a) {
        return "float int string balance volume audiopath event track".split(" ").includes(a) && a in this.completeEventData ? this.completeEventData[a] : ""
    }
};
"use strict";
const C3$jscomp$280 = self.C3;
C3$jscomp$280.Behaviors.Fade = class extends C3$jscomp$280.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$281 = self.C3;
C3$jscomp$281.Behaviors.Fade.Type = class extends C3$jscomp$281.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$282 = self.C3
  , C3X$jscomp$31 = self.C3X
  , IBehaviorInstance$jscomp$2 = self.IBehaviorInstance;
C3$jscomp$282.Behaviors.Fade.Instance = class extends C3$jscomp$282.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._fadeOutTime = this._waitTime = this._fadeInTime = 0;
        this._activeAtStart = this._destroy = !0;
        this._setMaxOpacity = !1;
        this._stage = 0;
        this._stageTime = C3$jscomp$282.New(C3$jscomp$282.KahanSum);
        this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1;
        b && (this._fadeInTime = b[0],
        this._waitTime = b[1],
        this._fadeOutTime = b[2],
        this._destroy = !!b[3],
        this._stage = (this._activeAtStart = !!b[4]) ? 0 : 3);
        this._activeAtStart && (0 === this._fadeInTime ? (this._stage = 1,
        0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0),
        this._runtime.UpdateRender()));
        this._StartTicking()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            fit: this._fadeInTime,
            wt: this._waitTime,
            fot: this._fadeOutTime,
            d: this._destroy,
            s: this._stage,
            st: this._stageTime.Get(),
            mo: this._maxOpacity
        }
    }
    LoadFromJson(a) {
        this._fadeInTime = a.fit;
        this._waitTime = a.wt;
        this._fadeOutTime = a.fot;
        this._destroy = a.d;
        this._stage = a.s;
        this._stageTime.Set(a.st);
        this._maxOpacity = a.mo;
        3 === this._stage ? this._StopTicking() : this._StartTicking()
    }
    Tick() {
        var a = this._runtime.GetDt(this._inst);
        this._stageTime.Add(a);
        a = this._inst.GetWorldInfo();
        0 === this._stage && (a.SetOpacity(this._stageTime.Get() / this._fadeInTime * this._maxOpacity),
        this._runtime.UpdateRender(),
        a.GetOpacity() >= this._maxOpacity && (a.SetOpacity(this._maxOpacity),
        this._stage = 1,
        this._stageTime.Reset(),
        this.DispatchScriptEvent("fadeinend"),
        this.Trigger(C3$jscomp$282.Behaviors.Fade.Cnds.OnFadeInEnd)));
        1 === this._stage && this._stageTime.Get() >= this._waitTime && (this._stage = 2,
        this._stageTime.Reset(),
        this.DispatchScriptEvent("waitend"),
        this.Trigger(C3$jscomp$282.Behaviors.Fade.Cnds.OnWaitEnd));
        2 === this._stage && (0 !== this._fadeOutTime ? (a.SetOpacity(this._maxOpacity - this._stageTime.Get() / this._fadeOutTime * this._maxOpacity),
        this._runtime.UpdateRender(),
        0 >= a.GetOpacity() && (this._stage = 3,
        this._stageTime.Reset(),
        this.DispatchScriptEvent("fadeoutend"),
        this.Trigger(C3$jscomp$282.Behaviors.Fade.Cnds.OnFadeOutEnd),
        this._destroy && this._runtime.DestroyInstance(this._inst))) : (this._stage = 3,
        this._stageTime.Reset()));
        3 === this._stage && this._StopTicking()
    }
    _StartFade() {
        this._activeAtStart || this._setMaxOpacity || (this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1,
        this._setMaxOpacity = !0);
        3 === this._stage && this.Start()
    }
    _RestartFade() {
        this.Start()
    }
    Start() {
        this._stage = 0;
        this._stageTime.Reset();
        0 === this._fadeInTime ? (this._stage = 1,
        0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0),
        this._runtime.UpdateRender());
        this._StartTicking()
    }
    _SetFadeInTime(a) {
        this._fadeInTime = Math.max(a, 0)
    }
    _GetFadeInTime() {
        return this._fadeInTime
    }
    _SetWaitTime(a) {
        this._waitTime = Math.max(a, 0)
    }
    _GetWaitTime() {
        return this._waitTime
    }
    _SetFadeOutTime(a) {
        this._fadeOutTime = Math.max(a, 0)
    }
    _GetFadeOutTime() {
        return this._fadeOutTime
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._GetFadeInTime();
        case 1:
            return this._GetWaitTime();
        case 2:
            return this._GetFadeOutTime();
        case 3:
            return this._destroy
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetFadeInTime(b);
            break;
        case 1:
            this._SetWaitTime(b);
            break;
        case 2:
            this._SetFadeOutTime(b);
            break;
        case 3:
            this._destroy = !!b
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.fade.properties.fade-in-time.name",
                value: this._GetFadeInTime(),
                onedit: a=>this._SetFadeInTime(a)
            }, {
                name: "behaviors.fade.properties.wait-time.name",
                value: this._GetWaitTime(),
                onedit: a=>this._SetWaitTime(a)
            }, {
                name: "behaviors.fade.properties.fade-out-time.name",
                value: this._GetFadeOutTime(),
                onedit: a=>this._SetFadeOutTime(a)
            }, {
                name: "behaviors.fade.debugger.stage",
                value: ["behaviors.fade.debugger." + ["fade-in", "wait", "fade-out", "done"][this._stage]]
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IFadeBehaviorInstance
    }
}
;
const map$jscomp$29 = new WeakMap;
self.IFadeBehaviorInstance = class extends IBehaviorInstance$jscomp$2 {
    constructor() {
        super();
        map$jscomp$29.set(this, IBehaviorInstance$jscomp$2._GetInitInst().GetSdkInstance())
    }
    startFade() {
        map$jscomp$29.get(this)._StartFade()
    }
    restartFade() {
        map$jscomp$29.get(this)._RestartFade()
    }
    set fadeInTime(a) {
        C3X$jscomp$31.RequireFiniteNumber(a);
        map$jscomp$29.get(this)._SetFadeInTime(a)
    }
    get fadeInTime() {
        return map$jscomp$29.get(this)._GetFadeInTime()
    }
    set waitTime(a) {
        C3X$jscomp$31.RequireFiniteNumber(a);
        map$jscomp$29.get(this)._SetWaitTime(a)
    }
    get waitTime() {
        return map$jscomp$29.get(this)._GetWaitTime()
    }
    set fadeOutTime(a) {
        C3X$jscomp$31.RequireFiniteNumber(a);
        map$jscomp$29.get(this)._SetFadeOutTime(a)
    }
    get fadeOutTime() {
        return map$jscomp$29.get(this)._GetFadeOutTime()
    }
}
;
self.C3.Behaviors.Fade.Cnds = {
    OnFadeOutEnd() {
        return !0
    },
    OnFadeInEnd() {
        return !0
    },
    OnWaitEnd() {
        return !0
    }
};
self.C3.Behaviors.Fade.Acts = {
    StartFade() {
        this._StartFade()
    },
    RestartFade() {
        this._RestartFade()
    },
    SetFadeInTime(a) {
        this._SetFadeInTime(a)
    },
    SetWaitTime(a) {
        this._SetWaitTime(a)
    },
    SetFadeOutTime(a) {
        this._SetFadeOutTime(a)
    }
};
self.C3.Behaviors.Fade.Exps = {
    FadeInTime() {
        return this._GetFadeInTime()
    },
    WaitTime() {
        return this._GetWaitTime()
    },
    FadeOutTime() {
        return this._GetFadeOutTime()
    }
};
"use strict";
const C3$jscomp$286 = self.C3;
C3$jscomp$286.Behaviors.Tween = class extends C3$jscomp$286.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$287 = self.C3;
C3$jscomp$287.Behaviors.Tween.Type = class extends C3$jscomp$287.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$288 = self.C3
  , NAMESPACE = C3$jscomp$288.Behaviors.Tween;
NAMESPACE.Instance = class extends C3$jscomp$288.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._allowMultiple = !1;
        this._enabled = !0;
        b && (this._allowMultiple = !1,
        this._enabled = !!b[0]);
        this._activeTweens = new Map;
        this._disabledTweens = [];
        this._waitingForReleaseTweens = new Map;
        this._waitingForReleaseTweensJson = this._disabledTweensJson = this._activeTweensJson = this._finishingTween = null;
        this._finishingTweenName = "";
        this._enabled && this._StartTicking2();
        this._afterLoad = d=>this._OnAfterLoad(d);
        this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad)
    }
    Release() {
        this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad);
        this._afterLoad = null;
        this._finishingTween && (this.ReleaseAndCompleteTween(this._finishingTween),
        this._finishingTween = null);
        this.ReleaseAndCompleteTweens();
        this._tweens = null;
        this.ClearDisabledList();
        this._disabledTweens = null;
        this._ReleaseWaitingTweens();
        this._waitingForReleaseTweens = null;
        super.Release()
    }
    SetEnabled(a) {
        this._enabled = !!a;
        a ? this._StartTicking2() : this._StopTicking2();
        for (const b of this.AllTweens())
            a ? this.IsInDisabledList(b) && b.Resume() : ((b.IsPlaying() || b.IsScheduled()) && this.AddToDisabledList(b),
            b.Stop());
        a && this.ClearDisabledList()
    }
    IsEnabled() {
        return this._enabled
    }
    AddToDisabledList(a) {
        this._disabledTweens.push(a)
    }
    IsInDisabledList(a) {
        return this._disabledTweens.includes(a)
    }
    ClearDisabledList() {
        C3$jscomp$288.clearArray(this._disabledTweens)
    }
    GetFinishingTween() {
        return this._finishingTween
    }
    IsInstanceValid() {
        const a = this.GetObjectInstance();
        return a ? !a.IsDestroyed() : !1
    }
    GetTween(a, b, d=!1) {
        if ((b = b ? this.PropertyTweens(b, d) : this.AllTweens(d)) && b.length)
            for (const c of b)
                if (c.HasTags(a))
                    return c
    }
    GetTweenIncludingWaitingForRelease(a, b) {
        return this.GetTween(a, b, !0)
    }
    *GetTweens(a, b, d=!1) {
        if ((b = b ? this.PropertyTweens(b, d) : this.AllTweens(d)) && b.length)
            for (const c of b)
                c.HasTags(a) && (yield c)
    }
    *GetTweensIncludingWaitingForRelease(a, b) {
        yield*this.GetTweens(a, b, !0)
    }
    PropertyTweens(a, b) {
        if (b)
            return b = this._activeTweens.get(a),
            a = this._waitingForReleaseTweens.get(a),
            b || (b = []),
            a || (a = []),
            b.concat(a).filter(d=>d).filter(d=>!d.IsReleased());
        (a = this._activeTweens.get(a)) || (a = []);
        return a.filter(d=>d).filter(d=>!d.IsReleased())
    }
    AllTweens(a) {
        if (a) {
            a = [...this._activeTweens.values()].flat();
            const b = [...this._waitingForReleaseTweens.values()].flat();
            return a.concat(b).filter(d=>d).filter(d=>!d.IsReleased())
        }
        return [...this._activeTweens.values()].flat().filter(b=>b).filter(b=>!b.IsReleased())
    }
    AllTweensIncludingWaitingForRelease() {
        return this.AllTweens(!0)
    }
    SaveToJson() {
        return {
            s: !1,
            e: !!this._enabled,
            at: this._SaveActiveTweensToJson(),
            dt: this._SaveDisabledTweensToJson(),
            wt: this._SaveWaitingForReleaseTweensToJson(),
            ft: this._SaveFinishingTweenToJson()
        }
    }
    LoadFromJson(a) {
        a && (this._activeTweensJson = a.at,
        this._disabledTweensJson = a.dt,
        this._waitingForReleaseTweensJson = a.wt,
        this._finishingTweenName = a.ft,
        this._allowMultiple = !1,
        this._enabled = !!a.e)
    }
    _OnAfterLoad(a) {
        a = this.GetRuntime().GetTimelineManager();
        this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, a);
        if (this._disabledTweensJson) {
            C3$jscomp$288.clearArray(this._disabledTweens);
            for (const b of this._disabledTweensJson)
                this._PopulateTweenArray(this._disabledTweens, b, a)
        }
        this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, a);
        this._finishingTween = this._GetTween(this._finishingTweenName, a);
        this._enabled ? this._StartTicking2() : this._StopTicking2()
    }
    _PopulateTweenMap(a, b, d) {
        if (a)
            for (const e in a) {
                let g = b.get(e);
                g ? C3$jscomp$288.clearArray(g) : g = [];
                var c = a[e];
                for (const k of c)
                    this._PopulateTweenArray(g, k.name, d) ? this._LoadTweenFromJson(k.name, k, d) : (c = C3$jscomp$288.TweenState.Build({
                        runtime: this.GetRuntime(),
                        json: k
                    }),
                    c.AddCompletedCallback(l=>this._FinishTriggers(l)),
                    d.AddScheduledTimeline(c),
                    this._PopulateTweenArray(g, c, d));
                b.set(e, g)
            }
    }
    _GetTween(a, b) {
        return b.GetScheduledOrPlayingTimelineByName(a)
    }
    _PopulateTweenArray(a, b, d) {
        if ("string" === typeof b) {
            if (b = this._GetTween(b, d))
                return !!a.push(b)
        } else
            return !!a.push(b);
        return !1
    }
    _LoadTweenFromJson(a, b, d) {
        "string" === typeof a ? (a = this._GetTween(a, d)) && a._LoadFromJson(b) : a._LoadFromJson(b)
    }
    _SaveActiveTweensToJson() {
        const a = {};
        for (const [b,d] of this._activeTweens)
            a[b] = d.filter(c=>!c.IsReleased()).map(c=>c._SaveToJson());
        return a
    }
    _SaveDisabledTweensToJson() {
        return this._disabledTweens.filter(a=>!a.IsReleased()).map(a=>a.GetName())
    }
    _SaveWaitingForReleaseTweensToJson() {
        const a = {};
        for (const [b,d] of this._waitingForReleaseTweens)
            a[b] = d.map(c=>c._SaveToJson());
        return a
    }
    _SaveFinishingTweenToJson() {
        return this._finishingTween ? this._finishingTween.GetName() : ""
    }
    Tick2() {
        this._ReleaseWaitingTweens()
    }
    CreateTween(a) {
        var b = NAMESPACE.Config.GetPropertyTracksConfig(a.property, a.startValue, a.endValue, a.ease, a.resultMode, this.GetObjectInstance());
        const d = NAMESPACE.Maps.GetPropertyFromIndex(a.property);
        NAMESPACE.Maps.IsValueId(d) || this.ReleaseTweens(a.property);
        b = C3$jscomp$288.TweenState.Build({
            runtime: this.GetRuntime(),
            id: d,
            tags: a.tags,
            time: a.time,
            instance: this.GetObjectInstance(),
            releaseOnComplete: !!a.releaseOnComplete,
            loop: !!a.loop,
            pingPong: !!a.pingPong,
            repeatCount: a.repeatCount,
            initialValueMode: a.initialValueMode,
            propertyTracksConfig: b
        });
        b.AddCompletedCallback(c=>this._FinishTriggers(c));
        this._AddTween(b, a.property);
        return b
    }
    _MaybeRemoveFromActiveTweenMap(a) {
        var b = a.GetId();
        this._activeTweens.has(b) && (b = this._activeTweens.get(b)) && (a = b.indexOf(a),
        -1 !== a && b.splice(a, 1))
    }
    ReleaseTween(a, b=!1) {
        this._MaybeRemoveFromActiveTweenMap(a);
        a.IsReleased() || this._IsInWaitingList(a) || (a.Stop(b),
        this._AddToWaitingList(a))
    }
    ReleaseTweens(a, b=!1) {
        if (C3$jscomp$288.IsFiniteNumber(a)) {
            var d = NAMESPACE.Maps.GetPropertyFromIndex(a);
            if (this._activeTweens.has(d)) {
                d = this._activeTweens.get(d);
                var c = this.GetFinishingTween();
                for (var e of d)
                    e === c || e.IsReleased() || this._IsInWaitingList(e) || (e.Stop(b),
                    e.Release());
                C3$jscomp$288.clearArray(d)
            }
        } else {
            e = this.GetFinishingTween();
            for (d of this.AllTweens())
                d === e || d.IsReleased() || this._IsInWaitingList(d) || (d.Stop(b),
                d.Release());
            for (c of this._activeTweens.keys())
                C3$jscomp$288.clearArray(this._activeTweens.get(c)),
                this._activeTweens.delete(c);
            this._activeTweens.clear()
        }
    }
    ReleaseAndCompleteTween(a) {
        this.ReleaseTween(a, !0)
    }
    ReleaseAndCompleteTweens() {
        this.ReleaseTweens(NaN, !0)
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._enabled
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._enabled = !!b
        }
    }
    _GetBehaviorType(a) {
        a = a.GetInstance().GetBehaviorInstances();
        for (const b of a)
            if (a = b.GetBehaviorType(),
            a.GetInstanceSdkCtor() === this.constructor)
                return a
    }
    Trigger(a, b, d, c) {
        return this._runtime ? super.Trigger(a) : b.Trigger(a, d, c)
    }
    _FinishTriggers(a) {
        this._finishingTween = a;
        NAMESPACE.Cnds.SetFinishingTween(a);
        let b, d;
        if (this.GetRuntime())
            b = this._inst,
            d = this._runtime,
            this.Trigger(NAMESPACE.Cnds.OnTweensFinished),
            this.Trigger(NAMESPACE.Cnds.OnAnyTweensFinished),
            this.ReleaseTween(a);
        else {
            b = a.GetInstance();
            if (!b || b && b.IsDestroyed())
                return;
            d = b.GetRuntime();
            const c = this._GetBehaviorType(a);
            this.Trigger(NAMESPACE.Cnds.OnTweensFinished, d, b, c);
            this.Trigger(NAMESPACE.Cnds.OnAnyTweensFinished, d, b, c);
            a.Stop()
        }
        this._finishingTween = null;
        NAMESPACE.Cnds.SetFinishingTween(null);
        a.GetDestroyInstanceOnComplete() && d.DestroyInstance(b)
    }
    _AddTween(a, b) {
        b = NAMESPACE.Maps.GetPropertyFromIndex(b);
        this._activeTweens.has(b) || this._activeTweens.set(b, []);
        this._activeTweens.get(b).push(a)
    }
    _AddToWaitingList(a) {
        const b = a.GetId();
        this._waitingForReleaseTweens.has(b) || this._waitingForReleaseTweens.set(b, []);
        this._waitingForReleaseTweens.get(b).push(a)
    }
    _IsInWaitingList(a) {
        const b = a.GetId();
        return this._waitingForReleaseTweens.has(b) ? this._waitingForReleaseTweens.get(b).includes(a) : !1
    }
    _ReleaseWaitingTweens() {
        if (this._waitingForReleaseTweens.size) {
            for (const a of this._waitingForReleaseTweens.values()) {
                for (const b of a)
                    b.IsReleased() || b.Release();
                C3$jscomp$288.clearArray(a)
            }
            this._waitingForReleaseTweens.clear()
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.tween.properties.enabled.name",
                value: this.IsEnabled(),
                onedit: a=>this.SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ITweenBehaviorInstance
    }
}
;
const C3$jscomp$289 = self.C3;
let finishingTween$jscomp$2 = null;
C3$jscomp$289.Behaviors.Tween.Cnds = {
    SetFinishingTween(a) {
        finishingTween$jscomp$2 = a
    },
    OnTweensFinished(a) {
        return finishingTween$jscomp$2.HasTags(a)
    },
    OnAnyTweensFinished() {
        return !0
    },
    IsPlaying(a) {
        return (a = [...this.GetTweensIncludingWaitingForRelease(a)],
        a.length) ? a.some(C3$jscomp$289.TweenState.IsPlaying) : !1
    },
    IsAnyPlaying() {
        const a = [...this.AllTweensIncludingWaitingForRelease()];
        return a && a.length ? a.some(C3$jscomp$289.TweenState.IsPlaying) : !1
    },
    IsPaused(a) {
        return (a = [...this.GetTweensIncludingWaitingForRelease(a)],
        a.length) ? a.some(C3$jscomp$289.TweenState.IsPaused) : !1
    },
    IsAnyPaused() {
        const a = [...this.AllTweensIncludingWaitingForRelease()];
        return a && a.length ? a.some(C3$jscomp$289.TweenState.IsPaused) : !1
    }
};
const C3$jscomp$290 = self.C3
  , Ease$jscomp$3 = self.Ease
  , NAMESPACE$jscomp$1 = C3$jscomp$290.Behaviors.Tween;
NAMESPACE$jscomp$1.Acts = {
    SetEnabled(a) {
        this.SetEnabled(!!a)
    },
    async TweenOneProperty(...a) {
        this.IsEnabled() && this.IsInstanceValid() && (a = this.CreateTween(NAMESPACE$jscomp$1.TweenArguments.OneProperty(this, ...a)),
        a.Play() && await a.GetPlayPromise())
    },
    async TweenTwoProperties(...a) {
        this.IsEnabled() && this.IsInstanceValid() && (a = this.CreateTween(NAMESPACE$jscomp$1.TweenArguments.TwoProperties(this, ...a)),
        a.Play() && await a.GetPlayPromise())
    },
    async TweenValue(...a) {
        this.IsEnabled() && this.IsInstanceValid() && (a = this.CreateTween(NAMESPACE$jscomp$1.TweenArguments.ValueProperty(this, ...a)),
        a.Play() && await a.GetPlayPromise())
    },
    PauseTweens(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.GetTweens(a))
                b.Stop()
    },
    PauseAllTweens() {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const a of this.AllTweens())
                a.Stop()
    },
    ResumeTweens(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.GetTweens(a))
                b.Resume()
    },
    ResumeAllTweens() {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const a of this.AllTweens())
                a.Resume()
    },
    StopTweens(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.GetTweens(a))
                this.ReleaseTween(b)
    },
    StopAllTweens() {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const a of this.AllTweens())
                this.ReleaseTween(a)
    },
    SetOnePropertyTweensEndValue(a, b, d) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            b = C3$jscomp$290.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(b);
            for (const c of this.GetTweens(a))
                c.BeforeSetEndValues([b]),
                c.SetEndValue(d, b)
        }
    },
    SetTwoPropertiesTweensEndValue(a, b, d, c) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            b = C3$jscomp$290.Behaviors.Tween.Maps.GetRealProperties(b);
            for (const e of this.GetTweens(a))
                e.BeforeSetEndValues(b),
                e.SetEndValue(d, b[0]),
                e.SetEndValue(c, b[1])
        }
    },
    SetValuePropertyTweensStartValue(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const d of this.GetTweens(a, "value"))
                d.SetStartValue(b, "value")
    },
    SetValuePropertyTweensEndValue(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const d of this.GetTweens(a, "value"))
                d.BeforeSetEndValues(["value"]),
                d.SetEndValue(b, "value")
    },
    SetTweensEase(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            b = Ease$jscomp$3.GetEaseFromIndex(b);
            for (const d of this.GetTweens(a))
                d.SetEase(b)
        }
    },
    SetAllTweensEase(a) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            a = Ease$jscomp$3.GetEaseFromIndex(a);
            for (const b of this.AllTweens())
                b.SetEase(a)
        }
    },
    SetTweensTime(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const d of this.GetTweens(a))
                d.SetTime(b)
    },
    SetAllTweensTime(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.AllTweens())
                b.SetTime(a)
    },
    SetTweensPlaybackRate(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const d of this.GetTweens(a))
                d.SetPlaybackRate(b)
    },
    SetAllTweensPlaybackRate(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.AllTweens())
                b.SetPlaybackRate(a)
    },
    SetTweensDestroyOnComplete(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const d of this.GetTweens(a))
                d.SetDestroyInstanceOnComplete(!!b)
    },
    SetAllTweensDestroyOnComplete(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.AllTweens())
                b.SetDestroyInstanceOnComplete(!!a)
    }
};
self.C3.Behaviors.Tween.Exps = {
    Time(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a)) ? a.GetTime() : 0
    },
    Progress(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a)) ? a.GetTime() / a.GetTotalTime() : 0
    },
    Value(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a, "value")) ? a.GetPropertyTrack("value").GetSourceAdapterValue() : 0
    },
    Tags() {
        return this.GetFinishingTween() ? this.GetFinishingTween().GetStringTags() : ""
    }
};
"use strict";
const C3$jscomp$292 = self.C3
  , Ease$jscomp$4 = self.Ease
  , PAIR_PROPERTIES = ["position", "size", "scale"]
  , SINGLE_PROPERTIES = "offsetX offsetY offsetWidth offsetHeight offsetAngle offsetOpacity offsetColor offsetZElevation offsetScaleX offsetScaleY".split(" ")
  , VALUE_PROPERTIES = ["value"]
  , PROPERTY_INDEX_TO_NAME = [].concat(PAIR_PROPERTIES).concat(SINGLE_PROPERTIES).concat(VALUE_PROPERTIES)
  , PROPERTY_PAIR_TO_REAL_PROPERTIES = {
    position: ["offsetX", "offsetY"],
    size: ["offsetWidth", "offsetHeight"],
    scale: ["offsetScaleX", "offsetScaleY"]
}
  , ALL_REAL_PROPERTIES = Object.assign({}, PROPERTY_INDEX_TO_NAME.reduce((a,b)=>Object.assign({}, a, {
    [b]: [b]
}), {}), PROPERTY_PAIR_TO_REAL_PROPERTIES);
C3$jscomp$292.Behaviors.Tween.Maps = class {
    constructor() {}
    static GetEases() {
        return [...Ease$jscomp$4.GetRuntimeEaseNames()]
    }
    static GetEaseFromIndex(a) {
        return [...Ease$jscomp$4.GetRuntimeEaseNames()][a]
    }
    static GetPropertyFromIndex(a) {
        return PROPERTY_INDEX_TO_NAME[a]
    }
    static GetPropertyIndexFromName(a) {
        return PROPERTY_INDEX_TO_NAME.indexOf(a)
    }
    static GetPairPropertyFromIndex(a) {
        return PAIR_PROPERTIES[a]
    }
    static GetSinglePropertyFromIndex(a) {
        return SINGLE_PROPERTIES[a]
    }
    static GetValuePropertyFromIndex(a) {
        return VALUE_PROPERTIES[a]
    }
    static GetPairProperties(a) {
        return PROPERTY_PAIR_TO_REAL_PROPERTIES[a]
    }
    static GetRealProperties(a) {
        return C3$jscomp$292.IsString(a) ? ALL_REAL_PROPERTIES[a] : ALL_REAL_PROPERTIES[PROPERTY_INDEX_TO_NAME[a]]
    }
    static IsPairId(a) {
        return !!PROPERTY_PAIR_TO_REAL_PROPERTIES[a]
    }
    static IsColorId(a) {
        return "offsetColor" === a
    }
    static IsAngleId(a) {
        return "offsetAngle" === a
    }
    static IsOpacityId(a) {
        return "offsetOpacity" === a
    }
    static IsValueId(a) {
        return "value" === a
    }
}
;
"use strict";
const C3$jscomp$293 = self.C3
  , NAMESPACE$jscomp$2 = C3$jscomp$293.Behaviors.Tween
  , TWEEN_CONFIGURATIONS = new Map;
NAMESPACE$jscomp$2.Config = class {
    constructor() {}
    static GetPropertyTracksConfig(a, b, d, c, e, g) {
        0 === TWEEN_CONFIGURATIONS.size && this._CreateConfigObjects();
        var k = NAMESPACE$jscomp$2.PropertyTypes.Pick(a);
        k = TWEEN_CONFIGURATIONS.get(k);
        C3$jscomp$293.IsFiniteNumber(a) && (a = NAMESPACE$jscomp$2.Maps.GetPropertyFromIndex(a));
        return this._GetConfig(k, a, b, d, c, e, g)
    }
    static TransformValue(a, b) {
        return C3$jscomp$293.Behaviors.Tween.GetPropertyTracksConfig(a).valueGetter(b)
    }
    static _CreateConfigObjects() {
        const a = NAMESPACE$jscomp$2.PropertyTypes
          , b = NAMESPACE$jscomp$2.ValueGetters;
        this._AddConfigObject(a.PAIR, this._GetPairConfig, b._GetPropertyValue);
        this._AddConfigObject(a.COLOR, this._GetColorConfig, b._GetColorPropertyValue);
        this._AddConfigObject(a.ANGLE, this._GetAngleConfig, b._GetPropertyAngleValue);
        this._AddConfigObject(a.VALUE, this._GetValueConfig, b._GetPropertyValue);
        this._AddConfigObject(a.OTHER, this._GetCommonConfig, b._GetPropertyValue)
    }
    static _AddConfigObject(a, b, d) {
        TWEEN_CONFIGURATIONS.set(a, this._CreateConfigObject(a, b, d))
    }
    static _CreateConfigObject(a, b, d) {
        return {
            name: a,
            configFunc: b,
            valueGetter: d
        }
    }
    static _GetConfig(a, b, d, c, e, g, k) {
        return a.configFunc(b, a.valueGetter(d), a.valueGetter(c), e, g, k)
    }
    static _GetPairConfig(a, b, d, c, e, g) {
        return NAMESPACE$jscomp$2.Maps.GetPairProperties(a).map((k,l)=>({
            sourceId: "world-instance",
            property: k,
            type: "float",
            valueType: "numeric",
            startValue: b[l],
            endValue: d[l],
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(c),
            resultMode: e
        }))
    }
    static _GetColorConfig(a, b, d, c, e, g) {
        return C3$jscomp$293.Plugins.Text && g.GetPlugin()instanceof C3$jscomp$293.Plugins.Text ? {
            sourceId: "plugin",
            sourceArgs: [7],
            property: "color",
            type: "color",
            valueType: "color",
            startValue: b,
            endValue: d,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(c),
            resultMode: e
        } : {
            sourceId: "world-instance",
            property: a,
            type: "color",
            valueType: "color",
            startValue: b,
            endValue: d,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(c),
            resultMode: e
        }
    }
    static _GetAngleConfig(a, b, d, c, e, g) {
        return {
            sourceId: "world-instance",
            property: a,
            type: "angle",
            valueType: "angle",
            startValue: b,
            endValue: d,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(c),
            resultMode: e
        }
    }
    static _GetCommonConfig(a, b, d, c, e, g) {
        return {
            sourceId: "world-instance",
            property: a,
            type: "float",
            valueType: "numeric",
            startValue: b,
            endValue: d,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(c),
            resultMode: e
        }
    }
    static _GetValueConfig(a, b, d, c, e, g) {
        return {
            sourceId: "value",
            property: a,
            type: "float",
            valueType: "numeric",
            startValue: b,
            endValue: d,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(c),
            resultMode: e
        }
    }
}
;
"use strict";
const C3$jscomp$294 = self.C3
  , NAMESPACE$jscomp$3 = C3$jscomp$294.Behaviors.Tween
  , COMMON_VARIABLE_ARGS = Object.assign({}, {
    resultMode: "absolute"
}, {
    tags: "",
    property: "",
    time: 0,
    ease: 0,
    releaseOnComplete: 0,
    loop: !1,
    pingPong: !1,
    repeatCount: 1
})
  , ONE_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
    initialValueMode: "current-state",
    startValue: 0,
    endValue: 0
})
  , TWO_PROPERTIES_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
    initialValueMode: "current-state",
    startValue: [0, 0],
    endValue: [0, 0]
})
  , COLOR_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
    initialValueMode: "current-state",
    startValue: [0, 0, 0],
    endValue: [0, 0, 0]
})
  , VALUE_PROPERTY_ARGS = Object.assign({}, ONE_PROPERTY_ARGS, {
    initialValueMode: "start-value"
});
NAMESPACE$jscomp$3.TweenArguments = class {
    constructor() {}
    static _SetCommonProperties(a, b, d, c, e, g, k, l) {
        a.tags = b;
        a.time = d;
        a.ease = c;
        a.releaseOnComplete = e;
        a.loop = g;
        a.pingPong = k;
        a.repeatCount = l
    }
    static OneProperty(a, b, d, c, e, g, k, l, n, p) {
        a = "string" === typeof d ? d : NAMESPACE$jscomp$3.Maps.GetSinglePropertyFromIndex(d);
        d = NAMESPACE$jscomp$3.Maps.IsColorId(a) ? COLOR_PROPERTY_ARGS : ONE_PROPERTY_ARGS;
        this._SetCommonProperties(d, b, e, g, k, l, n, p);
        NAMESPACE$jscomp$3.Maps.IsColorId(a) ? (COLOR_PROPERTY_ARGS.endValue[0] = C3$jscomp$294.GetRValue(c),
        COLOR_PROPERTY_ARGS.endValue[1] = C3$jscomp$294.GetGValue(c),
        COLOR_PROPERTY_ARGS.endValue[2] = C3$jscomp$294.GetBValue(c),
        COLOR_PROPERTY_ARGS.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName(a)) : NAMESPACE$jscomp$3.Maps.IsOpacityId(a) ? ONE_PROPERTY_ARGS.endValue = c / 100 : ONE_PROPERTY_ARGS.endValue = c;
        d.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName(a);
        return d
    }
    static TwoProperties(a, b, d, c, e, g, k, l, n, p, t) {
        this._SetCommonProperties(TWO_PROPERTIES_ARGS, b, g, k, l, n, p, t);
        a = "string" === typeof d ? d : NAMESPACE$jscomp$3.Maps.GetPairPropertyFromIndex(d);
        TWO_PROPERTIES_ARGS.endValue[0] = c;
        TWO_PROPERTIES_ARGS.endValue[1] = e;
        TWO_PROPERTIES_ARGS.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName(a);
        return TWO_PROPERTIES_ARGS
    }
    static ValueProperty(a, b, d, c, e, g, k, l, n, p) {
        this._SetCommonProperties(VALUE_PROPERTY_ARGS, b, e, g, k, l, n, p);
        VALUE_PROPERTY_ARGS.startValue = d;
        VALUE_PROPERTY_ARGS.endValue = c;
        VALUE_PROPERTY_ARGS.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName("value");
        return VALUE_PROPERTY_ARGS
    }
}
;
"use strict";
const C3$jscomp$295 = self.C3
  , NAMESPACE$jscomp$4 = C3$jscomp$295.Behaviors.Tween
  , TYPE_CHECK_OBJECTS = [];
NAMESPACE$jscomp$4.PropertyTypes = class {
    constructor() {}
    static Pick(a) {
        0 === TYPE_CHECK_OBJECTS.length && (TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsPairId,
            result: this.PAIR
        }),
        TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsColorId,
            result: this.COLOR
        }),
        TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsAngleId,
            result: this.ANGLE
        }),
        TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsValueId,
            result: this.VALUE
        }),
        TYPE_CHECK_OBJECTS.push({
            checkFunc: ()=>!0,
            result: this.OTHER
        }));
        C3$jscomp$295.IsFiniteNumber(a) && (a = C3$jscomp$295.Behaviors.Tween.Maps.GetPropertyFromIndex(a));
        for (const b of TYPE_CHECK_OBJECTS)
            if (b.checkFunc(a))
                return b.result
    }
    static get PAIR() {
        return "pair"
    }
    static get COLOR() {
        return "color"
    }
    static get ANGLE() {
        return "angle"
    }
    static get VALUE() {
        return "value"
    }
    static get OTHER() {
        return "other"
    }
}
;
"use strict";
const C3$jscomp$296 = self.C3;
C3$jscomp$296.Behaviors.Tween.ValueGetters = class {
    constructor() {}
    static _GetPropertyAngleValue(a) {
        a = C3$jscomp$296.toRadians(parseFloat(a));
        return C3$jscomp$296.clampAngle(a)
    }
    static _GetColorPropertyValue(a) {
        return a.slice(0)
    }
    static _GetPropertyValue(a) {
        return a
    }
}
;
"use strict";
const C3$jscomp$297 = self.C3
  , C3X$jscomp$32 = self.C3X
  , IBehaviorInstance$jscomp$3 = self.IBehaviorInstance
  , Ease$jscomp$5 = self.Ease
  , NAMESPACE$jscomp$6 = C3$jscomp$297.Behaviors.Tween
  , map$jscomp$31 = new WeakMap
  , TWEEN_PROPERTIES = new Map([["x", {
    name: "offsetX",
    type: "one"
}], ["y", {
    name: "offsetY",
    type: "one"
}], ["width", {
    name: "offsetWidth",
    type: "one"
}], ["height", {
    name: "offsetHeight",
    type: "one"
}], ["angle", {
    name: "offsetAngle",
    type: "one"
}], ["opacity", {
    name: "offsetOpacity",
    type: "one"
}], ["color", {
    name: "offsetColor",
    type: "color"
}], ["z-elevation", {
    name: "offsetZElevation",
    type: "one"
}], ["x-scale", {
    name: "offsetScaleX",
    type: "one"
}], ["y-scale", {
    name: "offsetScaleY",
    type: "one"
}], ["position", {
    name: "position",
    type: "two"
}], ["size", {
    name: "size",
    type: "two"
}], ["scale", {
    name: "scale",
    type: "two"
}], ["value", {
    name: "value",
    type: "value"
}]]);
function getIndexForEase(a) {
    C3X$jscomp$32.RequireString(a);
    var b = Ease$jscomp$5.ToInternal(a);
    b = b ? Ease$jscomp$5.GetIndexForEase(b, null) : Ease$jscomp$5.GetIndexForEase(a, null);
    if (-1 === b)
        throw Error(`invalid ease name '${a}'`);
    return b
}
const TWEEN_OPTS = {
    tags: "",
    destroyOnComplete: !1,
    loop: !1,
    pingPong: !1,
    repeatCount: 1,
    startValue: 0
}
  , I_TWEEN_OPTS = {
    easeToIndexFunc: getIndexForEase
};
self.ITweenBehaviorInstance = class extends IBehaviorInstance$jscomp$3 {
    constructor() {
        super();
        map$jscomp$31.set(this, IBehaviorInstance$jscomp$3._GetInitInst().GetSdkInstance())
    }
    startTween(a, b, d, c, e) {
        const g = map$jscomp$31.get(this);
        if (!g.IsEnabled() || !g.IsInstanceValid())
            return null;
        const k = TWEEN_PROPERTIES.get(a);
        if (!k)
            throw Error("invalid tween property");
        "one" === k.type || "value" === k.type ? C3X$jscomp$32.RequireNumber(b) : (C3X$jscomp$32.RequireArray(b),
        "two" === k.type ? (C3X$jscomp$32.RequireNumber(b[0]),
        C3X$jscomp$32.RequireNumber(b[1])) : "color" === k.type && (C3X$jscomp$32.RequireNumber(b[0]),
        C3X$jscomp$32.RequireNumber(b[1]),
        C3X$jscomp$32.RequireNumber(b[2])));
        "angle" === a ? b = C3$jscomp$297.toDegrees(b) : "opacity" === a ? b *= 100 : "color" === a && (b = C3$jscomp$297.PackRGBEx(b[0], b[1], b[2]));
        a = getIndexForEase(c);
        C3X$jscomp$32.RequireFiniteNumber(d);
        e = Object.assign({}, TWEEN_OPTS, e);
        "value" === k.type && C3X$jscomp$32.RequireNumber(e.startValue);
        let l;
        "one" === k.type || "color" === k.type ? l = g.CreateTween(NAMESPACE$jscomp$6.TweenArguments.OneProperty(g, e.tags, k.name, b, d, a, !!e.destroyOnComplete, !!e.loop, !!e.pingPong, e.repeatCount)) : "two" === k.type ? l = g.CreateTween(NAMESPACE$jscomp$6.TweenArguments.TwoProperties(g, e.tags, k.name, b[0], b[1], d, a, !!e.destroyOnComplete, !!e.loop, !!e.pingPong, e.repeatCount)) : "value" === k.type && (l = g.CreateTween(NAMESPACE$jscomp$6.TweenArguments.ValueProperty(g, e.tags, e.startValue, b, d, a, !!e.destroyOnComplete, !!e.loop, !!e.pingPong, e.repeatCount)));
        if (!l.Play())
            throw Error("failed to start tween");
        return l.GetITweenState(g, I_TWEEN_OPTS)
    }
    *allTweens() {
        const a = map$jscomp$31.get(this);
        for (const b of a.AllTweens())
            yield b.GetITweenState(a, I_TWEEN_OPTS)
    }
    *tweensByTags(a) {
        C3X$jscomp$32.RequireString(a);
        const b = map$jscomp$31.get(this);
        for (const d of b.GetTweens(a))
            yield d.GetITweenState(b, I_TWEEN_OPTS)
    }
    get isEnabled() {
        return map$jscomp$31.get(this).IsEnabled()
    }
    set isEnabled(a) {
        map$jscomp$31.get(this).SetEnabled(a)
    }
}
;
"use strict";
const C3$jscomp$298 = self.C3;
C3$jscomp$298.Behaviors.scrollto = class extends C3$jscomp$298.SDKBehaviorBase {
    constructor(a) {
        super(a);
        this._shakeMode = this._shakeEnd = this._shakeStart = this._shakeMag = 0
    }
    Release() {
        super.Release()
    }
    SetShakeMagnitude(a) {
        this._shakeMag = a
    }
    GetShakeMagnitude() {
        return this._shakeMag
    }
    SetShakeStart(a) {
        this._shakeStart = a
    }
    GetShakeStart() {
        return this._shakeStart
    }
    SetShakeEnd(a) {
        this._shakeEnd = a
    }
    GetShakeEnd() {
        return this._shakeEnd
    }
    SetShakeMode(a) {
        this._shakeMode = a
    }
    GetShakeMode() {
        return this._shakeMode
    }
}
;
const C3$jscomp$299 = self.C3;
C3$jscomp$299.Behaviors.scrollto.Type = class extends C3$jscomp$299.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$300 = self.C3;
C3$jscomp$300.Behaviors.scrollto.Instance = class extends C3$jscomp$300.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._isEnabled = !0;
        b && (this._isEnabled = b[0]);
        this._isEnabled && this._StartTicking2()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        const a = this.GetBehavior();
        return {
            e: this._isEnabled,
            smg: a.GetShakeMagnitude(),
            ss: a.GetShakeStart(),
            se: a.GetShakeEnd(),
            smd: a.GetShakeMode()
        }
    }
    LoadFromJson(a) {
        const b = this.GetBehavior();
        b.SetShakeMagnitude(a.smg);
        b.SetShakeStart(a.ss);
        b.SetShakeEnd(a.se);
        b.SetShakeMode(a.smd);
        (this._isEnabled = a.e) ? this._StartTicking2() : this._StopTicking2()
    }
    _SetEnabled(a) {
        (this._isEnabled = !!a) ? this._StartTicking2() : this._StopTicking2()
    }
    IsEnabled() {
        return this._isEnabled
    }
    Tick2() {
        if (this.IsEnabled()) {
            this._runtime.GetDt(this._inst);
            var a = this.GetBehavior()
              , b = a.GetInstances()
              , d = 0
              , c = 0
              , e = 0;
            for (var g of b)
                (b = g.GetBehaviorInstanceFromCtor(C3$jscomp$300.Behaviors.scrollto)) && b.GetSdkInstance().IsEnabled() && (b = g.GetWorldInfo(),
                d += b.GetX(),
                c += b.GetY(),
                ++e);
            g = this._inst.GetWorldInfo().GetLayout();
            var k = this._runtime.GetGameTime()
              , l = b = 0;
            k >= a.GetShakeStart() && k < a.GetShakeEnd() && (b = a.GetShakeMagnitude() * Math.min(this._runtime.GetTimeScale(), 1),
            0 === a.GetShakeMode() && (b *= 1 - (k - a.GetShakeStart()) / (a.GetShakeEnd() - a.GetShakeStart())),
            a = this._runtime.Random() * Math.PI * 2,
            k = this._runtime.Random() * b,
            b = Math.cos(a) * k,
            l = Math.sin(a) * k);
            g.SetScrollX(d / e + b);
            g.SetScrollY(c / e + l)
        }
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._isEnabled
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            (this._isEnabled = !!b) ? this._StartTicking2() : this._StopTicking2()
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.scrollto.properties.enabled.name",
                value: this.IsEnabled(),
                onedit: a=>this._SetEnabled(a)
            }]
        }]
    }
}
;
self.C3.Behaviors.scrollto.Cnds = {
    IsEnabled() {
        return this.IsEnabled()
    }
};
self.C3.Behaviors.scrollto.Acts = {
    Shake(a, b, d) {
        const c = this.GetBehavior();
        c.SetShakeMagnitude(a);
        c.SetShakeStart(this._runtime.GetGameTime());
        c.SetShakeEnd(this._runtime.GetGameTime() + b);
        c.SetShakeMode(d)
    },
    SetEnabled(a) {
        this._SetEnabled(0 !== a)
    }
};
self.C3.Behaviors.scrollto.Exps = {};
"use strict";
const C3$jscomp$304 = self.C3;
C3$jscomp$304.Behaviors.Sin = class extends C3$jscomp$304.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$305 = self.C3;
C3$jscomp$305.Behaviors.Sin.Type = class extends C3$jscomp$305.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$306 = self.C3
  , C3X$jscomp$33 = self.C3X
  , IBehaviorInstance$jscomp$4 = self.IBehaviorInstance
  , _2pi = 2 * Math.PI
  , _pi_2 = Math.PI / 2
  , _3pi_2 = 3 * Math.PI / 2
  , MOVEMENT_LOOKUP = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];
C3$jscomp$306.Behaviors.Sin.Instance = class extends C3$jscomp$306.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._mag = this._period = this._wave = this._movement = this._i = 0;
        this._isEnabled = !0;
        this._ratio = this._lastKnownValue2 = this._lastKnownValue = this._initialValue2 = this._initialValue = this._magnitudeRandom = this._periodOffsetRandom = this._periodRandom = this._baseMag = this._basePeriodOffset = this._basePeriod = 0;
        b && (this._movement = MOVEMENT_LOOKUP[b[0]],
        this._wave = b[1],
        this._periodRandom = this._runtime.Random() * b[3],
        this._basePeriod = b[2],
        this._period = b[2],
        this._period += this._periodRandom,
        this._basePeriodOffset = b[4],
        0 !== this._period && (this._periodOffsetRandom = this._runtime.Random() * b[5],
        this._i = b[4] / this._period * _2pi,
        this._i += this._periodOffsetRandom / this._period * _2pi),
        this._magnitudeRandom = this._runtime.Random() * b[7],
        this._baseMag = b[6],
        this._mag = b[6],
        this._mag += this._magnitudeRandom,
        this._isEnabled = !!b[8]);
        5 === this._movement && (this._mag = C3$jscomp$306.toRadians(this._mag));
        this.Init();
        this._isEnabled && this._StartTicking()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            i: this._i,
            e: this._isEnabled,
            mv: this._movement,
            w: this._wave,
            p: this._period,
            mag: this._mag,
            iv: this._initialValue,
            iv2: this._initialValue2,
            r: this._ratio,
            lkv: this._lastKnownValue,
            lkv2: this._lastKnownValue2
        }
    }
    LoadFromJson(a) {
        this._i = a.i;
        this._SetEnabled(a.e);
        this._movement = a.mv;
        this._wave = a.w;
        this._period = a.p;
        this._mag = a.mag;
        this._initialValue = a.iv;
        this._initialValue2 = a.iv2;
        this._ratio = a.r;
        this._lastKnownValue = a.lkv;
        this._lastKnownValue2 = a.lkv2
    }
    Init() {
        const a = this._inst.GetWorldInfo();
        switch (this._movement) {
        case 0:
            this._initialValue = a.GetX();
            break;
        case 1:
            this._initialValue = a.GetY();
            break;
        case 2:
            this._initialValue = a.GetWidth();
            this._ratio = a.GetHeight() / a.GetWidth();
            break;
        case 3:
            this._initialValue = a.GetWidth();
            break;
        case 4:
            this._initialValue = a.GetHeight();
            break;
        case 5:
            this._initialValue = a.GetAngle();
            break;
        case 6:
            this._initialValue = a.GetOpacity();
            break;
        case 7:
            this._initialValue = 0;
            break;
        case 8:
            this._initialValue = a.GetX();
            this._initialValue2 = a.GetY();
            break;
        case 9:
            this._initialValue = a.GetZElevation()
        }
        this._lastKnownValue = this._initialValue;
        this._lastKnownValue2 = this._initialValue2
    }
    WaveFunc(a) {
        a %= _2pi;
        switch (this._wave) {
        case 0:
            return Math.sin(a);
        case 1:
            return a <= _pi_2 ? a / _pi_2 : a <= _3pi_2 ? 1 - 2 * (a - _pi_2) / Math.PI : (a - _3pi_2) / _pi_2 - 1;
        case 2:
            return 2 * a / _2pi - 1;
        case 3:
            return -2 * a / _2pi + 1;
        case 4:
            return a < Math.PI ? -1 : 1
        }
        return 0
    }
    Tick() {
        const a = this._runtime.GetDt(this._inst);
        this._isEnabled && 0 !== a && (this._i = 0 === this._period ? 0 : (this._i + a / this._period * _2pi) % _2pi,
        this._UpdateFromPhase())
    }
    _UpdateFromPhase() {
        const a = this._inst.GetWorldInfo();
        switch (this._movement) {
        case 0:
            a.GetX() !== this._lastKnownValue && (this._initialValue += a.GetX() - this._lastKnownValue);
            a.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetX();
            break;
        case 1:
            a.GetY() !== this._lastKnownValue && (this._initialValue += a.GetY() - this._lastKnownValue);
            a.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetY();
            break;
        case 2:
            a.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
            a.SetHeight(a.GetWidth() * this._ratio);
            break;
        case 3:
            a.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
            break;
        case 4:
            a.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
            break;
        case 5:
            a.GetAngle() !== this._lastKnownValue && (this._initialValue = C3$jscomp$306.clampAngle(this._initialValue + (a.GetAngle() - this._lastKnownValue)));
            a.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetAngle();
            break;
        case 6:
            a.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);
            break;
        case 8:
            a.GetX() !== this._lastKnownValue && (this._initialValue += a.GetX() - this._lastKnownValue);
            a.GetY() !== this._lastKnownValue2 && (this._initialValue2 += a.GetY() - this._lastKnownValue2);
            a.SetX(this._initialValue + Math.cos(a.GetAngle()) * this.WaveFunc(this._i) * this._mag);
            a.SetY(this._initialValue2 + Math.sin(a.GetAngle()) * this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetX();
            this._lastKnownValue2 = a.GetY();
            break;
        case 9:
            a.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag)
        }
        a.SetBboxChanged()
    }
    _OnSpriteFrameChanged(a, b) {}
    _SetPeriod(a) {
        this._period = a
    }
    _GetPeriod() {
        return this._period
    }
    _SetMagnitude(a) {
        this._mag = a
    }
    _SetMagnitude_ConvertAngle(a) {
        5 === this._movement && (a = C3$jscomp$306.toRadians(a));
        this._SetMagnitude(a)
    }
    _GetMagnitude() {
        return this._mag
    }
    _GetMagnitude_ConvertAngle() {
        let a = this._GetMagnitude();
        5 === this._movement && (a = C3$jscomp$306.toDegrees(a));
        return a
    }
    _SetMovement(a) {
        5 === this._movement && 5 !== a && (this._mag = C3$jscomp$306.toDegrees(this._mag));
        this._movement = a;
        this.Init()
    }
    _GetMovement() {
        return this._movement
    }
    _SetWave(a) {
        this._wave = a
    }
    _GetWave() {
        return this._wave
    }
    _SetPhase(a) {
        this._i = C3$jscomp$306.clamp(a, 0, 2 * Math.PI);
        this._UpdateFromPhase()
    }
    _GetPhase() {
        return this._i
    }
    _SetEnabled(a) {
        (this._isEnabled = !!a) ? this._StartTicking() : this._StopTicking()
    }
    _IsEnabled() {
        return this._isEnabled
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._movement;
        case 1:
            return this._wave;
        case 2:
            return this._basePeriod;
        case 6:
            return this._baseMag;
        case 8:
            return this._isEnabled
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._movement = MOVEMENT_LOOKUP[b];
            this.Init();
            break;
        case 1:
            this._wave = b;
            break;
        case 2:
            this._basePeriod = b;
            this._period = this._basePeriod + this._periodRandom;
            this._isEnabled || (0 !== this._period ? (this._i = this._basePeriodOffset / this._period * _2pi,
            this._i += this._periodOffsetRandom / this._period * _2pi) : this._i = 0);
            break;
        case 6:
            this._baseMag = b;
            this._mag = this._baseMag + this._magnitudeRandom;
            5 === this._movement && (this._mag = C3$jscomp$306.toRadians(this._mag));
            break;
        case 8:
            this._isEnabled = !!b
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.sin.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a=>this._SetEnabled(a)
            }, {
                name: "behaviors.sin.properties.period.name",
                value: this._GetPeriod(),
                onedit: a=>this._SetPeriod(a)
            }, {
                name: "behaviors.sin.properties.magnitude.name",
                value: this._GetMagnitude_ConvertAngle(),
                onedit: a=>this._SetMagnitude_ConvertAngle(a)
            }, {
                name: "behaviors.sin.debugger.value",
                value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.ISineBehaviorInstance
    }
}
;
const map$jscomp$32 = new WeakMap
  , VALID_MOVEMENTS = "horizontal vertical size width height angle opacity value-only forwards-backwards z-elevation".split(" ")
  , VALID_WAVES = ["sine", "triangle", "sawtooth", "reverse-sawtooth", "square"];
self.ISineBehaviorInstance = class extends IBehaviorInstance$jscomp$4 {
    constructor() {
        super();
        map$jscomp$32.set(this, IBehaviorInstance$jscomp$4._GetInitInst().GetSdkInstance())
    }
    set period(a) {
        C3X$jscomp$33.RequireFiniteNumber(a);
        map$jscomp$32.get(this)._SetPeriod(a)
    }
    get period() {
        return map$jscomp$32.get(this)._GetPeriod()
    }
    set magnitude(a) {
        C3X$jscomp$33.RequireFiniteNumber(a);
        map$jscomp$32.get(this)._SetMagnitude(a)
    }
    get magnitude() {
        return map$jscomp$32.get(this)._GetMagnitude()
    }
    set phase(a) {
        map$jscomp$32.get(this)._SetPhase(a)
    }
    get phase() {
        return map$jscomp$32.get(this)._GetPhase()
    }
    set movement(a) {
        C3X$jscomp$33.RequireString(a);
        a = VALID_MOVEMENTS.indexOf(a);
        if (-1 === a)
            throw Error("invalid movement");
        map$jscomp$32.get(this)._SetMovement(a)
    }
    get movement() {
        return VALID_MOVEMENTS[map$jscomp$32.get(this)._GetMovement()]
    }
    set wave(a) {
        C3X$jscomp$33.RequireString(a);
        a = VALID_WAVES.indexOf(a);
        if (-1 === a)
            throw Error("invalid wave");
        map$jscomp$32.get(this)._SetWave(a)
    }
    get wave() {
        return VALID_WAVES[map$jscomp$32.get(this)._GetWave()]
    }
    get value() {
        const a = map$jscomp$32.get(this);
        return a.WaveFunc(a._GetPhase()) * a._GetMagnitude()
    }
    updateInitialState() {
        map$jscomp$32.get(this).Init()
    }
    set isEnabled(a) {
        map$jscomp$32.get(this)._SetEnabled(!!a)
    }
    get isEnabled() {
        return map$jscomp$32.get(this)._IsEnabled()
    }
}
;
const C3$jscomp$307 = self.C3;
C3$jscomp$307.Behaviors.Sin.Cnds = {
    IsEnabled() {
        return this._IsEnabled()
    },
    CompareMovement(a) {
        return this._GetMovement() === a
    },
    ComparePeriod(a, b) {
        return C3$jscomp$307.compare(this._GetPeriod(), a, b)
    },
    CompareMagnitude(a, b) {
        return C3$jscomp$307.compare(this._GetMagnitude_ConvertAngle(), a, b)
    },
    CompareWave(a) {
        return this._GetWave() === a
    }
};
self.C3.Behaviors.Sin.Acts = {
    SetEnabled(a) {
        this._SetEnabled(0 !== a)
    },
    SetPeriod(a) {
        this._SetPeriod(a)
    },
    SetMagnitude(a) {
        this._SetMagnitude_ConvertAngle(a)
    },
    SetMovement(a) {
        this._SetMovement(a)
    },
    SetWave(a) {
        this._wave = a
    },
    SetPhase(a) {
        const b = 2 * Math.PI;
        this._SetPhase(a * b % b)
    },
    UpdateInitialState() {
        this.Init()
    }
};
self.C3.Behaviors.Sin.Exps = {
    CyclePosition() {
        return this._GetPhase() / (2 * Math.PI)
    },
    Period() {
        return this._GetPeriod()
    },
    Magnitude() {
        return this._GetMagnitude_ConvertAngle()
    },
    Value() {
        return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()
    }
};
"use strict";
const C3$jscomp$310 = self.C3;
C3$jscomp$310.Behaviors.Rotate = class extends C3$jscomp$310.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$311 = self.C3;
C3$jscomp$311.Behaviors.Rotate.Type = class extends C3$jscomp$311.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$312 = self.C3
  , C3X$jscomp$34 = self.C3X
  , IBehaviorInstance$jscomp$5 = self.IBehaviorInstance;
C3$jscomp$312.Behaviors.Rotate.Instance = class extends C3$jscomp$312.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._acceleration = this._speed = 0;
        this._isEnabled = !0;
        b && (this._speed = C3$jscomp$312.toRadians(b[0]),
        this._acceleration = C3$jscomp$312.toRadians(b[1]),
        this._isEnabled = b[2]);
        this._isEnabled && this._StartTicking()
    }
    Release() {
        super.Release()
    }
    _SetSpeed(a) {
        this._speed = a
    }
    _GetSpeed() {
        return this._speed
    }
    _SetAcceleration(a) {
        this._acceleration = a
    }
    _GetAcceleration() {
        return this._acceleration
    }
    SaveToJson() {
        return {
            s: this._speed,
            a: this._acceleration,
            e: this._isEnabled
        }
    }
    LoadFromJson(a) {
        this._speed = a.s;
        this._acceleration = a.a;
        this._SetEnabled(a.e)
    }
    Tick() {
        if (this._isEnabled) {
            var a = this._runtime.GetDt(this._inst);
            if (0 !== a && (0 !== this._acceleration && (this._speed += this._acceleration * a),
            0 !== this._speed)) {
                const b = this._inst.GetWorldInfo();
                b.SetAngle(b.GetAngle() + this._speed * a);
                b.SetBboxChanged()
            }
        }
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return C3$jscomp$312.toDegrees(this._GetSpeed());
        case 1:
            return C3$jscomp$312.toDegrees(this._GetAcceleration());
        case 2:
            return this._IsEnabled()
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetSpeed(C3$jscomp$312.toRadians(b));
            break;
        case 1:
            this._SetAcceleration(C3$jscomp$312.toRadians(b));
            break;
        case 2:
            this._SetEnabled(b)
        }
    }
    _SetEnabled(a) {
        (this._isEnabled = !!a) ? this._StartTicking() : this._StopTicking()
    }
    _IsEnabled() {
        return this._isEnabled
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.rotate.properties.speed.name",
                value: C3$jscomp$312.toDegrees(this._GetSpeed()),
                onedit: a=>this._SetSpeed(C3$jscomp$312.toRadians(a))
            }, {
                name: "behaviors.rotate.properties.acceleration.name",
                value: C3$jscomp$312.toDegrees(this._GetAcceleration()),
                onedit: a=>this._SetAcceleration(C3$jscomp$312.toRadians(a))
            }, {
                name: "behaviors.rotate.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a=>this._SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IRotateBehaviorInstance
    }
}
;
const map$jscomp$33 = new WeakMap;
self.IRotateBehaviorInstance = class extends IBehaviorInstance$jscomp$5 {
    constructor() {
        super();
        map$jscomp$33.set(this, IBehaviorInstance$jscomp$5._GetInitInst().GetSdkInstance())
    }
    set speed(a) {
        C3X$jscomp$34.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetSpeed(a)
    }
    get speed() {
        return map$jscomp$33.get(this)._GetSpeed()
    }
    set acceleration(a) {
        C3X$jscomp$34.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetAcceleration(a)
    }
    get acceleration() {
        return map$jscomp$33.get(this)._GetAcceleration()
    }
    get isEnabled() {
        return map$jscomp$33.get(this)._IsEnabled()
    }
    set isEnabled(a) {
        map$jscomp$33.get(this)._SetEnabled(a)
    }
}
;
self.C3.Behaviors.Rotate.Cnds = {
    IsEnabled() {
        return this._IsEnabled()
    }
};
const C3$jscomp$314 = self.C3;
C3$jscomp$314.Behaviors.Rotate.Acts = {
    SetSpeed(a) {
        this._SetSpeed(C3$jscomp$314.toRadians(a))
    },
    SetAcceleration(a) {
        this._SetAcceleration(C3$jscomp$314.toRadians(a))
    },
    SetEnabled(a) {
        this._SetEnabled(a)
    }
};
const C3$jscomp$315 = self.C3;
C3$jscomp$315.Behaviors.Rotate.Exps = {
    Speed() {
        return C3$jscomp$315.toDegrees(this._GetSpeed())
    },
    Acceleration() {
        return C3$jscomp$315.toDegrees(this._GetAcceleration())
    }
};
"use strict";
const C3$jscomp$316 = self.C3;
C3$jscomp$316.Behaviors.Bullet = class extends C3$jscomp$316.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$317 = self.C3;
C3$jscomp$317.Behaviors.Bullet.Type = class extends C3$jscomp$317.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$318 = self.C3
  , C3X$jscomp$35 = self.C3X
  , IBehaviorInstance$jscomp$6 = self.IBehaviorInstance;
C3$jscomp$318.Behaviors.Bullet.Instance = class extends C3$jscomp$318.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        a = this.GetWorldInfo();
        this._g = this._acc = this._speed = 0;
        this._isStepping = this._setAngle = this._bounceOffSolid = !1;
        this._isEnabled = !0;
        this._dy = this._dx = 0;
        this._lastX = a.GetX();
        this._lastY = a.GetY();
        this._lastKnownAngle = a.GetAngle();
        this._travelled = 0;
        this._stepSize = Math.min(Math.abs(a.GetWidth()), Math.abs(a.GetHeight()) / 2);
        this._stopStepping = !1;
        b && (this._speed = b[0],
        this._acc = b[1],
        this._g = b[2],
        this._bounceOffSolid = !!b[3],
        this._setAngle = !!b[4],
        this._isStepping = !!b[5],
        this._isEnabled = !!b[6]);
        b = a.GetAngle();
        this._dx = Math.cos(b) * this._speed;
        this._dy = Math.sin(b) * this._speed;
        this._isEnabled && (this._StartTicking(),
        this._bounceOffSolid && this._StartPostTicking())
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        const a = {
            dx: this._dx,
            dy: this._dy,
            lx: this._lastX,
            ly: this._lastY,
            lka: this._lastKnownAngle,
            t: this._travelled
        };
        0 !== this._acc && (a.acc = this._acc);
        0 !== this._g && (a.g = this._g);
        this._isStepping && (a.st = this._isStepping);
        this._isEnabled || (a.e = this._isEnabled);
        this._bounceOffSolid && (a.bos = this._bounceOffSolid);
        this._setAngle && (a.sa = this._setAngle);
        return a
    }
    LoadFromJson(a) {
        this._dx = a.dx;
        this._dy = a.dy;
        this._lastX = a.lx;
        this._lastY = a.ly;
        this._lastKnownAngle = a.lka;
        this._travelled = a.t;
        this._acc = a.hasOwnProperty("acc") ? a.acc : 0;
        this._g = a.hasOwnProperty("g") ? a.g : 0;
        this._isStepping = a.hasOwnProperty("st") ? a.st : !1;
        this._bounceOffSolid = a.hasOwnProperty("bos") ? a.bos : !1;
        this._setAngle = a.hasOwnProperty("sa") ? a.sa : !1;
        this._SetEnabled(a.hasOwnProperty("e") ? a.e : !0)
    }
    Tick() {
        if (this._isEnabled) {
            var a = this._runtime.GetDt(this._inst)
              , b = this._inst.GetWorldInfo();
            if (b.GetAngle() !== this._lastKnownAngle) {
                var d = b.GetAngle();
                if (this._setAngle) {
                    var c = C3$jscomp$318.distanceTo(0, 0, this._dx, this._dy);
                    this._dx = Math.cos(d) * c;
                    this._dy = Math.sin(d) * c
                }
                this._lastKnownAngle = d
            }
            d = c = 0;
            if (0 !== this._acc) {
                let e = C3$jscomp$318.distanceTo(0, 0, this._dx, this._dy), g;
                g = 0 === this._dx && 0 === this._dy ? b.GetAngle() : C3$jscomp$318.angleTo(0, 0, this._dx, this._dy);
                e += this._acc * a;
                c = Math.cos(g) * this._acc;
                d = Math.sin(g) * this._acc;
                0 > e && (d = c = e = 0);
                this._dx = Math.cos(g) * e;
                this._dy = Math.sin(g) * e
            }
            0 !== this._g && (this._dy += this._g * a,
            d += this._g);
            this._lastX = b.GetX();
            this._lastY = b.GetY();
            if (0 !== this._dx || 0 !== this._dy)
                c = this._dx * a + .5 * c * a * a,
                a = this._dy * a + .5 * d * a * a,
                d = C3$jscomp$318.distanceTo(0, 0, c, a),
                this._MoveBy(c, a, d),
                this._travelled += d,
                !this._setAngle || 0 === c && 0 === a || (a = C3$jscomp$318.angleTo(0, 0, c, a),
                b.SetAngle(a),
                this._lastKnownAngle = b.GetAngle()),
                b.SetBboxChanged()
        }
    }
    _MoveBy(a, b, d) {
        const c = this.GetWorldInfo();
        if (!this._isStepping || d <= this._stepSize)
            c.OffsetXY(a, b),
            c.SetBboxChanged(),
            this._isStepping && this.Trigger(C3$jscomp$318.Behaviors.Bullet.Cnds.OnStep);
        else {
            this._stopStepping = !1;
            var e = c.GetX()
              , g = c.GetY()
              , k = e + a
              , l = g + b;
            b = C3$jscomp$318.angleTo(0, 0, a, b);
            a = Math.cos(b) * this._stepSize;
            b = Math.sin(b) * this._stepSize;
            d = Math.floor(d / this._stepSize);
            for (let n = 1; n <= d; ++n)
                if (c.SetXY(e + a * n, g + b * n),
                c.SetBboxChanged(),
                this.Trigger(C3$jscomp$318.Behaviors.Bullet.Cnds.OnStep),
                this._inst.IsDestroyed() || this._stopStepping)
                    return;
            c.SetXY(k, l);
            c.SetBboxChanged();
            this.Trigger(C3$jscomp$318.Behaviors.Bullet.Cnds.OnStep)
        }
    }
    PostTick() {
        if (this._isEnabled && this._bounceOffSolid && (0 !== this._dx || 0 !== this._dy)) {
            var a = this._runtime.GetDt(this._inst)
              , b = this._inst.GetWorldInfo()
              , d = this._runtime.GetCollisionEngine()
              , c = d.TestOverlapSolid(this._inst);
            if (c) {
                d.RegisterCollision(this._inst, c);
                c = C3$jscomp$318.distanceTo(0, 0, this._dx, this._dy);
                const e = d.CalculateBounceAngle(this._inst, this._lastX, this._lastY);
                this._dx = Math.cos(e) * c;
                this._dy = Math.sin(e) * c;
                b.OffsetXY(this._dx * a, this._dy * a);
                b.SetBboxChanged();
                this._setAngle && (b.SetAngle(e),
                this._lastKnownAngle = b.GetAngle(),
                b.SetBboxChanged());
                d.PushOutSolid(this._inst, this._dx / c, this._dy / c, Math.max(2.5 * c * a, 30)) || d.PushOutSolidNearest(this._inst, 100)
            }
        }
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._GetSpeed();
        case 1:
            return this._GetAcceleration();
        case 2:
            return this._GetGravity();
        case 4:
            return this._setAngle;
        case 5:
            return this._isStepping;
        case 6:
            return this._IsEnabled()
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._SetSpeed(b);
            break;
        case 1:
            this._acc = b;
            break;
        case 2:
            this._g = b;
            break;
        case 4:
            this._setAngle = !!b;
            break;
        case 5:
            this._isStepping = !!b;
            break;
        case 6:
            this._SetEnabled(!!b)
        }
    }
    _SetSpeed(a) {
        const b = C3$jscomp$318.angleTo(0, 0, this._dx, this._dy);
        this._dx = Math.cos(b) * a;
        this._dy = Math.sin(b) * a
    }
    _GetSpeed() {
        return C3$jscomp$318.roundToDp(C3$jscomp$318.distanceTo(0, 0, this._dx, this._dy), 6)
    }
    _SetAcceleration(a) {
        this._acc = a
    }
    _GetAcceleration() {
        return this._acc
    }
    _SetGravity(a) {
        this._g = a
    }
    _GetGravity() {
        return this._g
    }
    _SetAngleOfMotion(a) {
        const b = C3$jscomp$318.distanceTo(0, 0, this._dx, this._dy);
        this._dx = Math.cos(a) * b;
        this._dy = Math.sin(a) * b
    }
    _GetAngleOfMotion() {
        return C3$jscomp$318.angleTo(0, 0, this._dx, this._dy)
    }
    _SetBounceOffSolids(a) {
        a = !!a;
        this._bounceOffSolid !== a && (this._bounceOffSolid = a,
        this._isEnabled && (this._bounceOffSolid ? this._StartPostTicking() : this._StopPostTicking()))
    }
    _IsBounceOffSolids() {
        return this._bounceOffSolid
    }
    _SetDistanceTravelled(a) {
        this._travelled = a
    }
    _GetDistanceTravelled() {
        return this._travelled
    }
    _SetEnabled(a) {
        (this._isEnabled = !!a) ? (this._StartTicking(),
        this._bounceOffSolid && this._StartPostTicking()) : (this._StopTicking(),
        this._StopPostTicking())
    }
    _IsEnabled() {
        return this._isEnabled
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.bullet.debugger.vector-x",
                value: this._dx,
                onedit: a=>this._dx = a
            }, {
                name: "behaviors.bullet.debugger.vector-y",
                value: this._dy,
                onedit: a=>this._dy = a
            }, {
                name: "behaviors.bullet.properties.speed.name",
                value: this._GetSpeed(),
                onedit: a=>this._SetSpeed(a)
            }, {
                name: "behaviors.bullet.debugger.angle-of-motion",
                value: C3$jscomp$318.toDegrees(this._GetAngleOfMotion())
            }, {
                name: "behaviors.bullet.properties.gravity.name",
                value: this._GetGravity(),
                onedit: a=>this._SetGravity(a)
            }, {
                name: "behaviors.bullet.properties.acceleration.name",
                value: this._GetAcceleration(),
                onedit: a=>this._SetAcceleration(a)
            }, {
                name: "behaviors.bullet.debugger.distance-travelled",
                value: this._GetDistanceTravelled()
            }, {
                name: "behaviors.bullet.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a=>this._SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IBulletBehaviorInstance
    }
}
;
const map$jscomp$34 = new WeakMap;
self.IBulletBehaviorInstance = class extends IBehaviorInstance$jscomp$6 {
    constructor() {
        super();
        map$jscomp$34.set(this, IBehaviorInstance$jscomp$6._GetInitInst().GetSdkInstance())
    }
    get speed() {
        return map$jscomp$34.get(this)._GetSpeed()
    }
    set speed(a) {
        C3X$jscomp$35.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetSpeed(a)
    }
    get acceleration() {
        return map$jscomp$34.get(this)._GetAcceleration()
    }
    set acceleration(a) {
        C3X$jscomp$35.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetAcceleration(a)
    }
    get gravity() {
        return map$jscomp$34.get(this)._GetGravity()
    }
    set gravity(a) {
        C3X$jscomp$35.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetGravity(a)
    }
    get angleOfMotion() {
        return map$jscomp$34.get(this)._GetAngleOfMotion()
    }
    set angleOfMotion(a) {
        C3X$jscomp$35.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetAngleOfMotion(a)
    }
    get bounceOffSolids() {
        return map$jscomp$34.get(this)._IsBounceOffSolids()
    }
    set bounceOffSolids(a) {
        map$jscomp$34.get(this)._SetBounceOffSolids(!!a)
    }
    get distanceTravelled() {
        return map$jscomp$34.get(this)._GetDistanceTravelled()
    }
    set distanceTravelled(a) {
        C3X$jscomp$35.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetDistanceTravelled(a)
    }
    get isEnabled() {
        return map$jscomp$34.get(this)._IsEnabled()
    }
    set isEnabled(a) {
        map$jscomp$34.get(this)._SetEnabled(a)
    }
}
;
const C3$jscomp$319 = self.C3;
C3$jscomp$319.Behaviors.Bullet.Cnds = {
    CompareSpeed(a, b) {
        return C3$jscomp$319.compare(Math.hypot(this._dx, this._dy), a, b)
    },
    CompareTravelled(a, b) {
        return C3$jscomp$319.compare(this._GetDistanceTravelled(), a, b)
    },
    OnStep() {
        return !0
    },
    IsEnabled() {
        return this._IsEnabled()
    }
};
const C3$jscomp$320 = self.C3;
C3$jscomp$320.Behaviors.Bullet.Acts = {
    SetSpeed(a) {
        this._SetSpeed(a)
    },
    SetAcceleration(a) {
        this._SetAcceleration(a)
    },
    SetGravity(a) {
        this._SetGravity(a)
    },
    SetAngleOfMotion(a) {
        this._SetAngleOfMotion(C3$jscomp$320.toRadians(a))
    },
    Bounce(a) {
        if (a && (a = a.GetFirstPicked(this._inst))) {
            var b = this._inst.GetWorldInfo()
              , d = this._runtime.GetCollisionEngine()
              , c = this._runtime.GetDt(this._inst)
              , e = C3$jscomp$320.distanceTo(0, 0, this._dx, this._dy)
              , g = d.CalculateBounceAngle(this._inst, this._lastX, this._lastY, a);
            this._dx = Math.cos(g) * e;
            this._dy = Math.sin(g) * e;
            b.OffsetXY(this._dx * c, this._dy * c);
            b.SetBboxChanged();
            this._setAngle && (b.SetAngle(g),
            this._lastKnownAngle = b.GetAngle(),
            b.SetBboxChanged());
            0 !== e && (this._bounceOffSolid ? d.PushOutSolid(this._inst, this._dx / e, this._dy / e, Math.max(2.5 * e * c, 30)) || d.PushOutSolidNearest(this._inst, 100) : d.PushOut(this._inst, this._dx / e, this._dy / e, Math.max(2.5 * e * c, 30), a))
        }
    },
    SetBounceOffSolids(a) {
        this._SetBounceOffSolids(a)
    },
    SetDistanceTravelled(a) {
        this._SetDistanceTravelled(a)
    },
    SetEnabled(a) {
        this._SetEnabled(a)
    },
    StopStepping() {
        this._stopStepping = !0
    }
};
const C3$jscomp$321 = self.C3;
C3$jscomp$321.Behaviors.Bullet.Exps = {
    Speed() {
        return this._GetSpeed()
    },
    Acceleration() {
        return this._GetAcceleration()
    },
    AngleOfMotion() {
        return C3$jscomp$321.toDegrees(this._GetAngleOfMotion())
    },
    DistanceTravelled() {
        return this._GetDistanceTravelled()
    },
    Gravity() {
        return this._GetGravity()
    }
};
"use strict";
const C3$jscomp$322 = self.C3;
C3$jscomp$322.Behaviors.destroy = class extends C3$jscomp$322.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$323 = self.C3;
C3$jscomp$323.Behaviors.destroy.Type = class extends C3$jscomp$323.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$324 = self.C3;
C3$jscomp$324.Behaviors.destroy.Instance = class extends C3$jscomp$324.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._StartTicking()
    }
    Release() {
        super.Release()
    }
    Tick() {
        var a = this._inst.GetWorldInfo();
        const b = a.GetBoundingBox();
        a = a.GetLayout();
        (0 > b.getRight() || 0 > b.getBottom() || b.getLeft() > a.GetWidth() || b.getTop() > a.GetHeight()) && this._runtime.DestroyInstance(this._inst)
    }
}
;
self.C3.Behaviors.destroy.Cnds = {};
self.C3.Behaviors.destroy.Acts = {};
self.C3.Behaviors.destroy.Exps = {};
"use strict";
const C3$jscomp$328 = self.C3;
C3$jscomp$328.Behaviors.Timer = class extends C3$jscomp$328.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$329 = self.C3;
C3$jscomp$329.Behaviors.Timer.Type = class extends C3$jscomp$329.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$330 = self.C3
  , C3X$jscomp$36 = self.C3X
  , IBehaviorInstance$jscomp$7 = self.IBehaviorInstance;
C3$jscomp$330.Behaviors.Timer.SingleTimer = class {
    constructor(a, b, d, c) {
        this._current = C3$jscomp$330.New(C3$jscomp$330.KahanSum);
        this._current.Set(a || 0);
        this._total = C3$jscomp$330.New(C3$jscomp$330.KahanSum);
        this._total.Set(b || 0);
        this._duration = d || 0;
        this._isRegular = !!c;
        this._isPaused = !1
    }
    GetCurrentTime() {
        return this._current.Get()
    }
    GetTotalTime() {
        return this._total.Get()
    }
    GetDuration() {
        return this._duration
    }
    SetPaused(a) {
        this._isPaused = !!a
    }
    IsPaused() {
        return this._isPaused
    }
    Add(a) {
        this._current.Add(a);
        this._total.Add(a)
    }
    HasFinished() {
        return this._current.Get() >= this._duration
    }
    Update() {
        if (this.HasFinished())
            if (this._isRegular)
                this._current.Subtract(this._duration);
            else
                return !0;
        return !1
    }
    SaveToJson() {
        return {
            c: this._current.Get(),
            t: this._total.Get(),
            d: this._duration,
            r: this._isRegular,
            p: this._isPaused
        }
    }
    LoadFromJson(a) {
        this._current.Set(a.c);
        this._total.Set(a.t);
        this._duration = a.d;
        this._isRegular = !!a.r;
        this._isPaused = !!a.p
    }
}
;
C3$jscomp$330.Behaviors.Timer.Instance = class extends C3$jscomp$330.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._timers = new Map
    }
    Release() {
        this._timers.clear();
        super.Release()
    }
    _StartTimer(a, b, d) {
        a = new C3$jscomp$330.Behaviors.Timer.SingleTimer(0,0,a,d);
        this._timers.set(b.toLowerCase(), a);
        this._UpdateTickState()
    }
    _StopTimer(a) {
        this._timers.delete(a.toLowerCase());
        this._UpdateTickState()
    }
    _StopAllTimers() {
        this._timers.clear();
        this._UpdateTickState()
    }
    _IsTimerRunning(a) {
        return this._timers.has(a.toLowerCase())
    }
    _GetTimerCurrentTime(a) {
        return (a = this._timers.get(a.toLowerCase())) ? a.GetCurrentTime() : 0
    }
    _GetTimerTotalTime(a) {
        return (a = this._timers.get(a.toLowerCase())) ? a.GetTotalTime() : 0
    }
    _GetTimerDuration(a) {
        return (a = this._timers.get(a.toLowerCase())) ? a.GetDuration() : 0
    }
    _HasTimerFinished(a) {
        return (a = this._timers.get(a.toLowerCase())) ? a.HasFinished() : !1
    }
    _SetTimerPaused(a, b) {
        (a = this._timers.get(a.toLowerCase())) && a.SetPaused(b)
    }
    _IsTimerPaused(a) {
        return (a = this._timers.get(a.toLowerCase())) ? a.IsPaused() : !1
    }
    _UpdateTickState() {
        0 < this._timers.size ? (this._StartTicking(),
        this._StartTicking2()) : (this._StopTicking(),
        this._StopTicking2())
    }
    SaveToJson() {
        const a = {};
        for (const [b,d] of this._timers.entries())
            a[b] = d.SaveToJson();
        return a
    }
    LoadFromJson(a) {
        this._timers.clear();
        for (const [b,d] of Object.entries(a))
            a = new C3$jscomp$330.Behaviors.Timer.SingleTimer,
            a.LoadFromJson(d),
            this._timers.set(b, a);
        this._UpdateTickState()
    }
    Tick() {
        const a = this._runtime.GetDt(this._inst);
        for (const [b,d] of this._timers)
            d.IsPaused() || (d.Add(a),
            d.HasFinished() && this.DispatchScriptEvent("timer", !1, {
                tag: b
            }))
    }
    Tick2() {
        for (const [a,b] of this._timers.entries())
            b.Update() && this._timers.delete(a)
    }
    GetDebuggerProperties() {
        return [{
            title: "behaviors.timer.debugger.timers",
            properties: [...this._timers.entries()].map(a=>({
                name: "$" + a[0],
                value: `${Math.round(10 * a[1].GetCurrentTime()) / 10} / ${Math.round(10 * a[1].GetDuration()) / 10}`
            }))
        }]
    }
    GetScriptInterfaceClass() {
        return self.ITimerBehaviorInstance
    }
}
;
const map$jscomp$35 = new WeakMap
  , VALID_TIMER_TYPES = ["once", "regular"];
self.ITimerBehaviorInstance = class extends IBehaviorInstance$jscomp$7 {
    constructor() {
        super();
        map$jscomp$35.set(this, IBehaviorInstance$jscomp$7._GetInitInst().GetSdkInstance())
    }
    startTimer(a, b, d="once") {
        C3X$jscomp$36.RequireFiniteNumber(a);
        C3X$jscomp$36.RequireString(b);
        d = VALID_TIMER_TYPES.indexOf(d);
        if (-1 === d)
            throw Error("invalid type");
        map$jscomp$35.get(this)._StartTimer(a, b, 1 === d)
    }
    setTimerPaused(a, b) {
        C3X$jscomp$36.RequireString(a);
        map$jscomp$35.get(this)._SetTimerPaused(a, !!b)
    }
    stopTimer(a) {
        C3X$jscomp$36.RequireString(a);
        map$jscomp$35.get(this)._StopTimer(a)
    }
    stopAllTimers() {
        map$jscomp$35.get(this)._StopAllTimers()
    }
    isTimerRunning(a) {
        C3X$jscomp$36.RequireString(a);
        return map$jscomp$35.get(this)._IsTimerRunning(a)
    }
    isTimerPaused(a) {
        C3X$jscomp$36.RequireString(a);
        return map$jscomp$35.get(this)._IsTimerPaused(a)
    }
    getCurrentTime(a) {
        C3X$jscomp$36.RequireString(a);
        return map$jscomp$35.get(this)._GetTimerCurrentTime(a)
    }
    getTotalTime(a) {
        C3X$jscomp$36.RequireString(a);
        return map$jscomp$35.get(this)._GetTimerTotalTime(a)
    }
    getDuration(a) {
        C3X$jscomp$36.RequireString(a);
        return map$jscomp$35.get(this)._GetTimerDuration(a)
    }
    hasFinished(a) {
        C3X$jscomp$36.RequireString(a);
        return map$jscomp$35.get(this)._HasTimerFinished(a)
    }
}
;
self.C3.Behaviors.Timer.Cnds = {
    OnTimer(a) {
        return this._HasTimerFinished(a)
    },
    IsTimerRunning(a) {
        return this._IsTimerRunning(a)
    },
    IsTimerPaused(a) {
        return this._IsTimerPaused(a)
    }
};
self.C3.Behaviors.Timer.Acts = {
    StartTimer(a, b, d) {
        this._StartTimer(a, d, 1 === b)
    },
    StopTimer(a) {
        this._StopTimer(a)
    },
    StopAllTimers() {
        this._StopAllTimers()
    },
    PauseResumeTimer(a, b) {
        this._SetTimerPaused(a, 0 === b)
    }
};
self.C3.Behaviors.Timer.Exps = {
    CurrentTime(a) {
        return this._GetTimerCurrentTime(a)
    },
    TotalTime(a) {
        return this._GetTimerTotalTime(a)
    },
    Duration(a) {
        return this._GetTimerDuration(a)
    }
};
"use strict";
const C3$jscomp$334 = self.C3;
C3$jscomp$334.Behaviors.Anchor = class extends C3$jscomp$334.SDKBehaviorBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
}
;
const C3$jscomp$335 = self.C3;
C3$jscomp$335.Behaviors.Anchor.Type = class extends C3$jscomp$335.SDKBehaviorTypeBase {
    constructor(a) {
        super(a)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$336 = self.C3
  , IBehaviorInstance$jscomp$8 = self.IBehaviorInstance;
C3$jscomp$336.Behaviors.Anchor.Instance = class extends C3$jscomp$336.SDKBehaviorInstanceBase {
    constructor(a, b) {
        super(a);
        this._anchorTop = this._anchorLeft = 2;
        this._anchorBottom = this._anchorRight = 0;
        this._isEnabled = !0;
        a = this._inst.GetWorldInfo().GetBoundingBox();
        this._xLeft = a.getLeft();
        this._yTop = a.getTop();
        this._xRight = this._runtime.GetOriginalViewportWidth() - a.getLeft();
        this._yBottom = this._runtime.GetOriginalViewportHeight() - a.getTop();
        this._rDiff = this._runtime.GetOriginalViewportWidth() - a.getRight();
        this._bDiff = this._runtime.GetOriginalViewportHeight() - a.getBottom();
        b && (this._anchorLeft = b[0],
        this._anchorTop = b[1],
        this._anchorRight = b[2],
        this._anchorBottom = b[3],
        this._isEnabled = !!b[4]);
        b = this._runtime.Dispatcher();
        this._disposables = new C3$jscomp$336.CompositeDisposable(C3$jscomp$336.Disposable.From(b, "layoutchange", ()=>this._OnLayoutChange()));
        this._isEnabled && this._StartTicking()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            xl: this._xLeft,
            yt: this._yTop,
            xr: this._xRight,
            yb: this._yBottom,
            rd: this._rDiff,
            bd: this._bDiff,
            al: this._anchorLeft,
            at: this._anchorTop,
            ar: this._anchorRight,
            ab: this._anchorBottom,
            e: this._isEnabled
        }
    }
    LoadFromJson(a) {
        this._xLeft = a.xl;
        this._yTop = a.yt;
        this._xRight = a.xr;
        this._yBottom = a.yb;
        this._rDiff = a.rd;
        this._bDiff = a.bd;
        this._anchorLeft = a.al;
        this._anchorTop = a.at;
        this._anchorRight = a.ar;
        this._anchorBottom = a.ab;
        (this._isEnabled = a.e) ? this._StartTicking() : this._StopTicking()
    }
    _SetEnabled(a) {
        this._isEnabled && !a ? (this._isEnabled = !1,
        this._StopTicking()) : !this._isEnabled && a && (a = this._inst.GetWorldInfo().GetBoundingBox(),
        this._xLeft = a.getLeft(),
        this._yTop = a.getTop(),
        this._xRight = this._runtime.GetOriginalViewportWidth() - a.getLeft(),
        this._yBottom = this._runtime.GetOriginalViewportHeight() - a.getTop(),
        this._rDiff = this._runtime.GetOriginalViewportWidth() - a.getRight(),
        this._bDiff = this._runtime.GetOriginalViewportHeight() - a.getBottom(),
        this._isEnabled = !0,
        this._StartTicking())
    }
    _IsEnabled() {
        return this._isEnabled
    }
    _UpdatePosition() {
        if (this._isEnabled) {
            var a = this._inst.GetWorldInfo()
              , b = a.GetLayer().GetViewport();
            if (0 === this._anchorLeft) {
                var d = b.getLeft() + this._xLeft - a.GetBoundingBox().getLeft();
                0 !== d && (a.OffsetX(d),
                a.SetBboxChanged())
            } else
                1 === this._anchorLeft && (d = b.getRight() - this._xRight - a.GetBoundingBox().getLeft(),
                0 !== d && (a.OffsetX(d),
                a.SetBboxChanged()));
            0 === this._anchorTop ? (d = b.getTop() + this._yTop - a.GetBoundingBox().getTop(),
            0 !== d && (a.OffsetY(d),
            a.SetBboxChanged())) : 1 === this._anchorTop && (d = b.getBottom() - this._yBottom - a.GetBoundingBox().getTop(),
            0 !== d && (a.OffsetY(d),
            a.SetBboxChanged()));
            1 === this._anchorRight && (d = b.getRight() - this._rDiff - a.GetBoundingBox().getRight(),
            0 !== d && (a.OffsetX(a.GetOriginX() * d),
            a.SetWidth(Math.max(a.GetWidth() + d), 0),
            a.SetBboxChanged(),
            this._rDiff = b.getRight() - a.GetBoundingBox().getRight()));
            1 === this._anchorBottom && (d = b.getBottom() - this._bDiff - a.GetBoundingBox().getBottom(),
            0 !== d && (a.OffsetY(a.GetOriginY() * d),
            a.SetHeight(Math.max(a.GetHeight() + d, 0)),
            a.SetBboxChanged(),
            this._bDiff = b.getBottom() - a.GetBoundingBox().getBottom()))
        }
    }
    Tick() {
        this._UpdatePosition()
    }
    _OnLayoutChange() {
        this._UpdatePosition()
    }
    GetPropertyValueByIndex(a) {
        switch (a) {
        case 0:
            return this._anchorLeft;
        case 1:
            return this._anchorTop;
        case 2:
            return this._anchorRight;
        case 3:
            return this._anchorBottom;
        case 4:
            return this._isEnabled
        }
    }
    SetPropertyValueByIndex(a, b) {
        switch (a) {
        case 0:
            this._anchorLeft = b;
            break;
        case 1:
            this._anchorTop = b;
            break;
        case 2:
            this._anchorRight = b;
            break;
        case 3:
            this._anchorBottom = b;
            break;
        case 4:
            (this._isEnabled = !!b) ? this._StartTicking() : this._StopTicking()
        }
    }
    GetDebuggerProperties() {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.anchor.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a=>this._SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass() {
        return self.IAnchorBehaviorInstance
    }
}
;
const map$jscomp$36 = new WeakMap;
self.IAnchorBehaviorInstance = class extends IBehaviorInstance$jscomp$8 {
    constructor() {
        super();
        map$jscomp$36.set(this, IBehaviorInstance$jscomp$8._GetInitInst().GetSdkInstance())
    }
    get isEnabled() {
        return map$jscomp$36.get(this)._IsEnabled()
    }
    set isEnabled(a) {
        map$jscomp$36.get(this)._SetEnabled(a)
    }
}
;
self.C3.Behaviors.Anchor.Cnds = {
    IsEnabled() {
        return this._IsEnabled()
    }
};
self.C3.Behaviors.Anchor.Acts = {
    SetEnabled(a) {
        this._SetEnabled(0 !== a)
    }
};
self.C3.Behaviors.Anchor.Exps = {};
const C3$jscomp$340 = self.C3;
self.C3_GetObjectRefTable = function() {
    return [C3$jscomp$340.Plugins.Sprite, C3$jscomp$340.Behaviors.Fade, C3$jscomp$340.Behaviors.Tween, C3$jscomp$340.Plugins.Text, C3$jscomp$340.Plugins.TiledBg, C3$jscomp$340.Plugins.Spritefont2, C3$jscomp$340.Behaviors.scrollto, C3$jscomp$340.Behaviors.Sin, C3$jscomp$340.Behaviors.Rotate, C3$jscomp$340.Plugins.Arr, C3$jscomp$340.Plugins.Dictionary, C3$jscomp$340.Plugins.TextBox, C3$jscomp$340.Behaviors.Bullet, C3$jscomp$340.Behaviors.destroy, C3$jscomp$340.Behaviors.Timer, C3$jscomp$340.Behaviors.Anchor, C3$jscomp$340.Plugins.sliderbar, C3$jscomp$340.Plugins.AJAX, C3$jscomp$340.Plugins.Audio, C3$jscomp$340.Plugins.Browser, C3$jscomp$340.Plugins.Keyboard, C3$jscomp$340.Plugins.Mouse, C3$jscomp$340.Plugins.Touch, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP, C3$jscomp$340.Plugins.HTMLElement, C3$jscomp$340.Plugins.Gritsenko_Spine, C3$jscomp$340.Plugins.System.Cnds.OnLayoutStart, C3$jscomp$340.Plugins.System.Acts.SetVar, C3$jscomp$340.Plugins.Arr.Acts.SetX, C3$jscomp$340.Plugins.Sprite.Cnds.IsOnLayer, C3$jscomp$340.Plugins.Sprite.Acts.SetAnim, C3$jscomp$340.Plugins.System.Exps.int, C3$jscomp$340.Plugins.System.Exps.random, C3$jscomp$340.Plugins.Sprite.Acts.SetAnimFrame, C3$jscomp$340.Plugins.System.Cnds.ForEach, C3$jscomp$340.Plugins.Sprite.Cnds.CompareY, C3$jscomp$340.Plugins.Sprite.Acts.SetVisible, C3$jscomp$340.Plugins.Sprite.Cnds.IsVisible, C3$jscomp$340.Plugins.Sprite.Cnds.IsOverlapping, C3$jscomp$340.Plugins.Sprite.Acts.SetInstanceVar, C3$jscomp$340.Plugins.Sprite.Exps.AnimationName, C3$jscomp$340.Plugins.System.Cnds.IsGroupActive, C3$jscomp$340.Plugins.System.Cnds.TriggerOnce, C3$jscomp$340.Plugins.Sprite.Acts.SetX, C3$jscomp$340.Plugins.Sprite.Acts.Destroy, C3$jscomp$340.Plugins.System.Cnds.CompareBoolVar, C3$jscomp$340.Plugins.System.Acts.SetGroupActive, C3$jscomp$340.Plugins.Spritefont2.Acts.SetX, C3$jscomp$340.Plugins.TiledBg.Acts.SetVisible, C3$jscomp$340.Plugins.System.Cnds.Else, C3$jscomp$340.Plugins.Gritsenko_Spine.Acts.SetAnimation, C3$jscomp$340.Plugins.Sprite.Cnds.CompareInstanceVar, C3$jscomp$340.Behaviors.Tween.Acts.TweenOneProperty, C3$jscomp$340.Plugins.Arr.Exps.At, C3$jscomp$340.Plugins.Sprite.Exps.Y, C3$jscomp$340.Plugins.System.Acts.Wait, C3$jscomp$340.Plugins.System.Acts.AddVar, C3$jscomp$340.Plugins.System.Acts.Signal, C3$jscomp$340.Plugins.System.Acts.WaitForSignal, C3$jscomp$340.Behaviors.Tween.Cnds.OnTweensFinished, C3$jscomp$340.Plugins.Sprite.Acts.SetY, C3$jscomp$340.Plugins.Arr.Cnds.CompareX, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.SlotAt, C3$jscomp$340.Plugins.System.Cnds.CompareVar, C3$jscomp$340.Plugins.System.Cnds.EvaluateExpression, C3$jscomp$340.Plugins.Arr.Acts.Clear, C3$jscomp$340.Plugins.Arr.Cnds.ArrForEach, C3$jscomp$340.Plugins.Arr.Exps.CurX, C3$jscomp$340.Plugins.Arr.Exps.CurY, C3$jscomp$340.Plugins.Arr.Acts.SetXY, C3$jscomp$340.Plugins.Audio.Acts.Play, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.FreeSpin, C3$jscomp$340.Plugins.Sprite.Acts.SetOpacity, C3$jscomp$340.Plugins.Sprite.Cnds.IsAnimPlaying, C3$jscomp$340.Plugins.System.Acts.CreateObject, C3$jscomp$340.Plugins.Sprite.Exps.X, C3$jscomp$340.Behaviors.Tween.Acts.TweenTwoProperties, C3$jscomp$340.Plugins.Gritsenko_Spine.Exps.X, C3$jscomp$340.Plugins.Gritsenko_Spine.Exps.Y, C3$jscomp$340.Plugins.System.Acts.SetObjectTimescale, C3$jscomp$340.Plugins.Audio.Acts.SetVolume, C3$jscomp$340.Plugins.System.Cnds.While, C3$jscomp$340.Plugins.System.Cnds.PickNth, C3$jscomp$340.Plugins.System.Cnds.Repeat, C3$jscomp$340.Plugins.System.Exps.loopindex, C3$jscomp$340.Plugins.Sprite.Acts.Spawn, C3$jscomp$340.Plugins.Sprite.Acts.AddChild, C3$jscomp$340.Plugins.Sprite.Acts.SetScale, C3$jscomp$340.Plugins.Sprite.Acts.SetAnimSpeed, C3$jscomp$340.Plugins.Sprite.Acts.ZMoveToObject, C3$jscomp$340.Plugins.System.Cnds.EveryTick, C3$jscomp$340.Plugins.Text.Acts.AppendText, C3$jscomp$340.Plugins.Audio.Acts.PlayByName, C3$jscomp$340.Plugins.System.Exps.choose, C3$jscomp$340.Behaviors.Tween.Acts.TweenValue, C3$jscomp$340.Plugins.Sprite.Acts.MoveToTop, C3$jscomp$340.Plugins.Gritsenko_Spine.Cnds.OnAnimationFinished, C3$jscomp$340.Plugins.Gritsenko_Spine.Acts.SetOpacity, C3$jscomp$340.Behaviors.Tween.Cnds.IsPlaying, C3$jscomp$340.Plugins.System.Acts.SetLayerScale, C3$jscomp$340.Behaviors.Tween.Exps.Value, C3$jscomp$340.Plugins.System.Acts.SetLayerScroll, C3$jscomp$340.Plugins.System.Exps.scrollx, C3$jscomp$340.Behaviors.scrollto.Acts.Shake, C3$jscomp$340.Plugins.System.Cnds.Every, C3$jscomp$340.Behaviors.Fade.Acts.SetFadeOutTime, C3$jscomp$340.Plugins.Sprite.Acts.SetAngle, C3$jscomp$340.Behaviors.Bullet.Acts.SetSpeed, C3$jscomp$340.Plugins.Sprite.Cnds.OnAnyAnimFinished, C3$jscomp$340.Plugins.Sprite.Cnds.OnAnimFinished, C3$jscomp$340.Plugins.System.Exps.replace, C3$jscomp$340.Plugins.System.Exps.right, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.BetSize, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.BetLevel, C3$jscomp$340.Plugins.System.Exps.roundtodp, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Acts.OpenGameCss, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.Credit, C3$jscomp$340.Plugins.Text.Acts.SetText, C3$jscomp$340.Plugins.Dictionary.Exps.Get, C3$jscomp$340.Plugins.Touch.Cnds.OnTouchObject, C3$jscomp$340.Plugins.Sprite.Cnds.CompareFrame, C3$jscomp$340.Plugins.Mouse.Cnds.IsOverObject, C3$jscomp$340.Plugins.Arr.Exps.Back, C3$jscomp$340.Plugins.Arr.Exps.Width, C3$jscomp$340.Plugins.System.Acts.StopLoop, C3$jscomp$340.Plugins.System.Acts.SetBoolVar, C3$jscomp$340.Plugins.Arr.Exps.Front, C3$jscomp$340.Plugins.System.Cnds.For, C3$jscomp$340.Plugins.System.Acts.ToggleBoolVar, C3$jscomp$340.Plugins.Sprite.Cnds.CompareOpacity, C3$jscomp$340.Plugins.Touch.Cnds.IsTouchingObject, C3$jscomp$340.Plugins.Sprite.Acts.SetPosToObject, C3$jscomp$340.Plugins.Spritefont2.Acts.SetPos, C3$jscomp$340.Plugins.Sprite.Exps.ImagePointX, C3$jscomp$340.Plugins.Sprite.Exps.ImagePointY, C3$jscomp$340.Plugins.Spritefont2.Acts.SetText, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.IconWinOf, C3$jscomp$340.Plugins.Sprite.Acts.SetPos, C3$jscomp$340.Plugins.Text.Acts.SetPos, C3$jscomp$340.Behaviors.Timer.Acts.StartTimer, C3$jscomp$340.Behaviors.Rotate.Acts.SetSpeed, C3$jscomp$340.Behaviors.Timer.Cnds.OnTimer, C3$jscomp$340.Behaviors.Rotate.Acts.SetEnabled, C3$jscomp$340.Plugins.System.Acts.SetLayerVisible, C3$jscomp$340.Plugins.System.Acts.SetLayerOpacity, C3$jscomp$340.Plugins.Audio.Acts.Stop, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Acts.LoadGame, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onGameLoaded, C3$jscomp$340.Plugins.System.Acts.GoToLayout, C3$jscomp$340.Plugins.System.Exps.time, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Acts.BuyFeature, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Acts.SpinGame, C3$jscomp$340.Plugins.System.Cnds.LayerVisible, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onSpinSuccess, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onErrorOccurred, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.ErrorMsg, C3$jscomp$340.Plugins.TiledBg.Acts.SetSize, C3$jscomp$340.Plugins.Text.Acts.SetFontSize, C3$jscomp$340.Plugins.Text.Acts.SetSize, C3$jscomp$340.Plugins.Text.Acts.SetFontColor, C3$jscomp$340.Plugins.System.Exps.rgbex255, C3$jscomp$340.Plugins.System.Acts.RestartLayout, C3$jscomp$340.Plugins.TiledBg.Acts.SetImageOffsetX, C3$jscomp$340.Plugins.TiledBg.Acts.SetImageOffsetY, C3$jscomp$340.Plugins.TiledBg.Exps.ImageOffsetY, C3$jscomp$340.Plugins.TiledBg.Exps.ImageOffsetX, C3$jscomp$340.Plugins.System.Cnds.Compare, C3$jscomp$340.Plugins.Text.Exps.FaceSize, C3$jscomp$340.Plugins.Text.Cnds.CompareOpacity, C3$jscomp$340.Plugins.Text.Acts.SetOpacity, C3$jscomp$340.Plugins.Text.Exps.Opacity, C3$jscomp$340.Plugins.TiledBg.Acts.SetOpacity, C3$jscomp$340.Plugins.TiledBg.Exps.Opacity, C3$jscomp$340.Plugins.Text.Acts.MoveToLayer, C3$jscomp$340.Plugins.Sprite.Acts.SetBoolInstanceVar, C3$jscomp$340.Plugins.Text.Acts.SetY, C3$jscomp$340.Plugins.sliderbar.Acts.SetEnabled, C3$jscomp$340.Plugins.sliderbar.Acts.SetValue, C3$jscomp$340.Plugins.sliderbar.Exps.Minimum, C3$jscomp$340.Plugins.Sprite.Cnds.IsBoolInstanceVarSet, C3$jscomp$340.Plugins.Dictionary.Acts.AddKey, C3$jscomp$340.Plugins.Text.Exps.PlainText, C3$jscomp$340.Plugins.sliderbar.Cnds.CompareValue, C3$jscomp$340.Plugins.sliderbar.Exps.Value, C3$jscomp$340.Plugins.TiledBg.Acts.SetY, C3$jscomp$340.Plugins.TiledBg.Exps.Y, C3$jscomp$340.Plugins.sliderbar.Acts.SetVisible, C3$jscomp$340.Plugins.Text.Exps.Y, C3$jscomp$340.Plugins.Text.Acts.SetVisible, C3$jscomp$340.Plugins.Spritefont2.Cnds.IsOnLayer, C3$jscomp$340.Plugins.Dictionary.Acts.SetKey, C3$jscomp$340.Plugins.Spritefont2.Acts.Destroy, C3$jscomp$340.Plugins.Browser.Acts.Close, C3$jscomp$340.Plugins.Audio.Acts.SetSilent, C3$jscomp$340.Plugins.Text.Cnds.CompareY, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Acts.LoadIcon, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onIconLoaded, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Acts.OpenGameInfo, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onGamePayoutOpen, C3$jscomp$340.Plugins.HTMLElement.Acts.SetContent, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LogGameInfoTemplate, C3$jscomp$340.Plugins.HTMLElement.Acts.SetVisible, C3$jscomp$340.Plugins.HTMLElement.Cnds.OnClickedClass, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.WinAmount, C3$jscomp$340.Plugins.Audio.Acts.SetPaused, C3$jscomp$340.Plugins.Spritefont2.Acts.SetScale, C3$jscomp$340.Plugins.Spritefont2.Acts.SetZElevation, C3$jscomp$340.Plugins.System.Exps.len, C3$jscomp$340.Plugins.Spritefont2.Acts.MoveToTop, C3$jscomp$340.Plugins.Spritefont2.Exps.CharacterScale, C3$jscomp$340.Plugins.System.Exps.zeropad, C3$jscomp$340.Plugins.Touch.Cnds.OnTouchStart, C3$jscomp$340.Plugins.System.Exps.layoutwidth, C3$jscomp$340.Plugins.System.Exps.layoutheight, C3$jscomp$340.Plugins.Sprite.Cnds.OnCreated, C3$jscomp$340.Plugins.System.Exps.min, C3$jscomp$340.Plugins.System.Acts.SetFunctionReturnValue, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LineNumber, C3$jscomp$340.Plugins.Arr.Acts.SetSize, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.BetSizeTotal, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.CurrencyDecimal, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.CurrencyPrefix, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.CurrencySuffix, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.CurrencyThousand, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.BetSizeListAt, C3$jscomp$340.Plugins.Text.Acts.SetInstanceVar, C3$jscomp$340.Plugins.Text.Acts.ZMoveToObject, C3$jscomp$340.Plugins.Text.Acts.AddChild, C3$jscomp$340.Plugins.Arr.Exps.CurValue, C3$jscomp$340.Plugins.Arr.Acts.Push, C3$jscomp$340.Plugins.Arr.Acts.Pop, C3$jscomp$340.Plugins.Text.Cnds.CompareInstanceVar, C3$jscomp$340.Plugins.System.Cnds.CompareBetween, C3$jscomp$340.Behaviors.Tween.Cnds.OnAnyTweensFinished, C3$jscomp$340.Plugins.Sprite.Cnds.OnCollision, C3$jscomp$340.Plugins.TextBox.Cnds.CompareText, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Acts.OpenHistoryList, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryListOpen, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LogHtmlList, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Acts.LoadHistories, C3$jscomp$340.Plugins.TextBox.Exps.Text, C3$jscomp$340.Plugins.HTMLElement.Acts.SetContentAttribute, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onLogLoaded, C3$jscomp$340.Plugins.TextBox.Acts.SetText, C3$jscomp$340.Plugins.HTMLElement.Acts.InsertContent, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LogHistoryListData, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LogTotalRecord, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LogTotalBet, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LogTotalProfit, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onEnableLoadMore, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Acts.OpenHistoryNormal, C3$jscomp$340.Plugins.HTMLElement.Exps.TargetID, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryDetailOpen, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LogHistoryDetailTemplate, C3$jscomp$340.Plugins.HTMLElement.Cnds.OnClickedID, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Acts.HistorySlideMove, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistorySlideMove, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LogHistorySlideTo, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LogHistoryDetailTitle, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryEnablePrev, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onHistoryEnableNext, C3$jscomp$340.Plugins.Spritefont2.Exps.TextWidth, C3$jscomp$340.Plugins.System.Cnds.LayerCmpOpacity, C3$jscomp$340.Plugins.System.Exps.layeropacity, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Cnds.onGameInfoOpen, C3$jscomp$340.Plugins.Sprite.Exps.AnimationFrame, C3$jscomp$340.Plugins.Spritefont2.Acts.SetVisible, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LineActiveTotal, C3$jscomp$340.Plugins.Sprite.Acts.MoveToBottom, C3$jscomp$340.Plugins.Sprite.Acts.StopAnim, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.ActiveAt, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.ActiveByLine, C3$jscomp$340.Plugins.Spritefont2.Acts.SetY, C3$jscomp$340.Plugins.Spritefont2.Exps.Y, C3$jscomp$340.Plugins.Spritefont2.Acts.SetInstanceVar, C3$jscomp$340.Plugins.Spritefont2.Exps.X, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.LineAmountAt, C3$jscomp$340.Plugins.Spritefont2.Cnds.CompareInstanceVar, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.BuyLimit, C3$jscomp$340.Plugins.NhutCorp_SlotGenPHP.Exps.BuyFeature]
}
;
self.C3_JsPropNameTable = [{
    menubg: 0
}, {
    Fade: 0
}, {
    Tween: 0
}, {
    startbtn: 0
}, {
    Quit: 0
}, {
    Sound: 0
}, {
    Paytable: 0
}, {
    Rules: 0
}, {
    History: 0
}, {
    Menu: 0
}, {
    CloseMenu: 0
}, {
    Note: 0
}, {
    NoteBG: 0
}, {
    GuiBG: 0
}, {
    TouchShowSpriteFont: 0
}, {
    Strr: 0
}, {
    id: 0
}, {
    ZoneTouch: 0
}, {
    bl: 0
}, {
    ZoneWin: 0
}, {
    ScrollText: 0
}, {
    CloseScroll: 0
}, {
    ScrollTo: 0
}, {
    shar: 0
}, {
    StartFreespin: 0
}, {
    totalWinCollectBtn: 0
}, {
    Sine: 0
}, {
    Rotate: 0
}, {
    light: 0
}, {
    endfreespin_num: 0
}, {
    fs_txt: 0
}, {
    fs_SymbolsZone: 0
}, {
    BetOpacity: 0
}, {
    BetSelect: 0
}, {
    ID: 0
}, {
    BetLevel: 0
}, {
    BetSize: 0
}, {
    BetAmount: 0
}, {
    CloseBet: 0
}, {
    ConfirmBet: 0
}, {
    MaxBet: 0
}, {
    limit: 0
}, {
    wbg: 0
}, {
    BetSizeData: 0
}, {
    BetData: 0
}, {
    Currency: 0
}, {
    LogDetail: 0
}, {
    FristLog: 0
}, {
    PreLog: 0
}, {
    NextLog: 0
}, {
    LogSelect: 0
}, {
    info: 0
}, {
    freespin: 0
}, {
    LogBar: 0
}, {
    circle: 0
}, {
    PageNo: 0
}, {
    Lside: 0
}, {
    Rside: 0
}, {
    BackLog: 0
}, {
    CloseHistory: 0
}, {
    txtHistoryPage: 0
}, {
    TouchShow: 0
}, {
    botbg: 0
}, {
    notifyBar: 0
}, {
    AutoBtn: 0
}, {
    bettxt: 0
}, {
    Credit: 0
}, {
    BetAdd: 0
}, {
    BetSub: 0
}, {
    Turbo: 0
}, {
    Win: 0
}, {
    spinbtn: 0
}, {
    TouchShow3: 0
}, {
    notifyBar2: 0
}, {
    EffectCursorSpinbtn: 0
}, {
    EffectSpinbtn: 0
}, {
    moveTop: 0
}, {
    Bullet: 0
}, {
    DestroyOutsideLayout: 0
}, {
    paticular: 0
}, {
    Timer: 0
}, {
    rotate: 0
}, {
    Effect_CursorSpin1: 0
}, {
    BG_Gui6: 0
}, {
    winNote: 0
}, {
    Effect_CursorSpin2: 0
}, {
    buyBar: 0
}, {
    costTxt: 0
}, {
    main_bg: 0
}, {
    main_bg2: 0
}, {
    startBuy: 0
}, {
    VerticalRow: 0
}, {
    winValue2: 0
}, {
    winValue3: 0
}, {
    notifyBarVis: 0
}, {
    notifyBar_effect: 0
}, {
    notifyBar_effect2: 0
}, {
    Anchor: 0
}, {
    bbg: 0
}, {
    blackBG: 0
}, {
    systemtxt: 0
}, {
    blackBG2: 0
}, {
    CloseBalance: 0
}, {
    NormalWrite: 0
}, {
    CloseButton: 0
}, {
    TouchShowSpriteFont2: 0
}, {
    systemtxt2: 0
}, {
    reel: 0
}, {
    name: 0
}, {
    Symbol: 0
}, {
    SpinStep: 0
}, {
    WinBG: 0
}, {
    xx: 0
}, {
    WinAnimation: 0
}, {
    scatterPos: 0
}, {
    WinValue: 0
}, {
    WildScatter: 0
}, {
    posY: 0
}, {
    t_stop: 0
}, {
    WinValue4: 0
}, {
    SymbolV: 0
}, {
    WinAnimation2: 0
}, {
    Number: 0
}, {
    BalanceInTxt: 0
}, {
    BalanceDe: 0
}, {
    BalanceIn: 0
}, {
    WinEx: 0
}, {
    More: 0
}, {
    tr: 0
}, {
    StartAuto: 0
}, {
    StopAu: 0
}, {
    CloseAuto: 0
}, {
    BGtop: 0
}, {
    Auto: 0
}, {
    AutoSpinTxt: 0
}, {
    WinExTxt: 0
}, {
    BalanceDeTxt: 0
}, {
    AJAX: 0
}, {
    Audio: 0
}, {
    Browser: 0
}, {
    Keyboard: 0
}, {
    Mouse: 0
}, {
    Touch: 0
}, {
    SlotGenPHP: 0
}, {
    debug: 0
}, {
    touchtxt: 0
}, {
    htmlPayout: 0
}, {
    htmlGameRule: 0
}, {
    htmlHistoryList: 0
}, {
    htmlHistoryDetail: 0
}, {
    TiledBackground: 0
}, {
    gui_bgbot: 0
}, {
    gui_bgtop: 0
}, {
    gui_bgtop2: 0
}, {
    Spine: 0
}, {
    Sprite5: 0
}, {
    Sprite6: 0
}, {
    effect_fs: 0
}, {
    Sine2: 0
}, {
    BG_light1: 0
}, {
    bw_num_board: 0
}, {
    bw_txt: 0
}, {
    bw_shine: 0
}, {
    ef_spark: 0
}, {
    bw_glow_b: 0
}, {
    bw_glow_a: 0
}, {
    bw_coin: 0
}, {
    bw_firework: 0
}, {
    bullettt: 0
}, {
    main_bg7: 0
}, {
    EffectSpinbtn2: 0
}, {
    Sprite: 0
}, {
    blackBG_2: 0
}, {
    BaseBet: 0
}, {
    ngang: 0
}, {
    InfoTxt: 0
}, {
    Tween2: 0
}, {
    MainButton: 0
}, {
    BetOption: 0
}, {
    Tween3: 0
}, {
    EffectButton: 0
}, {
    Slider: 0
}, {
    ZoneTouchF: 0
}, {
    dY: 0
}, {
    Y_begin: 0
}, {
    t_roll: 0
}, {
    t_back: 0
}, {
    v_roll: 0
}, {
    scatter: 0
}, {
    timestopreel: 0
}, {
    reelStop: 0
}, {
    EnSpin: 0
}, {
    BuySpin: 0
}, {
    error: 0
}, {
    Num: 0
}, {
    Num2: 0
}, {
    Num3: 0
}, {
    temp: 0
}, {
    String: 0
}, {
    Boolean: 0
}, {
    idlenote: 0
}, {
    autoo: 0
}, {
    bw: 0
}, {
    coin: 0
}, {
    Firework: 0
}, {
    winn: 0
}, {
    linee: 0
}, {
    canhgiua: 0
}, {
    value: 0
}, {
    currency: 0
}, {
    multi: 0
}, {
    Totalmulti: 0
}, {
    TotalWin: 0
}, {
    SumFreeSpin: 0
}, {
    WildSpin: 0
}, {
    loop: 0
}, {
    CheckEnd: 0
}, {
    dem: 0
}, {
    varr: 0
}, {
    varr2: 0
}, {
    varr3: 0
}, {
    effectwin: 0
}, {
    line: 0
}, {
    TotalLine: 0
}];
function bothNumbers(a, b) {
    return "number" === typeof a && "number" === typeof b
}
function subtract$jscomp$1(a, b) {
    return bothNumbers(a, b) ? a - b : a
}
function divide$jscomp$1(a, b) {
    return bothNumbers(a, b) ? a / b : a
}
function and(a, b) {
    return "string" === typeof a || "string" === typeof b ? ("number" === typeof a ? (Math.round(1E10 * a) / 1E10).toString() : a) + ("number" === typeof b ? (Math.round(1E10 * b) / 1E10).toString() : b) : a && b ? 1 : 0
}
self.C3_ExpressionFuncs = [()=>3090.7429963459194, ()=>.3284, ()=>0, ()=>-2, ()=>1, ()=>201, ()=>2, ()=>404, ()=>3, ()=>607, ()=>4, ()=>810, ()=>5, ()=>1013, ()=>"Symbol", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetBoundMethod();
    return ()=>and("Symbol_", b(d(0, 7)))
}
, ()=>30, ()=>120, ()=>700, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject()
}
, ()=>"SpinMachine", ()=>900, ()=>"checkFS", ()=>"IdleNote", ()=>1E3, ()=>"top_excite_turnL", ()=>"Roll", a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject(5)
}
, a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1)
      , c = a._GetNode(2).GetVar();
    return ()=>divide$jscomp$1(subtract$jscomp$1(b.ExpObject(5), d.ExpObject()), c.GetValue())
}
, ()=>.3, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>b.GetValue().toString()
}
, ()=>"SpinCheck", ()=>"SpinOK", ()=>"2", ()=>"wildspin", ()=>6, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject(0)
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject(1)
}
, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>b.GetValue()
}
, ()=>"InBack", a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() + 203
}
, ()=>-205, ()=>.39408, ()=>"Blur", a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpInstVar()
}
, ()=>"End", ()=>.06568, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1);
    return ()=>b(d.ExpInstVar())
}
, ()=>"", ()=>.13136, ()=>"outback", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1);
    return ()=>b(d.ExpInstVar() + 3)
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject(2)
}
, ()=>.19704, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1);
    return ()=>b(d.ExpInstVar() + 6)
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject(3)
}
, ()=>.26272, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject(4)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(7)
}
, a=>{
    const b = a._GetNode(0);
    return ()=>1 === b.ExpInstVar() ? 1 : 0
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(2, 7)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(1, 7)
}
, a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1);
    return ()=>b.ExpObject() + 3 * d.ExpObject()
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b(d.GetValue())
}
, ()=>"Symbol_0", a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1).GetVar();
    return ()=>b.ExpObject(d.GetValue())
}
, ()=>"scrollStop", a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b()
}
, ()=>"top_excite_lookL", ()=>"top_excite_turnR", a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1).GetVar();
    return ()=>b.ExpObject(d.GetValue(), 0)
}
, ()=>.1, ()=>"Symbol_0_spawn", ()=>"WildSpin", ()=>"Gui", ()=>"hit", a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() - 50
}
, ()=>.5, ()=>.15, ()=>-1, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>b.GetValue() + 1
}
, ()=>"bg", ()=>-10, a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2).GetBoundMethod();
    return ()=>b.ExpObject(d.GetValue(), c())
}
, a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetBoundMethod();
    return ()=>b.GetValue() + 3 * d()
}
, ()=>1.05, ()=>"Symbol_1", ()=>31, ()=>750, ()=>"Spine", a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>and("vancong", b(1, 2, 3, 4, 5))
}
, ()=>"zoom_idle", ()=>"sc", ()=>.85, ()=>930, ()=>377, ()=>"Animation 1", ()=>-110, ()=>890, ()=>"idle", a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>and("idle", b("", 2, 3, 4))
}
, ()=>"idle2", ()=>"idle3", ()=>"idle4", ()=>"top_idle", a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>and("top_idle", b("", 2, 3))
}
, ()=>"top_idle2", ()=>"top_idle3", ()=>"top_enter", ()=>"top_excite_start", ()=>"wild", ()=>"small_win", ()=>"top_excite_lookR", ()=>"enter", a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>and("entop", b(1, 2))
}
, ()=>"exit", ()=>"top_winoverlay", a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>and("top_exit", b("", 2))
}
, ()=>"back", ()=>1006, ()=>"tbot", ()=>1010, ()=>114, ()=>666, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpBehavior("sc")
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() - 370 - 2
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpBehavior("back")
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() - 370 + 2
}
, ()=>"ttop", ()=>10, ()=>100, ()=>.2, ()=>"Effect - all", ()=>20, ()=>.4, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(.1, .6)
}
, ()=>368, ()=>982, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(1, 5)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(180, 360)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(.3, .8)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(90, 180)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(100, 200)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(.1, .3)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1)
      , c = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return ()=>b(d.ExpObject(), c(e.ExpObject(), 4), "") + "_win"
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1)
      , c = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3);
    return ()=>b(d.ExpObject(), c(e.ExpObject(), 4), "")
}
, ()=>"Symbol_0_win", ()=>"Symbol_0_winidle", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar();
    return ()=>b(d.GetValue() * c.GetValue() * e.GetValue(), 1)
}
, ()=>"payout.txt", ()=>"gamerule.txt", ()=>"history.txt", a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject("Value")
}
, ()=>"MainButton", ()=>"Balance", ()=>"BetOption", ()=>"History", ()=>"spinHover", ()=>"Maximum Bet", a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1).GetBoundMethod();
    return ()=>b.ExpObject(d())
}
, ()=>"SetBet", ()=>"Minimum Bet", a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() - 1
}
, ()=>"Menu", a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>b.GetValue() ? "Turbo Enable" : "Turbo Disable"
}
, ()=>"AutoMenu", ()=>"BuyFeature", ()=>60, a=>{
    const b = a._GetNode(0);
    return ()=>Math.sign(400 - b.ExpObject())
}
, ()=>"GuiMask", ()=>.8, ()=>"sizeback", ()=>"aback", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1);
    return ()=>b(d.ExpObject(), 3)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b("Symbol_0", 3)
}
, ()=>.7, ()=>80, ()=>1500, ()=>-800, ()=>-700, ()=>"SpinEnd", ()=>"SpinStart", ()=>"CheckBigWin", ()=>"BigWin", ()=>"WinEffect", ()=>"checkScatter", ()=>2.5, ()=>.6, ()=>15, ()=>"SpinEffect", ()=>"SpinStop", ()=>1200, ()=>"FreeSpinScreen", ()=>"LayerVisible", ()=>"Visible", ()=>376, ()=>1037, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b() + 3
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b() - d.GetValue()
}
, ()=>"Error", ()=>"Please Check Your Connection !", ()=>"Show", ()=>105, ()=>510, ()=>200, ()=>370, ()=>630, ()=>500, ()=>140, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(255, 66, 66)
}
, ()=>570, ()=>550, ()=>2E3, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>800 === b.GetValue() ? 720 : 800
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() + 60
}
, ()=>.02, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() - 2
}
, a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar();
    return ()=>and(b.GetValue() >= d.GetValue() ? 1 : 0, c.GetValue() < e.GetValue() + 100 ? 1 : 0)
}
, a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2).GetVar();
    return ()=>b.GetValue() / d.GetValue() / c.GetValue()
}
, ()=>32, ()=>"Note", ()=>17, ()=>872, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(240, 156, 66)
}
, ()=>157, ()=>1026, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(150, 241, 253)
}
, ()=>"mainbutton", ()=>"AutoSpin", ()=>1222, ()=>"Number", ()=>"BalanceDe", ()=>"BalanceIn", ()=>"WinEx", ()=>" None", ()=>"None", a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>b.GetValue() ? "320" : "-320"
}
, a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1).GetVar();
    return ()=>b.ExpObject() + d.GetValue()
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject("Number")
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1);
    return ()=>b(d.ExpObject("Number")) - 1
}
, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>b.GetValue() ? "Sound ON" : "Sound OFF"
}
, ()=>"Paytable", ()=>"Rule", ()=>1300, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() + 400
}
, ()=>.16, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() - 400
}
, ()=>325, ()=>420, ()=>525, ()=>9, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>and("Symbol_", b())
}
, ()=>300, ()=>720, ()=>"payout.html", ()=>".gameinfo", ()=>"paytable-rules-dismiss-button", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b() / d.GetValue()
}
, ()=>"bw", ()=>"bigwin", ()=>.05, ()=>"start", ()=>.25, ()=>35, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>35 * b.GetValue()
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod()
      , g = a._GetNode(4).GetBoundMethod()
      , k = a._GetNode(5).GetVar();
    return ()=>b() < 35 * d.GetValue() ? c(.06 * e() / 6, 2) : g(2.1 * k.GetValue() / 6, 2)
}
, a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetVar();
    return ()=>b.GetValue() - Math.floor(d.GetValue())
}
, ()=>"big win", ()=>.9, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() + .03
}
, ()=>.06, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod()
      , g = a._GetNode(4).GetVar();
    return ()=>b(d.GetValue()).toString() + "." + c(e(100 * g.GetValue()) % 100, 2)
}
, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>50 * b.GetValue()
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b() / 2
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(.6, 1.2)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(360)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(300, 500)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(1, 1.6)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(300, 800)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(100, 700)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(200, 1E3)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(150, 600)
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpBehavior("start")
}
, ()=>"zome", a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpBehavior("zome")
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(.7, 1)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(.1, .2)
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(.6, 1)
}
, ()=>"mw", ()=>1.3, ()=>"smw", ()=>1.6, ()=>1.1, ()=>1.4, ()=>"M", ()=>"S", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b(15 * d.GetValue() * .06 / 6, 2)
}
, ()=>"mega win", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetBoundMethod()
      , c = a._GetNode(2).GetVar();
    return ()=>b(d(), 50 * c.GetValue())
}
, a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetVar()
      , g = a._GetNode(4).GetBoundMethod()
      , k = a._GetNode(5).GetVar()
      , l = a._GetNode(6).GetVar()
      , n = a._GetNode(7).GetBoundMethod()
      , p = a._GetNode(8).GetVar()
      , t = a._GetNode(9).GetVar()
      , w = a._GetNode(10).GetBoundMethod()
      , z = a._GetNode(11).GetVar()
      , B = a._GetNode(12).GetVar();
    return ()=>b.GetValue() - 50 * d.GetValue() < 50 * c.GetValue() ? 1 > e.GetValue() ? g((k.GetValue() - 50 * l.GetValue()) / 20, 2) : n((p.GetValue() - 50 * t.GetValue()) / 35, 2) : w(.06 * (z.GetValue() - 50 * B.GetValue()) / 5, 2)
}
, ()=>"super mega win", a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetVar();
    return ()=>b.GetValue() / d.GetValue() / 10
}
, ()=>"Value", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b(Math.round(100 * d.GetValue()) % 100, 2)
}
, a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1);
    return ()=>and(b.ExpObject("Decimal"), d.ExpObject("Value"))
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2);
    return ()=>and(b(d.GetValue() % 1E3, 3), c.ExpObject("Value"))
}
, a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1);
    return ()=>and(b.ExpObject("Thousand"), d.ExpObject("Value"))
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b(d.GetValue() / 1E3)
}
, a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2)
      , e = a._GetNode(3);
    return ()=>and(and(and(b.ExpObject("Prefix"), d.GetValue()), c.ExpObject("Value")), e.ExpObject("Suffix"))
}
, ()=>"Decimal", ()=>"Prefix", ()=>"Suffix", ()=>"Thousand", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1);
    return ()=>b(d.ExpObject())
}
, ()=>838, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>b.GetValue() + 33
}
, ()=>65, a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetBoundMethod()
      , c = a._GetNode(2).GetVar();
    return ()=>b.GetValue() * d() * c.GetValue()
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b(d.GetValue(), 2)
}
, ()=>620, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>b(81, 225, 216)
}
, a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetVar();
    return ()=>5 * b.GetValue() * d.GetValue()
}
, a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetVar();
    return ()=>10 * b.GetValue() * d.GetValue()
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1);
    return ()=>b(d.ExpObject(), 2)
}
, a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1);
    return ()=>b.GetValue() - d.ExpObject()
}
, ()=>"BetControl", ()=>1100, ()=>"MoveSize", ()=>"ok", a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2).GetVar();
    return ()=>b.GetValue() * d.GetValue() * c.GetValue()
}
, ()=>"MoveAmount", ()=>"okok", ()=>"MoveLevel", ()=>"okokok", a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>Math.abs(b.GetValue() / 400)
}
, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>b.GetValue() + "ok"
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b(1, Math.abs(d.GetValue() / 500))
}
, ()=>"1", ()=>"history-list.html", ()=>".history-list", ()=>"style", ()=>"display:none", ()=>".body-more", ()=>"#game-list-wrapper", a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>and(b(), " record(s)")
}
, ()=>".total-record", a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>and(b(), "")
}
, ()=>".total-bet", ()=>".total-profit", ()=>"exit-icon", ()=>"body-more", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1);
    return ()=>b(d.ExpObject()) + 1
}
, ()=>"display:block", ()=>"item-detail", ()=>"history-detail.html", ()=>"symbol_atlas", ()=>"Log Detail", ()=>".history-detail", ()=>"#game-details-left-arrow", ()=>"#game-details-right-arrow", ()=>"game-details-left-arrow", ()=>"game-details-right-arrow", a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>and("position: absolute; height: 578px; transform: translate3d(-", 100 * b()) + "%,0,0)"
}
, ()=>"#game-detail-spring-wrapper", ()=>".title-top", ()=>"display:flex", ()=>"game-list-nav-image-container game-list-nav-image-container-slot", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b(3, d.GetValue() - 4)
}
, ()=>"Freespin", ()=>378, ()=>7, ()=>3.8, a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1)
      , c = a._GetNode(2);
    return ()=>720 < b.ExpObject() ? 900 : d.ExpObject(1) - c.ExpObject()
}
, ()=>387, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b(d.GetValue()) + 1
}
, ()=>"LayerInvisible", ()=>"Invisible", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b(d.GetValue()) - 1
}
, ()=>"gamerule.html", ()=>".gamerule", ()=>"ShowEffect", a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>and("Mouse-Win", b(1, 2, 3, 4))
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetBoundMethod()
      , c = a._GetNode(2).GetBoundMethod()
      , e = a._GetNode(3).GetBoundMethod()
      , g = a._GetNode(4).GetBoundMethod();
    return ()=>b(d()).toString() + "." + c(e(100 * g()) % 100, 2)
}
, a=>{
    const b = a._GetNode(0)
      , d = a._GetNode(1);
    return ()=>b.ExpObject(1) - d.ExpObject()
}
, ()=>"idleNote", ()=>"CreateEffect", a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetBoundMethod();
    return ()=>b(d(0, 3))
}
, a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetVar();
    return ()=>1500 > b.GetValue() ? 0 : d.GetValue() / 60
}
, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>5 * b.GetValue()
}
, ()=>"0.00", a=>{
    const b = a._GetNode(0).GetVar()
      , d = a._GetNode(1).GetBoundMethod()
      , c = a._GetNode(2).GetBoundMethod();
    return ()=>b.GetValue() + d(c(-1, 3), 2)
}
, ()=>"IdleEffect", ()=>1.2, a=>{
    const b = a._GetNode(0).GetVar();
    return ()=>b.GetValue() - 1
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetBoundMethod();
    return ()=>b(d())
}
, ()=>70, a=>{
    const b = a._GetNode(0).GetBoundMethod();
    return ()=>3 * b() + 1
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2).GetVar();
    return ()=>b(d.GetValue(), c.GetValue())
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() + 50
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpInstVar() + "_win"
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() + 800
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar()
      , c = a._GetNode(2).GetBoundMethod();
    return ()=>b(d.GetValue(), c())
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetBoundMethod()
      , c = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , g = a._GetNode(4).GetBoundMethod()
      , k = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6).GetVar();
    return ()=>b(d(c.GetValue())).toString() + "." + e(g(100 * k(l.GetValue())) % 100, 2)
}
, a=>{
    const b = a._GetNode(0);
    return ()=>b.ExpObject() - 800
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetVar();
    return ()=>b() * d.GetValue()
}
, a=>{
    const b = a._GetNode(0).GetBoundMethod()
      , d = a._GetNode(1).GetBoundMethod()
      , c = a._GetNode(2).GetVar()
      , e = a._GetNode(3).GetBoundMethod()
      , g = a._GetNode(4).GetBoundMethod()
      , k = a._GetNode(5).GetBoundMethod()
      , l = a._GetNode(6).GetVar();
    return ()=>b(d() * c.GetValue()).toString() + "." + e(g(k() * l.GetValue() * 100) % 100, 2)
}
, ()=>"featureBuy"];
var module$str$c3runtime = {};
var module$str$__c3root__ = {};
